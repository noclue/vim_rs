use std::sync::Arc;
use crate::vim_client::{VimClient, Result};
use crate::types::IpPool;
use crate::types::IpPoolManagerIpAllocation;
use crate::types::ManagedObjectReference;
/// Singleton Managed Object used to manage IP Pools.
/// 
/// IP Pools are used to allocate IPv4 and IPv6 addresses to vApps.
pub struct IpPoolManager {
    client: Arc<VimClient>,
    mo_id: String,
}
impl IpPoolManager {
    pub fn new(client: Arc<VimClient>, mo_id: &str) -> Self {
        Self {
            client,
            mo_id: mo_id.to_string(),
        }
    }
    /// Allocates an IPv4 address from an IP pool.
    /// 
    /// Allocated IP addresses are reserved in the IP pool until released by
    /// calling *IpPoolManager.ReleaseIpAllocation*, or until the IP pool is configured to
    /// have an IP range that does not contain the IP address, or until the IP
    /// pool is destroyed.
    /// 
    /// The caller must be a vCenter extension. Refer to *ExtensionManager*
    /// for details on vCenter extensions.
    /// 
    /// The caller specifies a per extension unique allocation ID. Calling this
    /// function twice with the same allocation ID for the same pool yields the
    /// same IP address. This makes it possible to do idempotent allocations.
    ///
    /// ## Parameters:
    ///
    /// ### dc
    /// The datacenter on which to find the pool
    /// 
    /// Refers instance of *Datacenter*.
    ///
    /// ### pool_id
    /// The unique ID of the pool
    ///
    /// ### allocation_id
    /// The unique ID for this allocation
    ///
    /// ## Returns:
    ///
    /// An IPv4 address if the pool has an available IPv4 address in its
    /// address ranges, otherwise the empty string.
    pub async fn allocate_ipv_4_address(&self, dc: &ManagedObjectReference, pool_id: i32, allocation_id: &str) -> Result<String> {
        let input = AllocateIpv4AddressRequestType {dc, pool_id, allocation_id, };
        let path = format!("/IpPoolManager/{moId}/AllocateIpv4Address", moId = &self.mo_id);
        let req = self.client.post_request(&path, &input);
        Ok(self.client.execute(req).await?)
    }
    /// Allocates an IPv6 address from an IP pool.
    /// 
    /// Allocated IP addresses are reserved in the IP pool until released by
    /// calling *IpPoolManager.ReleaseIpAllocation*, or until the IP pool is configured to
    /// have an IP range that does not contain the IP address, or until the IP
    /// pool is destroyed.
    /// 
    /// The caller must be a vCenter extension. Refer to *ExtensionManager*
    /// for details on vCenter extensions.
    /// 
    /// The caller specifies a per extension unique allocation ID. Calling this
    /// function twice with the same allocation ID for the same pool yields the
    /// same IP address. This makes it possible to do idempotent allocations.
    ///
    /// ## Parameters:
    ///
    /// ### dc
    /// The datacenter on which to find the pool
    /// 
    /// Refers instance of *Datacenter*.
    ///
    /// ### pool_id
    /// The unique ID of the pool
    ///
    /// ### allocation_id
    /// The unique ID for this allocation
    ///
    /// ## Returns:
    ///
    /// An IPv6 address if the pool has an available IPv6 address in its
    /// address ranges, otherwise the empty string.
    pub async fn allocate_ipv_6_address(&self, dc: &ManagedObjectReference, pool_id: i32, allocation_id: &str) -> Result<String> {
        let input = AllocateIpv6AddressRequestType {dc, pool_id, allocation_id, };
        let path = format!("/IpPoolManager/{moId}/AllocateIpv6Address", moId = &self.mo_id);
        let req = self.client.post_request(&path, &input);
        Ok(self.client.execute(req).await?)
    }
    /// Create a new IP pool.
    /// 
    /// The name field must be defined, all other fields are optional. If unset,
    /// they will be given default values.
    /// 
    /// The ID for the pool is generated by the server and should not be defined on the
    /// pool object passed to this method.
    ///
    /// ## Parameters:
    ///
    /// ### dc
    /// The datacenter on which to create the pool.
    /// 
    /// ***Required privileges:*** Datacenter.IpPoolConfig
    /// 
    /// Refers instance of *Datacenter*.
    ///
    /// ### pool
    /// The IP pool to create on the server
    ///
    /// ## Returns:
    ///
    /// The generated ID for the pool
    pub async fn create_ip_pool(&self, dc: &ManagedObjectReference, pool: &IpPool) -> Result<i32> {
        let input = CreateIpPoolRequestType {dc, pool, };
        let path = format!("/IpPoolManager/{moId}/CreateIpPool", moId = &self.mo_id);
        let req = self.client.post_request(&path, &input);
        Ok(self.client.execute(req).await?)
    }
    /// Destroys an IP pool on the given datacenter.
    /// 
    /// Looks up the pool on the datacenter by ID and deletes it. If the pool is in use,
    /// the method throws InvalidState unless the force flag is true.
    ///
    /// ## Parameters:
    ///
    /// ### dc
    /// The datacenter on which to find the pool
    /// 
    /// ***Required privileges:*** Datacenter.IpPoolConfig
    /// 
    /// Refers instance of *Datacenter*.
    ///
    /// ### id
    /// The unique ID of the pool
    ///
    /// ### force
    /// If true, the pool will be destroyed even if it is in use
    ///
    /// ## Errors:
    ///
    /// ***InvalidState***: if the pool is in use and the force flag is false
    pub async fn destroy_ip_pool(&self, dc: &ManagedObjectReference, id: i32, force: bool) -> Result<()> {
        let input = DestroyIpPoolRequestType {dc, id, force, };
        let path = format!("/IpPoolManager/{moId}/DestroyIpPool", moId = &self.mo_id);
        let req = self.client.post_request(&path, &input);
        Ok(self.client.execute_void(req).await?)
    }
    /// Query IP allocations by IP pool and extension key.
    ///
    /// ## Parameters:
    ///
    /// ### dc
    /// The datacenter on which to find the pool
    /// 
    /// ***Required privileges:*** Datacenter.IpPoolQueryAllocations
    /// 
    /// Refers instance of *Datacenter*.
    ///
    /// ### pool_id
    /// The unique ID of the pool
    ///
    /// ### extension_key
    /// The key of the extension
    ///
    /// ## Returns:
    ///
    /// The resulting list of @{link IpAllocation}.
    pub async fn query_ip_allocations(&self, dc: &ManagedObjectReference, pool_id: i32, extension_key: &str) -> Result<Vec<IpPoolManagerIpAllocation>> {
        let input = QueryIpAllocationsRequestType {dc, pool_id, extension_key, };
        let path = format!("/IpPoolManager/{moId}/QueryIPAllocations", moId = &self.mo_id);
        let req = self.client.post_request(&path, &input);
        Ok(self.client.execute(req).await?)
    }
    /// Return the list of IP pools for a datacenter.
    ///
    /// ## Parameters:
    ///
    /// ### dc
    /// The datacenter for which to look up the IP pools.
    /// 
    /// ***Required privileges:*** System.Read
    /// 
    /// Refers instance of *Datacenter*.
    ///
    /// ## Returns:
    ///
    /// The resulting list of pools.
    pub async fn query_ip_pools(&self, dc: &ManagedObjectReference) -> Result<Option<Vec<IpPool>>> {
        let input = QueryIpPoolsRequestType {dc, };
        let path = format!("/IpPoolManager/{moId}/QueryIpPools", moId = &self.mo_id);
        let req = self.client.post_request(&path, &input);
        Ok(self.client.execute_option(req).await?)
    }
    /// Releases an IP allocation back to it's IP pool.
    /// 
    /// Attempting to release an IP allocation that is not allocated from the
    /// specified IP pool with the specified allocation ID silently fails. This
    /// makes it possible to release IP allocations idempotently.
    /// 
    /// All IP addresses allocated by an extension are automatically released
    /// if the extension is unregistered from vCenter.
    ///
    /// ## Parameters:
    ///
    /// ### dc
    /// The datacenter on which to find the pool
    /// 
    /// ***Required privileges:*** Datacenter.IpPoolReleaseIp
    /// 
    /// Refers instance of *Datacenter*.
    ///
    /// ### pool_id
    /// The unique ID of the pool
    ///
    /// ### allocation_id
    /// The unique ID for this allocation
    pub async fn release_ip_allocation(&self, dc: &ManagedObjectReference, pool_id: i32, allocation_id: &str) -> Result<()> {
        let input = ReleaseIpAllocationRequestType {dc, pool_id, allocation_id, };
        let path = format!("/IpPoolManager/{moId}/ReleaseIpAllocation", moId = &self.mo_id);
        let req = self.client.post_request(&path, &input);
        Ok(self.client.execute_void(req).await?)
    }
    /// Update an IP pool on a datacenter.
    /// 
    /// The pool to update is looked up from the value of the id field.
    /// 
    /// All fields in the pool except the id are optional. Only defined values are stored
    /// on the server.
    ///
    /// ## Parameters:
    ///
    /// ### dc
    /// The datacenter on which to look up the pool.
    /// 
    /// ***Required privileges:*** Datacenter.IpPoolConfig
    /// 
    /// Refers instance of *Datacenter*.
    ///
    /// ### pool
    /// The IP pool to update on the server
    pub async fn update_ip_pool(&self, dc: &ManagedObjectReference, pool: &IpPool) -> Result<()> {
        let input = UpdateIpPoolRequestType {dc, pool, };
        let path = format!("/IpPoolManager/{moId}/UpdateIpPool", moId = &self.mo_id);
        let req = self.client.post_request(&path, &input);
        Ok(self.client.execute_void(req).await?)
    }
}
#[derive(serde::Serialize)]
#[serde(tag="_typeName")]
struct AllocateIpv4AddressRequestType<'a> {
    dc: &'a ManagedObjectReference,
    #[serde(rename = "poolId")]
    pool_id: i32,
    #[serde(rename = "allocationId")]
    allocation_id: &'a str,
}
#[derive(serde::Serialize)]
#[serde(tag="_typeName")]
struct AllocateIpv6AddressRequestType<'a> {
    dc: &'a ManagedObjectReference,
    #[serde(rename = "poolId")]
    pool_id: i32,
    #[serde(rename = "allocationId")]
    allocation_id: &'a str,
}
#[derive(serde::Serialize)]
#[serde(tag="_typeName")]
struct CreateIpPoolRequestType<'a> {
    dc: &'a ManagedObjectReference,
    pool: &'a IpPool,
}
#[derive(serde::Serialize)]
#[serde(tag="_typeName")]
struct DestroyIpPoolRequestType<'a> {
    dc: &'a ManagedObjectReference,
    id: i32,
    force: bool,
}
#[derive(serde::Serialize)]
#[serde(rename = "QueryIPAllocationsRequestType", tag = "_typeName")]
struct QueryIpAllocationsRequestType<'a> {
    dc: &'a ManagedObjectReference,
    #[serde(rename = "poolId")]
    pool_id: i32,
    #[serde(rename = "extensionKey")]
    extension_key: &'a str,
}
#[derive(serde::Serialize)]
#[serde(tag="_typeName")]
struct QueryIpPoolsRequestType<'a> {
    dc: &'a ManagedObjectReference,
}
#[derive(serde::Serialize)]
#[serde(tag="_typeName")]
struct ReleaseIpAllocationRequestType<'a> {
    dc: &'a ManagedObjectReference,
    #[serde(rename = "poolId")]
    pool_id: i32,
    #[serde(rename = "allocationId")]
    allocation_id: &'a str,
}
#[derive(serde::Serialize)]
#[serde(tag="_typeName")]
struct UpdateIpPoolRequestType<'a> {
    dc: &'a ManagedObjectReference,
    pool: &'a IpPool,
}
