use super::vim_object_trait::VimObjectTrait;
use super::dyn_serialize;
use super::convert::CastFrom;
use super::struct_enum::StructType;
use super::structs::*;
use serde::de;
use super::vim_any::VimAny;

/// This is the built-in base interface implemented by all
/// data objects.
pub trait DataObjectTrait : super::traits::VimObjectTrait {
}
impl<'s> serde::Serialize for dyn DataObjectTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DataObjectTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DataObjectVisitor)
            }
        }

struct DataObjectVisitor;

impl<'de> de::Visitor<'de> for DataObjectVisitor {
    type Value = Box<dyn DataObjectTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DataObjectTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DataObjectTrait for DataObject {
}
impl DataObjectTrait for AboutInfo {
}
impl DataObjectTrait for AuthorizationDescription {
}
impl DataObjectTrait for EntityPrivilege {
}
impl DataObjectTrait for Permission {
}
impl DataObjectTrait for AuthorizationPrivilege {
}
impl DataObjectTrait for PrivilegeAvailability {
}
impl DataObjectTrait for AuthorizationRole {
}
impl DataObjectTrait for UserPrivilegeResult {
}
impl DataObjectTrait for BatchResult {
}
impl DataObjectTrait for Capability {
}
impl DataObjectTrait for ClusterComputeResourceClusterConfigResult {
}
impl DataObjectTrait for ClusterComputeResourceDvsSetting {
}
impl DataObjectTrait for ClusterComputeResourceDvsSettingDvPortgroupToServiceMapping {
}
impl DataObjectTrait for ClusterComputeResourceDvsProfile {
}
impl DataObjectTrait for ClusterComputeResourceDvsProfileDvPortgroupSpecToServiceMapping {
}
impl DataObjectTrait for ClusterComputeResourceHciConfigInfo {
}
impl DataObjectTrait for ClusterComputeResourceHciConfigSpec {
}
impl DataObjectTrait for ClusterComputeResourceHostConfigurationInput {
}
impl DataObjectTrait for ClusterComputeResourceHostConfigurationProfile {
}
impl DataObjectTrait for ClusterComputeResourceHostVmkNicInfo {
}
impl DataObjectTrait for ClusterComputeResourceVcProfile {
}
impl DataObjectTrait for ClusterComputeResourceValidationResultBase {
}
impl DataObjectTrait for ClusterComputeResourceDvsConfigurationValidation {
}
impl DataObjectTrait for ClusterComputeResourceHostConfigurationValidation {
}
impl DataObjectTrait for ClusterComputeResourceVcsSlots {
}
impl DataObjectTrait for ComputeResourceConfigInfo {
}
impl DataObjectTrait for ClusterConfigInfoEx {
}
impl DataObjectTrait for ComputeResourceConfigSpec {
}
impl DataObjectTrait for ClusterConfigSpecEx {
}
impl DataObjectTrait for ComputeResourceHostSpbmLicenseInfo {
}
impl DataObjectTrait for ComputeResourceSummary {
}
impl DataObjectTrait for ClusterComputeResourceSummary {
}
impl DataObjectTrait for CustomFieldDef {
}
impl DataObjectTrait for CustomFieldValue {
}
impl DataObjectTrait for CustomFieldStringValue {
}
impl DataObjectTrait for CustomizationSpecInfo {
}
impl DataObjectTrait for CustomizationSpecItem {
}
impl DataObjectTrait for DatacenterBasicConnectInfo {
}
impl DataObjectTrait for DatacenterConfigInfo {
}
impl DataObjectTrait for DatacenterConfigSpec {
}
impl DataObjectTrait for DatastoreCapability {
}
impl DataObjectTrait for DatastoreHostMount {
}
impl DataObjectTrait for DatastoreInfo {
}
impl DataObjectTrait for LocalDatastoreInfo {
}
impl DataObjectTrait for NasDatastoreInfo {
}
impl DataObjectTrait for PMemDatastoreInfo {
}
impl DataObjectTrait for VmfsDatastoreInfo {
}
impl DataObjectTrait for VsanDatastoreInfo {
}
impl DataObjectTrait for VvolDatastoreInfo {
}
impl DataObjectTrait for DatastoreMountPathDatastorePair {
}
impl DataObjectTrait for DatastoreSummary {
}
impl DataObjectTrait for DatastoreVVolContainerFailoverPair {
}
impl DataObjectTrait for DatastoreNamespaceManagerDirectoryInfo {
}
impl DataObjectTrait for Description {
}
impl DataObjectTrait for ElementDescription {
}
impl DataObjectTrait for EvcMode {
}
impl DataObjectTrait for ExtendedElementDescription {
}
impl DataObjectTrait for FeatureEvcMode {
}
impl DataObjectTrait for OptionDef {
}
impl DataObjectTrait for ExtendedDescription {
}
impl DataObjectTrait for MethodDescription {
}
impl DataObjectTrait for TypeDescription {
}
impl DataObjectTrait for ScheduledTaskDetail {
}
impl DataObjectTrait for DesiredSoftwareSpec {
}
impl DataObjectTrait for DesiredSoftwareSpecBaseImageSpec {
}
impl DataObjectTrait for DesiredSoftwareSpecComponentSpec {
}
impl DataObjectTrait for DesiredSoftwareSpecVendorAddOnSpec {
}
impl DataObjectTrait for DiagnosticManagerAuditRecordResult {
}
impl DataObjectTrait for DiagnosticManagerBundleInfo {
}
impl DataObjectTrait for DiagnosticManagerLogDescriptor {
}
impl DataObjectTrait for DiagnosticManagerLogHeader {
}
impl DataObjectTrait for DvsBackupRestoreCapability {
}
impl DataObjectTrait for DvsCapability {
}
impl DataObjectTrait for DvsConfigInfo {
}
impl DataObjectTrait for VMwareDvsConfigInfo {
}
impl DataObjectTrait for DvsConfigSpec {
}
impl DataObjectTrait for VMwareDvsConfigSpec {
}
impl DataObjectTrait for DvsContactInfo {
}
impl DataObjectTrait for DvsCreateSpec {
}
impl DataObjectTrait for DvsFeatureCapability {
}
impl DataObjectTrait for VMwareDvsFeatureCapability {
}
impl DataObjectTrait for DvsHealthCheckConfig {
}
impl DataObjectTrait for VMwareDvsHealthCheckConfig {
}
impl DataObjectTrait for VMwareDvsTeamingHealthCheckConfig {
}
impl DataObjectTrait for VMwareDvsVlanMtuHealthCheckConfig {
}
impl DataObjectTrait for DvsHealthCheckCapability {
}
impl DataObjectTrait for VMwareDvsHealthCheckCapability {
}
impl DataObjectTrait for DvsHostInfrastructureTrafficResource {
}
impl DataObjectTrait for DvsHostInfrastructureTrafficResourceAllocation {
}
impl DataObjectTrait for DvsNetworkResourceManagementCapability {
}
impl DataObjectTrait for DvsResourceRuntimeInfo {
}
impl DataObjectTrait for DvsRollbackCapability {
}
impl DataObjectTrait for DvsRuntimeInfo {
}
impl DataObjectTrait for DvsSummary {
}
impl DataObjectTrait for DvsPolicy {
}
impl DataObjectTrait for DvsUplinkPortPolicy {
}
impl DataObjectTrait for DvsNameArrayUplinkPortPolicy {
}
impl DataObjectTrait for EnumDescription {
}
impl DataObjectTrait for EnvironmentBrowserConfigOptionQuerySpec {
}
impl DataObjectTrait for Extension {
}
impl DataObjectTrait for ExtensionClientInfo {
}
impl DataObjectTrait for ExtensionEventTypeInfo {
}
impl DataObjectTrait for ExtensionFaultTypeInfo {
}
impl DataObjectTrait for ExtensionHealthInfo {
}
impl DataObjectTrait for ExtensionOvfConsumerInfo {
}
impl DataObjectTrait for ExtensionPrivilegeInfo {
}
impl DataObjectTrait for ExtensionResourceInfo {
}
impl DataObjectTrait for ExtensionServerInfo {
}
impl DataObjectTrait for ExtensionTaskTypeInfo {
}
impl DataObjectTrait for ExtensionManagerIpAllocationUsage {
}
impl DataObjectTrait for FaultsByHost {
}
impl DataObjectTrait for FaultsByVm {
}
impl DataObjectTrait for FileLockInfo {
}
impl DataObjectTrait for FileLockInfoResult {
}
impl DataObjectTrait for FolderBatchAddHostsToClusterResult {
}
impl DataObjectTrait for FolderBatchAddStandaloneHostsResult {
}
impl DataObjectTrait for FolderFailedHostResult {
}
impl DataObjectTrait for FolderNewHostSpec {
}
impl DataObjectTrait for HbrManagerReplicationVmInfo {
}
impl DataObjectTrait for ReplicationVmProgressInfo {
}
impl DataObjectTrait for HbrManagerVmReplicationCapability {
}
impl DataObjectTrait for HealthUpdate {
}
impl DataObjectTrait for HealthUpdateInfo {
}
impl DataObjectTrait for PerfInterval {
}
impl DataObjectTrait for HostServiceTicket {
}
impl DataObjectTrait for HostSystemComplianceCheckState {
}
impl DataObjectTrait for HostSystemReconnectSpec {
}
impl DataObjectTrait for HostSystemRemediationState {
}
impl DataObjectTrait for HttpNfcLeaseCapabilities {
}
impl DataObjectTrait for HttpNfcLeaseDatastoreLeaseInfo {
}
impl DataObjectTrait for HttpNfcLeaseDeviceUrl {
}
impl DataObjectTrait for HttpNfcLeaseHostInfo {
}
impl DataObjectTrait for HttpNfcLeaseInfo {
}
impl DataObjectTrait for HttpNfcLeaseManifestEntry {
}
impl DataObjectTrait for HttpNfcLeaseProbeResult {
}
impl DataObjectTrait for HttpNfcLeaseSourceFile {
}
impl DataObjectTrait for ImportSpec {
}
impl DataObjectTrait for VirtualAppImportSpec {
}
impl DataObjectTrait for VirtualMachineImportSpec {
}
impl DataObjectTrait for InheritablePolicy {
}
impl DataObjectTrait for BoolPolicy {
}
impl DataObjectTrait for IntPolicy {
}
impl DataObjectTrait for LongPolicy {
}
impl DataObjectTrait for StringPolicy {
}
impl DataObjectTrait for DvsFilterConfig {
}
impl DataObjectTrait for DvsFilterConfigSpec {
}
impl DataObjectTrait for DvsTrafficFilterConfig {
}
impl DataObjectTrait for DvsTrafficFilterConfigSpec {
}
impl DataObjectTrait for DvsFilterPolicy {
}
impl DataObjectTrait for DvsTrafficShapingPolicy {
}
impl DataObjectTrait for DvsVendorSpecificConfig {
}
impl DataObjectTrait for DvsFailureCriteria {
}
impl DataObjectTrait for DvsMacLearningPolicy {
}
impl DataObjectTrait for DvsMacManagementPolicy {
}
impl DataObjectTrait for DvsSecurityPolicy {
}
impl DataObjectTrait for VMwareUplinkLacpPolicy {
}
impl DataObjectTrait for VMwareUplinkPortOrderPolicy {
}
impl DataObjectTrait for VmwareUplinkPortTeamingPolicy {
}
impl DataObjectTrait for VmwareDistributedVirtualSwitchVlanSpec {
}
impl DataObjectTrait for VmwareDistributedVirtualSwitchPvlanSpec {
}
impl DataObjectTrait for VmwareDistributedVirtualSwitchTrunkVlanSpec {
}
impl DataObjectTrait for VmwareDistributedVirtualSwitchVlanIdSpec {
}
impl DataObjectTrait for IoFilterInfo {
}
impl DataObjectTrait for ClusterIoFilterInfo {
}
impl DataObjectTrait for HostIoFilterInfo {
}
impl DataObjectTrait for IoFilterQueryIssueResult {
}
impl DataObjectTrait for IoFilterHostIssue {
}
impl DataObjectTrait for IpPoolManagerIpAllocation {
}
impl DataObjectTrait for KeyValue {
}
impl DataObjectTrait for LatencySensitivity {
}
impl DataObjectTrait for LicenseAssignmentManagerLicenseAssignment {
}
impl DataObjectTrait for LicenseAvailabilityInfo {
}
impl DataObjectTrait for LicenseDiagnostics {
}
impl DataObjectTrait for LicenseManagerEvaluationInfo {
}
impl DataObjectTrait for LicenseFeatureInfo {
}
impl DataObjectTrait for HostLicensableResourceInfo {
}
impl DataObjectTrait for LicenseManagerLicenseInfo {
}
impl DataObjectTrait for LicenseSource {
}
impl DataObjectTrait for EvaluationLicenseSource {
}
impl DataObjectTrait for LicenseServerSource {
}
impl DataObjectTrait for LocalLicenseSource {
}
impl DataObjectTrait for LicenseUsageInfo {
}
impl DataObjectTrait for LicenseReservationInfo {
}
impl DataObjectTrait for LocalizationManagerMessageCatalog {
}
impl DataObjectTrait for NegatableExpression {
}
impl DataObjectTrait for IntExpression {
}
impl DataObjectTrait for IpAddress {
}
impl DataObjectTrait for IpRange {
}
impl DataObjectTrait for SingleIp {
}
impl DataObjectTrait for MacAddress {
}
impl DataObjectTrait for MacRange {
}
impl DataObjectTrait for SingleMac {
}
impl DataObjectTrait for StringExpression {
}
impl DataObjectTrait for DvsIpPort {
}
impl DataObjectTrait for DvsIpPortRange {
}
impl DataObjectTrait for DvsSingleIpPort {
}
impl DataObjectTrait for NetworkSummary {
}
impl DataObjectTrait for OpaqueNetworkSummary {
}
impl DataObjectTrait for NumericRange {
}
impl DataObjectTrait for OpaqueNetworkCapability {
}
impl DataObjectTrait for OvfConsumerOstNode {
}
impl DataObjectTrait for OvfConsumerOvfSection {
}
impl DataObjectTrait for OvfManagerCommonParams {
}
impl DataObjectTrait for OvfCreateImportSpecParams {
}
impl DataObjectTrait for OvfParseDescriptorParams {
}
impl DataObjectTrait for OvfValidateHostParams {
}
impl DataObjectTrait for OvfCreateDescriptorParams {
}
impl DataObjectTrait for OvfCreateDescriptorResult {
}
impl DataObjectTrait for OvfCreateImportSpecResult {
}
impl DataObjectTrait for OvfDeploymentOption {
}
impl DataObjectTrait for OvfFileItem {
}
impl DataObjectTrait for OvfNetworkInfo {
}
impl DataObjectTrait for OvfNetworkMapping {
}
impl DataObjectTrait for OvfFile {
}
impl DataObjectTrait for OvfOptionInfo {
}
impl DataObjectTrait for OvfParseDescriptorResult {
}
impl DataObjectTrait for OvfResourceMap {
}
impl DataObjectTrait for OvfValidateHostResult {
}
impl DataObjectTrait for PasswordField {
}
impl DataObjectTrait for PerformanceDescription {
}
impl DataObjectTrait for PerfCompositeMetric {
}
impl DataObjectTrait for PerfCounterInfo {
}
impl DataObjectTrait for PerformanceManagerCounterLevelMapping {
}
impl DataObjectTrait for PerfEntityMetricBase {
}
impl DataObjectTrait for PerfEntityMetric {
}
impl DataObjectTrait for PerfEntityMetricCsv {
}
impl DataObjectTrait for PerfMetricId {
}
impl DataObjectTrait for PerfMetricSeries {
}
impl DataObjectTrait for PerfMetricIntSeries {
}
impl DataObjectTrait for PerfMetricSeriesCsv {
}
impl DataObjectTrait for PerfProviderSummary {
}
impl DataObjectTrait for PerfQuerySpec {
}
impl DataObjectTrait for PerfSampleInfo {
}
impl DataObjectTrait for PrivilegePolicyDef {
}
impl DataObjectTrait for ResourceAllocationInfo {
}
impl DataObjectTrait for ResourceAllocationOption {
}
impl DataObjectTrait for ResourceConfigOption {
}
impl DataObjectTrait for ResourceConfigSpec {
}
impl DataObjectTrait for DatabaseSizeEstimate {
}
impl DataObjectTrait for DatabaseSizeParam {
}
impl DataObjectTrait for InventoryDescription {
}
impl DataObjectTrait for PerformanceStatisticsDescription {
}
impl DataObjectTrait for ResourcePoolResourceUsage {
}
impl DataObjectTrait for ResourcePoolRuntimeInfo {
}
impl DataObjectTrait for ResourcePoolSummary {
}
impl DataObjectTrait for VirtualAppSummary {
}
impl DataObjectTrait for ResourcePoolQuickStats {
}
impl DataObjectTrait for SddcBase {
}
impl DataObjectTrait for SelectionSet {
}
impl DataObjectTrait for DvPortgroupSelection {
}
impl DataObjectTrait for DvsSelection {
}
impl DataObjectTrait for HostVMotionCompatibility {
}
impl DataObjectTrait for ProductComponentInfo {
}
impl DataObjectTrait for ServiceContent {
}
impl DataObjectTrait for ServiceLocator {
}
impl DataObjectTrait for ServiceLocatorCredential {
}
impl DataObjectTrait for ServiceLocatorNamePassword {
}
impl DataObjectTrait for ServiceLocatorSamlCredential {
}
impl DataObjectTrait for ServiceManagerServiceInfo {
}
impl DataObjectTrait for SessionManagerGenericServiceTicket {
}
impl DataObjectTrait for SessionManagerLocalTicket {
}
impl DataObjectTrait for SessionManagerServiceRequestSpec {
}
impl DataObjectTrait for SessionManagerHttpServiceRequestSpec {
}
impl DataObjectTrait for SessionManagerVmomiServiceRequestSpec {
}
impl DataObjectTrait for SharesInfo {
}
impl DataObjectTrait for SharesOption {
}
impl DataObjectTrait for SiteInfo {
}
impl DataObjectTrait for StoragePodSummary {
}
impl DataObjectTrait for StorageIoAllocationInfo {
}
impl DataObjectTrait for StorageIoAllocationOption {
}
impl DataObjectTrait for StorageIormInfo {
}
impl DataObjectTrait for StorageIormConfigOption {
}
impl DataObjectTrait for StorageIormConfigSpec {
}
impl DataObjectTrait for PodStorageDrsEntry {
}
impl DataObjectTrait for StoragePerformanceSummary {
}
impl DataObjectTrait for StorageResourceManagerStorageProfileStatistics {
}
impl DataObjectTrait for Tag {
}
impl DataObjectTrait for TaskDescription {
}
impl DataObjectTrait for TaskFilterSpec {
}
impl DataObjectTrait for TaskFilterSpecByEntity {
}
impl DataObjectTrait for TaskFilterSpecByTime {
}
impl DataObjectTrait for TaskFilterSpecByUsername {
}
impl DataObjectTrait for TaskInfo {
}
impl DataObjectTrait for TaskReason {
}
impl DataObjectTrait for TaskReasonAlarm {
}
impl DataObjectTrait for TaskReasonSchedule {
}
impl DataObjectTrait for TaskReasonSystem {
}
impl DataObjectTrait for TaskReasonUser {
}
impl DataObjectTrait for UpdateVirtualMachineFilesResult {
}
impl DataObjectTrait for UpdateVirtualMachineFilesResultFailedVmFileInfo {
}
impl DataObjectTrait for UserSearchResult {
}
impl DataObjectTrait for PosixUserSearchResult {
}
impl DataObjectTrait for UserSession {
}
impl DataObjectTrait for VVolVmConfigFileUpdateResult {
}
impl DataObjectTrait for VVolVmConfigFileUpdateResultFailedVmConfigFileInfo {
}
impl DataObjectTrait for VasaStorageArray {
}
impl DataObjectTrait for VasaStorageArrayDiscoveryFcTransport {
}
impl DataObjectTrait for VasaStorageArrayDiscoveryIpTransport {
}
impl DataObjectTrait for VasaStorageArrayDiscoverySvcInfo {
}
impl DataObjectTrait for VasaProviderContainerSpec {
}
impl DataObjectTrait for VimVasaProvider {
}
impl DataObjectTrait for VimVasaProviderStatePerArray {
}
impl DataObjectTrait for VimVasaProviderVirtualHostConfig {
}
impl DataObjectTrait for VimVasaProviderInfo {
}
impl DataObjectTrait for VirtualAppLinkInfo {
}
impl DataObjectTrait for VirtualDiskSpec {
}
impl DataObjectTrait for DeviceBackedVirtualDiskSpec {
}
impl DataObjectTrait for FileBackedVirtualDiskSpec {
}
impl DataObjectTrait for SeSparseVirtualDiskSpec {
}
impl DataObjectTrait for VirtualMachineConnection {
}
impl DataObjectTrait for VirtualMachineMksConnection {
}
impl DataObjectTrait for DiskChangeInfo {
}
impl DataObjectTrait for DiskChangeExtent {
}
impl DataObjectTrait for VirtualMachineDisplayTopology {
}
impl DataObjectTrait for VirtualMachineMksTicket {
}
impl DataObjectTrait for StorageRequirement {
}
impl DataObjectTrait for VirtualMachineTicket {
}
impl DataObjectTrait for VirtualMachineWipeResult {
}
impl DataObjectTrait for VsanUpgradeSystemNetworkPartitionInfo {
}
impl DataObjectTrait for VsanUpgradeSystemPreflightCheckIssue {
}
impl DataObjectTrait for VsanUpgradeSystemApiBrokenIssue {
}
impl DataObjectTrait for VsanUpgradeSystemAutoClaimEnabledOnHostsIssue {
}
impl DataObjectTrait for VsanUpgradeSystemHostsDisconnectedIssue {
}
impl DataObjectTrait for VsanUpgradeSystemMissingHostsInClusterIssue {
}
impl DataObjectTrait for VsanUpgradeSystemNetworkPartitionIssue {
}
impl DataObjectTrait for VsanUpgradeSystemNotEnoughFreeCapacityIssue {
}
impl DataObjectTrait for VsanUpgradeSystemRogueHostsInClusterIssue {
}
impl DataObjectTrait for VsanUpgradeSystemV2ObjectsPresentDuringDowngradeIssue {
}
impl DataObjectTrait for VsanUpgradeSystemWrongEsxVersionIssue {
}
impl DataObjectTrait for VsanUpgradeSystemPreflightCheckResult {
}
impl DataObjectTrait for VsanUpgradeSystemUpgradeHistoryItem {
}
impl DataObjectTrait for VsanUpgradeSystemUpgradeHistoryDiskGroupOp {
}
impl DataObjectTrait for VsanUpgradeSystemUpgradeHistoryPreflightFail {
}
impl DataObjectTrait for VsanUpgradeSystemUpgradeStatus {
}
impl DataObjectTrait for Action {
}
impl DataObjectTrait for CreateTaskAction {
}
impl DataObjectTrait for MethodAction {
}
impl DataObjectTrait for RunScriptAction {
}
impl DataObjectTrait for SendEmailAction {
}
impl DataObjectTrait for SendSnmpAction {
}
impl DataObjectTrait for MethodActionArgument {
}
impl DataObjectTrait for AlarmAction {
}
impl DataObjectTrait for AlarmTriggeringAction {
}
impl DataObjectTrait for GroupAlarmAction {
}
impl DataObjectTrait for AlarmDescription {
}
impl DataObjectTrait for AlarmExpression {
}
impl DataObjectTrait for AndAlarmExpression {
}
impl DataObjectTrait for EventAlarmExpression {
}
impl DataObjectTrait for MetricAlarmExpression {
}
impl DataObjectTrait for OrAlarmExpression {
}
impl DataObjectTrait for StateAlarmExpression {
}
impl DataObjectTrait for AlarmFilterSpec {
}
impl DataObjectTrait for AlarmSetting {
}
impl DataObjectTrait for AlarmSpec {
}
impl DataObjectTrait for AlarmInfo {
}
impl DataObjectTrait for AlarmState {
}
impl DataObjectTrait for AlarmTriggeringActionTransitionSpec {
}
impl DataObjectTrait for EventAlarmExpressionComparison {
}
impl DataObjectTrait for ClusterAction {
}
impl DataObjectTrait for ClusterClusterInitialPlacementAction {
}
impl DataObjectTrait for ClusterHostInfraUpdateHaModeAction {
}
impl DataObjectTrait for ClusterHostPowerAction {
}
impl DataObjectTrait for ClusterInitialPlacementAction {
}
impl DataObjectTrait for ClusterMigrationAction {
}
impl DataObjectTrait for PlacementAction {
}
impl DataObjectTrait for HbrDiskMigrationAction {
}
impl DataObjectTrait for StorageMigrationAction {
}
impl DataObjectTrait for StoragePlacementAction {
}
impl DataObjectTrait for ClusterActionHistory {
}
impl DataObjectTrait for ClusterAttemptedVmInfo {
}
impl DataObjectTrait for ClusterConfigInfo {
}
impl DataObjectTrait for ClusterConfigSpec {
}
impl DataObjectTrait for ClusterCryptoConfigInfo {
}
impl DataObjectTrait for ClusterDasAamNodeState {
}
impl DataObjectTrait for ClusterDasAdmissionControlInfo {
}
impl DataObjectTrait for ClusterFailoverHostAdmissionControlInfo {
}
impl DataObjectTrait for ClusterFailoverLevelAdmissionControlInfo {
}
impl DataObjectTrait for ClusterFailoverResourcesAdmissionControlInfo {
}
impl DataObjectTrait for ClusterDasAdmissionControlPolicy {
}
impl DataObjectTrait for ClusterFailoverHostAdmissionControlPolicy {
}
impl DataObjectTrait for ClusterFailoverLevelAdmissionControlPolicy {
}
impl DataObjectTrait for ClusterFailoverResourcesAdmissionControlPolicy {
}
impl DataObjectTrait for ClusterDasAdvancedRuntimeInfo {
}
impl DataObjectTrait for ClusterDasFailoverLevelAdvancedRuntimeInfo {
}
impl DataObjectTrait for DasHeartbeatDatastoreInfo {
}
impl DataObjectTrait for ClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo {
}
impl DataObjectTrait for ClusterDasConfigInfo {
}
impl DataObjectTrait for ClusterDasData {
}
impl DataObjectTrait for ClusterDasDataSummary {
}
impl DataObjectTrait for ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots {
}
impl DataObjectTrait for ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo {
}
impl DataObjectTrait for ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots {
}
impl DataObjectTrait for ClusterDasFdmHostState {
}
impl DataObjectTrait for ClusterDasHostInfo {
}
impl DataObjectTrait for ClusterDasAamHostInfo {
}
impl DataObjectTrait for ClusterDasHostRecommendation {
}
impl DataObjectTrait for ClusterDasVmConfigInfo {
}
impl DataObjectTrait for ClusterDasVmSettings {
}
impl DataObjectTrait for ClusterDpmConfigInfo {
}
impl DataObjectTrait for ClusterDpmHostConfigInfo {
}
impl DataObjectTrait for ClusterDrsConfigInfo {
}
impl DataObjectTrait for ClusterDrsFaults {
}
impl DataObjectTrait for ClusterDrsFaultsFaultsByVm {
}
impl DataObjectTrait for ClusterDrsFaultsFaultsByVirtualDisk {
}
impl DataObjectTrait for ClusterDrsMigration {
}
impl DataObjectTrait for ClusterDrsRecommendation {
}
impl DataObjectTrait for ClusterDrsVmConfigInfo {
}
impl DataObjectTrait for ClusterEvcManagerCheckResult {
}
impl DataObjectTrait for ClusterEvcManagerEvcState {
}
impl DataObjectTrait for ClusterEnterMaintenanceResult {
}
impl DataObjectTrait for ClusterFailoverHostAdmissionControlInfoHostStatus {
}
impl DataObjectTrait for ClusterGroupInfo {
}
impl DataObjectTrait for ClusterHostGroup {
}
impl DataObjectTrait for ClusterVmGroup {
}
impl DataObjectTrait for ClusterHostRecommendation {
}
impl DataObjectTrait for ClusterInfraUpdateHaConfigInfo {
}
impl DataObjectTrait for ClusterNotAttemptedVmInfo {
}
impl DataObjectTrait for ClusterOrchestrationInfo {
}
impl DataObjectTrait for PlacementResult {
}
impl DataObjectTrait for PlacementSpec {
}
impl DataObjectTrait for ClusterPowerOnVmResult {
}
impl DataObjectTrait for ClusterPreemptibleVmPairInfo {
}
impl DataObjectTrait for ClusterProactiveDrsConfigInfo {
}
impl DataObjectTrait for ClusterRecommendation {
}
impl DataObjectTrait for ClusterResourceUsageSummary {
}
impl DataObjectTrait for ClusterRuleInfo {
}
impl DataObjectTrait for ClusterAffinityRuleSpec {
}
impl DataObjectTrait for ClusterAntiAffinityRuleSpec {
}
impl DataObjectTrait for ClusterDependencyRuleInfo {
}
impl DataObjectTrait for ClusterVmHostRuleInfo {
}
impl DataObjectTrait for VirtualDiskAntiAffinityRuleSpec {
}
impl DataObjectTrait for VirtualDiskRuleSpec {
}
impl DataObjectTrait for ClusterSlotPolicy {
}
impl DataObjectTrait for ClusterFixedSizeSlotPolicy {
}
impl DataObjectTrait for ClusterSystemVMsConfigInfo {
}
impl DataObjectTrait for ClusterSystemVMsConfigSpec {
}
impl DataObjectTrait for ClusterUsageSummary {
}
impl DataObjectTrait for ClusterVmComponentProtectionSettings {
}
impl DataObjectTrait for ClusterVmOrchestrationInfo {
}
impl DataObjectTrait for ClusterVmReadiness {
}
impl DataObjectTrait for ClusterVmToolsMonitoringSettings {
}
impl DataObjectTrait for DistributedVirtualPort {
}
impl DataObjectTrait for DvPortConfigInfo {
}
impl DataObjectTrait for DvPortConfigSpec {
}
impl DataObjectTrait for DvsFilterParameter {
}
impl DataObjectTrait for DvsHostLocalPortInfo {
}
impl DataObjectTrait for DvPortStatus {
}
impl DataObjectTrait for DvPortSetting {
}
impl DataObjectTrait for VMwareDvsPortSetting {
}
impl DataObjectTrait for DvPortState {
}
impl DataObjectTrait for DvPortgroupConfigInfo {
}
impl DataObjectTrait for DvPortgroupConfigSpec {
}
impl DataObjectTrait for DistributedVirtualPortgroupNsxPortgroupOperationResult {
}
impl DataObjectTrait for DvPortgroupPolicy {
}
impl DataObjectTrait for VMwareDvsPortgroupPolicy {
}
impl DataObjectTrait for DistributedVirtualPortgroupProblem {
}
impl DataObjectTrait for DistributedVirtualPortgroupInfo {
}
impl DataObjectTrait for DistributedVirtualSwitchInfo {
}
impl DataObjectTrait for DistributedVirtualSwitchManagerCompatibilityResult {
}
impl DataObjectTrait for DvsManagerDvsConfigTarget {
}
impl DataObjectTrait for DistributedVirtualSwitchManagerDvsProductSpec {
}
impl DataObjectTrait for DistributedVirtualSwitchManagerHostContainer {
}
impl DataObjectTrait for DistributedVirtualSwitchManagerHostDvsFilterSpec {
}
impl DataObjectTrait for DistributedVirtualSwitchManagerHostArrayFilter {
}
impl DataObjectTrait for DistributedVirtualSwitchManagerHostContainerFilter {
}
impl DataObjectTrait for DistributedVirtualSwitchManagerHostDvsMembershipFilter {
}
impl DataObjectTrait for DistributedVirtualSwitchManagerImportResult {
}
impl DataObjectTrait for DvsManagerPhysicalNicsList {
}
impl DataObjectTrait for EntityBackup {
}
impl DataObjectTrait for EntityBackupConfig {
}
impl DataObjectTrait for DistributedVirtualSwitchHostMember {
}
impl DataObjectTrait for DistributedVirtualSwitchHostMemberBacking {
}
impl DataObjectTrait for DistributedVirtualSwitchHostMemberPnicBacking {
}
impl DataObjectTrait for DistributedVirtualSwitchHostMemberConfigInfo {
}
impl DataObjectTrait for DistributedVirtualSwitchHostMemberConfigSpec {
}
impl DataObjectTrait for HostMemberHealthCheckResult {
}
impl DataObjectTrait for HostMemberUplinkHealthCheckResult {
}
impl DataObjectTrait for VMwareDvsMtuHealthCheckResult {
}
impl DataObjectTrait for VMwareDvsVlanHealthCheckResult {
}
impl DataObjectTrait for VMwareDvsTeamingHealthCheckResult {
}
impl DataObjectTrait for DistributedVirtualSwitchHostMemberPnicSpec {
}
impl DataObjectTrait for HostMemberRuntimeInfo {
}
impl DataObjectTrait for DistributedVirtualSwitchHostMemberRuntimeState {
}
impl DataObjectTrait for DistributedVirtualSwitchHostMemberTransportZoneInfo {
}
impl DataObjectTrait for DistributedVirtualSwitchHostProductSpec {
}
impl DataObjectTrait for DistributedVirtualSwitchKeyedOpaqueBlob {
}
impl DataObjectTrait for DistributedVirtualSwitchNetworkOffloadSpec {
}
impl DataObjectTrait for DvsNetworkResourcePool {
}
impl DataObjectTrait for DvsNetworkResourcePoolAllocationInfo {
}
impl DataObjectTrait for DvsNetworkResourcePoolConfigSpec {
}
impl DataObjectTrait for DistributedVirtualSwitchPortConnectee {
}
impl DataObjectTrait for DistributedVirtualSwitchPortConnection {
}
impl DataObjectTrait for DistributedVirtualSwitchPortCriteria {
}
impl DataObjectTrait for DistributedVirtualSwitchPortStatistics {
}
impl DataObjectTrait for DistributedVirtualSwitchProductSpec {
}
impl DataObjectTrait for DvsTrafficRule {
}
impl DataObjectTrait for DvsNetworkRuleAction {
}
impl DataObjectTrait for DvsAcceptNetworkRuleAction {
}
impl DataObjectTrait for DvsCopyNetworkRuleAction {
}
impl DataObjectTrait for DvsDropNetworkRuleAction {
}
impl DataObjectTrait for DvsGreEncapNetworkRuleAction {
}
impl DataObjectTrait for DvsLogNetworkRuleAction {
}
impl DataObjectTrait for DvsMacRewriteNetworkRuleAction {
}
impl DataObjectTrait for DvsPuntNetworkRuleAction {
}
impl DataObjectTrait for DvsRateLimitNetworkRuleAction {
}
impl DataObjectTrait for DvsUpdateTagNetworkRuleAction {
}
impl DataObjectTrait for DvsNetworkRuleQualifier {
}
impl DataObjectTrait for DvsIpNetworkRuleQualifier {
}
impl DataObjectTrait for DvsMacNetworkRuleQualifier {
}
impl DataObjectTrait for DvsSystemTrafficNetworkRuleQualifier {
}
impl DataObjectTrait for DvsTrafficRuleset {
}
impl DataObjectTrait for DvsVmVnicNetworkResourcePool {
}
impl DataObjectTrait for DvsVmVnicResourcePoolConfigSpec {
}
impl DataObjectTrait for DvsVmVnicResourceAllocation {
}
impl DataObjectTrait for DvsVmVnicNetworkResourcePoolRuntimeInfo {
}
impl DataObjectTrait for DvsVnicAllocatedResource {
}
impl DataObjectTrait for VMwareDvsDpuCapability {
}
impl DataObjectTrait for VMwareIpfixConfig {
}
impl DataObjectTrait for VMwareDvsIpfixCapability {
}
impl DataObjectTrait for VMwareDvsLacpCapability {
}
impl DataObjectTrait for VMwareDvsLacpGroupConfig {
}
impl DataObjectTrait for VMwareDvsLacpGroupSpec {
}
impl DataObjectTrait for VMwareDvsLagIpfixConfig {
}
impl DataObjectTrait for VMwareDvsLagVlanConfig {
}
impl DataObjectTrait for VMwareDvsMtuCapability {
}
impl DataObjectTrait for VMwareDvsPvlanConfigSpec {
}
impl DataObjectTrait for VMwareDvsPvlanMapEntry {
}
impl DataObjectTrait for VMwareDvsVspanConfigSpec {
}
impl DataObjectTrait for VMwareDvsVspanCapability {
}
impl DataObjectTrait for VMwareVspanPort {
}
impl DataObjectTrait for VMwareVspanSession {
}
impl DataObjectTrait for CryptoKeyId {
}
impl DataObjectTrait for CryptoKeyPlain {
}
impl DataObjectTrait for CryptoKeyResult {
}
impl DataObjectTrait for CryptoManagerHostKeyStatus {
}
impl DataObjectTrait for CryptoManagerKmipCertSignRequest {
}
impl DataObjectTrait for CryptoManagerKmipCertificateInfo {
}
impl DataObjectTrait for CryptoManagerKmipClusterStatus {
}
impl DataObjectTrait for CryptoManagerKmipCryptoKeyStatus {
}
impl DataObjectTrait for CryptoManagerKmipCustomAttributeSpec {
}
impl DataObjectTrait for CryptoManagerKmipServerCertInfo {
}
impl DataObjectTrait for CryptoManagerKmipServerStatus {
}
impl DataObjectTrait for CryptoSpec {
}
impl DataObjectTrait for CryptoSpecDecrypt {
}
impl DataObjectTrait for CryptoSpecDeepRecrypt {
}
impl DataObjectTrait for CryptoSpecEncrypt {
}
impl DataObjectTrait for CryptoSpecNoOp {
}
impl DataObjectTrait for CryptoSpecRegister {
}
impl DataObjectTrait for CryptoSpecShallowRecrypt {
}
impl DataObjectTrait for KeyProviderId {
}
impl DataObjectTrait for KmipClusterInfo {
}
impl DataObjectTrait for KmipServerInfo {
}
impl DataObjectTrait for KmipServerSpec {
}
impl DataObjectTrait for KmipServerStatus {
}
impl DataObjectTrait for ChangesInfoEventArgument {
}
impl DataObjectTrait for DvsOutOfSyncHostArgument {
}
impl DataObjectTrait for Event {
}
impl DataObjectTrait for EventArgument {
}
impl DataObjectTrait for EntityEventArgument {
}
impl DataObjectTrait for AlarmEventArgument {
}
impl DataObjectTrait for ComputeResourceEventArgument {
}
impl DataObjectTrait for DatacenterEventArgument {
}
impl DataObjectTrait for DatastoreEventArgument {
}
impl DataObjectTrait for DvsEventArgument {
}
impl DataObjectTrait for FolderEventArgument {
}
impl DataObjectTrait for HostEventArgument {
}
impl DataObjectTrait for ManagedEntityEventArgument {
}
impl DataObjectTrait for NetworkEventArgument {
}
impl DataObjectTrait for ResourcePoolEventArgument {
}
impl DataObjectTrait for ScheduledTaskEventArgument {
}
impl DataObjectTrait for VmEventArgument {
}
impl DataObjectTrait for ProfileEventArgument {
}
impl DataObjectTrait for RoleEventArgument {
}
impl DataObjectTrait for EventDescription {
}
impl DataObjectTrait for EventArgDesc {
}
impl DataObjectTrait for EventDescriptionEventDetail {
}
impl DataObjectTrait for EventFilterSpec {
}
impl DataObjectTrait for EventFilterSpecByEntity {
}
impl DataObjectTrait for EventFilterSpecByTime {
}
impl DataObjectTrait for EventFilterSpecByUsername {
}
impl DataObjectTrait for ExtendedEventPair {
}
impl DataObjectTrait for VnicPortArgument {
}
impl DataObjectTrait for ExtExtendedProductInfo {
}
impl DataObjectTrait for ManagedByInfo {
}
impl DataObjectTrait for ExtManagedEntityInfo {
}
impl DataObjectTrait for ExtSolutionManagerInfo {
}
impl DataObjectTrait for ExtSolutionManagerInfoTabInfo {
}
impl DataObjectTrait for AnswerFileUpdateFailure {
}
impl DataObjectTrait for ConflictingConfigurationConfig {
}
impl DataObjectTrait for DatacenterMismatchArgument {
}
impl DataObjectTrait for DvsApplyOperationFaultFaultOnObject {
}
impl DataObjectTrait for DvsOperationBulkFaultFaultOnHost {
}
impl DataObjectTrait for ImportOperationBulkFaultFaultOnImport {
}
impl DataObjectTrait for MultipleCertificatesVerifyFaultThumbprintData {
}
impl DataObjectTrait for NoPermissionEntityPrivileges {
}
impl DataObjectTrait for ProfileUpdateFailedUpdateFailure {
}
impl DataObjectTrait for HostActiveDirectory {
}
impl DataObjectTrait for HostActiveDirectorySpec {
}
impl DataObjectTrait for HostAssignableHardwareBinding {
}
impl DataObjectTrait for HostAssignableHardwareConfig {
}
impl DataObjectTrait for HostAssignableHardwareConfigAttributeOverride {
}
impl DataObjectTrait for HostAuthenticationManagerInfo {
}
impl DataObjectTrait for HostAuthenticationStoreInfo {
}
impl DataObjectTrait for HostDirectoryStoreInfo {
}
impl DataObjectTrait for HostActiveDirectoryInfo {
}
impl DataObjectTrait for HostLocalAuthenticationInfo {
}
impl DataObjectTrait for AutoStartPowerInfo {
}
impl DataObjectTrait for HostAutoStartManagerConfig {
}
impl DataObjectTrait for AutoStartDefaults {
}
impl DataObjectTrait for HostBiosInfo {
}
impl DataObjectTrait for HostBootDeviceInfo {
}
impl DataObjectTrait for HostBootDevice {
}
impl DataObjectTrait for HostCacheConfigurationInfo {
}
impl DataObjectTrait for HostCacheConfigurationSpec {
}
impl DataObjectTrait for HostCapability {
}
impl DataObjectTrait for HostCertificateManagerCertificateInfo {
}
impl DataObjectTrait for HostCertificateManagerCertificateSpec {
}
impl DataObjectTrait for HostConfigChange {
}
impl DataObjectTrait for HostConfigInfo {
}
impl DataObjectTrait for HostConfigManager {
}
impl DataObjectTrait for HostConfigSpec {
}
impl DataObjectTrait for HostConnectInfo {
}
impl DataObjectTrait for HostDatastoreConnectInfo {
}
impl DataObjectTrait for HostDatastoreExistsConnectInfo {
}
impl DataObjectTrait for HostDatastoreNameConflictConnectInfo {
}
impl DataObjectTrait for HostLicenseConnectInfo {
}
impl DataObjectTrait for HostConnectInfoNetworkInfo {
}
impl DataObjectTrait for HostNewNetworkConnectInfo {
}
impl DataObjectTrait for HostConnectSpec {
}
impl DataObjectTrait for HostCpuIdInfo {
}
impl DataObjectTrait for HostCpuInfo {
}
impl DataObjectTrait for HostCpuPackage {
}
impl DataObjectTrait for HostCpuPowerManagementInfo {
}
impl DataObjectTrait for HostHyperThreadScheduleInfo {
}
impl DataObjectTrait for HostDataTransportConnectionInfo {
}
impl DataObjectTrait for HostNfcConnectionInfo {
}
impl DataObjectTrait for FileInfo {
}
impl DataObjectTrait for FloppyImageFileInfo {
}
impl DataObjectTrait for FolderFileInfo {
}
impl DataObjectTrait for IsoImageFileInfo {
}
impl DataObjectTrait for VmConfigFileInfo {
}
impl DataObjectTrait for TemplateConfigFileInfo {
}
impl DataObjectTrait for VmDiskFileInfo {
}
impl DataObjectTrait for VmLogFileInfo {
}
impl DataObjectTrait for VmNvramFileInfo {
}
impl DataObjectTrait for VmSnapshotFileInfo {
}
impl DataObjectTrait for FileQueryFlags {
}
impl DataObjectTrait for FileQuery {
}
impl DataObjectTrait for FloppyImageFileQuery {
}
impl DataObjectTrait for FolderFileQuery {
}
impl DataObjectTrait for IsoImageFileQuery {
}
impl DataObjectTrait for VmConfigFileQuery {
}
impl DataObjectTrait for TemplateConfigFileQuery {
}
impl DataObjectTrait for VmDiskFileQuery {
}
impl DataObjectTrait for VmLogFileQuery {
}
impl DataObjectTrait for VmNvramFileQuery {
}
impl DataObjectTrait for VmSnapshotFileQuery {
}
impl DataObjectTrait for HostDatastoreBrowserSearchResults {
}
impl DataObjectTrait for HostDatastoreBrowserSearchSpec {
}
impl DataObjectTrait for VmConfigFileEncryptionInfo {
}
impl DataObjectTrait for VmConfigFileQueryFlags {
}
impl DataObjectTrait for VmConfigFileQueryFilter {
}
impl DataObjectTrait for VmDiskFileEncryptionInfo {
}
impl DataObjectTrait for VmDiskFileQueryFlags {
}
impl DataObjectTrait for VmDiskFileQueryFilter {
}
impl DataObjectTrait for HostDatastoreSystemCapabilities {
}
impl DataObjectTrait for HostDatastoreSystemDatastoreResult {
}
impl DataObjectTrait for HostDatastoreSystemVvolDatastoreSpec {
}
impl DataObjectTrait for HostDateTimeConfig {
}
impl DataObjectTrait for HostDateTimeInfo {
}
impl DataObjectTrait for HostDateTimeSystemServiceTestResult {
}
impl DataObjectTrait for HostDateTimeSystemTimeZone {
}
impl DataObjectTrait for HostDeploymentInfo {
}
impl DataObjectTrait for HostDevice {
}
impl DataObjectTrait for ScsiLun {
}
impl DataObjectTrait for HostScsiDisk {
}
impl DataObjectTrait for HostDhcpService {
}
impl DataObjectTrait for HostDhcpServiceConfig {
}
impl DataObjectTrait for HostDhcpServiceSpec {
}
impl DataObjectTrait for HostDiagnosticPartition {
}
impl DataObjectTrait for HostDiagnosticPartitionCreateDescription {
}
impl DataObjectTrait for HostDiagnosticPartitionCreateOption {
}
impl DataObjectTrait for HostDiagnosticPartitionCreateSpec {
}
impl DataObjectTrait for HostDigestInfo {
}
impl DataObjectTrait for HostTpmDigestInfo {
}
impl DataObjectTrait for HostDiskConfigurationResult {
}
impl DataObjectTrait for HostDiskDimensions {
}
impl DataObjectTrait for HostDiskDimensionsChs {
}
impl DataObjectTrait for HostDiskDimensionsLba {
}
impl DataObjectTrait for HostDiskPartitionInfo {
}
impl DataObjectTrait for HostDiskPartitionBlockRange {
}
impl DataObjectTrait for HostDiskPartitionLayout {
}
impl DataObjectTrait for HostDiskPartitionAttributes {
}
impl DataObjectTrait for HostDiskPartitionSpec {
}
impl DataObjectTrait for HostDnsConfig {
}
impl DataObjectTrait for HostDnsConfigSpec {
}
impl DataObjectTrait for HostDvxClass {
}
impl DataObjectTrait for HostEnterMaintenanceResult {
}
impl DataObjectTrait for HostEsxAgentHostManagerConfigInfo {
}
impl DataObjectTrait for HostFaultToleranceManagerComponentHealthInfo {
}
impl DataObjectTrait for FcoeConfig {
}
impl DataObjectTrait for FcoeConfigFcoeCapabilities {
}
impl DataObjectTrait for FcoeConfigFcoeSpecification {
}
impl DataObjectTrait for FcoeConfigVlanRange {
}
impl DataObjectTrait for HostFeatureCapability {
}
impl DataObjectTrait for HostFeatureMask {
}
impl DataObjectTrait for HostFeatureVersionInfo {
}
impl DataObjectTrait for HostFibreChannelOverEthernetHbaLinkInfo {
}
impl DataObjectTrait for HostFileAccess {
}
impl DataObjectTrait for ModeInfo {
}
impl DataObjectTrait for HostFileSystemMountInfo {
}
impl DataObjectTrait for HostFileSystemVolume {
}
impl DataObjectTrait for HostLocalFileSystemVolume {
}
impl DataObjectTrait for HostNasVolume {
}
impl DataObjectTrait for HostPMemVolume {
}
impl DataObjectTrait for HostVfatVolume {
}
impl DataObjectTrait for HostVffsVolume {
}
impl DataObjectTrait for HostVmfsVolume {
}
impl DataObjectTrait for HostVvolVolume {
}
impl DataObjectTrait for HostFileSystemVolumeInfo {
}
impl DataObjectTrait for HostFirewallConfig {
}
impl DataObjectTrait for HostFirewallConfigRuleSetConfig {
}
impl DataObjectTrait for HostFirewallInfo {
}
impl DataObjectTrait for HostFirewallDefaultPolicy {
}
impl DataObjectTrait for HostFlagInfo {
}
impl DataObjectTrait for HostForceMountedInfo {
}
impl DataObjectTrait for HostFru {
}
impl DataObjectTrait for HostGatewaySpec {
}
impl DataObjectTrait for HostGraphicsConfig {
}
impl DataObjectTrait for HostGraphicsConfigDeviceType {
}
impl DataObjectTrait for HostGraphicsInfo {
}
impl DataObjectTrait for HostHardwareInfo {
}
impl DataObjectTrait for HostHardwareStatusInfo {
}
impl DataObjectTrait for DpuStatusInfoOperationalInfo {
}
impl DataObjectTrait for HostHardwareElementInfo {
}
impl DataObjectTrait for DpuStatusInfo {
}
impl DataObjectTrait for HostStorageElementInfo {
}
impl DataObjectTrait for HostStorageOperationalInfo {
}
impl DataObjectTrait for HostHbaCreateSpec {
}
impl DataObjectTrait for HostTcpHbaCreateSpec {
}
impl DataObjectTrait for HealthSystemRuntime {
}
impl DataObjectTrait for HostAccessControlEntry {
}
impl DataObjectTrait for HostHostBusAdapter {
}
impl DataObjectTrait for HostBlockHba {
}
impl DataObjectTrait for HostFibreChannelHba {
}
impl DataObjectTrait for HostFibreChannelOverEthernetHba {
}
impl DataObjectTrait for HostInternetScsiHba {
}
impl DataObjectTrait for HostParallelScsiHba {
}
impl DataObjectTrait for HostPcieHba {
}
impl DataObjectTrait for HostRdmaHba {
}
impl DataObjectTrait for HostSerialAttachedHba {
}
impl DataObjectTrait for HostTcpHba {
}
impl DataObjectTrait for HostProxySwitch {
}
impl DataObjectTrait for HostProxySwitchConfig {
}
impl DataObjectTrait for HostProxySwitchEnsInfo {
}
impl DataObjectTrait for HostProxySwitchHostLagConfig {
}
impl DataObjectTrait for HostProxySwitchSpec {
}
impl DataObjectTrait for HostImageProfileSummary {
}
impl DataObjectTrait for HostInternetScsiHbaAuthenticationCapabilities {
}
impl DataObjectTrait for HostInternetScsiHbaAuthenticationProperties {
}
impl DataObjectTrait for HostInternetScsiHbaDigestCapabilities {
}
impl DataObjectTrait for HostInternetScsiHbaDigestProperties {
}
impl DataObjectTrait for HostInternetScsiHbaDiscoveryCapabilities {
}
impl DataObjectTrait for HostInternetScsiHbaDiscoveryProperties {
}
impl DataObjectTrait for HostInternetScsiHbaIpCapabilities {
}
impl DataObjectTrait for HostInternetScsiHbaIpProperties {
}
impl DataObjectTrait for HostInternetScsiHbaIPv6Properties {
}
impl DataObjectTrait for HostInternetScsiHbaIscsiIpv6Address {
}
impl DataObjectTrait for HostInternetScsiHbaSendTarget {
}
impl DataObjectTrait for HostInternetScsiHbaStaticTarget {
}
impl DataObjectTrait for HostInternetScsiHbaTargetSet {
}
impl DataObjectTrait for HostIpConfig {
}
impl DataObjectTrait for HostIpConfigIpV6Address {
}
impl DataObjectTrait for HostIpConfigIpV6AddressConfiguration {
}
impl DataObjectTrait for HostIpRouteConfig {
}
impl DataObjectTrait for HostIpRouteConfigSpec {
}
impl DataObjectTrait for HostIpRouteEntry {
}
impl DataObjectTrait for HostIpRouteOp {
}
impl DataObjectTrait for HostIpRouteTableConfig {
}
impl DataObjectTrait for HostIpRouteTableInfo {
}
impl DataObjectTrait for HostIpmiInfo {
}
impl DataObjectTrait for IscsiDependencyEntity {
}
impl DataObjectTrait for IscsiMigrationDependency {
}
impl DataObjectTrait for IscsiPortInfo {
}
impl DataObjectTrait for IscsiStatus {
}
impl DataObjectTrait for KernelModuleInfo {
}
impl DataObjectTrait for KernelModuleSectionInfo {
}
impl DataObjectTrait for HostLicenseSpec {
}
impl DataObjectTrait for LinkDiscoveryProtocolConfig {
}
impl DataObjectTrait for HostAccountSpec {
}
impl DataObjectTrait for HostPosixAccountSpec {
}
impl DataObjectTrait for HostLocalFileSystemVolumeSpec {
}
impl DataObjectTrait for HostLowLevelProvisioningManagerDiskLayoutSpec {
}
impl DataObjectTrait for HostLowLevelProvisioningManagerFileDeleteResult {
}
impl DataObjectTrait for HostLowLevelProvisioningManagerFileDeleteSpec {
}
impl DataObjectTrait for HostLowLevelProvisioningManagerFileReserveResult {
}
impl DataObjectTrait for HostLowLevelProvisioningManagerFileReserveSpec {
}
impl DataObjectTrait for HostLowLevelProvisioningManagerSnapshotLayoutSpec {
}
impl DataObjectTrait for HostLowLevelProvisioningManagerVmMigrationStatus {
}
impl DataObjectTrait for HostLowLevelProvisioningManagerVmRecoveryInfo {
}
impl DataObjectTrait for HostMaintenanceSpec {
}
impl DataObjectTrait for ServiceConsoleReservationInfo {
}
impl DataObjectTrait for VirtualMachineMemoryReservationInfo {
}
impl DataObjectTrait for VirtualMachineMemoryReservationSpec {
}
impl DataObjectTrait for HostMemorySpec {
}
impl DataObjectTrait for HostMemoryTierInfo {
}
impl DataObjectTrait for HostMountInfo {
}
impl DataObjectTrait for HostMultipathInfo {
}
impl DataObjectTrait for HostMultipathInfoLogicalUnit {
}
impl DataObjectTrait for HostMultipathInfoLogicalUnitPolicy {
}
impl DataObjectTrait for HostMultipathInfoFixedLogicalUnitPolicy {
}
impl DataObjectTrait for HostMultipathInfoHppLogicalUnitPolicy {
}
impl DataObjectTrait for HostMultipathInfoLogicalUnitStorageArrayTypePolicy {
}
impl DataObjectTrait for HostMultipathInfoPath {
}
impl DataObjectTrait for HostMultipathStateInfo {
}
impl DataObjectTrait for HostMultipathStateInfoPath {
}
impl DataObjectTrait for HostNasVolumeConfig {
}
impl DataObjectTrait for HostNasVolumeSpec {
}
impl DataObjectTrait for HostNasVolumeUserInfo {
}
impl DataObjectTrait for HostNatService {
}
impl DataObjectTrait for HostNatServiceConfig {
}
impl DataObjectTrait for HostNatServiceNameServiceSpec {
}
impl DataObjectTrait for HostNatServicePortForwardSpec {
}
impl DataObjectTrait for HostNatServiceSpec {
}
impl DataObjectTrait for HostNetCapabilities {
}
impl DataObjectTrait for HostNetOffloadCapabilities {
}
impl DataObjectTrait for HostNetStackInstance {
}
impl DataObjectTrait for HostNetworkConfig {
}
impl DataObjectTrait for HostNetworkConfigNetStackSpec {
}
impl DataObjectTrait for HostNetworkConfigResult {
}
impl DataObjectTrait for HostNetworkInfo {
}
impl DataObjectTrait for HostNetworkPolicy {
}
impl DataObjectTrait for HostNicFailureCriteria {
}
impl DataObjectTrait for HostNicOrderPolicy {
}
impl DataObjectTrait for HostNicTeamingPolicy {
}
impl DataObjectTrait for HostNetworkSecurityPolicy {
}
impl DataObjectTrait for HostNetworkTrafficShapingPolicy {
}
impl DataObjectTrait for HostNtpConfig {
}
impl DataObjectTrait for HostNumaInfo {
}
impl DataObjectTrait for HostNumaNode {
}
impl DataObjectTrait for HostNumericSensorInfo {
}
impl DataObjectTrait for NvdimmDimmInfo {
}
impl DataObjectTrait for NvdimmGuid {
}
impl DataObjectTrait for NvdimmHealthInfo {
}
impl DataObjectTrait for NvdimmInterleaveSetInfo {
}
impl DataObjectTrait for NvdimmNamespaceCreateSpec {
}
impl DataObjectTrait for NvdimmNamespaceDeleteSpec {
}
impl DataObjectTrait for NvdimmNamespaceDetails {
}
impl DataObjectTrait for NvdimmNamespaceInfo {
}
impl DataObjectTrait for NvdimmSystemInfo {
}
impl DataObjectTrait for NvdimmPMemNamespaceCreateSpec {
}
impl DataObjectTrait for NvdimmRegionInfo {
}
impl DataObjectTrait for NvdimmSummary {
}
impl DataObjectTrait for HostNvmeController {
}
impl DataObjectTrait for HostNvmeDisconnectSpec {
}
impl DataObjectTrait for HostNvmeDiscoveryLog {
}
impl DataObjectTrait for HostNvmeDiscoveryLogEntry {
}
impl DataObjectTrait for HostNvmeNamespace {
}
impl DataObjectTrait for HostNvmeSpec {
}
impl DataObjectTrait for HostNvmeConnectSpec {
}
impl DataObjectTrait for HostNvmeDiscoverSpec {
}
impl DataObjectTrait for HostNvmeTopology {
}
impl DataObjectTrait for HostNvmeTopologyInterface {
}
impl DataObjectTrait for HostNvmeTransportParameters {
}
impl DataObjectTrait for HostNvmeOpaqueTransportParameters {
}
impl DataObjectTrait for HostNvmeOverFibreChannelParameters {
}
impl DataObjectTrait for HostNvmeOverRdmaParameters {
}
impl DataObjectTrait for HostNvmeOverTcpParameters {
}
impl DataObjectTrait for HostOpaqueNetworkInfo {
}
impl DataObjectTrait for HostOpaqueSwitch {
}
impl DataObjectTrait for HostOpaqueSwitchPhysicalNicZone {
}
impl DataObjectTrait for HostPatchManagerLocator {
}
impl DataObjectTrait for HostPatchManagerPatchManagerOperationSpec {
}
impl DataObjectTrait for HostPatchManagerResult {
}
impl DataObjectTrait for HostPatchManagerStatus {
}
impl DataObjectTrait for HostPatchManagerStatusPrerequisitePatch {
}
impl DataObjectTrait for HostPathSelectionPolicyOption {
}
impl DataObjectTrait for HostPciDevice {
}
impl DataObjectTrait for HostPciPassthruConfig {
}
impl DataObjectTrait for HostSriovConfig {
}
impl DataObjectTrait for HostPciPassthruInfo {
}
impl DataObjectTrait for HostSriovInfo {
}
impl DataObjectTrait for HostPersistentMemoryInfo {
}
impl DataObjectTrait for PhysicalNic {
}
impl DataObjectTrait for PhysicalNicCdpDeviceCapability {
}
impl DataObjectTrait for PhysicalNicCdpInfo {
}
impl DataObjectTrait for PhysicalNicConfig {
}
impl DataObjectTrait for PhysicalNicLinkInfo {
}
impl DataObjectTrait for LinkLayerDiscoveryProtocolInfo {
}
impl DataObjectTrait for PhysicalNicHintInfo {
}
impl DataObjectTrait for PhysicalNicHint {
}
impl DataObjectTrait for PhysicalNicIpHint {
}
impl DataObjectTrait for PhysicalNicNameHint {
}
impl DataObjectTrait for PhysicalNicSpec {
}
impl DataObjectTrait for HostPlugStoreTopology {
}
impl DataObjectTrait for HostPlugStoreTopologyAdapter {
}
impl DataObjectTrait for HostPlugStoreTopologyDevice {
}
impl DataObjectTrait for HostPlugStoreTopologyPath {
}
impl DataObjectTrait for HostPlugStoreTopologyPlugin {
}
impl DataObjectTrait for HostPlugStoreTopologyTarget {
}
impl DataObjectTrait for HostPortGroup {
}
impl DataObjectTrait for HostPortGroupConfig {
}
impl DataObjectTrait for HostPortGroupPort {
}
impl DataObjectTrait for HostPortGroupSpec {
}
impl DataObjectTrait for PowerSystemCapability {
}
impl DataObjectTrait for PowerSystemInfo {
}
impl DataObjectTrait for HostPowerPolicy {
}
impl DataObjectTrait for HostProtocolEndpoint {
}
impl DataObjectTrait for HostPtpConfig {
}
impl DataObjectTrait for HostPtpConfigPtpPort {
}
impl DataObjectTrait for HostQualifiedName {
}
impl DataObjectTrait for HostRdmaDevice {
}
impl DataObjectTrait for HostRdmaDeviceBacking {
}
impl DataObjectTrait for HostRdmaDevicePnicBacking {
}
impl DataObjectTrait for HostRdmaDeviceCapability {
}
impl DataObjectTrait for HostRdmaDeviceConnectionInfo {
}
impl DataObjectTrait for HostReliableMemoryInfo {
}
impl DataObjectTrait for HostResignatureRescanResult {
}
impl DataObjectTrait for HostFirewallRuleset {
}
impl DataObjectTrait for HostFirewallRulesetIpList {
}
impl DataObjectTrait for HostFirewallRulesetIpNetwork {
}
impl DataObjectTrait for HostFirewallRule {
}
impl DataObjectTrait for HostFirewallRulesetRulesetSpec {
}
impl DataObjectTrait for HostRuntimeInfo {
}
impl DataObjectTrait for HostRuntimeInfoNetStackInstanceRuntimeInfo {
}
impl DataObjectTrait for HostNetworkResourceRuntime {
}
impl DataObjectTrait for HostRuntimeInfoNetworkRuntimeInfo {
}
impl DataObjectTrait for HostPlacedVirtualNicIdentifier {
}
impl DataObjectTrait for HostPnicNetworkResourceInfo {
}
impl DataObjectTrait for HostRuntimeInfoStateEncryptionInfo {
}
impl DataObjectTrait for HostScsiDiskPartition {
}
impl DataObjectTrait for ScsiLunCapabilities {
}
impl DataObjectTrait for ScsiLunDescriptor {
}
impl DataObjectTrait for ScsiLunDurableName {
}
impl DataObjectTrait for HostScsiTopology {
}
impl DataObjectTrait for HostScsiTopologyInterface {
}
impl DataObjectTrait for HostScsiTopologyLun {
}
impl DataObjectTrait for HostScsiTopologyTarget {
}
impl DataObjectTrait for HostSecuritySpec {
}
impl DataObjectTrait for HostService {
}
impl DataObjectTrait for HostServiceSourcePackage {
}
impl DataObjectTrait for HostServiceConfig {
}
impl DataObjectTrait for HostServiceInfo {
}
impl DataObjectTrait for HostSevInfo {
}
impl DataObjectTrait for HostSgxInfo {
}
impl DataObjectTrait for HostSgxRegistrationInfo {
}
impl DataObjectTrait for HostSharedGpuCapabilities {
}
impl DataObjectTrait for HostSnmpSystemAgentLimits {
}
impl DataObjectTrait for HostSnmpConfigSpec {
}
impl DataObjectTrait for HostSnmpDestination {
}
impl DataObjectTrait for SoftwarePackage {
}
impl DataObjectTrait for SoftwarePackageCapability {
}
impl DataObjectTrait for Relation {
}
impl DataObjectTrait for HostSriovDevicePoolInfo {
}
impl DataObjectTrait for HostSriovNetworkDevicePoolInfo {
}
impl DataObjectTrait for HostSslThumbprintInfo {
}
impl DataObjectTrait for HostStorageArrayTypePolicyOption {
}
impl DataObjectTrait for HostStorageDeviceInfo {
}
impl DataObjectTrait for HostStorageSystemDiskLocatorLedResult {
}
impl DataObjectTrait for HostStorageSystemScsiLunResult {
}
impl DataObjectTrait for HostStorageSystemVmfsVolumeResult {
}
impl DataObjectTrait for HostListSummary {
}
impl DataObjectTrait for HostConfigSummary {
}
impl DataObjectTrait for HostListSummaryGatewaySummary {
}
impl DataObjectTrait for HostHardwareSummary {
}
impl DataObjectTrait for HostListSummaryQuickStats {
}
impl DataObjectTrait for SystemEventInfo {
}
impl DataObjectTrait for HostSystemHealthInfo {
}
impl DataObjectTrait for HostSystemIdentificationInfo {
}
impl DataObjectTrait for HostSystemInfo {
}
impl DataObjectTrait for HostSystemResourceInfo {
}
impl DataObjectTrait for HostSystemSwapConfiguration {
}
impl DataObjectTrait for HostSystemSwapConfigurationSystemSwapOption {
}
impl DataObjectTrait for HostSystemSwapConfigurationDatastoreOption {
}
impl DataObjectTrait for HostSystemSwapConfigurationDisabledOption {
}
impl DataObjectTrait for HostSystemSwapConfigurationHostCacheOption {
}
impl DataObjectTrait for HostSystemSwapConfigurationHostLocalSwapOption {
}
impl DataObjectTrait for HostTargetTransport {
}
impl DataObjectTrait for HostBlockAdapterTargetTransport {
}
impl DataObjectTrait for HostFibreChannelTargetTransport {
}
impl DataObjectTrait for HostFibreChannelOverEthernetTargetTransport {
}
impl DataObjectTrait for HostInternetScsiTargetTransport {
}
impl DataObjectTrait for HostParallelScsiTargetTransport {
}
impl DataObjectTrait for HostPcieTargetTransport {
}
impl DataObjectTrait for HostRdmaTargetTransport {
}
impl DataObjectTrait for HostSerialAttachedTargetTransport {
}
impl DataObjectTrait for HostTcpTargetTransport {
}
impl DataObjectTrait for HostTpmAttestationInfo {
}
impl DataObjectTrait for HostTpmAttestationReport {
}
impl DataObjectTrait for HostTpmEventDetails {
}
impl DataObjectTrait for HostTpmBootCompleteEventDetails {
}
impl DataObjectTrait for HostTpmBootSecurityOptionEventDetails {
}
impl DataObjectTrait for HostTpmNvTagEventDetails {
}
impl DataObjectTrait for HostTpmSignerEventDetails {
}
impl DataObjectTrait for HostTpmCommandEventDetails {
}
impl DataObjectTrait for HostTpmOptionEventDetails {
}
impl DataObjectTrait for HostTpmSoftwareComponentEventDetails {
}
impl DataObjectTrait for HostTpmVersionEventDetails {
}
impl DataObjectTrait for HostTpmEventLogEntry {
}
impl DataObjectTrait for HostTrustAuthorityAttestationInfo {
}
impl DataObjectTrait for HostUnresolvedVmfsExtent {
}
impl DataObjectTrait for HostUnresolvedVmfsResignatureSpec {
}
impl DataObjectTrait for HostUnresolvedVmfsResolutionResult {
}
impl DataObjectTrait for HostUnresolvedVmfsResolutionSpec {
}
impl DataObjectTrait for HostUnresolvedVmfsVolume {
}
impl DataObjectTrait for HostUnresolvedVmfsVolumeResolveStatus {
}
impl DataObjectTrait for HostVFlashManagerVFlashCacheConfigInfo {
}
impl DataObjectTrait for HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption {
}
impl DataObjectTrait for HostVFlashManagerVFlashCacheConfigSpec {
}
impl DataObjectTrait for HostVFlashManagerVFlashConfigInfo {
}
impl DataObjectTrait for HostVFlashManagerVFlashResourceConfigInfo {
}
impl DataObjectTrait for HostVFlashManagerVFlashResourceConfigSpec {
}
impl DataObjectTrait for HostVFlashManagerVFlashResourceRunTimeInfo {
}
impl DataObjectTrait for HostVFlashResourceConfigurationResult {
}
impl DataObjectTrait for HostVMotionConfig {
}
impl DataObjectTrait for HostVMotionInfo {
}
impl DataObjectTrait for HostVMotionManagerDstInstantCloneResult {
}
impl DataObjectTrait for HostVMotionManagerSrcInstantCloneResult {
}
impl DataObjectTrait for HostVMotionNetConfig {
}
impl DataObjectTrait for HostVffsSpec {
}
impl DataObjectTrait for HostVirtualNic {
}
impl DataObjectTrait for HostVirtualNicConfig {
}
impl DataObjectTrait for HostVirtualNicIpRouteSpec {
}
impl DataObjectTrait for HostVirtualNicOpaqueNetworkSpec {
}
impl DataObjectTrait for HostVirtualNicSpec {
}
impl DataObjectTrait for HostVirtualNicConnection {
}
impl DataObjectTrait for VirtualNicManagerNetConfig {
}
impl DataObjectTrait for HostVirtualNicManagerNicTypeSelection {
}
impl DataObjectTrait for HostVirtualNicManagerInfo {
}
impl DataObjectTrait for HostVirtualSwitch {
}
impl DataObjectTrait for HostVirtualSwitchBeaconConfig {
}
impl DataObjectTrait for HostVirtualSwitchBridge {
}
impl DataObjectTrait for HostVirtualSwitchAutoBridge {
}
impl DataObjectTrait for HostVirtualSwitchBondBridge {
}
impl DataObjectTrait for HostVirtualSwitchSimpleBridge {
}
impl DataObjectTrait for HostVirtualSwitchConfig {
}
impl DataObjectTrait for HostVirtualSwitchSpec {
}
impl DataObjectTrait for HostVmciAccessManagerAccessSpec {
}
impl DataObjectTrait for VmfsDatastoreOption {
}
impl DataObjectTrait for VmfsDatastoreBaseOption {
}
impl DataObjectTrait for VmfsDatastoreMultipleExtentOption {
}
impl DataObjectTrait for VmfsDatastoreSingleExtentOption {
}
impl DataObjectTrait for VmfsDatastoreAllExtentOption {
}
impl DataObjectTrait for VmfsDatastoreSpec {
}
impl DataObjectTrait for VmfsDatastoreCreateSpec {
}
impl DataObjectTrait for VmfsDatastoreExpandSpec {
}
impl DataObjectTrait for VmfsDatastoreExtendSpec {
}
impl DataObjectTrait for HostVmfsRescanResult {
}
impl DataObjectTrait for VmfsConfigOption {
}
impl DataObjectTrait for HostVmfsSpec {
}
impl DataObjectTrait for VmfsUnmapBandwidthSpec {
}
impl DataObjectTrait for HostVsanInternalSystemCmmdsQuery {
}
impl DataObjectTrait for HostVsanInternalSystemDeleteVsanObjectsResult {
}
impl DataObjectTrait for VsanNewPolicyBatch {
}
impl DataObjectTrait for VsanPolicyChangeBatch {
}
impl DataObjectTrait for VsanPolicyCost {
}
impl DataObjectTrait for VsanPolicySatisfiability {
}
impl DataObjectTrait for HostVsanInternalSystemVsanObjectOperationResult {
}
impl DataObjectTrait for HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult {
}
impl DataObjectTrait for HostVvolNqn {
}
impl DataObjectTrait for VVolHostPe {
}
impl DataObjectTrait for HostVvolVolumeHostVvolNqn {
}
impl DataObjectTrait for HostVvolVolumeSpecification {
}
impl DataObjectTrait for NetDhcpConfigInfo {
}
impl DataObjectTrait for NetDhcpConfigInfoDhcpOptions {
}
impl DataObjectTrait for NetDhcpConfigSpec {
}
impl DataObjectTrait for NetDhcpConfigSpecDhcpOptionsSpec {
}
impl DataObjectTrait for NetDnsConfigInfo {
}
impl DataObjectTrait for NetDnsConfigSpec {
}
impl DataObjectTrait for NetIpConfigInfo {
}
impl DataObjectTrait for NetIpConfigInfoIpAddress {
}
impl DataObjectTrait for NetIpConfigSpec {
}
impl DataObjectTrait for NetIpConfigSpecIpAddressSpec {
}
impl DataObjectTrait for NetIpRouteConfigInfo {
}
impl DataObjectTrait for NetIpRouteConfigInfoGateway {
}
impl DataObjectTrait for NetIpRouteConfigInfoIpRoute {
}
impl DataObjectTrait for NetIpRouteConfigSpec {
}
impl DataObjectTrait for NetIpRouteConfigSpecGatewaySpec {
}
impl DataObjectTrait for NetIpRouteConfigSpecIpRouteSpec {
}
impl DataObjectTrait for NetIpStackInfo {
}
impl DataObjectTrait for NetIpStackInfoDefaultRouter {
}
impl DataObjectTrait for NetIpStackInfoNetToMedia {
}
impl DataObjectTrait for NetBiosConfigInfo {
}
impl DataObjectTrait for WinNetBiosConfigInfo {
}
impl DataObjectTrait for ArrayUpdateSpec {
}
impl DataObjectTrait for ClusterDasVmConfigSpec {
}
impl DataObjectTrait for ClusterDatastoreUpdateSpec {
}
impl DataObjectTrait for ClusterDpmHostConfigSpec {
}
impl DataObjectTrait for ClusterDrsVmConfigSpec {
}
impl DataObjectTrait for ClusterGroupSpec {
}
impl DataObjectTrait for ClusterPreemptibleVmPairSpec {
}
impl DataObjectTrait for ClusterRuleSpec {
}
impl DataObjectTrait for ClusterTagCategoryUpdateSpec {
}
impl DataObjectTrait for ClusterVmOrchestrationSpec {
}
impl DataObjectTrait for StorageDrsOptionSpec {
}
impl DataObjectTrait for StorageDrsVmConfigSpec {
}
impl DataObjectTrait for VAppOvfSectionSpec {
}
impl DataObjectTrait for VAppProductSpec {
}
impl DataObjectTrait for VAppPropertySpec {
}
impl DataObjectTrait for VirtualMachineCpuIdInfoSpec {
}
impl DataObjectTrait for OptionType {
}
impl DataObjectTrait for BoolOption {
}
impl DataObjectTrait for ChoiceOption {
}
impl DataObjectTrait for FloatOption {
}
impl DataObjectTrait for IntOption {
}
impl DataObjectTrait for LongOption {
}
impl DataObjectTrait for StringOption {
}
impl DataObjectTrait for OptionValue {
}
impl DataObjectTrait for HostInternetScsiHbaParamValue {
}
impl DataObjectTrait for ApplyProfile {
}
impl DataObjectTrait for ProfileApplyProfileElement {
}
impl DataObjectTrait for ActiveDirectoryProfile {
}
impl DataObjectTrait for AuthenticationProfile {
}
impl DataObjectTrait for DateTimeProfile {
}
impl DataObjectTrait for DvsProfile {
}
impl DataObjectTrait for DvsVNicProfile {
}
impl DataObjectTrait for DvsHostVNicProfile {
}
impl DataObjectTrait for DvsServiceConsoleVNicProfile {
}
impl DataObjectTrait for FirewallProfile {
}
impl DataObjectTrait for FirewallProfileRulesetProfile {
}
impl DataObjectTrait for HostApplyProfile {
}
impl DataObjectTrait for HostMemoryProfile {
}
impl DataObjectTrait for IpAddressProfile {
}
impl DataObjectTrait for IpRouteProfile {
}
impl DataObjectTrait for NasStorageProfile {
}
impl DataObjectTrait for NetStackInstanceProfile {
}
impl DataObjectTrait for NetworkPolicyProfile {
}
impl DataObjectTrait for NetworkProfile {
}
impl DataObjectTrait for NetworkProfileDnsConfigProfile {
}
impl DataObjectTrait for NsxHostVNicProfile {
}
impl DataObjectTrait for OpaqueSwitchProfile {
}
impl DataObjectTrait for OptionProfile {
}
impl DataObjectTrait for PermissionProfile {
}
impl DataObjectTrait for PhysicalNicProfile {
}
impl DataObjectTrait for PnicUplinkProfile {
}
impl DataObjectTrait for PortGroupProfile {
}
impl DataObjectTrait for HostPortGroupProfile {
}
impl DataObjectTrait for ServiceConsolePortGroupProfile {
}
impl DataObjectTrait for VmPortGroupProfile {
}
impl DataObjectTrait for VirtualSwitchSelectionProfile {
}
impl DataObjectTrait for VlanProfile {
}
impl DataObjectTrait for SecurityProfile {
}
impl DataObjectTrait for ServiceProfile {
}
impl DataObjectTrait for StaticRouteProfile {
}
impl DataObjectTrait for StorageProfile {
}
impl DataObjectTrait for UserGroupProfile {
}
impl DataObjectTrait for UserProfile {
}
impl DataObjectTrait for VirtualSwitchProfile {
}
impl DataObjectTrait for LinkProfile {
}
impl DataObjectTrait for NumPortsProfile {
}
impl DataObjectTrait for ProfileApplyProfileProperty {
}
impl DataObjectTrait for ComplianceLocator {
}
impl DataObjectTrait for ComplianceProfile {
}
impl DataObjectTrait for ComplianceResult {
}
impl DataObjectTrait for ComplianceFailure {
}
impl DataObjectTrait for ComplianceFailureComplianceFailureValues {
}
impl DataObjectTrait for ProfileDeferredPolicyOptionParameter {
}
impl DataObjectTrait for ProfileExpression {
}
impl DataObjectTrait for ProfileCompositeExpression {
}
impl DataObjectTrait for ProfileSimpleExpression {
}
impl DataObjectTrait for ProfileExpressionMetadata {
}
impl DataObjectTrait for ProfileParameterMetadata {
}
impl DataObjectTrait for ProfileParameterMetadataParameterRelationMetadata {
}
impl DataObjectTrait for ProfilePolicy {
}
impl DataObjectTrait for ProfilePolicyMetadata {
}
impl DataObjectTrait for PolicyOption {
}
impl DataObjectTrait for CompositePolicyOption {
}
impl DataObjectTrait for ProfilePolicyOptionMetadata {
}
impl DataObjectTrait for ProfileCompositePolicyOptionMetadata {
}
impl DataObjectTrait for UserInputRequiredParameterMetadata {
}
impl DataObjectTrait for ProfileConfigInfo {
}
impl DataObjectTrait for ClusterProfileConfigInfo {
}
impl DataObjectTrait for HostProfileConfigInfo {
}
impl DataObjectTrait for ProfileCreateSpec {
}
impl DataObjectTrait for ProfileSerializedCreateSpec {
}
impl DataObjectTrait for HostProfileSerializedHostProfileSpec {
}
impl DataObjectTrait for ClusterProfileCreateSpec {
}
impl DataObjectTrait for ClusterProfileConfigSpec {
}
impl DataObjectTrait for ClusterProfileCompleteConfigSpec {
}
impl DataObjectTrait for ClusterProfileConfigServiceCreateSpec {
}
impl DataObjectTrait for HostProfileConfigSpec {
}
impl DataObjectTrait for HostProfileCompleteConfigSpec {
}
impl DataObjectTrait for HostProfileHostBasedConfigSpec {
}
impl DataObjectTrait for ProfileDescription {
}
impl DataObjectTrait for ProfileDescriptionSection {
}
impl DataObjectTrait for ProfileMetadata {
}
impl DataObjectTrait for ProfileMetadataProfileOperationMessage {
}
impl DataObjectTrait for ProfileMetadataProfileSortSpec {
}
impl DataObjectTrait for ProfilePropertyPath {
}
impl DataObjectTrait for ProfileProfileStructure {
}
impl DataObjectTrait for ProfileProfileStructureProperty {
}
impl DataObjectTrait for AnswerFile {
}
impl DataObjectTrait for AnswerFileStatusResult {
}
impl DataObjectTrait for AnswerFileStatusError {
}
impl DataObjectTrait for ProfileExecuteResult {
}
impl DataObjectTrait for ApplyHostProfileConfigurationSpec {
}
impl DataObjectTrait for ProfileExecuteError {
}
impl DataObjectTrait for HostProfileValidationFailureInfo {
}
impl DataObjectTrait for HostSpecification {
}
impl DataObjectTrait for HostSubSpecification {
}
impl DataObjectTrait for AnswerFileCreateSpec {
}
impl DataObjectTrait for AnswerFileOptionsCreateSpec {
}
impl DataObjectTrait for AnswerFileSerializedCreateSpec {
}
impl DataObjectTrait for ApplyHostProfileConfigurationResult {
}
impl DataObjectTrait for HostProfileManagerCompositionResult {
}
impl DataObjectTrait for HostProfileManagerCompositionResultResultElement {
}
impl DataObjectTrait for HostProfileManagerCompositionValidationResult {
}
impl DataObjectTrait for HostProfileManagerCompositionValidationResultResultElement {
}
impl DataObjectTrait for HostProfileManagerConfigTaskList {
}
impl DataObjectTrait for HostProfilesEntityCustomizations {
}
impl DataObjectTrait for StructuredCustomizations {
}
impl DataObjectTrait for HostProfileManagerHostToConfigSpecMap {
}
impl DataObjectTrait for ScheduledTaskDescription {
}
impl DataObjectTrait for ScheduledTaskSpec {
}
impl DataObjectTrait for ScheduledTaskInfo {
}
impl DataObjectTrait for TaskScheduler {
}
impl DataObjectTrait for AfterStartupTaskScheduler {
}
impl DataObjectTrait for OnceTaskScheduler {
}
impl DataObjectTrait for RecurrentTaskScheduler {
}
impl DataObjectTrait for HourlyTaskScheduler {
}
impl DataObjectTrait for DailyTaskScheduler {
}
impl DataObjectTrait for MonthlyTaskScheduler {
}
impl DataObjectTrait for MonthlyByDayTaskScheduler {
}
impl DataObjectTrait for MonthlyByWeekdayTaskScheduler {
}
impl DataObjectTrait for WeeklyTaskScheduler {
}
impl DataObjectTrait for ApplyStorageRecommendationResult {
}
impl DataObjectTrait for StorageDrsAutomationConfig {
}
impl DataObjectTrait for StorageDrsConfigInfo {
}
impl DataObjectTrait for StorageDrsConfigSpec {
}
impl DataObjectTrait for StorageDrsIoLoadBalanceConfig {
}
impl DataObjectTrait for PlacementAffinityRule {
}
impl DataObjectTrait for PlacementRankResult {
}
impl DataObjectTrait for PlacementRankSpec {
}
impl DataObjectTrait for StorageDrsPlacementRankVmSpec {
}
impl DataObjectTrait for StorageDrsPodConfigInfo {
}
impl DataObjectTrait for StorageDrsPodConfigSpec {
}
impl DataObjectTrait for StorageDrsPodSelectionSpec {
}
impl DataObjectTrait for PodDiskLocator {
}
impl DataObjectTrait for VmPodConfigForPlacement {
}
impl DataObjectTrait for StorageDrsSpaceLoadBalanceConfig {
}
impl DataObjectTrait for StoragePlacementResult {
}
impl DataObjectTrait for StoragePlacementSpec {
}
impl DataObjectTrait for StorageDrsVmConfigInfo {
}
impl DataObjectTrait for VAppCloneSpec {
}
impl DataObjectTrait for VAppCloneSpecNetworkMappingPair {
}
impl DataObjectTrait for VAppCloneSpecResourceMap {
}
impl DataObjectTrait for VAppEntityConfigInfo {
}
impl DataObjectTrait for VAppIpAssignmentInfo {
}
impl DataObjectTrait for IpPool {
}
impl DataObjectTrait for IpPoolAssociation {
}
impl DataObjectTrait for IpPoolIpPoolConfigInfo {
}
impl DataObjectTrait for VAppOvfSectionInfo {
}
impl DataObjectTrait for VAppProductInfo {
}
impl DataObjectTrait for VAppPropertyInfo {
}
impl DataObjectTrait for VmConfigInfo {
}
impl DataObjectTrait for VAppConfigInfo {
}
impl DataObjectTrait for VmConfigSpec {
}
impl DataObjectTrait for VAppConfigSpec {
}
impl DataObjectTrait for ClusterNetworkConfigSpec {
}
impl DataObjectTrait for FailoverNodeInfo {
}
impl DataObjectTrait for NodeDeploymentSpec {
}
impl DataObjectTrait for PassiveNodeDeploymentSpec {
}
impl DataObjectTrait for NodeNetworkSpec {
}
impl DataObjectTrait for PassiveNodeNetworkSpec {
}
impl DataObjectTrait for SourceNodeSpec {
}
impl DataObjectTrait for VchaClusterConfigInfo {
}
impl DataObjectTrait for VchaClusterConfigSpec {
}
impl DataObjectTrait for VchaClusterDeploymentSpec {
}
impl DataObjectTrait for VchaClusterNetworkSpec {
}
impl DataObjectTrait for WitnessNodeInfo {
}
impl DataObjectTrait for VchaClusterHealth {
}
impl DataObjectTrait for VchaClusterRuntimeInfo {
}
impl DataObjectTrait for VchaNodeRuntimeInfo {
}
impl DataObjectTrait for VirtualMachineAffinityInfo {
}
impl DataObjectTrait for VirtualMachineBaseIndependentFilterSpec {
}
impl DataObjectTrait for VirtualMachineEmptyIndependentFilterSpec {
}
impl DataObjectTrait for VirtualMachineIndependentFilterSpec {
}
impl DataObjectTrait for VirtualMachineBootOptions {
}
impl DataObjectTrait for VirtualMachineBootOptionsBootableDevice {
}
impl DataObjectTrait for VirtualMachineBootOptionsBootableCdromDevice {
}
impl DataObjectTrait for VirtualMachineBootOptionsBootableDiskDevice {
}
impl DataObjectTrait for VirtualMachineBootOptionsBootableEthernetDevice {
}
impl DataObjectTrait for VirtualMachineBootOptionsBootableFloppyDevice {
}
impl DataObjectTrait for VirtualMachineCapability {
}
impl DataObjectTrait for VirtualMachineCertThumbprint {
}
impl DataObjectTrait for VirtualMachineCloneSpec {
}
impl DataObjectTrait for VirtualMachineConfigInfo {
}
impl DataObjectTrait for VirtualMachineConfigInfoDatastoreUrlPair {
}
impl DataObjectTrait for VirtualMachineConfigInfoOverheadInfo {
}
impl DataObjectTrait for VirtualMachineConfigOption {
}
impl DataObjectTrait for VirtualMachineConfigOptionDescriptor {
}
impl DataObjectTrait for VirtualMachineConfigSpec {
}
impl DataObjectTrait for ConfigTarget {
}
impl DataObjectTrait for VirtualMachineConsolePreferences {
}
impl DataObjectTrait for VirtualMachineContentLibraryItemInfo {
}
impl DataObjectTrait for DatastoreOption {
}
impl DataObjectTrait for VirtualMachineDatastoreVolumeOption {
}
impl DataObjectTrait for VirtualMachineDefaultPowerOpInfo {
}
impl DataObjectTrait for VirtualMachineDeviceRuntimeInfo {
}
impl DataObjectTrait for VirtualMachineDeviceRuntimeInfoDeviceRuntimeState {
}
impl DataObjectTrait for VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState {
}
impl DataObjectTrait for VirtualMachineDvxClassInfo {
}
impl DataObjectTrait for FaultToleranceConfigInfo {
}
impl DataObjectTrait for FaultTolerancePrimaryConfigInfo {
}
impl DataObjectTrait for FaultToleranceSecondaryConfigInfo {
}
impl DataObjectTrait for FaultToleranceConfigSpec {
}
impl DataObjectTrait for FaultToleranceMetaSpec {
}
impl DataObjectTrait for FaultToleranceSecondaryOpResult {
}
impl DataObjectTrait for FaultToleranceVmConfigSpec {
}
impl DataObjectTrait for FaultToleranceDiskSpec {
}
impl DataObjectTrait for VirtualMachineFeatureRequirement {
}
impl DataObjectTrait for VirtualMachineFileInfo {
}
impl DataObjectTrait for VirtualMachineFileLayout {
}
impl DataObjectTrait for VirtualMachineFileLayoutDiskLayout {
}
impl DataObjectTrait for VirtualMachineFileLayoutSnapshotLayout {
}
impl DataObjectTrait for VirtualMachineFileLayoutEx {
}
impl DataObjectTrait for VirtualMachineFileLayoutExDiskLayout {
}
impl DataObjectTrait for VirtualMachineFileLayoutExDiskUnit {
}
impl DataObjectTrait for VirtualMachineFileLayoutExFileInfo {
}
impl DataObjectTrait for VirtualMachineFileLayoutExSnapshotLayout {
}
impl DataObjectTrait for VirtualMachineFlagInfo {
}
impl DataObjectTrait for VirtualMachineForkConfigInfo {
}
impl DataObjectTrait for GuestInfo {
}
impl DataObjectTrait for GuestInfoCustomizationInfo {
}
impl DataObjectTrait for GuestDiskInfo {
}
impl DataObjectTrait for GuestInfoNamespaceGenerationInfo {
}
impl DataObjectTrait for GuestNicInfo {
}
impl DataObjectTrait for GuestScreenInfo {
}
impl DataObjectTrait for GuestStackInfo {
}
impl DataObjectTrait for GuestInfoVirtualDiskMapping {
}
impl DataObjectTrait for VirtualMachineGuestIntegrityInfo {
}
impl DataObjectTrait for VirtualMachineGuestMonitoringModeInfo {
}
impl DataObjectTrait for GuestOsDescriptor {
}
impl DataObjectTrait for VirtualMachineGuestQuiesceSpec {
}
impl DataObjectTrait for VirtualMachineWindowsQuiesceSpec {
}
impl DataObjectTrait for VirtualMachineIdeDiskDevicePartitionInfo {
}
impl DataObjectTrait for VirtualMachineInstantCloneSpec {
}
impl DataObjectTrait for VirtualMachineLegacyNetworkSwitchInfo {
}
impl DataObjectTrait for VirtualMachineMessage {
}
impl DataObjectTrait for VirtualMachineMetadataManagerVmMetadata {
}
impl DataObjectTrait for VirtualMachineMetadataManagerVmMetadataInput {
}
impl DataObjectTrait for VirtualMachineMetadataManagerVmMetadataOwner {
}
impl DataObjectTrait for VirtualMachineMetadataManagerVmMetadataResult {
}
impl DataObjectTrait for VirtualMachineNetworkShaperInfo {
}
impl DataObjectTrait for VirtualMachineProfileDetails {
}
impl DataObjectTrait for VirtualMachineProfileDetailsDiskProfileDetails {
}
impl DataObjectTrait for VirtualMachineProfileRawData {
}
impl DataObjectTrait for VirtualMachineProfileSpec {
}
impl DataObjectTrait for VirtualMachineDefaultProfileSpec {
}
impl DataObjectTrait for VirtualMachineDefinedProfileSpec {
}
impl DataObjectTrait for VirtualMachineEmptyProfileSpec {
}
impl DataObjectTrait for VirtualMachinePropertyRelation {
}
impl DataObjectTrait for VirtualMachineQuestionInfo {
}
impl DataObjectTrait for VirtualMachineRelocateSpec {
}
impl DataObjectTrait for VirtualMachineRelocateSpecDiskLocator {
}
impl DataObjectTrait for VirtualMachineRelocateSpecDiskLocatorBackingSpec {
}
impl DataObjectTrait for ReplicationConfigSpec {
}
impl DataObjectTrait for ReplicationInfoDiskSettings {
}
impl DataObjectTrait for VirtualMachineRuntimeInfo {
}
impl DataObjectTrait for VirtualMachineRuntimeInfoDasProtectionState {
}
impl DataObjectTrait for ScheduledHardwareUpgradeInfo {
}
impl DataObjectTrait for VirtualMachineSgxInfo {
}
impl DataObjectTrait for VirtualMachineSnapshotInfo {
}
impl DataObjectTrait for VirtualMachineSnapshotTree {
}
impl DataObjectTrait for VirtualMachineSriovDevicePoolInfo {
}
impl DataObjectTrait for VirtualMachineSriovNetworkDevicePoolInfo {
}
impl DataObjectTrait for VirtualMachineStorageInfo {
}
impl DataObjectTrait for VirtualMachineUsageOnDatastore {
}
impl DataObjectTrait for VirtualMachineSummary {
}
impl DataObjectTrait for VirtualMachineConfigSummary {
}
impl DataObjectTrait for VirtualMachineGuestSummary {
}
impl DataObjectTrait for VirtualMachineQuickStats {
}
impl DataObjectTrait for VirtualMachineQuickStatsMemoryTierStats {
}
impl DataObjectTrait for VirtualMachineStorageSummary {
}
impl DataObjectTrait for VirtualMachineTargetInfo {
}
impl DataObjectTrait for VirtualMachineCdromInfo {
}
impl DataObjectTrait for VirtualMachineDatastoreInfo {
}
impl DataObjectTrait for VirtualMachineDiskDeviceInfo {
}
impl DataObjectTrait for VirtualMachineIdeDiskDeviceInfo {
}
impl DataObjectTrait for VirtualMachineScsiDiskDeviceInfo {
}
impl DataObjectTrait for VirtualMachineDynamicPassthroughInfo {
}
impl DataObjectTrait for VirtualMachineFloppyInfo {
}
impl DataObjectTrait for VirtualMachineNetworkInfo {
}
impl DataObjectTrait for OpaqueNetworkTargetInfo {
}
impl DataObjectTrait for VirtualMachineParallelInfo {
}
impl DataObjectTrait for VirtualMachinePciPassthroughInfo {
}
impl DataObjectTrait for VirtualMachineSriovInfo {
}
impl DataObjectTrait for VirtualMachinePciSharedGpuPassthroughInfo {
}
impl DataObjectTrait for VirtualMachinePrecisionClockInfo {
}
impl DataObjectTrait for VirtualMachineScsiPassthroughInfo {
}
impl DataObjectTrait for VirtualMachineSerialInfo {
}
impl DataObjectTrait for VirtualMachineSgxTargetInfo {
}
impl DataObjectTrait for VirtualMachineSoundInfo {
}
impl DataObjectTrait for VirtualMachineUsbInfo {
}
impl DataObjectTrait for VirtualMachineVFlashModuleInfo {
}
impl DataObjectTrait for VirtualMachineVMotionStunTimeInfo {
}
impl DataObjectTrait for VirtualMachineVendorDeviceGroupInfo {
}
impl DataObjectTrait for VirtualMachineVgpuDeviceInfo {
}
impl DataObjectTrait for VirtualMachineVgpuProfileInfo {
}
impl DataObjectTrait for ToolsConfigInfo {
}
impl DataObjectTrait for ToolsConfigInfoToolsLastInstallInfo {
}
impl DataObjectTrait for UsbScanCodeSpec {
}
impl DataObjectTrait for UsbScanCodeSpecKeyEvent {
}
impl DataObjectTrait for UsbScanCodeSpecModifierType {
}
impl DataObjectTrait for VirtualMachineVcpuConfig {
}
impl DataObjectTrait for VirtualMachineVendorDeviceGroupInfoComponentDeviceInfo {
}
impl DataObjectTrait for VirtualMachineVirtualDeviceGroups {
}
impl DataObjectTrait for VirtualMachineVirtualDeviceGroupsDeviceGroup {
}
impl DataObjectTrait for VirtualMachineVirtualDeviceGroupsVendorDeviceGroup {
}
impl DataObjectTrait for VirtualMachineVirtualDeviceSwap {
}
impl DataObjectTrait for VirtualMachineVirtualDeviceSwapDeviceSwapInfo {
}
impl DataObjectTrait for VirtualHardware {
}
impl DataObjectTrait for VirtualHardwareOption {
}
impl DataObjectTrait for VirtualMachineVirtualNuma {
}
impl DataObjectTrait for VirtualMachineVirtualNumaInfo {
}
impl DataObjectTrait for VirtualMachineVirtualPMem {
}
impl DataObjectTrait for CheckResult {
}
impl DataObjectTrait for CustomizationAdapterMapping {
}
impl DataObjectTrait for CustomizationGlobalIpSettings {
}
impl DataObjectTrait for CustomizationGuiRunOnce {
}
impl DataObjectTrait for CustomizationGuiUnattended {
}
impl DataObjectTrait for CustomizationIpSettings {
}
impl DataObjectTrait for CustomizationIpSettingsIpV6AddressSpec {
}
impl DataObjectTrait for CustomizationIdentification {
}
impl DataObjectTrait for CustomizationIdentitySettings {
}
impl DataObjectTrait for CustomizationCloudinitPrep {
}
impl DataObjectTrait for CustomizationLinuxPrep {
}
impl DataObjectTrait for CustomizationSysprep {
}
impl DataObjectTrait for CustomizationSysprepText {
}
impl DataObjectTrait for CustomizationIpGenerator {
}
impl DataObjectTrait for CustomizationCustomIpGenerator {
}
impl DataObjectTrait for CustomizationDhcpIpGenerator {
}
impl DataObjectTrait for CustomizationFixedIp {
}
impl DataObjectTrait for CustomizationUnknownIpGenerator {
}
impl DataObjectTrait for CustomizationIpV6Generator {
}
impl DataObjectTrait for CustomizationAutoIpV6Generator {
}
impl DataObjectTrait for CustomizationCustomIpV6Generator {
}
impl DataObjectTrait for CustomizationDhcpIpV6Generator {
}
impl DataObjectTrait for CustomizationFixedIpV6 {
}
impl DataObjectTrait for CustomizationStatelessIpV6Generator {
}
impl DataObjectTrait for CustomizationUnknownIpV6Generator {
}
impl DataObjectTrait for CustomizationLicenseFilePrintData {
}
impl DataObjectTrait for CustomizationName {
}
impl DataObjectTrait for CustomizationCustomName {
}
impl DataObjectTrait for CustomizationFixedName {
}
impl DataObjectTrait for CustomizationPrefixName {
}
impl DataObjectTrait for CustomizationUnknownName {
}
impl DataObjectTrait for CustomizationVirtualMachineName {
}
impl DataObjectTrait for CustomizationOptions {
}
impl DataObjectTrait for CustomizationLinuxOptions {
}
impl DataObjectTrait for CustomizationWinOptions {
}
impl DataObjectTrait for CustomizationPassword {
}
impl DataObjectTrait for CustomizationSpec {
}
impl DataObjectTrait for CustomizationUserData {
}
impl DataObjectTrait for HostDiskMappingInfo {
}
impl DataObjectTrait for HostDiskMappingPartitionInfo {
}
impl DataObjectTrait for HostDiskMappingOption {
}
impl DataObjectTrait for HostDiskMappingPartitionOption {
}
impl DataObjectTrait for VirtualDevice {
}
impl DataObjectTrait for VirtualCdrom {
}
impl DataObjectTrait for VirtualController {
}
impl DataObjectTrait for VirtualIdeController {
}
impl DataObjectTrait for VirtualNvdimmController {
}
impl DataObjectTrait for VirtualNvmeController {
}
impl DataObjectTrait for VirtualPciController {
}
impl DataObjectTrait for VirtualPs2Controller {
}
impl DataObjectTrait for VirtualSataController {
}
impl DataObjectTrait for VirtualAhciController {
}
impl DataObjectTrait for VirtualScsiController {
}
impl DataObjectTrait for ParaVirtualScsiController {
}
impl DataObjectTrait for VirtualBusLogicController {
}
impl DataObjectTrait for VirtualLsiLogicController {
}
impl DataObjectTrait for VirtualLsiLogicSasController {
}
impl DataObjectTrait for VirtualSioController {
}
impl DataObjectTrait for VirtualUsbController {
}
impl DataObjectTrait for VirtualUsbxhciController {
}
impl DataObjectTrait for VirtualDisk {
}
impl DataObjectTrait for VirtualEthernetCard {
}
impl DataObjectTrait for VirtualE1000 {
}
impl DataObjectTrait for VirtualE1000E {
}
impl DataObjectTrait for VirtualPcNet32 {
}
impl DataObjectTrait for VirtualSriovEthernetCard {
}
impl DataObjectTrait for VirtualVmxnet {
}
impl DataObjectTrait for VirtualVmxnet2 {
}
impl DataObjectTrait for VirtualVmxnet3 {
}
impl DataObjectTrait for VirtualVmxnet3Vrdma {
}
impl DataObjectTrait for VirtualFloppy {
}
impl DataObjectTrait for VirtualKeyboard {
}
impl DataObjectTrait for VirtualNvdimm {
}
impl DataObjectTrait for VirtualPciPassthrough {
}
impl DataObjectTrait for VirtualParallelPort {
}
impl DataObjectTrait for VirtualPointingDevice {
}
impl DataObjectTrait for VirtualPrecisionClock {
}
impl DataObjectTrait for VirtualScsiPassthrough {
}
impl DataObjectTrait for VirtualSerialPort {
}
impl DataObjectTrait for VirtualSoundCard {
}
impl DataObjectTrait for VirtualEnsoniq1371 {
}
impl DataObjectTrait for VirtualHdAudioCard {
}
impl DataObjectTrait for VirtualSoundBlaster16 {
}
impl DataObjectTrait for VirtualTpm {
}
impl DataObjectTrait for VirtualUsb {
}
impl DataObjectTrait for VirtualMachineVmciDevice {
}
impl DataObjectTrait for VirtualMachineVmirom {
}
impl DataObjectTrait for VirtualMachineVideoCard {
}
impl DataObjectTrait for VirtualWdt {
}
impl DataObjectTrait for VirtualDeviceBackingInfo {
}
impl DataObjectTrait for VirtualDeviceDeviceBackingInfo {
}
impl DataObjectTrait for VirtualCdromAtapiBackingInfo {
}
impl DataObjectTrait for VirtualCdromPassthroughBackingInfo {
}
impl DataObjectTrait for VirtualDiskRawDiskVer2BackingInfo {
}
impl DataObjectTrait for VirtualDiskPartitionedRawDiskVer2BackingInfo {
}
impl DataObjectTrait for VirtualEthernetCardLegacyNetworkBackingInfo {
}
impl DataObjectTrait for VirtualEthernetCardNetworkBackingInfo {
}
impl DataObjectTrait for VirtualFloppyDeviceBackingInfo {
}
impl DataObjectTrait for VirtualPciPassthroughDeviceBackingInfo {
}
impl DataObjectTrait for VirtualPciPassthroughDynamicBackingInfo {
}
impl DataObjectTrait for VirtualParallelPortDeviceBackingInfo {
}
impl DataObjectTrait for VirtualPointingDeviceDeviceBackingInfo {
}
impl DataObjectTrait for VirtualScsiPassthroughDeviceBackingInfo {
}
impl DataObjectTrait for VirtualSerialPortDeviceBackingInfo {
}
impl DataObjectTrait for VirtualSoundCardDeviceBackingInfo {
}
impl DataObjectTrait for VirtualUsbRemoteHostBackingInfo {
}
impl DataObjectTrait for VirtualUsbusbBackingInfo {
}
impl DataObjectTrait for VirtualDeviceFileBackingInfo {
}
impl DataObjectTrait for VirtualCdromIsoBackingInfo {
}
impl DataObjectTrait for VirtualDiskFlatVer1BackingInfo {
}
impl DataObjectTrait for VirtualDiskFlatVer2BackingInfo {
}
impl DataObjectTrait for VirtualDiskLocalPMemBackingInfo {
}
impl DataObjectTrait for VirtualDiskRawDiskMappingVer1BackingInfo {
}
impl DataObjectTrait for VirtualDiskSeSparseBackingInfo {
}
impl DataObjectTrait for VirtualDiskSparseVer1BackingInfo {
}
impl DataObjectTrait for VirtualDiskSparseVer2BackingInfo {
}
impl DataObjectTrait for VirtualFloppyImageBackingInfo {
}
impl DataObjectTrait for VirtualNvdimmBackingInfo {
}
impl DataObjectTrait for VirtualParallelPortFileBackingInfo {
}
impl DataObjectTrait for VirtualSerialPortFileBackingInfo {
}
impl DataObjectTrait for VirtualDevicePipeBackingInfo {
}
impl DataObjectTrait for VirtualSerialPortPipeBackingInfo {
}
impl DataObjectTrait for VirtualDeviceRemoteDeviceBackingInfo {
}
impl DataObjectTrait for VirtualCdromRemoteAtapiBackingInfo {
}
impl DataObjectTrait for VirtualCdromRemotePassthroughBackingInfo {
}
impl DataObjectTrait for VirtualFloppyRemoteDeviceBackingInfo {
}
impl DataObjectTrait for VirtualUsbRemoteClientBackingInfo {
}
impl DataObjectTrait for VirtualDeviceUriBackingInfo {
}
impl DataObjectTrait for VirtualSerialPortUriBackingInfo {
}
impl DataObjectTrait for VirtualEthernetCardDistributedVirtualPortBackingInfo {
}
impl DataObjectTrait for VirtualEthernetCardOpaqueNetworkBackingInfo {
}
impl DataObjectTrait for VirtualPciPassthroughDvxBackingInfo {
}
impl DataObjectTrait for VirtualPciPassthroughPluginBackingInfo {
}
impl DataObjectTrait for VirtualPciPassthroughVmiopBackingInfo {
}
impl DataObjectTrait for VirtualPrecisionClockSystemClockBackingInfo {
}
impl DataObjectTrait for VirtualSerialPortThinPrintBackingInfo {
}
impl DataObjectTrait for VirtualSriovEthernetCardSriovBackingInfo {
}
impl DataObjectTrait for VirtualDeviceBusSlotInfo {
}
impl DataObjectTrait for VirtualDevicePciBusSlotInfo {
}
impl DataObjectTrait for VirtualUsbControllerPciBusSlotInfo {
}
impl DataObjectTrait for VirtualDeviceConnectInfo {
}
impl DataObjectTrait for VirtualDeviceDeviceGroupInfo {
}
impl DataObjectTrait for VirtualDeviceOption {
}
impl DataObjectTrait for VirtualCdromOption {
}
impl DataObjectTrait for VirtualControllerOption {
}
impl DataObjectTrait for VirtualIdeControllerOption {
}
impl DataObjectTrait for VirtualNvdimmControllerOption {
}
impl DataObjectTrait for VirtualNvmeControllerOption {
}
impl DataObjectTrait for VirtualPciControllerOption {
}
impl DataObjectTrait for VirtualPs2ControllerOption {
}
impl DataObjectTrait for VirtualSataControllerOption {
}
impl DataObjectTrait for VirtualAhciControllerOption {
}
impl DataObjectTrait for VirtualScsiControllerOption {
}
impl DataObjectTrait for ParaVirtualScsiControllerOption {
}
impl DataObjectTrait for VirtualBusLogicControllerOption {
}
impl DataObjectTrait for VirtualLsiLogicControllerOption {
}
impl DataObjectTrait for VirtualLsiLogicSasControllerOption {
}
impl DataObjectTrait for VirtualSioControllerOption {
}
impl DataObjectTrait for VirtualUsbControllerOption {
}
impl DataObjectTrait for VirtualUsbxhciControllerOption {
}
impl DataObjectTrait for VirtualDiskOption {
}
impl DataObjectTrait for VirtualEthernetCardOption {
}
impl DataObjectTrait for VirtualE1000Option {
}
impl DataObjectTrait for VirtualE1000EOption {
}
impl DataObjectTrait for VirtualPcNet32Option {
}
impl DataObjectTrait for VirtualSriovEthernetCardOption {
}
impl DataObjectTrait for VirtualVmxnetOption {
}
impl DataObjectTrait for VirtualVmxnet2Option {
}
impl DataObjectTrait for VirtualVmxnet3Option {
}
impl DataObjectTrait for VirtualVmxnet3VrdmaOption {
}
impl DataObjectTrait for VirtualFloppyOption {
}
impl DataObjectTrait for VirtualKeyboardOption {
}
impl DataObjectTrait for VirtualNvdimmOption {
}
impl DataObjectTrait for VirtualPciPassthroughOption {
}
impl DataObjectTrait for VirtualParallelPortOption {
}
impl DataObjectTrait for VirtualPointingDeviceOption {
}
impl DataObjectTrait for VirtualPrecisionClockOption {
}
impl DataObjectTrait for VirtualScsiPassthroughOption {
}
impl DataObjectTrait for VirtualSerialPortOption {
}
impl DataObjectTrait for VirtualSoundCardOption {
}
impl DataObjectTrait for VirtualEnsoniq1371Option {
}
impl DataObjectTrait for VirtualHdAudioCardOption {
}
impl DataObjectTrait for VirtualSoundBlaster16Option {
}
impl DataObjectTrait for VirtualTpmOption {
}
impl DataObjectTrait for VirtualUsbOption {
}
impl DataObjectTrait for VirtualMachineVmciDeviceOption {
}
impl DataObjectTrait for VirtualVmiromOption {
}
impl DataObjectTrait for VirtualVideoCardOption {
}
impl DataObjectTrait for VirtualWdtOption {
}
impl DataObjectTrait for VirtualDeviceBackingOption {
}
impl DataObjectTrait for VirtualDeviceDeviceBackingOption {
}
impl DataObjectTrait for VirtualCdromAtapiBackingOption {
}
impl DataObjectTrait for VirtualCdromPassthroughBackingOption {
}
impl DataObjectTrait for VirtualCdromRemoteAtapiBackingOption {
}
impl DataObjectTrait for VirtualDiskRawDiskMappingVer1BackingOption {
}
impl DataObjectTrait for VirtualDiskRawDiskVer2BackingOption {
}
impl DataObjectTrait for VirtualDiskPartitionedRawDiskVer2BackingOption {
}
impl DataObjectTrait for VirtualEthernetCardLegacyNetworkBackingOption {
}
impl DataObjectTrait for VirtualEthernetCardNetworkBackingOption {
}
impl DataObjectTrait for VirtualFloppyDeviceBackingOption {
}
impl DataObjectTrait for VirtualPciPassthroughDeviceBackingOption {
}
impl DataObjectTrait for VirtualPciPassthroughDynamicBackingOption {
}
impl DataObjectTrait for VirtualParallelPortDeviceBackingOption {
}
impl DataObjectTrait for VirtualPointingDeviceBackingOption {
}
impl DataObjectTrait for VirtualScsiPassthroughDeviceBackingOption {
}
impl DataObjectTrait for VirtualSerialPortDeviceBackingOption {
}
impl DataObjectTrait for VirtualSoundCardDeviceBackingOption {
}
impl DataObjectTrait for VirtualUsbRemoteHostBackingOption {
}
impl DataObjectTrait for VirtualUsbusbBackingOption {
}
impl DataObjectTrait for VirtualDeviceFileBackingOption {
}
impl DataObjectTrait for VirtualCdromIsoBackingOption {
}
impl DataObjectTrait for VirtualDiskFlatVer1BackingOption {
}
impl DataObjectTrait for VirtualDiskFlatVer2BackingOption {
}
impl DataObjectTrait for VirtualDiskLocalPMemBackingOption {
}
impl DataObjectTrait for VirtualDiskSeSparseBackingOption {
}
impl DataObjectTrait for VirtualDiskSparseVer1BackingOption {
}
impl DataObjectTrait for VirtualDiskSparseVer2BackingOption {
}
impl DataObjectTrait for VirtualFloppyImageBackingOption {
}
impl DataObjectTrait for VirtualParallelPortFileBackingOption {
}
impl DataObjectTrait for VirtualSerialPortFileBackingOption {
}
impl DataObjectTrait for VirtualDevicePipeBackingOption {
}
impl DataObjectTrait for VirtualSerialPortPipeBackingOption {
}
impl DataObjectTrait for VirtualDeviceRemoteDeviceBackingOption {
}
impl DataObjectTrait for VirtualCdromRemotePassthroughBackingOption {
}
impl DataObjectTrait for VirtualFloppyRemoteDeviceBackingOption {
}
impl DataObjectTrait for VirtualUsbRemoteClientBackingOption {
}
impl DataObjectTrait for VirtualDeviceUriBackingOption {
}
impl DataObjectTrait for VirtualSerialPortUriBackingOption {
}
impl DataObjectTrait for VirtualEthernetCardDvPortBackingOption {
}
impl DataObjectTrait for VirtualEthernetCardOpaqueNetworkBackingOption {
}
impl DataObjectTrait for VirtualPciPassthroughDvxBackingOption {
}
impl DataObjectTrait for VirtualPciPassthroughPluginBackingOption {
}
impl DataObjectTrait for VirtualPciPassthroughVmiopBackingOption {
}
impl DataObjectTrait for VirtualPrecisionClockSystemClockBackingOption {
}
impl DataObjectTrait for VirtualSerialPortThinPrintBackingOption {
}
impl DataObjectTrait for VirtualSriovEthernetCardSriovBackingOption {
}
impl DataObjectTrait for VirtualDeviceBusSlotOption {
}
impl DataObjectTrait for VirtualDeviceConnectOption {
}
impl DataObjectTrait for VirtualDeviceConfigSpec {
}
impl DataObjectTrait for VirtualDiskConfigSpec {
}
impl DataObjectTrait for VirtualDeviceConfigSpecBackingSpec {
}
impl DataObjectTrait for VirtualDiskVFlashCacheConfigInfo {
}
impl DataObjectTrait for VirtualDiskId {
}
impl DataObjectTrait for VirtualDiskDeltaDiskFormatsSupported {
}
impl DataObjectTrait for VirtualDiskOptionVFlashCacheConfigOption {
}
impl DataObjectTrait for VirtualEthernetCardResourceAllocation {
}
impl DataObjectTrait for VirtualPciPassthroughAllowedDevice {
}
impl DataObjectTrait for VirtualMachineVmciDeviceFilterInfo {
}
impl DataObjectTrait for VirtualMachineVmciDeviceFilterSpec {
}
impl DataObjectTrait for VirtualMachineVmciDeviceOptionFilterSpecOption {
}
impl DataObjectTrait for GuestAliases {
}
impl DataObjectTrait for GuestAuthAliasInfo {
}
impl DataObjectTrait for GuestAuthSubject {
}
impl DataObjectTrait for GuestAuthAnySubject {
}
impl DataObjectTrait for GuestAuthNamedSubject {
}
impl DataObjectTrait for GuestMappedAliases {
}
impl DataObjectTrait for GuestFileAttributes {
}
impl DataObjectTrait for GuestPosixFileAttributes {
}
impl DataObjectTrait for GuestWindowsFileAttributes {
}
impl DataObjectTrait for GuestFileInfo {
}
impl DataObjectTrait for FileTransferInformation {
}
impl DataObjectTrait for GuestListFileInfo {
}
impl DataObjectTrait for GuestAuthentication {
}
impl DataObjectTrait for NamePasswordAuthentication {
}
impl DataObjectTrait for SamlTokenAuthentication {
}
impl DataObjectTrait for SspiAuthentication {
}
impl DataObjectTrait for TicketedSessionAuthentication {
}
impl DataObjectTrait for GuestProcessInfo {
}
impl DataObjectTrait for GuestProgramSpec {
}
impl DataObjectTrait for GuestWindowsProgramSpec {
}
impl DataObjectTrait for GuestRegKeySpec {
}
impl DataObjectTrait for GuestRegKeyNameSpec {
}
impl DataObjectTrait for GuestRegKeyRecordSpec {
}
impl DataObjectTrait for GuestRegValueSpec {
}
impl DataObjectTrait for GuestRegValueDataSpec {
}
impl DataObjectTrait for GuestRegValueBinarySpec {
}
impl DataObjectTrait for GuestRegValueDwordSpec {
}
impl DataObjectTrait for GuestRegValueExpandStringSpec {
}
impl DataObjectTrait for GuestRegValueMultiStringSpec {
}
impl DataObjectTrait for GuestRegValueQwordSpec {
}
impl DataObjectTrait for GuestRegValueStringSpec {
}
impl DataObjectTrait for GuestRegValueNameSpec {
}
impl DataObjectTrait for DeviceGroupId {
}
impl DataObjectTrait for FaultDomainId {
}
impl DataObjectTrait for ReplicationGroupId {
}
impl DataObjectTrait for ReplicationSpec {
}
impl DataObjectTrait for VsanClusterConfigInfo {
}
impl DataObjectTrait for VsanClusterConfigInfoHostDefaultInfo {
}
impl DataObjectTrait for VsanHostClusterStatus {
}
impl DataObjectTrait for VsanHostClusterStatusState {
}
impl DataObjectTrait for VsanHostClusterStatusStateCompletionEstimate {
}
impl DataObjectTrait for VsanHostConfigInfo {
}
impl DataObjectTrait for VsanHostConfigInfoClusterInfo {
}
impl DataObjectTrait for VsanHostFaultDomainInfo {
}
impl DataObjectTrait for VsanHostConfigInfoNetworkInfo {
}
impl DataObjectTrait for VsanHostConfigInfoNetworkInfoPortConfig {
}
impl DataObjectTrait for VsanHostConfigInfoStorageInfo {
}
impl DataObjectTrait for VsanHostDecommissionMode {
}
impl DataObjectTrait for VsanHostDiskMapInfo {
}
impl DataObjectTrait for VsanHostDiskMapResult {
}
impl DataObjectTrait for VsanHostDiskMapping {
}
impl DataObjectTrait for VsanHostDiskResult {
}
impl DataObjectTrait for VsanHostIpConfig {
}
impl DataObjectTrait for VsanHostMembershipInfo {
}
impl DataObjectTrait for VsanHostVsanDiskInfo {
}
impl DataObjectTrait for VsanHostRuntimeInfo {
}
impl DataObjectTrait for VsanHostRuntimeInfoDiskIssue {
}
impl DataObjectTrait for BaseConfigInfo {
}
impl DataObjectTrait for VStorageObjectConfigInfo {
}
impl DataObjectTrait for BaseConfigInfoBackingInfo {
}
impl DataObjectTrait for BaseConfigInfoFileBackingInfo {
}
impl DataObjectTrait for BaseConfigInfoDiskFileBackingInfo {
}
impl DataObjectTrait for BaseConfigInfoRawDiskMappingBackingInfo {
}
impl DataObjectTrait for VslmCreateSpec {
}
impl DataObjectTrait for VslmCreateSpecBackingSpec {
}
impl DataObjectTrait for VslmCreateSpecDiskFileBackingSpec {
}
impl DataObjectTrait for VslmCreateSpecRawDiskMappingBackingSpec {
}
impl DataObjectTrait for DiskCryptoSpec {
}
impl DataObjectTrait for Id {
}
impl DataObjectTrait for VslmInfrastructureObjectPolicy {
}
impl DataObjectTrait for VslmInfrastructureObjectPolicySpec {
}
impl DataObjectTrait for VslmMigrateSpec {
}
impl DataObjectTrait for VslmCloneSpec {
}
impl DataObjectTrait for VslmRelocateSpec {
}
impl DataObjectTrait for VStorageObjectStateInfo {
}
impl DataObjectTrait for VslmTagEntry {
}
impl DataObjectTrait for VslmVClockInfo {
}
impl DataObjectTrait for VStorageObject {
}
impl DataObjectTrait for VStorageObjectSnapshot {
}
impl DataObjectTrait for VStorageObjectSnapshotDetails {
}
impl DataObjectTrait for VStorageObjectSnapshotInfo {
}
impl DataObjectTrait for VStorageObjectSnapshotInfoVStorageObjectSnapshot {
}
impl DataObjectTrait for RetrieveVStorageObjSpec {
}
impl DataObjectTrait for VStorageObjectAssociations {
}
impl DataObjectTrait for VStorageObjectAssociationsVmDiskAssociations {
}
impl DataObjectTrait for DynamicArray {
}
impl DataObjectTrait for DynamicProperty {
}
impl DataObjectTrait for KeyAnyValue {
}
impl DataObjectTrait for LocalizableMessage {
}
impl DataObjectTrait for LocalizedMethodFault {
}
impl DataObjectTrait for PropertyChange {
}
impl DataObjectTrait for PropertyFilterSpec {
}
impl DataObjectTrait for PropertyFilterUpdate {
}
impl DataObjectTrait for MissingObject {
}
impl DataObjectTrait for MissingProperty {
}
impl DataObjectTrait for ObjectContent {
}
impl DataObjectTrait for ObjectSpec {
}
impl DataObjectTrait for ObjectUpdate {
}
impl DataObjectTrait for PropertySpec {
}
impl DataObjectTrait for RetrieveOptions {
}
impl DataObjectTrait for RetrieveResult {
}
impl DataObjectTrait for SelectionSpec {
}
impl DataObjectTrait for TraversalSpec {
}
impl DataObjectTrait for UpdateSet {
}
impl DataObjectTrait for WaitOptions {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DataObjectTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DataObject => Some(from.as_any_ref().downcast_ref::<DataObject>()?),
            StructType::AboutInfo => Some(from.as_any_ref().downcast_ref::<AboutInfo>()?),
            StructType::AuthorizationDescription => Some(from.as_any_ref().downcast_ref::<AuthorizationDescription>()?),
            StructType::EntityPrivilege => Some(from.as_any_ref().downcast_ref::<EntityPrivilege>()?),
            StructType::Permission => Some(from.as_any_ref().downcast_ref::<Permission>()?),
            StructType::AuthorizationPrivilege => Some(from.as_any_ref().downcast_ref::<AuthorizationPrivilege>()?),
            StructType::PrivilegeAvailability => Some(from.as_any_ref().downcast_ref::<PrivilegeAvailability>()?),
            StructType::AuthorizationRole => Some(from.as_any_ref().downcast_ref::<AuthorizationRole>()?),
            StructType::UserPrivilegeResult => Some(from.as_any_ref().downcast_ref::<UserPrivilegeResult>()?),
            StructType::BatchResult => Some(from.as_any_ref().downcast_ref::<BatchResult>()?),
            StructType::Capability => Some(from.as_any_ref().downcast_ref::<Capability>()?),
            StructType::ClusterComputeResourceClusterConfigResult => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceClusterConfigResult>()?),
            StructType::ClusterComputeResourceDvsSetting => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceDvsSetting>()?),
            StructType::ClusterComputeResourceDvsSettingDvPortgroupToServiceMapping => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceDvsSettingDvPortgroupToServiceMapping>()?),
            StructType::ClusterComputeResourceDvsProfile => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceDvsProfile>()?),
            StructType::ClusterComputeResourceDvsProfileDvPortgroupSpecToServiceMapping => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceDvsProfileDvPortgroupSpecToServiceMapping>()?),
            StructType::ClusterComputeResourceHciConfigInfo => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceHciConfigInfo>()?),
            StructType::ClusterComputeResourceHciConfigSpec => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceHciConfigSpec>()?),
            StructType::ClusterComputeResourceHostConfigurationInput => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceHostConfigurationInput>()?),
            StructType::ClusterComputeResourceHostConfigurationProfile => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceHostConfigurationProfile>()?),
            StructType::ClusterComputeResourceHostVmkNicInfo => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceHostVmkNicInfo>()?),
            StructType::ClusterComputeResourceVcProfile => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceVcProfile>()?),
            StructType::ClusterComputeResourceValidationResultBase => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceValidationResultBase>()?),
            StructType::ClusterComputeResourceDvsConfigurationValidation => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceDvsConfigurationValidation>()?),
            StructType::ClusterComputeResourceHostConfigurationValidation => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceHostConfigurationValidation>()?),
            StructType::ClusterComputeResourceVcsSlots => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceVcsSlots>()?),
            StructType::ComputeResourceConfigInfo => Some(from.as_any_ref().downcast_ref::<ComputeResourceConfigInfo>()?),
            StructType::ClusterConfigInfoEx => Some(from.as_any_ref().downcast_ref::<ClusterConfigInfoEx>()?),
            StructType::ComputeResourceConfigSpec => Some(from.as_any_ref().downcast_ref::<ComputeResourceConfigSpec>()?),
            StructType::ClusterConfigSpecEx => Some(from.as_any_ref().downcast_ref::<ClusterConfigSpecEx>()?),
            StructType::ComputeResourceHostSpbmLicenseInfo => Some(from.as_any_ref().downcast_ref::<ComputeResourceHostSpbmLicenseInfo>()?),
            StructType::ComputeResourceSummary => Some(from.as_any_ref().downcast_ref::<ComputeResourceSummary>()?),
            StructType::ClusterComputeResourceSummary => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceSummary>()?),
            StructType::CustomFieldDef => Some(from.as_any_ref().downcast_ref::<CustomFieldDef>()?),
            StructType::CustomFieldValue => Some(from.as_any_ref().downcast_ref::<CustomFieldValue>()?),
            StructType::CustomFieldStringValue => Some(from.as_any_ref().downcast_ref::<CustomFieldStringValue>()?),
            StructType::CustomizationSpecInfo => Some(from.as_any_ref().downcast_ref::<CustomizationSpecInfo>()?),
            StructType::CustomizationSpecItem => Some(from.as_any_ref().downcast_ref::<CustomizationSpecItem>()?),
            StructType::DatacenterBasicConnectInfo => Some(from.as_any_ref().downcast_ref::<DatacenterBasicConnectInfo>()?),
            StructType::DatacenterConfigInfo => Some(from.as_any_ref().downcast_ref::<DatacenterConfigInfo>()?),
            StructType::DatacenterConfigSpec => Some(from.as_any_ref().downcast_ref::<DatacenterConfigSpec>()?),
            StructType::DatastoreCapability => Some(from.as_any_ref().downcast_ref::<DatastoreCapability>()?),
            StructType::DatastoreHostMount => Some(from.as_any_ref().downcast_ref::<DatastoreHostMount>()?),
            StructType::DatastoreInfo => Some(from.as_any_ref().downcast_ref::<DatastoreInfo>()?),
            StructType::LocalDatastoreInfo => Some(from.as_any_ref().downcast_ref::<LocalDatastoreInfo>()?),
            StructType::NasDatastoreInfo => Some(from.as_any_ref().downcast_ref::<NasDatastoreInfo>()?),
            StructType::PMemDatastoreInfo => Some(from.as_any_ref().downcast_ref::<PMemDatastoreInfo>()?),
            StructType::VmfsDatastoreInfo => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreInfo>()?),
            StructType::VsanDatastoreInfo => Some(from.as_any_ref().downcast_ref::<VsanDatastoreInfo>()?),
            StructType::VvolDatastoreInfo => Some(from.as_any_ref().downcast_ref::<VvolDatastoreInfo>()?),
            StructType::DatastoreMountPathDatastorePair => Some(from.as_any_ref().downcast_ref::<DatastoreMountPathDatastorePair>()?),
            StructType::DatastoreSummary => Some(from.as_any_ref().downcast_ref::<DatastoreSummary>()?),
            StructType::DatastoreVVolContainerFailoverPair => Some(from.as_any_ref().downcast_ref::<DatastoreVVolContainerFailoverPair>()?),
            StructType::DatastoreNamespaceManagerDirectoryInfo => Some(from.as_any_ref().downcast_ref::<DatastoreNamespaceManagerDirectoryInfo>()?),
            StructType::Description => Some(from.as_any_ref().downcast_ref::<Description>()?),
            StructType::ElementDescription => Some(from.as_any_ref().downcast_ref::<ElementDescription>()?),
            StructType::EvcMode => Some(from.as_any_ref().downcast_ref::<EvcMode>()?),
            StructType::ExtendedElementDescription => Some(from.as_any_ref().downcast_ref::<ExtendedElementDescription>()?),
            StructType::FeatureEvcMode => Some(from.as_any_ref().downcast_ref::<FeatureEvcMode>()?),
            StructType::OptionDef => Some(from.as_any_ref().downcast_ref::<OptionDef>()?),
            StructType::ExtendedDescription => Some(from.as_any_ref().downcast_ref::<ExtendedDescription>()?),
            StructType::MethodDescription => Some(from.as_any_ref().downcast_ref::<MethodDescription>()?),
            StructType::TypeDescription => Some(from.as_any_ref().downcast_ref::<TypeDescription>()?),
            StructType::ScheduledTaskDetail => Some(from.as_any_ref().downcast_ref::<ScheduledTaskDetail>()?),
            StructType::DesiredSoftwareSpec => Some(from.as_any_ref().downcast_ref::<DesiredSoftwareSpec>()?),
            StructType::DesiredSoftwareSpecBaseImageSpec => Some(from.as_any_ref().downcast_ref::<DesiredSoftwareSpecBaseImageSpec>()?),
            StructType::DesiredSoftwareSpecComponentSpec => Some(from.as_any_ref().downcast_ref::<DesiredSoftwareSpecComponentSpec>()?),
            StructType::DesiredSoftwareSpecVendorAddOnSpec => Some(from.as_any_ref().downcast_ref::<DesiredSoftwareSpecVendorAddOnSpec>()?),
            StructType::DiagnosticManagerAuditRecordResult => Some(from.as_any_ref().downcast_ref::<DiagnosticManagerAuditRecordResult>()?),
            StructType::DiagnosticManagerBundleInfo => Some(from.as_any_ref().downcast_ref::<DiagnosticManagerBundleInfo>()?),
            StructType::DiagnosticManagerLogDescriptor => Some(from.as_any_ref().downcast_ref::<DiagnosticManagerLogDescriptor>()?),
            StructType::DiagnosticManagerLogHeader => Some(from.as_any_ref().downcast_ref::<DiagnosticManagerLogHeader>()?),
            StructType::DvsBackupRestoreCapability => Some(from.as_any_ref().downcast_ref::<DvsBackupRestoreCapability>()?),
            StructType::DvsCapability => Some(from.as_any_ref().downcast_ref::<DvsCapability>()?),
            StructType::DvsConfigInfo => Some(from.as_any_ref().downcast_ref::<DvsConfigInfo>()?),
            StructType::VMwareDvsConfigInfo => Some(from.as_any_ref().downcast_ref::<VMwareDvsConfigInfo>()?),
            StructType::DvsConfigSpec => Some(from.as_any_ref().downcast_ref::<DvsConfigSpec>()?),
            StructType::VMwareDvsConfigSpec => Some(from.as_any_ref().downcast_ref::<VMwareDvsConfigSpec>()?),
            StructType::DvsContactInfo => Some(from.as_any_ref().downcast_ref::<DvsContactInfo>()?),
            StructType::DvsCreateSpec => Some(from.as_any_ref().downcast_ref::<DvsCreateSpec>()?),
            StructType::DvsFeatureCapability => Some(from.as_any_ref().downcast_ref::<DvsFeatureCapability>()?),
            StructType::VMwareDvsFeatureCapability => Some(from.as_any_ref().downcast_ref::<VMwareDvsFeatureCapability>()?),
            StructType::DvsHealthCheckConfig => Some(from.as_any_ref().downcast_ref::<DvsHealthCheckConfig>()?),
            StructType::VMwareDvsHealthCheckConfig => Some(from.as_any_ref().downcast_ref::<VMwareDvsHealthCheckConfig>()?),
            StructType::VMwareDvsTeamingHealthCheckConfig => Some(from.as_any_ref().downcast_ref::<VMwareDvsTeamingHealthCheckConfig>()?),
            StructType::VMwareDvsVlanMtuHealthCheckConfig => Some(from.as_any_ref().downcast_ref::<VMwareDvsVlanMtuHealthCheckConfig>()?),
            StructType::DvsHealthCheckCapability => Some(from.as_any_ref().downcast_ref::<DvsHealthCheckCapability>()?),
            StructType::VMwareDvsHealthCheckCapability => Some(from.as_any_ref().downcast_ref::<VMwareDvsHealthCheckCapability>()?),
            StructType::DvsHostInfrastructureTrafficResource => Some(from.as_any_ref().downcast_ref::<DvsHostInfrastructureTrafficResource>()?),
            StructType::DvsHostInfrastructureTrafficResourceAllocation => Some(from.as_any_ref().downcast_ref::<DvsHostInfrastructureTrafficResourceAllocation>()?),
            StructType::DvsNetworkResourceManagementCapability => Some(from.as_any_ref().downcast_ref::<DvsNetworkResourceManagementCapability>()?),
            StructType::DvsResourceRuntimeInfo => Some(from.as_any_ref().downcast_ref::<DvsResourceRuntimeInfo>()?),
            StructType::DvsRollbackCapability => Some(from.as_any_ref().downcast_ref::<DvsRollbackCapability>()?),
            StructType::DvsRuntimeInfo => Some(from.as_any_ref().downcast_ref::<DvsRuntimeInfo>()?),
            StructType::DvsSummary => Some(from.as_any_ref().downcast_ref::<DvsSummary>()?),
            StructType::DvsPolicy => Some(from.as_any_ref().downcast_ref::<DvsPolicy>()?),
            StructType::DvsUplinkPortPolicy => Some(from.as_any_ref().downcast_ref::<DvsUplinkPortPolicy>()?),
            StructType::DvsNameArrayUplinkPortPolicy => Some(from.as_any_ref().downcast_ref::<DvsNameArrayUplinkPortPolicy>()?),
            StructType::EnumDescription => Some(from.as_any_ref().downcast_ref::<EnumDescription>()?),
            StructType::EnvironmentBrowserConfigOptionQuerySpec => Some(from.as_any_ref().downcast_ref::<EnvironmentBrowserConfigOptionQuerySpec>()?),
            StructType::Extension => Some(from.as_any_ref().downcast_ref::<Extension>()?),
            StructType::ExtensionClientInfo => Some(from.as_any_ref().downcast_ref::<ExtensionClientInfo>()?),
            StructType::ExtensionEventTypeInfo => Some(from.as_any_ref().downcast_ref::<ExtensionEventTypeInfo>()?),
            StructType::ExtensionFaultTypeInfo => Some(from.as_any_ref().downcast_ref::<ExtensionFaultTypeInfo>()?),
            StructType::ExtensionHealthInfo => Some(from.as_any_ref().downcast_ref::<ExtensionHealthInfo>()?),
            StructType::ExtensionOvfConsumerInfo => Some(from.as_any_ref().downcast_ref::<ExtensionOvfConsumerInfo>()?),
            StructType::ExtensionPrivilegeInfo => Some(from.as_any_ref().downcast_ref::<ExtensionPrivilegeInfo>()?),
            StructType::ExtensionResourceInfo => Some(from.as_any_ref().downcast_ref::<ExtensionResourceInfo>()?),
            StructType::ExtensionServerInfo => Some(from.as_any_ref().downcast_ref::<ExtensionServerInfo>()?),
            StructType::ExtensionTaskTypeInfo => Some(from.as_any_ref().downcast_ref::<ExtensionTaskTypeInfo>()?),
            StructType::ExtensionManagerIpAllocationUsage => Some(from.as_any_ref().downcast_ref::<ExtensionManagerIpAllocationUsage>()?),
            StructType::FaultsByHost => Some(from.as_any_ref().downcast_ref::<FaultsByHost>()?),
            StructType::FaultsByVm => Some(from.as_any_ref().downcast_ref::<FaultsByVm>()?),
            StructType::FileLockInfo => Some(from.as_any_ref().downcast_ref::<FileLockInfo>()?),
            StructType::FileLockInfoResult => Some(from.as_any_ref().downcast_ref::<FileLockInfoResult>()?),
            StructType::FolderBatchAddHostsToClusterResult => Some(from.as_any_ref().downcast_ref::<FolderBatchAddHostsToClusterResult>()?),
            StructType::FolderBatchAddStandaloneHostsResult => Some(from.as_any_ref().downcast_ref::<FolderBatchAddStandaloneHostsResult>()?),
            StructType::FolderFailedHostResult => Some(from.as_any_ref().downcast_ref::<FolderFailedHostResult>()?),
            StructType::FolderNewHostSpec => Some(from.as_any_ref().downcast_ref::<FolderNewHostSpec>()?),
            StructType::HbrManagerReplicationVmInfo => Some(from.as_any_ref().downcast_ref::<HbrManagerReplicationVmInfo>()?),
            StructType::ReplicationVmProgressInfo => Some(from.as_any_ref().downcast_ref::<ReplicationVmProgressInfo>()?),
            StructType::HbrManagerVmReplicationCapability => Some(from.as_any_ref().downcast_ref::<HbrManagerVmReplicationCapability>()?),
            StructType::HealthUpdate => Some(from.as_any_ref().downcast_ref::<HealthUpdate>()?),
            StructType::HealthUpdateInfo => Some(from.as_any_ref().downcast_ref::<HealthUpdateInfo>()?),
            StructType::PerfInterval => Some(from.as_any_ref().downcast_ref::<PerfInterval>()?),
            StructType::HostServiceTicket => Some(from.as_any_ref().downcast_ref::<HostServiceTicket>()?),
            StructType::HostSystemComplianceCheckState => Some(from.as_any_ref().downcast_ref::<HostSystemComplianceCheckState>()?),
            StructType::HostSystemReconnectSpec => Some(from.as_any_ref().downcast_ref::<HostSystemReconnectSpec>()?),
            StructType::HostSystemRemediationState => Some(from.as_any_ref().downcast_ref::<HostSystemRemediationState>()?),
            StructType::HttpNfcLeaseCapabilities => Some(from.as_any_ref().downcast_ref::<HttpNfcLeaseCapabilities>()?),
            StructType::HttpNfcLeaseDatastoreLeaseInfo => Some(from.as_any_ref().downcast_ref::<HttpNfcLeaseDatastoreLeaseInfo>()?),
            StructType::HttpNfcLeaseDeviceUrl => Some(from.as_any_ref().downcast_ref::<HttpNfcLeaseDeviceUrl>()?),
            StructType::HttpNfcLeaseHostInfo => Some(from.as_any_ref().downcast_ref::<HttpNfcLeaseHostInfo>()?),
            StructType::HttpNfcLeaseInfo => Some(from.as_any_ref().downcast_ref::<HttpNfcLeaseInfo>()?),
            StructType::HttpNfcLeaseManifestEntry => Some(from.as_any_ref().downcast_ref::<HttpNfcLeaseManifestEntry>()?),
            StructType::HttpNfcLeaseProbeResult => Some(from.as_any_ref().downcast_ref::<HttpNfcLeaseProbeResult>()?),
            StructType::HttpNfcLeaseSourceFile => Some(from.as_any_ref().downcast_ref::<HttpNfcLeaseSourceFile>()?),
            StructType::ImportSpec => Some(from.as_any_ref().downcast_ref::<ImportSpec>()?),
            StructType::VirtualAppImportSpec => Some(from.as_any_ref().downcast_ref::<VirtualAppImportSpec>()?),
            StructType::VirtualMachineImportSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineImportSpec>()?),
            StructType::InheritablePolicy => Some(from.as_any_ref().downcast_ref::<InheritablePolicy>()?),
            StructType::BoolPolicy => Some(from.as_any_ref().downcast_ref::<BoolPolicy>()?),
            StructType::IntPolicy => Some(from.as_any_ref().downcast_ref::<IntPolicy>()?),
            StructType::LongPolicy => Some(from.as_any_ref().downcast_ref::<LongPolicy>()?),
            StructType::StringPolicy => Some(from.as_any_ref().downcast_ref::<StringPolicy>()?),
            StructType::DvsFilterConfig => Some(from.as_any_ref().downcast_ref::<DvsFilterConfig>()?),
            StructType::DvsFilterConfigSpec => Some(from.as_any_ref().downcast_ref::<DvsFilterConfigSpec>()?),
            StructType::DvsTrafficFilterConfig => Some(from.as_any_ref().downcast_ref::<DvsTrafficFilterConfig>()?),
            StructType::DvsTrafficFilterConfigSpec => Some(from.as_any_ref().downcast_ref::<DvsTrafficFilterConfigSpec>()?),
            StructType::DvsFilterPolicy => Some(from.as_any_ref().downcast_ref::<DvsFilterPolicy>()?),
            StructType::DvsTrafficShapingPolicy => Some(from.as_any_ref().downcast_ref::<DvsTrafficShapingPolicy>()?),
            StructType::DvsVendorSpecificConfig => Some(from.as_any_ref().downcast_ref::<DvsVendorSpecificConfig>()?),
            StructType::DvsFailureCriteria => Some(from.as_any_ref().downcast_ref::<DvsFailureCriteria>()?),
            StructType::DvsMacLearningPolicy => Some(from.as_any_ref().downcast_ref::<DvsMacLearningPolicy>()?),
            StructType::DvsMacManagementPolicy => Some(from.as_any_ref().downcast_ref::<DvsMacManagementPolicy>()?),
            StructType::DvsSecurityPolicy => Some(from.as_any_ref().downcast_ref::<DvsSecurityPolicy>()?),
            StructType::VMwareUplinkLacpPolicy => Some(from.as_any_ref().downcast_ref::<VMwareUplinkLacpPolicy>()?),
            StructType::VMwareUplinkPortOrderPolicy => Some(from.as_any_ref().downcast_ref::<VMwareUplinkPortOrderPolicy>()?),
            StructType::VmwareUplinkPortTeamingPolicy => Some(from.as_any_ref().downcast_ref::<VmwareUplinkPortTeamingPolicy>()?),
            StructType::VmwareDistributedVirtualSwitchVlanSpec => Some(from.as_any_ref().downcast_ref::<VmwareDistributedVirtualSwitchVlanSpec>()?),
            StructType::VmwareDistributedVirtualSwitchPvlanSpec => Some(from.as_any_ref().downcast_ref::<VmwareDistributedVirtualSwitchPvlanSpec>()?),
            StructType::VmwareDistributedVirtualSwitchTrunkVlanSpec => Some(from.as_any_ref().downcast_ref::<VmwareDistributedVirtualSwitchTrunkVlanSpec>()?),
            StructType::VmwareDistributedVirtualSwitchVlanIdSpec => Some(from.as_any_ref().downcast_ref::<VmwareDistributedVirtualSwitchVlanIdSpec>()?),
            StructType::IoFilterInfo => Some(from.as_any_ref().downcast_ref::<IoFilterInfo>()?),
            StructType::ClusterIoFilterInfo => Some(from.as_any_ref().downcast_ref::<ClusterIoFilterInfo>()?),
            StructType::HostIoFilterInfo => Some(from.as_any_ref().downcast_ref::<HostIoFilterInfo>()?),
            StructType::IoFilterQueryIssueResult => Some(from.as_any_ref().downcast_ref::<IoFilterQueryIssueResult>()?),
            StructType::IoFilterHostIssue => Some(from.as_any_ref().downcast_ref::<IoFilterHostIssue>()?),
            StructType::IpPoolManagerIpAllocation => Some(from.as_any_ref().downcast_ref::<IpPoolManagerIpAllocation>()?),
            StructType::KeyValue => Some(from.as_any_ref().downcast_ref::<KeyValue>()?),
            StructType::LatencySensitivity => Some(from.as_any_ref().downcast_ref::<LatencySensitivity>()?),
            StructType::LicenseAssignmentManagerLicenseAssignment => Some(from.as_any_ref().downcast_ref::<LicenseAssignmentManagerLicenseAssignment>()?),
            StructType::LicenseAvailabilityInfo => Some(from.as_any_ref().downcast_ref::<LicenseAvailabilityInfo>()?),
            StructType::LicenseDiagnostics => Some(from.as_any_ref().downcast_ref::<LicenseDiagnostics>()?),
            StructType::LicenseManagerEvaluationInfo => Some(from.as_any_ref().downcast_ref::<LicenseManagerEvaluationInfo>()?),
            StructType::LicenseFeatureInfo => Some(from.as_any_ref().downcast_ref::<LicenseFeatureInfo>()?),
            StructType::HostLicensableResourceInfo => Some(from.as_any_ref().downcast_ref::<HostLicensableResourceInfo>()?),
            StructType::LicenseManagerLicenseInfo => Some(from.as_any_ref().downcast_ref::<LicenseManagerLicenseInfo>()?),
            StructType::LicenseSource => Some(from.as_any_ref().downcast_ref::<LicenseSource>()?),
            StructType::EvaluationLicenseSource => Some(from.as_any_ref().downcast_ref::<EvaluationLicenseSource>()?),
            StructType::LicenseServerSource => Some(from.as_any_ref().downcast_ref::<LicenseServerSource>()?),
            StructType::LocalLicenseSource => Some(from.as_any_ref().downcast_ref::<LocalLicenseSource>()?),
            StructType::LicenseUsageInfo => Some(from.as_any_ref().downcast_ref::<LicenseUsageInfo>()?),
            StructType::LicenseReservationInfo => Some(from.as_any_ref().downcast_ref::<LicenseReservationInfo>()?),
            StructType::LocalizationManagerMessageCatalog => Some(from.as_any_ref().downcast_ref::<LocalizationManagerMessageCatalog>()?),
            StructType::NegatableExpression => Some(from.as_any_ref().downcast_ref::<NegatableExpression>()?),
            StructType::IntExpression => Some(from.as_any_ref().downcast_ref::<IntExpression>()?),
            StructType::IpAddress => Some(from.as_any_ref().downcast_ref::<IpAddress>()?),
            StructType::IpRange => Some(from.as_any_ref().downcast_ref::<IpRange>()?),
            StructType::SingleIp => Some(from.as_any_ref().downcast_ref::<SingleIp>()?),
            StructType::MacAddress => Some(from.as_any_ref().downcast_ref::<MacAddress>()?),
            StructType::MacRange => Some(from.as_any_ref().downcast_ref::<MacRange>()?),
            StructType::SingleMac => Some(from.as_any_ref().downcast_ref::<SingleMac>()?),
            StructType::StringExpression => Some(from.as_any_ref().downcast_ref::<StringExpression>()?),
            StructType::DvsIpPort => Some(from.as_any_ref().downcast_ref::<DvsIpPort>()?),
            StructType::DvsIpPortRange => Some(from.as_any_ref().downcast_ref::<DvsIpPortRange>()?),
            StructType::DvsSingleIpPort => Some(from.as_any_ref().downcast_ref::<DvsSingleIpPort>()?),
            StructType::NetworkSummary => Some(from.as_any_ref().downcast_ref::<NetworkSummary>()?),
            StructType::OpaqueNetworkSummary => Some(from.as_any_ref().downcast_ref::<OpaqueNetworkSummary>()?),
            StructType::NumericRange => Some(from.as_any_ref().downcast_ref::<NumericRange>()?),
            StructType::OpaqueNetworkCapability => Some(from.as_any_ref().downcast_ref::<OpaqueNetworkCapability>()?),
            StructType::OvfConsumerOstNode => Some(from.as_any_ref().downcast_ref::<OvfConsumerOstNode>()?),
            StructType::OvfConsumerOvfSection => Some(from.as_any_ref().downcast_ref::<OvfConsumerOvfSection>()?),
            StructType::OvfManagerCommonParams => Some(from.as_any_ref().downcast_ref::<OvfManagerCommonParams>()?),
            StructType::OvfCreateImportSpecParams => Some(from.as_any_ref().downcast_ref::<OvfCreateImportSpecParams>()?),
            StructType::OvfParseDescriptorParams => Some(from.as_any_ref().downcast_ref::<OvfParseDescriptorParams>()?),
            StructType::OvfValidateHostParams => Some(from.as_any_ref().downcast_ref::<OvfValidateHostParams>()?),
            StructType::OvfCreateDescriptorParams => Some(from.as_any_ref().downcast_ref::<OvfCreateDescriptorParams>()?),
            StructType::OvfCreateDescriptorResult => Some(from.as_any_ref().downcast_ref::<OvfCreateDescriptorResult>()?),
            StructType::OvfCreateImportSpecResult => Some(from.as_any_ref().downcast_ref::<OvfCreateImportSpecResult>()?),
            StructType::OvfDeploymentOption => Some(from.as_any_ref().downcast_ref::<OvfDeploymentOption>()?),
            StructType::OvfFileItem => Some(from.as_any_ref().downcast_ref::<OvfFileItem>()?),
            StructType::OvfNetworkInfo => Some(from.as_any_ref().downcast_ref::<OvfNetworkInfo>()?),
            StructType::OvfNetworkMapping => Some(from.as_any_ref().downcast_ref::<OvfNetworkMapping>()?),
            StructType::OvfFile => Some(from.as_any_ref().downcast_ref::<OvfFile>()?),
            StructType::OvfOptionInfo => Some(from.as_any_ref().downcast_ref::<OvfOptionInfo>()?),
            StructType::OvfParseDescriptorResult => Some(from.as_any_ref().downcast_ref::<OvfParseDescriptorResult>()?),
            StructType::OvfResourceMap => Some(from.as_any_ref().downcast_ref::<OvfResourceMap>()?),
            StructType::OvfValidateHostResult => Some(from.as_any_ref().downcast_ref::<OvfValidateHostResult>()?),
            StructType::PasswordField => Some(from.as_any_ref().downcast_ref::<PasswordField>()?),
            StructType::PerformanceDescription => Some(from.as_any_ref().downcast_ref::<PerformanceDescription>()?),
            StructType::PerfCompositeMetric => Some(from.as_any_ref().downcast_ref::<PerfCompositeMetric>()?),
            StructType::PerfCounterInfo => Some(from.as_any_ref().downcast_ref::<PerfCounterInfo>()?),
            StructType::PerformanceManagerCounterLevelMapping => Some(from.as_any_ref().downcast_ref::<PerformanceManagerCounterLevelMapping>()?),
            StructType::PerfEntityMetricBase => Some(from.as_any_ref().downcast_ref::<PerfEntityMetricBase>()?),
            StructType::PerfEntityMetric => Some(from.as_any_ref().downcast_ref::<PerfEntityMetric>()?),
            StructType::PerfEntityMetricCsv => Some(from.as_any_ref().downcast_ref::<PerfEntityMetricCsv>()?),
            StructType::PerfMetricId => Some(from.as_any_ref().downcast_ref::<PerfMetricId>()?),
            StructType::PerfMetricSeries => Some(from.as_any_ref().downcast_ref::<PerfMetricSeries>()?),
            StructType::PerfMetricIntSeries => Some(from.as_any_ref().downcast_ref::<PerfMetricIntSeries>()?),
            StructType::PerfMetricSeriesCsv => Some(from.as_any_ref().downcast_ref::<PerfMetricSeriesCsv>()?),
            StructType::PerfProviderSummary => Some(from.as_any_ref().downcast_ref::<PerfProviderSummary>()?),
            StructType::PerfQuerySpec => Some(from.as_any_ref().downcast_ref::<PerfQuerySpec>()?),
            StructType::PerfSampleInfo => Some(from.as_any_ref().downcast_ref::<PerfSampleInfo>()?),
            StructType::PrivilegePolicyDef => Some(from.as_any_ref().downcast_ref::<PrivilegePolicyDef>()?),
            StructType::ResourceAllocationInfo => Some(from.as_any_ref().downcast_ref::<ResourceAllocationInfo>()?),
            StructType::ResourceAllocationOption => Some(from.as_any_ref().downcast_ref::<ResourceAllocationOption>()?),
            StructType::ResourceConfigOption => Some(from.as_any_ref().downcast_ref::<ResourceConfigOption>()?),
            StructType::ResourceConfigSpec => Some(from.as_any_ref().downcast_ref::<ResourceConfigSpec>()?),
            StructType::DatabaseSizeEstimate => Some(from.as_any_ref().downcast_ref::<DatabaseSizeEstimate>()?),
            StructType::DatabaseSizeParam => Some(from.as_any_ref().downcast_ref::<DatabaseSizeParam>()?),
            StructType::InventoryDescription => Some(from.as_any_ref().downcast_ref::<InventoryDescription>()?),
            StructType::PerformanceStatisticsDescription => Some(from.as_any_ref().downcast_ref::<PerformanceStatisticsDescription>()?),
            StructType::ResourcePoolResourceUsage => Some(from.as_any_ref().downcast_ref::<ResourcePoolResourceUsage>()?),
            StructType::ResourcePoolRuntimeInfo => Some(from.as_any_ref().downcast_ref::<ResourcePoolRuntimeInfo>()?),
            StructType::ResourcePoolSummary => Some(from.as_any_ref().downcast_ref::<ResourcePoolSummary>()?),
            StructType::VirtualAppSummary => Some(from.as_any_ref().downcast_ref::<VirtualAppSummary>()?),
            StructType::ResourcePoolQuickStats => Some(from.as_any_ref().downcast_ref::<ResourcePoolQuickStats>()?),
            StructType::SddcBase => Some(from.as_any_ref().downcast_ref::<SddcBase>()?),
            StructType::SelectionSet => Some(from.as_any_ref().downcast_ref::<SelectionSet>()?),
            StructType::DvPortgroupSelection => Some(from.as_any_ref().downcast_ref::<DvPortgroupSelection>()?),
            StructType::DvsSelection => Some(from.as_any_ref().downcast_ref::<DvsSelection>()?),
            StructType::HostVMotionCompatibility => Some(from.as_any_ref().downcast_ref::<HostVMotionCompatibility>()?),
            StructType::ProductComponentInfo => Some(from.as_any_ref().downcast_ref::<ProductComponentInfo>()?),
            StructType::ServiceContent => Some(from.as_any_ref().downcast_ref::<ServiceContent>()?),
            StructType::ServiceLocator => Some(from.as_any_ref().downcast_ref::<ServiceLocator>()?),
            StructType::ServiceLocatorCredential => Some(from.as_any_ref().downcast_ref::<ServiceLocatorCredential>()?),
            StructType::ServiceLocatorNamePassword => Some(from.as_any_ref().downcast_ref::<ServiceLocatorNamePassword>()?),
            StructType::ServiceLocatorSamlCredential => Some(from.as_any_ref().downcast_ref::<ServiceLocatorSamlCredential>()?),
            StructType::ServiceManagerServiceInfo => Some(from.as_any_ref().downcast_ref::<ServiceManagerServiceInfo>()?),
            StructType::SessionManagerGenericServiceTicket => Some(from.as_any_ref().downcast_ref::<SessionManagerGenericServiceTicket>()?),
            StructType::SessionManagerLocalTicket => Some(from.as_any_ref().downcast_ref::<SessionManagerLocalTicket>()?),
            StructType::SessionManagerServiceRequestSpec => Some(from.as_any_ref().downcast_ref::<SessionManagerServiceRequestSpec>()?),
            StructType::SessionManagerHttpServiceRequestSpec => Some(from.as_any_ref().downcast_ref::<SessionManagerHttpServiceRequestSpec>()?),
            StructType::SessionManagerVmomiServiceRequestSpec => Some(from.as_any_ref().downcast_ref::<SessionManagerVmomiServiceRequestSpec>()?),
            StructType::SharesInfo => Some(from.as_any_ref().downcast_ref::<SharesInfo>()?),
            StructType::SharesOption => Some(from.as_any_ref().downcast_ref::<SharesOption>()?),
            StructType::SiteInfo => Some(from.as_any_ref().downcast_ref::<SiteInfo>()?),
            StructType::StoragePodSummary => Some(from.as_any_ref().downcast_ref::<StoragePodSummary>()?),
            StructType::StorageIoAllocationInfo => Some(from.as_any_ref().downcast_ref::<StorageIoAllocationInfo>()?),
            StructType::StorageIoAllocationOption => Some(from.as_any_ref().downcast_ref::<StorageIoAllocationOption>()?),
            StructType::StorageIormInfo => Some(from.as_any_ref().downcast_ref::<StorageIormInfo>()?),
            StructType::StorageIormConfigOption => Some(from.as_any_ref().downcast_ref::<StorageIormConfigOption>()?),
            StructType::StorageIormConfigSpec => Some(from.as_any_ref().downcast_ref::<StorageIormConfigSpec>()?),
            StructType::PodStorageDrsEntry => Some(from.as_any_ref().downcast_ref::<PodStorageDrsEntry>()?),
            StructType::StoragePerformanceSummary => Some(from.as_any_ref().downcast_ref::<StoragePerformanceSummary>()?),
            StructType::StorageResourceManagerStorageProfileStatistics => Some(from.as_any_ref().downcast_ref::<StorageResourceManagerStorageProfileStatistics>()?),
            StructType::Tag => Some(from.as_any_ref().downcast_ref::<Tag>()?),
            StructType::TaskDescription => Some(from.as_any_ref().downcast_ref::<TaskDescription>()?),
            StructType::TaskFilterSpec => Some(from.as_any_ref().downcast_ref::<TaskFilterSpec>()?),
            StructType::TaskFilterSpecByEntity => Some(from.as_any_ref().downcast_ref::<TaskFilterSpecByEntity>()?),
            StructType::TaskFilterSpecByTime => Some(from.as_any_ref().downcast_ref::<TaskFilterSpecByTime>()?),
            StructType::TaskFilterSpecByUsername => Some(from.as_any_ref().downcast_ref::<TaskFilterSpecByUsername>()?),
            StructType::TaskInfo => Some(from.as_any_ref().downcast_ref::<TaskInfo>()?),
            StructType::TaskReason => Some(from.as_any_ref().downcast_ref::<TaskReason>()?),
            StructType::TaskReasonAlarm => Some(from.as_any_ref().downcast_ref::<TaskReasonAlarm>()?),
            StructType::TaskReasonSchedule => Some(from.as_any_ref().downcast_ref::<TaskReasonSchedule>()?),
            StructType::TaskReasonSystem => Some(from.as_any_ref().downcast_ref::<TaskReasonSystem>()?),
            StructType::TaskReasonUser => Some(from.as_any_ref().downcast_ref::<TaskReasonUser>()?),
            StructType::UpdateVirtualMachineFilesResult => Some(from.as_any_ref().downcast_ref::<UpdateVirtualMachineFilesResult>()?),
            StructType::UpdateVirtualMachineFilesResultFailedVmFileInfo => Some(from.as_any_ref().downcast_ref::<UpdateVirtualMachineFilesResultFailedVmFileInfo>()?),
            StructType::UserSearchResult => Some(from.as_any_ref().downcast_ref::<UserSearchResult>()?),
            StructType::PosixUserSearchResult => Some(from.as_any_ref().downcast_ref::<PosixUserSearchResult>()?),
            StructType::UserSession => Some(from.as_any_ref().downcast_ref::<UserSession>()?),
            StructType::VVolVmConfigFileUpdateResult => Some(from.as_any_ref().downcast_ref::<VVolVmConfigFileUpdateResult>()?),
            StructType::VVolVmConfigFileUpdateResultFailedVmConfigFileInfo => Some(from.as_any_ref().downcast_ref::<VVolVmConfigFileUpdateResultFailedVmConfigFileInfo>()?),
            StructType::VasaStorageArray => Some(from.as_any_ref().downcast_ref::<VasaStorageArray>()?),
            StructType::VasaStorageArrayDiscoveryFcTransport => Some(from.as_any_ref().downcast_ref::<VasaStorageArrayDiscoveryFcTransport>()?),
            StructType::VasaStorageArrayDiscoveryIpTransport => Some(from.as_any_ref().downcast_ref::<VasaStorageArrayDiscoveryIpTransport>()?),
            StructType::VasaStorageArrayDiscoverySvcInfo => Some(from.as_any_ref().downcast_ref::<VasaStorageArrayDiscoverySvcInfo>()?),
            StructType::VasaProviderContainerSpec => Some(from.as_any_ref().downcast_ref::<VasaProviderContainerSpec>()?),
            StructType::VimVasaProvider => Some(from.as_any_ref().downcast_ref::<VimVasaProvider>()?),
            StructType::VimVasaProviderStatePerArray => Some(from.as_any_ref().downcast_ref::<VimVasaProviderStatePerArray>()?),
            StructType::VimVasaProviderVirtualHostConfig => Some(from.as_any_ref().downcast_ref::<VimVasaProviderVirtualHostConfig>()?),
            StructType::VimVasaProviderInfo => Some(from.as_any_ref().downcast_ref::<VimVasaProviderInfo>()?),
            StructType::VirtualAppLinkInfo => Some(from.as_any_ref().downcast_ref::<VirtualAppLinkInfo>()?),
            StructType::VirtualDiskSpec => Some(from.as_any_ref().downcast_ref::<VirtualDiskSpec>()?),
            StructType::DeviceBackedVirtualDiskSpec => Some(from.as_any_ref().downcast_ref::<DeviceBackedVirtualDiskSpec>()?),
            StructType::FileBackedVirtualDiskSpec => Some(from.as_any_ref().downcast_ref::<FileBackedVirtualDiskSpec>()?),
            StructType::SeSparseVirtualDiskSpec => Some(from.as_any_ref().downcast_ref::<SeSparseVirtualDiskSpec>()?),
            StructType::VirtualMachineConnection => Some(from.as_any_ref().downcast_ref::<VirtualMachineConnection>()?),
            StructType::VirtualMachineMksConnection => Some(from.as_any_ref().downcast_ref::<VirtualMachineMksConnection>()?),
            StructType::DiskChangeInfo => Some(from.as_any_ref().downcast_ref::<DiskChangeInfo>()?),
            StructType::DiskChangeExtent => Some(from.as_any_ref().downcast_ref::<DiskChangeExtent>()?),
            StructType::VirtualMachineDisplayTopology => Some(from.as_any_ref().downcast_ref::<VirtualMachineDisplayTopology>()?),
            StructType::VirtualMachineMksTicket => Some(from.as_any_ref().downcast_ref::<VirtualMachineMksTicket>()?),
            StructType::StorageRequirement => Some(from.as_any_ref().downcast_ref::<StorageRequirement>()?),
            StructType::VirtualMachineTicket => Some(from.as_any_ref().downcast_ref::<VirtualMachineTicket>()?),
            StructType::VirtualMachineWipeResult => Some(from.as_any_ref().downcast_ref::<VirtualMachineWipeResult>()?),
            StructType::VsanUpgradeSystemNetworkPartitionInfo => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemNetworkPartitionInfo>()?),
            StructType::VsanUpgradeSystemPreflightCheckIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemPreflightCheckIssue>()?),
            StructType::VsanUpgradeSystemApiBrokenIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemApiBrokenIssue>()?),
            StructType::VsanUpgradeSystemAutoClaimEnabledOnHostsIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemAutoClaimEnabledOnHostsIssue>()?),
            StructType::VsanUpgradeSystemHostsDisconnectedIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemHostsDisconnectedIssue>()?),
            StructType::VsanUpgradeSystemMissingHostsInClusterIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemMissingHostsInClusterIssue>()?),
            StructType::VsanUpgradeSystemNetworkPartitionIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemNetworkPartitionIssue>()?),
            StructType::VsanUpgradeSystemNotEnoughFreeCapacityIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemNotEnoughFreeCapacityIssue>()?),
            StructType::VsanUpgradeSystemRogueHostsInClusterIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemRogueHostsInClusterIssue>()?),
            StructType::VsanUpgradeSystemV2ObjectsPresentDuringDowngradeIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemV2ObjectsPresentDuringDowngradeIssue>()?),
            StructType::VsanUpgradeSystemWrongEsxVersionIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemWrongEsxVersionIssue>()?),
            StructType::VsanUpgradeSystemPreflightCheckResult => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemPreflightCheckResult>()?),
            StructType::VsanUpgradeSystemUpgradeHistoryItem => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemUpgradeHistoryItem>()?),
            StructType::VsanUpgradeSystemUpgradeHistoryDiskGroupOp => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemUpgradeHistoryDiskGroupOp>()?),
            StructType::VsanUpgradeSystemUpgradeHistoryPreflightFail => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemUpgradeHistoryPreflightFail>()?),
            StructType::VsanUpgradeSystemUpgradeStatus => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemUpgradeStatus>()?),
            StructType::Action => Some(from.as_any_ref().downcast_ref::<Action>()?),
            StructType::CreateTaskAction => Some(from.as_any_ref().downcast_ref::<CreateTaskAction>()?),
            StructType::MethodAction => Some(from.as_any_ref().downcast_ref::<MethodAction>()?),
            StructType::RunScriptAction => Some(from.as_any_ref().downcast_ref::<RunScriptAction>()?),
            StructType::SendEmailAction => Some(from.as_any_ref().downcast_ref::<SendEmailAction>()?),
            StructType::SendSnmpAction => Some(from.as_any_ref().downcast_ref::<SendSnmpAction>()?),
            StructType::MethodActionArgument => Some(from.as_any_ref().downcast_ref::<MethodActionArgument>()?),
            StructType::AlarmAction => Some(from.as_any_ref().downcast_ref::<AlarmAction>()?),
            StructType::AlarmTriggeringAction => Some(from.as_any_ref().downcast_ref::<AlarmTriggeringAction>()?),
            StructType::GroupAlarmAction => Some(from.as_any_ref().downcast_ref::<GroupAlarmAction>()?),
            StructType::AlarmDescription => Some(from.as_any_ref().downcast_ref::<AlarmDescription>()?),
            StructType::AlarmExpression => Some(from.as_any_ref().downcast_ref::<AlarmExpression>()?),
            StructType::AndAlarmExpression => Some(from.as_any_ref().downcast_ref::<AndAlarmExpression>()?),
            StructType::EventAlarmExpression => Some(from.as_any_ref().downcast_ref::<EventAlarmExpression>()?),
            StructType::MetricAlarmExpression => Some(from.as_any_ref().downcast_ref::<MetricAlarmExpression>()?),
            StructType::OrAlarmExpression => Some(from.as_any_ref().downcast_ref::<OrAlarmExpression>()?),
            StructType::StateAlarmExpression => Some(from.as_any_ref().downcast_ref::<StateAlarmExpression>()?),
            StructType::AlarmFilterSpec => Some(from.as_any_ref().downcast_ref::<AlarmFilterSpec>()?),
            StructType::AlarmSetting => Some(from.as_any_ref().downcast_ref::<AlarmSetting>()?),
            StructType::AlarmSpec => Some(from.as_any_ref().downcast_ref::<AlarmSpec>()?),
            StructType::AlarmInfo => Some(from.as_any_ref().downcast_ref::<AlarmInfo>()?),
            StructType::AlarmState => Some(from.as_any_ref().downcast_ref::<AlarmState>()?),
            StructType::AlarmTriggeringActionTransitionSpec => Some(from.as_any_ref().downcast_ref::<AlarmTriggeringActionTransitionSpec>()?),
            StructType::EventAlarmExpressionComparison => Some(from.as_any_ref().downcast_ref::<EventAlarmExpressionComparison>()?),
            StructType::ClusterAction => Some(from.as_any_ref().downcast_ref::<ClusterAction>()?),
            StructType::ClusterClusterInitialPlacementAction => Some(from.as_any_ref().downcast_ref::<ClusterClusterInitialPlacementAction>()?),
            StructType::ClusterHostInfraUpdateHaModeAction => Some(from.as_any_ref().downcast_ref::<ClusterHostInfraUpdateHaModeAction>()?),
            StructType::ClusterHostPowerAction => Some(from.as_any_ref().downcast_ref::<ClusterHostPowerAction>()?),
            StructType::ClusterInitialPlacementAction => Some(from.as_any_ref().downcast_ref::<ClusterInitialPlacementAction>()?),
            StructType::ClusterMigrationAction => Some(from.as_any_ref().downcast_ref::<ClusterMigrationAction>()?),
            StructType::PlacementAction => Some(from.as_any_ref().downcast_ref::<PlacementAction>()?),
            StructType::HbrDiskMigrationAction => Some(from.as_any_ref().downcast_ref::<HbrDiskMigrationAction>()?),
            StructType::StorageMigrationAction => Some(from.as_any_ref().downcast_ref::<StorageMigrationAction>()?),
            StructType::StoragePlacementAction => Some(from.as_any_ref().downcast_ref::<StoragePlacementAction>()?),
            StructType::ClusterActionHistory => Some(from.as_any_ref().downcast_ref::<ClusterActionHistory>()?),
            StructType::ClusterAttemptedVmInfo => Some(from.as_any_ref().downcast_ref::<ClusterAttemptedVmInfo>()?),
            StructType::ClusterConfigInfo => Some(from.as_any_ref().downcast_ref::<ClusterConfigInfo>()?),
            StructType::ClusterConfigSpec => Some(from.as_any_ref().downcast_ref::<ClusterConfigSpec>()?),
            StructType::ClusterCryptoConfigInfo => Some(from.as_any_ref().downcast_ref::<ClusterCryptoConfigInfo>()?),
            StructType::ClusterDasAamNodeState => Some(from.as_any_ref().downcast_ref::<ClusterDasAamNodeState>()?),
            StructType::ClusterDasAdmissionControlInfo => Some(from.as_any_ref().downcast_ref::<ClusterDasAdmissionControlInfo>()?),
            StructType::ClusterFailoverHostAdmissionControlInfo => Some(from.as_any_ref().downcast_ref::<ClusterFailoverHostAdmissionControlInfo>()?),
            StructType::ClusterFailoverLevelAdmissionControlInfo => Some(from.as_any_ref().downcast_ref::<ClusterFailoverLevelAdmissionControlInfo>()?),
            StructType::ClusterFailoverResourcesAdmissionControlInfo => Some(from.as_any_ref().downcast_ref::<ClusterFailoverResourcesAdmissionControlInfo>()?),
            StructType::ClusterDasAdmissionControlPolicy => Some(from.as_any_ref().downcast_ref::<ClusterDasAdmissionControlPolicy>()?),
            StructType::ClusterFailoverHostAdmissionControlPolicy => Some(from.as_any_ref().downcast_ref::<ClusterFailoverHostAdmissionControlPolicy>()?),
            StructType::ClusterFailoverLevelAdmissionControlPolicy => Some(from.as_any_ref().downcast_ref::<ClusterFailoverLevelAdmissionControlPolicy>()?),
            StructType::ClusterFailoverResourcesAdmissionControlPolicy => Some(from.as_any_ref().downcast_ref::<ClusterFailoverResourcesAdmissionControlPolicy>()?),
            StructType::ClusterDasAdvancedRuntimeInfo => Some(from.as_any_ref().downcast_ref::<ClusterDasAdvancedRuntimeInfo>()?),
            StructType::ClusterDasFailoverLevelAdvancedRuntimeInfo => Some(from.as_any_ref().downcast_ref::<ClusterDasFailoverLevelAdvancedRuntimeInfo>()?),
            StructType::DasHeartbeatDatastoreInfo => Some(from.as_any_ref().downcast_ref::<DasHeartbeatDatastoreInfo>()?),
            StructType::ClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo => Some(from.as_any_ref().downcast_ref::<ClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo>()?),
            StructType::ClusterDasConfigInfo => Some(from.as_any_ref().downcast_ref::<ClusterDasConfigInfo>()?),
            StructType::ClusterDasData => Some(from.as_any_ref().downcast_ref::<ClusterDasData>()?),
            StructType::ClusterDasDataSummary => Some(from.as_any_ref().downcast_ref::<ClusterDasDataSummary>()?),
            StructType::ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots => Some(from.as_any_ref().downcast_ref::<ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots>()?),
            StructType::ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo => Some(from.as_any_ref().downcast_ref::<ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo>()?),
            StructType::ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots => Some(from.as_any_ref().downcast_ref::<ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots>()?),
            StructType::ClusterDasFdmHostState => Some(from.as_any_ref().downcast_ref::<ClusterDasFdmHostState>()?),
            StructType::ClusterDasHostInfo => Some(from.as_any_ref().downcast_ref::<ClusterDasHostInfo>()?),
            StructType::ClusterDasAamHostInfo => Some(from.as_any_ref().downcast_ref::<ClusterDasAamHostInfo>()?),
            StructType::ClusterDasHostRecommendation => Some(from.as_any_ref().downcast_ref::<ClusterDasHostRecommendation>()?),
            StructType::ClusterDasVmConfigInfo => Some(from.as_any_ref().downcast_ref::<ClusterDasVmConfigInfo>()?),
            StructType::ClusterDasVmSettings => Some(from.as_any_ref().downcast_ref::<ClusterDasVmSettings>()?),
            StructType::ClusterDpmConfigInfo => Some(from.as_any_ref().downcast_ref::<ClusterDpmConfigInfo>()?),
            StructType::ClusterDpmHostConfigInfo => Some(from.as_any_ref().downcast_ref::<ClusterDpmHostConfigInfo>()?),
            StructType::ClusterDrsConfigInfo => Some(from.as_any_ref().downcast_ref::<ClusterDrsConfigInfo>()?),
            StructType::ClusterDrsFaults => Some(from.as_any_ref().downcast_ref::<ClusterDrsFaults>()?),
            StructType::ClusterDrsFaultsFaultsByVm => Some(from.as_any_ref().downcast_ref::<ClusterDrsFaultsFaultsByVm>()?),
            StructType::ClusterDrsFaultsFaultsByVirtualDisk => Some(from.as_any_ref().downcast_ref::<ClusterDrsFaultsFaultsByVirtualDisk>()?),
            StructType::ClusterDrsMigration => Some(from.as_any_ref().downcast_ref::<ClusterDrsMigration>()?),
            StructType::ClusterDrsRecommendation => Some(from.as_any_ref().downcast_ref::<ClusterDrsRecommendation>()?),
            StructType::ClusterDrsVmConfigInfo => Some(from.as_any_ref().downcast_ref::<ClusterDrsVmConfigInfo>()?),
            StructType::ClusterEvcManagerCheckResult => Some(from.as_any_ref().downcast_ref::<ClusterEvcManagerCheckResult>()?),
            StructType::ClusterEvcManagerEvcState => Some(from.as_any_ref().downcast_ref::<ClusterEvcManagerEvcState>()?),
            StructType::ClusterEnterMaintenanceResult => Some(from.as_any_ref().downcast_ref::<ClusterEnterMaintenanceResult>()?),
            StructType::ClusterFailoverHostAdmissionControlInfoHostStatus => Some(from.as_any_ref().downcast_ref::<ClusterFailoverHostAdmissionControlInfoHostStatus>()?),
            StructType::ClusterGroupInfo => Some(from.as_any_ref().downcast_ref::<ClusterGroupInfo>()?),
            StructType::ClusterHostGroup => Some(from.as_any_ref().downcast_ref::<ClusterHostGroup>()?),
            StructType::ClusterVmGroup => Some(from.as_any_ref().downcast_ref::<ClusterVmGroup>()?),
            StructType::ClusterHostRecommendation => Some(from.as_any_ref().downcast_ref::<ClusterHostRecommendation>()?),
            StructType::ClusterInfraUpdateHaConfigInfo => Some(from.as_any_ref().downcast_ref::<ClusterInfraUpdateHaConfigInfo>()?),
            StructType::ClusterNotAttemptedVmInfo => Some(from.as_any_ref().downcast_ref::<ClusterNotAttemptedVmInfo>()?),
            StructType::ClusterOrchestrationInfo => Some(from.as_any_ref().downcast_ref::<ClusterOrchestrationInfo>()?),
            StructType::PlacementResult => Some(from.as_any_ref().downcast_ref::<PlacementResult>()?),
            StructType::PlacementSpec => Some(from.as_any_ref().downcast_ref::<PlacementSpec>()?),
            StructType::ClusterPowerOnVmResult => Some(from.as_any_ref().downcast_ref::<ClusterPowerOnVmResult>()?),
            StructType::ClusterPreemptibleVmPairInfo => Some(from.as_any_ref().downcast_ref::<ClusterPreemptibleVmPairInfo>()?),
            StructType::ClusterProactiveDrsConfigInfo => Some(from.as_any_ref().downcast_ref::<ClusterProactiveDrsConfigInfo>()?),
            StructType::ClusterRecommendation => Some(from.as_any_ref().downcast_ref::<ClusterRecommendation>()?),
            StructType::ClusterResourceUsageSummary => Some(from.as_any_ref().downcast_ref::<ClusterResourceUsageSummary>()?),
            StructType::ClusterRuleInfo => Some(from.as_any_ref().downcast_ref::<ClusterRuleInfo>()?),
            StructType::ClusterAffinityRuleSpec => Some(from.as_any_ref().downcast_ref::<ClusterAffinityRuleSpec>()?),
            StructType::ClusterAntiAffinityRuleSpec => Some(from.as_any_ref().downcast_ref::<ClusterAntiAffinityRuleSpec>()?),
            StructType::ClusterDependencyRuleInfo => Some(from.as_any_ref().downcast_ref::<ClusterDependencyRuleInfo>()?),
            StructType::ClusterVmHostRuleInfo => Some(from.as_any_ref().downcast_ref::<ClusterVmHostRuleInfo>()?),
            StructType::VirtualDiskAntiAffinityRuleSpec => Some(from.as_any_ref().downcast_ref::<VirtualDiskAntiAffinityRuleSpec>()?),
            StructType::VirtualDiskRuleSpec => Some(from.as_any_ref().downcast_ref::<VirtualDiskRuleSpec>()?),
            StructType::ClusterSlotPolicy => Some(from.as_any_ref().downcast_ref::<ClusterSlotPolicy>()?),
            StructType::ClusterFixedSizeSlotPolicy => Some(from.as_any_ref().downcast_ref::<ClusterFixedSizeSlotPolicy>()?),
            StructType::ClusterSystemVMsConfigInfo => Some(from.as_any_ref().downcast_ref::<ClusterSystemVMsConfigInfo>()?),
            StructType::ClusterSystemVMsConfigSpec => Some(from.as_any_ref().downcast_ref::<ClusterSystemVMsConfigSpec>()?),
            StructType::ClusterUsageSummary => Some(from.as_any_ref().downcast_ref::<ClusterUsageSummary>()?),
            StructType::ClusterVmComponentProtectionSettings => Some(from.as_any_ref().downcast_ref::<ClusterVmComponentProtectionSettings>()?),
            StructType::ClusterVmOrchestrationInfo => Some(from.as_any_ref().downcast_ref::<ClusterVmOrchestrationInfo>()?),
            StructType::ClusterVmReadiness => Some(from.as_any_ref().downcast_ref::<ClusterVmReadiness>()?),
            StructType::ClusterVmToolsMonitoringSettings => Some(from.as_any_ref().downcast_ref::<ClusterVmToolsMonitoringSettings>()?),
            StructType::DistributedVirtualPort => Some(from.as_any_ref().downcast_ref::<DistributedVirtualPort>()?),
            StructType::DvPortConfigInfo => Some(from.as_any_ref().downcast_ref::<DvPortConfigInfo>()?),
            StructType::DvPortConfigSpec => Some(from.as_any_ref().downcast_ref::<DvPortConfigSpec>()?),
            StructType::DvsFilterParameter => Some(from.as_any_ref().downcast_ref::<DvsFilterParameter>()?),
            StructType::DvsHostLocalPortInfo => Some(from.as_any_ref().downcast_ref::<DvsHostLocalPortInfo>()?),
            StructType::DvPortStatus => Some(from.as_any_ref().downcast_ref::<DvPortStatus>()?),
            StructType::DvPortSetting => Some(from.as_any_ref().downcast_ref::<DvPortSetting>()?),
            StructType::VMwareDvsPortSetting => Some(from.as_any_ref().downcast_ref::<VMwareDvsPortSetting>()?),
            StructType::DvPortState => Some(from.as_any_ref().downcast_ref::<DvPortState>()?),
            StructType::DvPortgroupConfigInfo => Some(from.as_any_ref().downcast_ref::<DvPortgroupConfigInfo>()?),
            StructType::DvPortgroupConfigSpec => Some(from.as_any_ref().downcast_ref::<DvPortgroupConfigSpec>()?),
            StructType::DistributedVirtualPortgroupNsxPortgroupOperationResult => Some(from.as_any_ref().downcast_ref::<DistributedVirtualPortgroupNsxPortgroupOperationResult>()?),
            StructType::DvPortgroupPolicy => Some(from.as_any_ref().downcast_ref::<DvPortgroupPolicy>()?),
            StructType::VMwareDvsPortgroupPolicy => Some(from.as_any_ref().downcast_ref::<VMwareDvsPortgroupPolicy>()?),
            StructType::DistributedVirtualPortgroupProblem => Some(from.as_any_ref().downcast_ref::<DistributedVirtualPortgroupProblem>()?),
            StructType::DistributedVirtualPortgroupInfo => Some(from.as_any_ref().downcast_ref::<DistributedVirtualPortgroupInfo>()?),
            StructType::DistributedVirtualSwitchInfo => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchInfo>()?),
            StructType::DistributedVirtualSwitchManagerCompatibilityResult => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchManagerCompatibilityResult>()?),
            StructType::DvsManagerDvsConfigTarget => Some(from.as_any_ref().downcast_ref::<DvsManagerDvsConfigTarget>()?),
            StructType::DistributedVirtualSwitchManagerDvsProductSpec => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchManagerDvsProductSpec>()?),
            StructType::DistributedVirtualSwitchManagerHostContainer => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchManagerHostContainer>()?),
            StructType::DistributedVirtualSwitchManagerHostDvsFilterSpec => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchManagerHostDvsFilterSpec>()?),
            StructType::DistributedVirtualSwitchManagerHostArrayFilter => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchManagerHostArrayFilter>()?),
            StructType::DistributedVirtualSwitchManagerHostContainerFilter => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchManagerHostContainerFilter>()?),
            StructType::DistributedVirtualSwitchManagerHostDvsMembershipFilter => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchManagerHostDvsMembershipFilter>()?),
            StructType::DistributedVirtualSwitchManagerImportResult => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchManagerImportResult>()?),
            StructType::DvsManagerPhysicalNicsList => Some(from.as_any_ref().downcast_ref::<DvsManagerPhysicalNicsList>()?),
            StructType::EntityBackup => Some(from.as_any_ref().downcast_ref::<EntityBackup>()?),
            StructType::EntityBackupConfig => Some(from.as_any_ref().downcast_ref::<EntityBackupConfig>()?),
            StructType::DistributedVirtualSwitchHostMember => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchHostMember>()?),
            StructType::DistributedVirtualSwitchHostMemberBacking => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchHostMemberBacking>()?),
            StructType::DistributedVirtualSwitchHostMemberPnicBacking => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchHostMemberPnicBacking>()?),
            StructType::DistributedVirtualSwitchHostMemberConfigInfo => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchHostMemberConfigInfo>()?),
            StructType::DistributedVirtualSwitchHostMemberConfigSpec => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchHostMemberConfigSpec>()?),
            StructType::HostMemberHealthCheckResult => Some(from.as_any_ref().downcast_ref::<HostMemberHealthCheckResult>()?),
            StructType::HostMemberUplinkHealthCheckResult => Some(from.as_any_ref().downcast_ref::<HostMemberUplinkHealthCheckResult>()?),
            StructType::VMwareDvsMtuHealthCheckResult => Some(from.as_any_ref().downcast_ref::<VMwareDvsMtuHealthCheckResult>()?),
            StructType::VMwareDvsVlanHealthCheckResult => Some(from.as_any_ref().downcast_ref::<VMwareDvsVlanHealthCheckResult>()?),
            StructType::VMwareDvsTeamingHealthCheckResult => Some(from.as_any_ref().downcast_ref::<VMwareDvsTeamingHealthCheckResult>()?),
            StructType::DistributedVirtualSwitchHostMemberPnicSpec => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchHostMemberPnicSpec>()?),
            StructType::HostMemberRuntimeInfo => Some(from.as_any_ref().downcast_ref::<HostMemberRuntimeInfo>()?),
            StructType::DistributedVirtualSwitchHostMemberRuntimeState => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchHostMemberRuntimeState>()?),
            StructType::DistributedVirtualSwitchHostMemberTransportZoneInfo => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchHostMemberTransportZoneInfo>()?),
            StructType::DistributedVirtualSwitchHostProductSpec => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchHostProductSpec>()?),
            StructType::DistributedVirtualSwitchKeyedOpaqueBlob => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchKeyedOpaqueBlob>()?),
            StructType::DistributedVirtualSwitchNetworkOffloadSpec => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchNetworkOffloadSpec>()?),
            StructType::DvsNetworkResourcePool => Some(from.as_any_ref().downcast_ref::<DvsNetworkResourcePool>()?),
            StructType::DvsNetworkResourcePoolAllocationInfo => Some(from.as_any_ref().downcast_ref::<DvsNetworkResourcePoolAllocationInfo>()?),
            StructType::DvsNetworkResourcePoolConfigSpec => Some(from.as_any_ref().downcast_ref::<DvsNetworkResourcePoolConfigSpec>()?),
            StructType::DistributedVirtualSwitchPortConnectee => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchPortConnectee>()?),
            StructType::DistributedVirtualSwitchPortConnection => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchPortConnection>()?),
            StructType::DistributedVirtualSwitchPortCriteria => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchPortCriteria>()?),
            StructType::DistributedVirtualSwitchPortStatistics => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchPortStatistics>()?),
            StructType::DistributedVirtualSwitchProductSpec => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchProductSpec>()?),
            StructType::DvsTrafficRule => Some(from.as_any_ref().downcast_ref::<DvsTrafficRule>()?),
            StructType::DvsNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsNetworkRuleAction>()?),
            StructType::DvsAcceptNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsAcceptNetworkRuleAction>()?),
            StructType::DvsCopyNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsCopyNetworkRuleAction>()?),
            StructType::DvsDropNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsDropNetworkRuleAction>()?),
            StructType::DvsGreEncapNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsGreEncapNetworkRuleAction>()?),
            StructType::DvsLogNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsLogNetworkRuleAction>()?),
            StructType::DvsMacRewriteNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsMacRewriteNetworkRuleAction>()?),
            StructType::DvsPuntNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsPuntNetworkRuleAction>()?),
            StructType::DvsRateLimitNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsRateLimitNetworkRuleAction>()?),
            StructType::DvsUpdateTagNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsUpdateTagNetworkRuleAction>()?),
            StructType::DvsNetworkRuleQualifier => Some(from.as_any_ref().downcast_ref::<DvsNetworkRuleQualifier>()?),
            StructType::DvsIpNetworkRuleQualifier => Some(from.as_any_ref().downcast_ref::<DvsIpNetworkRuleQualifier>()?),
            StructType::DvsMacNetworkRuleQualifier => Some(from.as_any_ref().downcast_ref::<DvsMacNetworkRuleQualifier>()?),
            StructType::DvsSystemTrafficNetworkRuleQualifier => Some(from.as_any_ref().downcast_ref::<DvsSystemTrafficNetworkRuleQualifier>()?),
            StructType::DvsTrafficRuleset => Some(from.as_any_ref().downcast_ref::<DvsTrafficRuleset>()?),
            StructType::DvsVmVnicNetworkResourcePool => Some(from.as_any_ref().downcast_ref::<DvsVmVnicNetworkResourcePool>()?),
            StructType::DvsVmVnicResourcePoolConfigSpec => Some(from.as_any_ref().downcast_ref::<DvsVmVnicResourcePoolConfigSpec>()?),
            StructType::DvsVmVnicResourceAllocation => Some(from.as_any_ref().downcast_ref::<DvsVmVnicResourceAllocation>()?),
            StructType::DvsVmVnicNetworkResourcePoolRuntimeInfo => Some(from.as_any_ref().downcast_ref::<DvsVmVnicNetworkResourcePoolRuntimeInfo>()?),
            StructType::DvsVnicAllocatedResource => Some(from.as_any_ref().downcast_ref::<DvsVnicAllocatedResource>()?),
            StructType::VMwareDvsDpuCapability => Some(from.as_any_ref().downcast_ref::<VMwareDvsDpuCapability>()?),
            StructType::VMwareIpfixConfig => Some(from.as_any_ref().downcast_ref::<VMwareIpfixConfig>()?),
            StructType::VMwareDvsIpfixCapability => Some(from.as_any_ref().downcast_ref::<VMwareDvsIpfixCapability>()?),
            StructType::VMwareDvsLacpCapability => Some(from.as_any_ref().downcast_ref::<VMwareDvsLacpCapability>()?),
            StructType::VMwareDvsLacpGroupConfig => Some(from.as_any_ref().downcast_ref::<VMwareDvsLacpGroupConfig>()?),
            StructType::VMwareDvsLacpGroupSpec => Some(from.as_any_ref().downcast_ref::<VMwareDvsLacpGroupSpec>()?),
            StructType::VMwareDvsLagIpfixConfig => Some(from.as_any_ref().downcast_ref::<VMwareDvsLagIpfixConfig>()?),
            StructType::VMwareDvsLagVlanConfig => Some(from.as_any_ref().downcast_ref::<VMwareDvsLagVlanConfig>()?),
            StructType::VMwareDvsMtuCapability => Some(from.as_any_ref().downcast_ref::<VMwareDvsMtuCapability>()?),
            StructType::VMwareDvsPvlanConfigSpec => Some(from.as_any_ref().downcast_ref::<VMwareDvsPvlanConfigSpec>()?),
            StructType::VMwareDvsPvlanMapEntry => Some(from.as_any_ref().downcast_ref::<VMwareDvsPvlanMapEntry>()?),
            StructType::VMwareDvsVspanConfigSpec => Some(from.as_any_ref().downcast_ref::<VMwareDvsVspanConfigSpec>()?),
            StructType::VMwareDvsVspanCapability => Some(from.as_any_ref().downcast_ref::<VMwareDvsVspanCapability>()?),
            StructType::VMwareVspanPort => Some(from.as_any_ref().downcast_ref::<VMwareVspanPort>()?),
            StructType::VMwareVspanSession => Some(from.as_any_ref().downcast_ref::<VMwareVspanSession>()?),
            StructType::CryptoKeyId => Some(from.as_any_ref().downcast_ref::<CryptoKeyId>()?),
            StructType::CryptoKeyPlain => Some(from.as_any_ref().downcast_ref::<CryptoKeyPlain>()?),
            StructType::CryptoKeyResult => Some(from.as_any_ref().downcast_ref::<CryptoKeyResult>()?),
            StructType::CryptoManagerHostKeyStatus => Some(from.as_any_ref().downcast_ref::<CryptoManagerHostKeyStatus>()?),
            StructType::CryptoManagerKmipCertSignRequest => Some(from.as_any_ref().downcast_ref::<CryptoManagerKmipCertSignRequest>()?),
            StructType::CryptoManagerKmipCertificateInfo => Some(from.as_any_ref().downcast_ref::<CryptoManagerKmipCertificateInfo>()?),
            StructType::CryptoManagerKmipClusterStatus => Some(from.as_any_ref().downcast_ref::<CryptoManagerKmipClusterStatus>()?),
            StructType::CryptoManagerKmipCryptoKeyStatus => Some(from.as_any_ref().downcast_ref::<CryptoManagerKmipCryptoKeyStatus>()?),
            StructType::CryptoManagerKmipCustomAttributeSpec => Some(from.as_any_ref().downcast_ref::<CryptoManagerKmipCustomAttributeSpec>()?),
            StructType::CryptoManagerKmipServerCertInfo => Some(from.as_any_ref().downcast_ref::<CryptoManagerKmipServerCertInfo>()?),
            StructType::CryptoManagerKmipServerStatus => Some(from.as_any_ref().downcast_ref::<CryptoManagerKmipServerStatus>()?),
            StructType::CryptoSpec => Some(from.as_any_ref().downcast_ref::<CryptoSpec>()?),
            StructType::CryptoSpecDecrypt => Some(from.as_any_ref().downcast_ref::<CryptoSpecDecrypt>()?),
            StructType::CryptoSpecDeepRecrypt => Some(from.as_any_ref().downcast_ref::<CryptoSpecDeepRecrypt>()?),
            StructType::CryptoSpecEncrypt => Some(from.as_any_ref().downcast_ref::<CryptoSpecEncrypt>()?),
            StructType::CryptoSpecNoOp => Some(from.as_any_ref().downcast_ref::<CryptoSpecNoOp>()?),
            StructType::CryptoSpecRegister => Some(from.as_any_ref().downcast_ref::<CryptoSpecRegister>()?),
            StructType::CryptoSpecShallowRecrypt => Some(from.as_any_ref().downcast_ref::<CryptoSpecShallowRecrypt>()?),
            StructType::KeyProviderId => Some(from.as_any_ref().downcast_ref::<KeyProviderId>()?),
            StructType::KmipClusterInfo => Some(from.as_any_ref().downcast_ref::<KmipClusterInfo>()?),
            StructType::KmipServerInfo => Some(from.as_any_ref().downcast_ref::<KmipServerInfo>()?),
            StructType::KmipServerSpec => Some(from.as_any_ref().downcast_ref::<KmipServerSpec>()?),
            StructType::KmipServerStatus => Some(from.as_any_ref().downcast_ref::<KmipServerStatus>()?),
            StructType::ChangesInfoEventArgument => Some(from.as_any_ref().downcast_ref::<ChangesInfoEventArgument>()?),
            StructType::DvsOutOfSyncHostArgument => Some(from.as_any_ref().downcast_ref::<DvsOutOfSyncHostArgument>()?),
            StructType::Event => Some(from.as_any_ref().downcast_ref::<Event>()?),
            StructType::EventArgument => Some(from.as_any_ref().downcast_ref::<EventArgument>()?),
            StructType::EntityEventArgument => Some(from.as_any_ref().downcast_ref::<EntityEventArgument>()?),
            StructType::AlarmEventArgument => Some(from.as_any_ref().downcast_ref::<AlarmEventArgument>()?),
            StructType::ComputeResourceEventArgument => Some(from.as_any_ref().downcast_ref::<ComputeResourceEventArgument>()?),
            StructType::DatacenterEventArgument => Some(from.as_any_ref().downcast_ref::<DatacenterEventArgument>()?),
            StructType::DatastoreEventArgument => Some(from.as_any_ref().downcast_ref::<DatastoreEventArgument>()?),
            StructType::DvsEventArgument => Some(from.as_any_ref().downcast_ref::<DvsEventArgument>()?),
            StructType::FolderEventArgument => Some(from.as_any_ref().downcast_ref::<FolderEventArgument>()?),
            StructType::HostEventArgument => Some(from.as_any_ref().downcast_ref::<HostEventArgument>()?),
            StructType::ManagedEntityEventArgument => Some(from.as_any_ref().downcast_ref::<ManagedEntityEventArgument>()?),
            StructType::NetworkEventArgument => Some(from.as_any_ref().downcast_ref::<NetworkEventArgument>()?),
            StructType::ResourcePoolEventArgument => Some(from.as_any_ref().downcast_ref::<ResourcePoolEventArgument>()?),
            StructType::ScheduledTaskEventArgument => Some(from.as_any_ref().downcast_ref::<ScheduledTaskEventArgument>()?),
            StructType::VmEventArgument => Some(from.as_any_ref().downcast_ref::<VmEventArgument>()?),
            StructType::ProfileEventArgument => Some(from.as_any_ref().downcast_ref::<ProfileEventArgument>()?),
            StructType::RoleEventArgument => Some(from.as_any_ref().downcast_ref::<RoleEventArgument>()?),
            StructType::EventDescription => Some(from.as_any_ref().downcast_ref::<EventDescription>()?),
            StructType::EventArgDesc => Some(from.as_any_ref().downcast_ref::<EventArgDesc>()?),
            StructType::EventDescriptionEventDetail => Some(from.as_any_ref().downcast_ref::<EventDescriptionEventDetail>()?),
            StructType::EventFilterSpec => Some(from.as_any_ref().downcast_ref::<EventFilterSpec>()?),
            StructType::EventFilterSpecByEntity => Some(from.as_any_ref().downcast_ref::<EventFilterSpecByEntity>()?),
            StructType::EventFilterSpecByTime => Some(from.as_any_ref().downcast_ref::<EventFilterSpecByTime>()?),
            StructType::EventFilterSpecByUsername => Some(from.as_any_ref().downcast_ref::<EventFilterSpecByUsername>()?),
            StructType::ExtendedEventPair => Some(from.as_any_ref().downcast_ref::<ExtendedEventPair>()?),
            StructType::VnicPortArgument => Some(from.as_any_ref().downcast_ref::<VnicPortArgument>()?),
            StructType::ExtExtendedProductInfo => Some(from.as_any_ref().downcast_ref::<ExtExtendedProductInfo>()?),
            StructType::ManagedByInfo => Some(from.as_any_ref().downcast_ref::<ManagedByInfo>()?),
            StructType::ExtManagedEntityInfo => Some(from.as_any_ref().downcast_ref::<ExtManagedEntityInfo>()?),
            StructType::ExtSolutionManagerInfo => Some(from.as_any_ref().downcast_ref::<ExtSolutionManagerInfo>()?),
            StructType::ExtSolutionManagerInfoTabInfo => Some(from.as_any_ref().downcast_ref::<ExtSolutionManagerInfoTabInfo>()?),
            StructType::AnswerFileUpdateFailure => Some(from.as_any_ref().downcast_ref::<AnswerFileUpdateFailure>()?),
            StructType::ConflictingConfigurationConfig => Some(from.as_any_ref().downcast_ref::<ConflictingConfigurationConfig>()?),
            StructType::DatacenterMismatchArgument => Some(from.as_any_ref().downcast_ref::<DatacenterMismatchArgument>()?),
            StructType::DvsApplyOperationFaultFaultOnObject => Some(from.as_any_ref().downcast_ref::<DvsApplyOperationFaultFaultOnObject>()?),
            StructType::DvsOperationBulkFaultFaultOnHost => Some(from.as_any_ref().downcast_ref::<DvsOperationBulkFaultFaultOnHost>()?),
            StructType::ImportOperationBulkFaultFaultOnImport => Some(from.as_any_ref().downcast_ref::<ImportOperationBulkFaultFaultOnImport>()?),
            StructType::MultipleCertificatesVerifyFaultThumbprintData => Some(from.as_any_ref().downcast_ref::<MultipleCertificatesVerifyFaultThumbprintData>()?),
            StructType::NoPermissionEntityPrivileges => Some(from.as_any_ref().downcast_ref::<NoPermissionEntityPrivileges>()?),
            StructType::ProfileUpdateFailedUpdateFailure => Some(from.as_any_ref().downcast_ref::<ProfileUpdateFailedUpdateFailure>()?),
            StructType::HostActiveDirectory => Some(from.as_any_ref().downcast_ref::<HostActiveDirectory>()?),
            StructType::HostActiveDirectorySpec => Some(from.as_any_ref().downcast_ref::<HostActiveDirectorySpec>()?),
            StructType::HostAssignableHardwareBinding => Some(from.as_any_ref().downcast_ref::<HostAssignableHardwareBinding>()?),
            StructType::HostAssignableHardwareConfig => Some(from.as_any_ref().downcast_ref::<HostAssignableHardwareConfig>()?),
            StructType::HostAssignableHardwareConfigAttributeOverride => Some(from.as_any_ref().downcast_ref::<HostAssignableHardwareConfigAttributeOverride>()?),
            StructType::HostAuthenticationManagerInfo => Some(from.as_any_ref().downcast_ref::<HostAuthenticationManagerInfo>()?),
            StructType::HostAuthenticationStoreInfo => Some(from.as_any_ref().downcast_ref::<HostAuthenticationStoreInfo>()?),
            StructType::HostDirectoryStoreInfo => Some(from.as_any_ref().downcast_ref::<HostDirectoryStoreInfo>()?),
            StructType::HostActiveDirectoryInfo => Some(from.as_any_ref().downcast_ref::<HostActiveDirectoryInfo>()?),
            StructType::HostLocalAuthenticationInfo => Some(from.as_any_ref().downcast_ref::<HostLocalAuthenticationInfo>()?),
            StructType::AutoStartPowerInfo => Some(from.as_any_ref().downcast_ref::<AutoStartPowerInfo>()?),
            StructType::HostAutoStartManagerConfig => Some(from.as_any_ref().downcast_ref::<HostAutoStartManagerConfig>()?),
            StructType::AutoStartDefaults => Some(from.as_any_ref().downcast_ref::<AutoStartDefaults>()?),
            StructType::HostBiosInfo => Some(from.as_any_ref().downcast_ref::<HostBiosInfo>()?),
            StructType::HostBootDeviceInfo => Some(from.as_any_ref().downcast_ref::<HostBootDeviceInfo>()?),
            StructType::HostBootDevice => Some(from.as_any_ref().downcast_ref::<HostBootDevice>()?),
            StructType::HostCacheConfigurationInfo => Some(from.as_any_ref().downcast_ref::<HostCacheConfigurationInfo>()?),
            StructType::HostCacheConfigurationSpec => Some(from.as_any_ref().downcast_ref::<HostCacheConfigurationSpec>()?),
            StructType::HostCapability => Some(from.as_any_ref().downcast_ref::<HostCapability>()?),
            StructType::HostCertificateManagerCertificateInfo => Some(from.as_any_ref().downcast_ref::<HostCertificateManagerCertificateInfo>()?),
            StructType::HostCertificateManagerCertificateSpec => Some(from.as_any_ref().downcast_ref::<HostCertificateManagerCertificateSpec>()?),
            StructType::HostConfigChange => Some(from.as_any_ref().downcast_ref::<HostConfigChange>()?),
            StructType::HostConfigInfo => Some(from.as_any_ref().downcast_ref::<HostConfigInfo>()?),
            StructType::HostConfigManager => Some(from.as_any_ref().downcast_ref::<HostConfigManager>()?),
            StructType::HostConfigSpec => Some(from.as_any_ref().downcast_ref::<HostConfigSpec>()?),
            StructType::HostConnectInfo => Some(from.as_any_ref().downcast_ref::<HostConnectInfo>()?),
            StructType::HostDatastoreConnectInfo => Some(from.as_any_ref().downcast_ref::<HostDatastoreConnectInfo>()?),
            StructType::HostDatastoreExistsConnectInfo => Some(from.as_any_ref().downcast_ref::<HostDatastoreExistsConnectInfo>()?),
            StructType::HostDatastoreNameConflictConnectInfo => Some(from.as_any_ref().downcast_ref::<HostDatastoreNameConflictConnectInfo>()?),
            StructType::HostLicenseConnectInfo => Some(from.as_any_ref().downcast_ref::<HostLicenseConnectInfo>()?),
            StructType::HostConnectInfoNetworkInfo => Some(from.as_any_ref().downcast_ref::<HostConnectInfoNetworkInfo>()?),
            StructType::HostNewNetworkConnectInfo => Some(from.as_any_ref().downcast_ref::<HostNewNetworkConnectInfo>()?),
            StructType::HostConnectSpec => Some(from.as_any_ref().downcast_ref::<HostConnectSpec>()?),
            StructType::HostCpuIdInfo => Some(from.as_any_ref().downcast_ref::<HostCpuIdInfo>()?),
            StructType::HostCpuInfo => Some(from.as_any_ref().downcast_ref::<HostCpuInfo>()?),
            StructType::HostCpuPackage => Some(from.as_any_ref().downcast_ref::<HostCpuPackage>()?),
            StructType::HostCpuPowerManagementInfo => Some(from.as_any_ref().downcast_ref::<HostCpuPowerManagementInfo>()?),
            StructType::HostHyperThreadScheduleInfo => Some(from.as_any_ref().downcast_ref::<HostHyperThreadScheduleInfo>()?),
            StructType::HostDataTransportConnectionInfo => Some(from.as_any_ref().downcast_ref::<HostDataTransportConnectionInfo>()?),
            StructType::HostNfcConnectionInfo => Some(from.as_any_ref().downcast_ref::<HostNfcConnectionInfo>()?),
            StructType::FileInfo => Some(from.as_any_ref().downcast_ref::<FileInfo>()?),
            StructType::FloppyImageFileInfo => Some(from.as_any_ref().downcast_ref::<FloppyImageFileInfo>()?),
            StructType::FolderFileInfo => Some(from.as_any_ref().downcast_ref::<FolderFileInfo>()?),
            StructType::IsoImageFileInfo => Some(from.as_any_ref().downcast_ref::<IsoImageFileInfo>()?),
            StructType::VmConfigFileInfo => Some(from.as_any_ref().downcast_ref::<VmConfigFileInfo>()?),
            StructType::TemplateConfigFileInfo => Some(from.as_any_ref().downcast_ref::<TemplateConfigFileInfo>()?),
            StructType::VmDiskFileInfo => Some(from.as_any_ref().downcast_ref::<VmDiskFileInfo>()?),
            StructType::VmLogFileInfo => Some(from.as_any_ref().downcast_ref::<VmLogFileInfo>()?),
            StructType::VmNvramFileInfo => Some(from.as_any_ref().downcast_ref::<VmNvramFileInfo>()?),
            StructType::VmSnapshotFileInfo => Some(from.as_any_ref().downcast_ref::<VmSnapshotFileInfo>()?),
            StructType::FileQueryFlags => Some(from.as_any_ref().downcast_ref::<FileQueryFlags>()?),
            StructType::FileQuery => Some(from.as_any_ref().downcast_ref::<FileQuery>()?),
            StructType::FloppyImageFileQuery => Some(from.as_any_ref().downcast_ref::<FloppyImageFileQuery>()?),
            StructType::FolderFileQuery => Some(from.as_any_ref().downcast_ref::<FolderFileQuery>()?),
            StructType::IsoImageFileQuery => Some(from.as_any_ref().downcast_ref::<IsoImageFileQuery>()?),
            StructType::VmConfigFileQuery => Some(from.as_any_ref().downcast_ref::<VmConfigFileQuery>()?),
            StructType::TemplateConfigFileQuery => Some(from.as_any_ref().downcast_ref::<TemplateConfigFileQuery>()?),
            StructType::VmDiskFileQuery => Some(from.as_any_ref().downcast_ref::<VmDiskFileQuery>()?),
            StructType::VmLogFileQuery => Some(from.as_any_ref().downcast_ref::<VmLogFileQuery>()?),
            StructType::VmNvramFileQuery => Some(from.as_any_ref().downcast_ref::<VmNvramFileQuery>()?),
            StructType::VmSnapshotFileQuery => Some(from.as_any_ref().downcast_ref::<VmSnapshotFileQuery>()?),
            StructType::HostDatastoreBrowserSearchResults => Some(from.as_any_ref().downcast_ref::<HostDatastoreBrowserSearchResults>()?),
            StructType::HostDatastoreBrowserSearchSpec => Some(from.as_any_ref().downcast_ref::<HostDatastoreBrowserSearchSpec>()?),
            StructType::VmConfigFileEncryptionInfo => Some(from.as_any_ref().downcast_ref::<VmConfigFileEncryptionInfo>()?),
            StructType::VmConfigFileQueryFlags => Some(from.as_any_ref().downcast_ref::<VmConfigFileQueryFlags>()?),
            StructType::VmConfigFileQueryFilter => Some(from.as_any_ref().downcast_ref::<VmConfigFileQueryFilter>()?),
            StructType::VmDiskFileEncryptionInfo => Some(from.as_any_ref().downcast_ref::<VmDiskFileEncryptionInfo>()?),
            StructType::VmDiskFileQueryFlags => Some(from.as_any_ref().downcast_ref::<VmDiskFileQueryFlags>()?),
            StructType::VmDiskFileQueryFilter => Some(from.as_any_ref().downcast_ref::<VmDiskFileQueryFilter>()?),
            StructType::HostDatastoreSystemCapabilities => Some(from.as_any_ref().downcast_ref::<HostDatastoreSystemCapabilities>()?),
            StructType::HostDatastoreSystemDatastoreResult => Some(from.as_any_ref().downcast_ref::<HostDatastoreSystemDatastoreResult>()?),
            StructType::HostDatastoreSystemVvolDatastoreSpec => Some(from.as_any_ref().downcast_ref::<HostDatastoreSystemVvolDatastoreSpec>()?),
            StructType::HostDateTimeConfig => Some(from.as_any_ref().downcast_ref::<HostDateTimeConfig>()?),
            StructType::HostDateTimeInfo => Some(from.as_any_ref().downcast_ref::<HostDateTimeInfo>()?),
            StructType::HostDateTimeSystemServiceTestResult => Some(from.as_any_ref().downcast_ref::<HostDateTimeSystemServiceTestResult>()?),
            StructType::HostDateTimeSystemTimeZone => Some(from.as_any_ref().downcast_ref::<HostDateTimeSystemTimeZone>()?),
            StructType::HostDeploymentInfo => Some(from.as_any_ref().downcast_ref::<HostDeploymentInfo>()?),
            StructType::HostDevice => Some(from.as_any_ref().downcast_ref::<HostDevice>()?),
            StructType::ScsiLun => Some(from.as_any_ref().downcast_ref::<ScsiLun>()?),
            StructType::HostScsiDisk => Some(from.as_any_ref().downcast_ref::<HostScsiDisk>()?),
            StructType::HostDhcpService => Some(from.as_any_ref().downcast_ref::<HostDhcpService>()?),
            StructType::HostDhcpServiceConfig => Some(from.as_any_ref().downcast_ref::<HostDhcpServiceConfig>()?),
            StructType::HostDhcpServiceSpec => Some(from.as_any_ref().downcast_ref::<HostDhcpServiceSpec>()?),
            StructType::HostDiagnosticPartition => Some(from.as_any_ref().downcast_ref::<HostDiagnosticPartition>()?),
            StructType::HostDiagnosticPartitionCreateDescription => Some(from.as_any_ref().downcast_ref::<HostDiagnosticPartitionCreateDescription>()?),
            StructType::HostDiagnosticPartitionCreateOption => Some(from.as_any_ref().downcast_ref::<HostDiagnosticPartitionCreateOption>()?),
            StructType::HostDiagnosticPartitionCreateSpec => Some(from.as_any_ref().downcast_ref::<HostDiagnosticPartitionCreateSpec>()?),
            StructType::HostDigestInfo => Some(from.as_any_ref().downcast_ref::<HostDigestInfo>()?),
            StructType::HostTpmDigestInfo => Some(from.as_any_ref().downcast_ref::<HostTpmDigestInfo>()?),
            StructType::HostDiskConfigurationResult => Some(from.as_any_ref().downcast_ref::<HostDiskConfigurationResult>()?),
            StructType::HostDiskDimensions => Some(from.as_any_ref().downcast_ref::<HostDiskDimensions>()?),
            StructType::HostDiskDimensionsChs => Some(from.as_any_ref().downcast_ref::<HostDiskDimensionsChs>()?),
            StructType::HostDiskDimensionsLba => Some(from.as_any_ref().downcast_ref::<HostDiskDimensionsLba>()?),
            StructType::HostDiskPartitionInfo => Some(from.as_any_ref().downcast_ref::<HostDiskPartitionInfo>()?),
            StructType::HostDiskPartitionBlockRange => Some(from.as_any_ref().downcast_ref::<HostDiskPartitionBlockRange>()?),
            StructType::HostDiskPartitionLayout => Some(from.as_any_ref().downcast_ref::<HostDiskPartitionLayout>()?),
            StructType::HostDiskPartitionAttributes => Some(from.as_any_ref().downcast_ref::<HostDiskPartitionAttributes>()?),
            StructType::HostDiskPartitionSpec => Some(from.as_any_ref().downcast_ref::<HostDiskPartitionSpec>()?),
            StructType::HostDnsConfig => Some(from.as_any_ref().downcast_ref::<HostDnsConfig>()?),
            StructType::HostDnsConfigSpec => Some(from.as_any_ref().downcast_ref::<HostDnsConfigSpec>()?),
            StructType::HostDvxClass => Some(from.as_any_ref().downcast_ref::<HostDvxClass>()?),
            StructType::HostEnterMaintenanceResult => Some(from.as_any_ref().downcast_ref::<HostEnterMaintenanceResult>()?),
            StructType::HostEsxAgentHostManagerConfigInfo => Some(from.as_any_ref().downcast_ref::<HostEsxAgentHostManagerConfigInfo>()?),
            StructType::HostFaultToleranceManagerComponentHealthInfo => Some(from.as_any_ref().downcast_ref::<HostFaultToleranceManagerComponentHealthInfo>()?),
            StructType::FcoeConfig => Some(from.as_any_ref().downcast_ref::<FcoeConfig>()?),
            StructType::FcoeConfigFcoeCapabilities => Some(from.as_any_ref().downcast_ref::<FcoeConfigFcoeCapabilities>()?),
            StructType::FcoeConfigFcoeSpecification => Some(from.as_any_ref().downcast_ref::<FcoeConfigFcoeSpecification>()?),
            StructType::FcoeConfigVlanRange => Some(from.as_any_ref().downcast_ref::<FcoeConfigVlanRange>()?),
            StructType::HostFeatureCapability => Some(from.as_any_ref().downcast_ref::<HostFeatureCapability>()?),
            StructType::HostFeatureMask => Some(from.as_any_ref().downcast_ref::<HostFeatureMask>()?),
            StructType::HostFeatureVersionInfo => Some(from.as_any_ref().downcast_ref::<HostFeatureVersionInfo>()?),
            StructType::HostFibreChannelOverEthernetHbaLinkInfo => Some(from.as_any_ref().downcast_ref::<HostFibreChannelOverEthernetHbaLinkInfo>()?),
            StructType::HostFileAccess => Some(from.as_any_ref().downcast_ref::<HostFileAccess>()?),
            StructType::ModeInfo => Some(from.as_any_ref().downcast_ref::<ModeInfo>()?),
            StructType::HostFileSystemMountInfo => Some(from.as_any_ref().downcast_ref::<HostFileSystemMountInfo>()?),
            StructType::HostFileSystemVolume => Some(from.as_any_ref().downcast_ref::<HostFileSystemVolume>()?),
            StructType::HostLocalFileSystemVolume => Some(from.as_any_ref().downcast_ref::<HostLocalFileSystemVolume>()?),
            StructType::HostNasVolume => Some(from.as_any_ref().downcast_ref::<HostNasVolume>()?),
            StructType::HostPMemVolume => Some(from.as_any_ref().downcast_ref::<HostPMemVolume>()?),
            StructType::HostVfatVolume => Some(from.as_any_ref().downcast_ref::<HostVfatVolume>()?),
            StructType::HostVffsVolume => Some(from.as_any_ref().downcast_ref::<HostVffsVolume>()?),
            StructType::HostVmfsVolume => Some(from.as_any_ref().downcast_ref::<HostVmfsVolume>()?),
            StructType::HostVvolVolume => Some(from.as_any_ref().downcast_ref::<HostVvolVolume>()?),
            StructType::HostFileSystemVolumeInfo => Some(from.as_any_ref().downcast_ref::<HostFileSystemVolumeInfo>()?),
            StructType::HostFirewallConfig => Some(from.as_any_ref().downcast_ref::<HostFirewallConfig>()?),
            StructType::HostFirewallConfigRuleSetConfig => Some(from.as_any_ref().downcast_ref::<HostFirewallConfigRuleSetConfig>()?),
            StructType::HostFirewallInfo => Some(from.as_any_ref().downcast_ref::<HostFirewallInfo>()?),
            StructType::HostFirewallDefaultPolicy => Some(from.as_any_ref().downcast_ref::<HostFirewallDefaultPolicy>()?),
            StructType::HostFlagInfo => Some(from.as_any_ref().downcast_ref::<HostFlagInfo>()?),
            StructType::HostForceMountedInfo => Some(from.as_any_ref().downcast_ref::<HostForceMountedInfo>()?),
            StructType::HostFru => Some(from.as_any_ref().downcast_ref::<HostFru>()?),
            StructType::HostGatewaySpec => Some(from.as_any_ref().downcast_ref::<HostGatewaySpec>()?),
            StructType::HostGraphicsConfig => Some(from.as_any_ref().downcast_ref::<HostGraphicsConfig>()?),
            StructType::HostGraphicsConfigDeviceType => Some(from.as_any_ref().downcast_ref::<HostGraphicsConfigDeviceType>()?),
            StructType::HostGraphicsInfo => Some(from.as_any_ref().downcast_ref::<HostGraphicsInfo>()?),
            StructType::HostHardwareInfo => Some(from.as_any_ref().downcast_ref::<HostHardwareInfo>()?),
            StructType::HostHardwareStatusInfo => Some(from.as_any_ref().downcast_ref::<HostHardwareStatusInfo>()?),
            StructType::DpuStatusInfoOperationalInfo => Some(from.as_any_ref().downcast_ref::<DpuStatusInfoOperationalInfo>()?),
            StructType::HostHardwareElementInfo => Some(from.as_any_ref().downcast_ref::<HostHardwareElementInfo>()?),
            StructType::DpuStatusInfo => Some(from.as_any_ref().downcast_ref::<DpuStatusInfo>()?),
            StructType::HostStorageElementInfo => Some(from.as_any_ref().downcast_ref::<HostStorageElementInfo>()?),
            StructType::HostStorageOperationalInfo => Some(from.as_any_ref().downcast_ref::<HostStorageOperationalInfo>()?),
            StructType::HostHbaCreateSpec => Some(from.as_any_ref().downcast_ref::<HostHbaCreateSpec>()?),
            StructType::HostTcpHbaCreateSpec => Some(from.as_any_ref().downcast_ref::<HostTcpHbaCreateSpec>()?),
            StructType::HealthSystemRuntime => Some(from.as_any_ref().downcast_ref::<HealthSystemRuntime>()?),
            StructType::HostAccessControlEntry => Some(from.as_any_ref().downcast_ref::<HostAccessControlEntry>()?),
            StructType::HostHostBusAdapter => Some(from.as_any_ref().downcast_ref::<HostHostBusAdapter>()?),
            StructType::HostBlockHba => Some(from.as_any_ref().downcast_ref::<HostBlockHba>()?),
            StructType::HostFibreChannelHba => Some(from.as_any_ref().downcast_ref::<HostFibreChannelHba>()?),
            StructType::HostFibreChannelOverEthernetHba => Some(from.as_any_ref().downcast_ref::<HostFibreChannelOverEthernetHba>()?),
            StructType::HostInternetScsiHba => Some(from.as_any_ref().downcast_ref::<HostInternetScsiHba>()?),
            StructType::HostParallelScsiHba => Some(from.as_any_ref().downcast_ref::<HostParallelScsiHba>()?),
            StructType::HostPcieHba => Some(from.as_any_ref().downcast_ref::<HostPcieHba>()?),
            StructType::HostRdmaHba => Some(from.as_any_ref().downcast_ref::<HostRdmaHba>()?),
            StructType::HostSerialAttachedHba => Some(from.as_any_ref().downcast_ref::<HostSerialAttachedHba>()?),
            StructType::HostTcpHba => Some(from.as_any_ref().downcast_ref::<HostTcpHba>()?),
            StructType::HostProxySwitch => Some(from.as_any_ref().downcast_ref::<HostProxySwitch>()?),
            StructType::HostProxySwitchConfig => Some(from.as_any_ref().downcast_ref::<HostProxySwitchConfig>()?),
            StructType::HostProxySwitchEnsInfo => Some(from.as_any_ref().downcast_ref::<HostProxySwitchEnsInfo>()?),
            StructType::HostProxySwitchHostLagConfig => Some(from.as_any_ref().downcast_ref::<HostProxySwitchHostLagConfig>()?),
            StructType::HostProxySwitchSpec => Some(from.as_any_ref().downcast_ref::<HostProxySwitchSpec>()?),
            StructType::HostImageProfileSummary => Some(from.as_any_ref().downcast_ref::<HostImageProfileSummary>()?),
            StructType::HostInternetScsiHbaAuthenticationCapabilities => Some(from.as_any_ref().downcast_ref::<HostInternetScsiHbaAuthenticationCapabilities>()?),
            StructType::HostInternetScsiHbaAuthenticationProperties => Some(from.as_any_ref().downcast_ref::<HostInternetScsiHbaAuthenticationProperties>()?),
            StructType::HostInternetScsiHbaDigestCapabilities => Some(from.as_any_ref().downcast_ref::<HostInternetScsiHbaDigestCapabilities>()?),
            StructType::HostInternetScsiHbaDigestProperties => Some(from.as_any_ref().downcast_ref::<HostInternetScsiHbaDigestProperties>()?),
            StructType::HostInternetScsiHbaDiscoveryCapabilities => Some(from.as_any_ref().downcast_ref::<HostInternetScsiHbaDiscoveryCapabilities>()?),
            StructType::HostInternetScsiHbaDiscoveryProperties => Some(from.as_any_ref().downcast_ref::<HostInternetScsiHbaDiscoveryProperties>()?),
            StructType::HostInternetScsiHbaIpCapabilities => Some(from.as_any_ref().downcast_ref::<HostInternetScsiHbaIpCapabilities>()?),
            StructType::HostInternetScsiHbaIpProperties => Some(from.as_any_ref().downcast_ref::<HostInternetScsiHbaIpProperties>()?),
            StructType::HostInternetScsiHbaIPv6Properties => Some(from.as_any_ref().downcast_ref::<HostInternetScsiHbaIPv6Properties>()?),
            StructType::HostInternetScsiHbaIscsiIpv6Address => Some(from.as_any_ref().downcast_ref::<HostInternetScsiHbaIscsiIpv6Address>()?),
            StructType::HostInternetScsiHbaSendTarget => Some(from.as_any_ref().downcast_ref::<HostInternetScsiHbaSendTarget>()?),
            StructType::HostInternetScsiHbaStaticTarget => Some(from.as_any_ref().downcast_ref::<HostInternetScsiHbaStaticTarget>()?),
            StructType::HostInternetScsiHbaTargetSet => Some(from.as_any_ref().downcast_ref::<HostInternetScsiHbaTargetSet>()?),
            StructType::HostIpConfig => Some(from.as_any_ref().downcast_ref::<HostIpConfig>()?),
            StructType::HostIpConfigIpV6Address => Some(from.as_any_ref().downcast_ref::<HostIpConfigIpV6Address>()?),
            StructType::HostIpConfigIpV6AddressConfiguration => Some(from.as_any_ref().downcast_ref::<HostIpConfigIpV6AddressConfiguration>()?),
            StructType::HostIpRouteConfig => Some(from.as_any_ref().downcast_ref::<HostIpRouteConfig>()?),
            StructType::HostIpRouteConfigSpec => Some(from.as_any_ref().downcast_ref::<HostIpRouteConfigSpec>()?),
            StructType::HostIpRouteEntry => Some(from.as_any_ref().downcast_ref::<HostIpRouteEntry>()?),
            StructType::HostIpRouteOp => Some(from.as_any_ref().downcast_ref::<HostIpRouteOp>()?),
            StructType::HostIpRouteTableConfig => Some(from.as_any_ref().downcast_ref::<HostIpRouteTableConfig>()?),
            StructType::HostIpRouteTableInfo => Some(from.as_any_ref().downcast_ref::<HostIpRouteTableInfo>()?),
            StructType::HostIpmiInfo => Some(from.as_any_ref().downcast_ref::<HostIpmiInfo>()?),
            StructType::IscsiDependencyEntity => Some(from.as_any_ref().downcast_ref::<IscsiDependencyEntity>()?),
            StructType::IscsiMigrationDependency => Some(from.as_any_ref().downcast_ref::<IscsiMigrationDependency>()?),
            StructType::IscsiPortInfo => Some(from.as_any_ref().downcast_ref::<IscsiPortInfo>()?),
            StructType::IscsiStatus => Some(from.as_any_ref().downcast_ref::<IscsiStatus>()?),
            StructType::KernelModuleInfo => Some(from.as_any_ref().downcast_ref::<KernelModuleInfo>()?),
            StructType::KernelModuleSectionInfo => Some(from.as_any_ref().downcast_ref::<KernelModuleSectionInfo>()?),
            StructType::HostLicenseSpec => Some(from.as_any_ref().downcast_ref::<HostLicenseSpec>()?),
            StructType::LinkDiscoveryProtocolConfig => Some(from.as_any_ref().downcast_ref::<LinkDiscoveryProtocolConfig>()?),
            StructType::HostAccountSpec => Some(from.as_any_ref().downcast_ref::<HostAccountSpec>()?),
            StructType::HostPosixAccountSpec => Some(from.as_any_ref().downcast_ref::<HostPosixAccountSpec>()?),
            StructType::HostLocalFileSystemVolumeSpec => Some(from.as_any_ref().downcast_ref::<HostLocalFileSystemVolumeSpec>()?),
            StructType::HostLowLevelProvisioningManagerDiskLayoutSpec => Some(from.as_any_ref().downcast_ref::<HostLowLevelProvisioningManagerDiskLayoutSpec>()?),
            StructType::HostLowLevelProvisioningManagerFileDeleteResult => Some(from.as_any_ref().downcast_ref::<HostLowLevelProvisioningManagerFileDeleteResult>()?),
            StructType::HostLowLevelProvisioningManagerFileDeleteSpec => Some(from.as_any_ref().downcast_ref::<HostLowLevelProvisioningManagerFileDeleteSpec>()?),
            StructType::HostLowLevelProvisioningManagerFileReserveResult => Some(from.as_any_ref().downcast_ref::<HostLowLevelProvisioningManagerFileReserveResult>()?),
            StructType::HostLowLevelProvisioningManagerFileReserveSpec => Some(from.as_any_ref().downcast_ref::<HostLowLevelProvisioningManagerFileReserveSpec>()?),
            StructType::HostLowLevelProvisioningManagerSnapshotLayoutSpec => Some(from.as_any_ref().downcast_ref::<HostLowLevelProvisioningManagerSnapshotLayoutSpec>()?),
            StructType::HostLowLevelProvisioningManagerVmMigrationStatus => Some(from.as_any_ref().downcast_ref::<HostLowLevelProvisioningManagerVmMigrationStatus>()?),
            StructType::HostLowLevelProvisioningManagerVmRecoveryInfo => Some(from.as_any_ref().downcast_ref::<HostLowLevelProvisioningManagerVmRecoveryInfo>()?),
            StructType::HostMaintenanceSpec => Some(from.as_any_ref().downcast_ref::<HostMaintenanceSpec>()?),
            StructType::ServiceConsoleReservationInfo => Some(from.as_any_ref().downcast_ref::<ServiceConsoleReservationInfo>()?),
            StructType::VirtualMachineMemoryReservationInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineMemoryReservationInfo>()?),
            StructType::VirtualMachineMemoryReservationSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineMemoryReservationSpec>()?),
            StructType::HostMemorySpec => Some(from.as_any_ref().downcast_ref::<HostMemorySpec>()?),
            StructType::HostMemoryTierInfo => Some(from.as_any_ref().downcast_ref::<HostMemoryTierInfo>()?),
            StructType::HostMountInfo => Some(from.as_any_ref().downcast_ref::<HostMountInfo>()?),
            StructType::HostMultipathInfo => Some(from.as_any_ref().downcast_ref::<HostMultipathInfo>()?),
            StructType::HostMultipathInfoLogicalUnit => Some(from.as_any_ref().downcast_ref::<HostMultipathInfoLogicalUnit>()?),
            StructType::HostMultipathInfoLogicalUnitPolicy => Some(from.as_any_ref().downcast_ref::<HostMultipathInfoLogicalUnitPolicy>()?),
            StructType::HostMultipathInfoFixedLogicalUnitPolicy => Some(from.as_any_ref().downcast_ref::<HostMultipathInfoFixedLogicalUnitPolicy>()?),
            StructType::HostMultipathInfoHppLogicalUnitPolicy => Some(from.as_any_ref().downcast_ref::<HostMultipathInfoHppLogicalUnitPolicy>()?),
            StructType::HostMultipathInfoLogicalUnitStorageArrayTypePolicy => Some(from.as_any_ref().downcast_ref::<HostMultipathInfoLogicalUnitStorageArrayTypePolicy>()?),
            StructType::HostMultipathInfoPath => Some(from.as_any_ref().downcast_ref::<HostMultipathInfoPath>()?),
            StructType::HostMultipathStateInfo => Some(from.as_any_ref().downcast_ref::<HostMultipathStateInfo>()?),
            StructType::HostMultipathStateInfoPath => Some(from.as_any_ref().downcast_ref::<HostMultipathStateInfoPath>()?),
            StructType::HostNasVolumeConfig => Some(from.as_any_ref().downcast_ref::<HostNasVolumeConfig>()?),
            StructType::HostNasVolumeSpec => Some(from.as_any_ref().downcast_ref::<HostNasVolumeSpec>()?),
            StructType::HostNasVolumeUserInfo => Some(from.as_any_ref().downcast_ref::<HostNasVolumeUserInfo>()?),
            StructType::HostNatService => Some(from.as_any_ref().downcast_ref::<HostNatService>()?),
            StructType::HostNatServiceConfig => Some(from.as_any_ref().downcast_ref::<HostNatServiceConfig>()?),
            StructType::HostNatServiceNameServiceSpec => Some(from.as_any_ref().downcast_ref::<HostNatServiceNameServiceSpec>()?),
            StructType::HostNatServicePortForwardSpec => Some(from.as_any_ref().downcast_ref::<HostNatServicePortForwardSpec>()?),
            StructType::HostNatServiceSpec => Some(from.as_any_ref().downcast_ref::<HostNatServiceSpec>()?),
            StructType::HostNetCapabilities => Some(from.as_any_ref().downcast_ref::<HostNetCapabilities>()?),
            StructType::HostNetOffloadCapabilities => Some(from.as_any_ref().downcast_ref::<HostNetOffloadCapabilities>()?),
            StructType::HostNetStackInstance => Some(from.as_any_ref().downcast_ref::<HostNetStackInstance>()?),
            StructType::HostNetworkConfig => Some(from.as_any_ref().downcast_ref::<HostNetworkConfig>()?),
            StructType::HostNetworkConfigNetStackSpec => Some(from.as_any_ref().downcast_ref::<HostNetworkConfigNetStackSpec>()?),
            StructType::HostNetworkConfigResult => Some(from.as_any_ref().downcast_ref::<HostNetworkConfigResult>()?),
            StructType::HostNetworkInfo => Some(from.as_any_ref().downcast_ref::<HostNetworkInfo>()?),
            StructType::HostNetworkPolicy => Some(from.as_any_ref().downcast_ref::<HostNetworkPolicy>()?),
            StructType::HostNicFailureCriteria => Some(from.as_any_ref().downcast_ref::<HostNicFailureCriteria>()?),
            StructType::HostNicOrderPolicy => Some(from.as_any_ref().downcast_ref::<HostNicOrderPolicy>()?),
            StructType::HostNicTeamingPolicy => Some(from.as_any_ref().downcast_ref::<HostNicTeamingPolicy>()?),
            StructType::HostNetworkSecurityPolicy => Some(from.as_any_ref().downcast_ref::<HostNetworkSecurityPolicy>()?),
            StructType::HostNetworkTrafficShapingPolicy => Some(from.as_any_ref().downcast_ref::<HostNetworkTrafficShapingPolicy>()?),
            StructType::HostNtpConfig => Some(from.as_any_ref().downcast_ref::<HostNtpConfig>()?),
            StructType::HostNumaInfo => Some(from.as_any_ref().downcast_ref::<HostNumaInfo>()?),
            StructType::HostNumaNode => Some(from.as_any_ref().downcast_ref::<HostNumaNode>()?),
            StructType::HostNumericSensorInfo => Some(from.as_any_ref().downcast_ref::<HostNumericSensorInfo>()?),
            StructType::NvdimmDimmInfo => Some(from.as_any_ref().downcast_ref::<NvdimmDimmInfo>()?),
            StructType::NvdimmGuid => Some(from.as_any_ref().downcast_ref::<NvdimmGuid>()?),
            StructType::NvdimmHealthInfo => Some(from.as_any_ref().downcast_ref::<NvdimmHealthInfo>()?),
            StructType::NvdimmInterleaveSetInfo => Some(from.as_any_ref().downcast_ref::<NvdimmInterleaveSetInfo>()?),
            StructType::NvdimmNamespaceCreateSpec => Some(from.as_any_ref().downcast_ref::<NvdimmNamespaceCreateSpec>()?),
            StructType::NvdimmNamespaceDeleteSpec => Some(from.as_any_ref().downcast_ref::<NvdimmNamespaceDeleteSpec>()?),
            StructType::NvdimmNamespaceDetails => Some(from.as_any_ref().downcast_ref::<NvdimmNamespaceDetails>()?),
            StructType::NvdimmNamespaceInfo => Some(from.as_any_ref().downcast_ref::<NvdimmNamespaceInfo>()?),
            StructType::NvdimmSystemInfo => Some(from.as_any_ref().downcast_ref::<NvdimmSystemInfo>()?),
            StructType::NvdimmPMemNamespaceCreateSpec => Some(from.as_any_ref().downcast_ref::<NvdimmPMemNamespaceCreateSpec>()?),
            StructType::NvdimmRegionInfo => Some(from.as_any_ref().downcast_ref::<NvdimmRegionInfo>()?),
            StructType::NvdimmSummary => Some(from.as_any_ref().downcast_ref::<NvdimmSummary>()?),
            StructType::HostNvmeController => Some(from.as_any_ref().downcast_ref::<HostNvmeController>()?),
            StructType::HostNvmeDisconnectSpec => Some(from.as_any_ref().downcast_ref::<HostNvmeDisconnectSpec>()?),
            StructType::HostNvmeDiscoveryLog => Some(from.as_any_ref().downcast_ref::<HostNvmeDiscoveryLog>()?),
            StructType::HostNvmeDiscoveryLogEntry => Some(from.as_any_ref().downcast_ref::<HostNvmeDiscoveryLogEntry>()?),
            StructType::HostNvmeNamespace => Some(from.as_any_ref().downcast_ref::<HostNvmeNamespace>()?),
            StructType::HostNvmeSpec => Some(from.as_any_ref().downcast_ref::<HostNvmeSpec>()?),
            StructType::HostNvmeConnectSpec => Some(from.as_any_ref().downcast_ref::<HostNvmeConnectSpec>()?),
            StructType::HostNvmeDiscoverSpec => Some(from.as_any_ref().downcast_ref::<HostNvmeDiscoverSpec>()?),
            StructType::HostNvmeTopology => Some(from.as_any_ref().downcast_ref::<HostNvmeTopology>()?),
            StructType::HostNvmeTopologyInterface => Some(from.as_any_ref().downcast_ref::<HostNvmeTopologyInterface>()?),
            StructType::HostNvmeTransportParameters => Some(from.as_any_ref().downcast_ref::<HostNvmeTransportParameters>()?),
            StructType::HostNvmeOpaqueTransportParameters => Some(from.as_any_ref().downcast_ref::<HostNvmeOpaqueTransportParameters>()?),
            StructType::HostNvmeOverFibreChannelParameters => Some(from.as_any_ref().downcast_ref::<HostNvmeOverFibreChannelParameters>()?),
            StructType::HostNvmeOverRdmaParameters => Some(from.as_any_ref().downcast_ref::<HostNvmeOverRdmaParameters>()?),
            StructType::HostNvmeOverTcpParameters => Some(from.as_any_ref().downcast_ref::<HostNvmeOverTcpParameters>()?),
            StructType::HostOpaqueNetworkInfo => Some(from.as_any_ref().downcast_ref::<HostOpaqueNetworkInfo>()?),
            StructType::HostOpaqueSwitch => Some(from.as_any_ref().downcast_ref::<HostOpaqueSwitch>()?),
            StructType::HostOpaqueSwitchPhysicalNicZone => Some(from.as_any_ref().downcast_ref::<HostOpaqueSwitchPhysicalNicZone>()?),
            StructType::HostPatchManagerLocator => Some(from.as_any_ref().downcast_ref::<HostPatchManagerLocator>()?),
            StructType::HostPatchManagerPatchManagerOperationSpec => Some(from.as_any_ref().downcast_ref::<HostPatchManagerPatchManagerOperationSpec>()?),
            StructType::HostPatchManagerResult => Some(from.as_any_ref().downcast_ref::<HostPatchManagerResult>()?),
            StructType::HostPatchManagerStatus => Some(from.as_any_ref().downcast_ref::<HostPatchManagerStatus>()?),
            StructType::HostPatchManagerStatusPrerequisitePatch => Some(from.as_any_ref().downcast_ref::<HostPatchManagerStatusPrerequisitePatch>()?),
            StructType::HostPathSelectionPolicyOption => Some(from.as_any_ref().downcast_ref::<HostPathSelectionPolicyOption>()?),
            StructType::HostPciDevice => Some(from.as_any_ref().downcast_ref::<HostPciDevice>()?),
            StructType::HostPciPassthruConfig => Some(from.as_any_ref().downcast_ref::<HostPciPassthruConfig>()?),
            StructType::HostSriovConfig => Some(from.as_any_ref().downcast_ref::<HostSriovConfig>()?),
            StructType::HostPciPassthruInfo => Some(from.as_any_ref().downcast_ref::<HostPciPassthruInfo>()?),
            StructType::HostSriovInfo => Some(from.as_any_ref().downcast_ref::<HostSriovInfo>()?),
            StructType::HostPersistentMemoryInfo => Some(from.as_any_ref().downcast_ref::<HostPersistentMemoryInfo>()?),
            StructType::PhysicalNic => Some(from.as_any_ref().downcast_ref::<PhysicalNic>()?),
            StructType::PhysicalNicCdpDeviceCapability => Some(from.as_any_ref().downcast_ref::<PhysicalNicCdpDeviceCapability>()?),
            StructType::PhysicalNicCdpInfo => Some(from.as_any_ref().downcast_ref::<PhysicalNicCdpInfo>()?),
            StructType::PhysicalNicConfig => Some(from.as_any_ref().downcast_ref::<PhysicalNicConfig>()?),
            StructType::PhysicalNicLinkInfo => Some(from.as_any_ref().downcast_ref::<PhysicalNicLinkInfo>()?),
            StructType::LinkLayerDiscoveryProtocolInfo => Some(from.as_any_ref().downcast_ref::<LinkLayerDiscoveryProtocolInfo>()?),
            StructType::PhysicalNicHintInfo => Some(from.as_any_ref().downcast_ref::<PhysicalNicHintInfo>()?),
            StructType::PhysicalNicHint => Some(from.as_any_ref().downcast_ref::<PhysicalNicHint>()?),
            StructType::PhysicalNicIpHint => Some(from.as_any_ref().downcast_ref::<PhysicalNicIpHint>()?),
            StructType::PhysicalNicNameHint => Some(from.as_any_ref().downcast_ref::<PhysicalNicNameHint>()?),
            StructType::PhysicalNicSpec => Some(from.as_any_ref().downcast_ref::<PhysicalNicSpec>()?),
            StructType::HostPlugStoreTopology => Some(from.as_any_ref().downcast_ref::<HostPlugStoreTopology>()?),
            StructType::HostPlugStoreTopologyAdapter => Some(from.as_any_ref().downcast_ref::<HostPlugStoreTopologyAdapter>()?),
            StructType::HostPlugStoreTopologyDevice => Some(from.as_any_ref().downcast_ref::<HostPlugStoreTopologyDevice>()?),
            StructType::HostPlugStoreTopologyPath => Some(from.as_any_ref().downcast_ref::<HostPlugStoreTopologyPath>()?),
            StructType::HostPlugStoreTopologyPlugin => Some(from.as_any_ref().downcast_ref::<HostPlugStoreTopologyPlugin>()?),
            StructType::HostPlugStoreTopologyTarget => Some(from.as_any_ref().downcast_ref::<HostPlugStoreTopologyTarget>()?),
            StructType::HostPortGroup => Some(from.as_any_ref().downcast_ref::<HostPortGroup>()?),
            StructType::HostPortGroupConfig => Some(from.as_any_ref().downcast_ref::<HostPortGroupConfig>()?),
            StructType::HostPortGroupPort => Some(from.as_any_ref().downcast_ref::<HostPortGroupPort>()?),
            StructType::HostPortGroupSpec => Some(from.as_any_ref().downcast_ref::<HostPortGroupSpec>()?),
            StructType::PowerSystemCapability => Some(from.as_any_ref().downcast_ref::<PowerSystemCapability>()?),
            StructType::PowerSystemInfo => Some(from.as_any_ref().downcast_ref::<PowerSystemInfo>()?),
            StructType::HostPowerPolicy => Some(from.as_any_ref().downcast_ref::<HostPowerPolicy>()?),
            StructType::HostProtocolEndpoint => Some(from.as_any_ref().downcast_ref::<HostProtocolEndpoint>()?),
            StructType::HostPtpConfig => Some(from.as_any_ref().downcast_ref::<HostPtpConfig>()?),
            StructType::HostPtpConfigPtpPort => Some(from.as_any_ref().downcast_ref::<HostPtpConfigPtpPort>()?),
            StructType::HostQualifiedName => Some(from.as_any_ref().downcast_ref::<HostQualifiedName>()?),
            StructType::HostRdmaDevice => Some(from.as_any_ref().downcast_ref::<HostRdmaDevice>()?),
            StructType::HostRdmaDeviceBacking => Some(from.as_any_ref().downcast_ref::<HostRdmaDeviceBacking>()?),
            StructType::HostRdmaDevicePnicBacking => Some(from.as_any_ref().downcast_ref::<HostRdmaDevicePnicBacking>()?),
            StructType::HostRdmaDeviceCapability => Some(from.as_any_ref().downcast_ref::<HostRdmaDeviceCapability>()?),
            StructType::HostRdmaDeviceConnectionInfo => Some(from.as_any_ref().downcast_ref::<HostRdmaDeviceConnectionInfo>()?),
            StructType::HostReliableMemoryInfo => Some(from.as_any_ref().downcast_ref::<HostReliableMemoryInfo>()?),
            StructType::HostResignatureRescanResult => Some(from.as_any_ref().downcast_ref::<HostResignatureRescanResult>()?),
            StructType::HostFirewallRuleset => Some(from.as_any_ref().downcast_ref::<HostFirewallRuleset>()?),
            StructType::HostFirewallRulesetIpList => Some(from.as_any_ref().downcast_ref::<HostFirewallRulesetIpList>()?),
            StructType::HostFirewallRulesetIpNetwork => Some(from.as_any_ref().downcast_ref::<HostFirewallRulesetIpNetwork>()?),
            StructType::HostFirewallRule => Some(from.as_any_ref().downcast_ref::<HostFirewallRule>()?),
            StructType::HostFirewallRulesetRulesetSpec => Some(from.as_any_ref().downcast_ref::<HostFirewallRulesetRulesetSpec>()?),
            StructType::HostRuntimeInfo => Some(from.as_any_ref().downcast_ref::<HostRuntimeInfo>()?),
            StructType::HostRuntimeInfoNetStackInstanceRuntimeInfo => Some(from.as_any_ref().downcast_ref::<HostRuntimeInfoNetStackInstanceRuntimeInfo>()?),
            StructType::HostNetworkResourceRuntime => Some(from.as_any_ref().downcast_ref::<HostNetworkResourceRuntime>()?),
            StructType::HostRuntimeInfoNetworkRuntimeInfo => Some(from.as_any_ref().downcast_ref::<HostRuntimeInfoNetworkRuntimeInfo>()?),
            StructType::HostPlacedVirtualNicIdentifier => Some(from.as_any_ref().downcast_ref::<HostPlacedVirtualNicIdentifier>()?),
            StructType::HostPnicNetworkResourceInfo => Some(from.as_any_ref().downcast_ref::<HostPnicNetworkResourceInfo>()?),
            StructType::HostRuntimeInfoStateEncryptionInfo => Some(from.as_any_ref().downcast_ref::<HostRuntimeInfoStateEncryptionInfo>()?),
            StructType::HostScsiDiskPartition => Some(from.as_any_ref().downcast_ref::<HostScsiDiskPartition>()?),
            StructType::ScsiLunCapabilities => Some(from.as_any_ref().downcast_ref::<ScsiLunCapabilities>()?),
            StructType::ScsiLunDescriptor => Some(from.as_any_ref().downcast_ref::<ScsiLunDescriptor>()?),
            StructType::ScsiLunDurableName => Some(from.as_any_ref().downcast_ref::<ScsiLunDurableName>()?),
            StructType::HostScsiTopology => Some(from.as_any_ref().downcast_ref::<HostScsiTopology>()?),
            StructType::HostScsiTopologyInterface => Some(from.as_any_ref().downcast_ref::<HostScsiTopologyInterface>()?),
            StructType::HostScsiTopologyLun => Some(from.as_any_ref().downcast_ref::<HostScsiTopologyLun>()?),
            StructType::HostScsiTopologyTarget => Some(from.as_any_ref().downcast_ref::<HostScsiTopologyTarget>()?),
            StructType::HostSecuritySpec => Some(from.as_any_ref().downcast_ref::<HostSecuritySpec>()?),
            StructType::HostService => Some(from.as_any_ref().downcast_ref::<HostService>()?),
            StructType::HostServiceSourcePackage => Some(from.as_any_ref().downcast_ref::<HostServiceSourcePackage>()?),
            StructType::HostServiceConfig => Some(from.as_any_ref().downcast_ref::<HostServiceConfig>()?),
            StructType::HostServiceInfo => Some(from.as_any_ref().downcast_ref::<HostServiceInfo>()?),
            StructType::HostSevInfo => Some(from.as_any_ref().downcast_ref::<HostSevInfo>()?),
            StructType::HostSgxInfo => Some(from.as_any_ref().downcast_ref::<HostSgxInfo>()?),
            StructType::HostSgxRegistrationInfo => Some(from.as_any_ref().downcast_ref::<HostSgxRegistrationInfo>()?),
            StructType::HostSharedGpuCapabilities => Some(from.as_any_ref().downcast_ref::<HostSharedGpuCapabilities>()?),
            StructType::HostSnmpSystemAgentLimits => Some(from.as_any_ref().downcast_ref::<HostSnmpSystemAgentLimits>()?),
            StructType::HostSnmpConfigSpec => Some(from.as_any_ref().downcast_ref::<HostSnmpConfigSpec>()?),
            StructType::HostSnmpDestination => Some(from.as_any_ref().downcast_ref::<HostSnmpDestination>()?),
            StructType::SoftwarePackage => Some(from.as_any_ref().downcast_ref::<SoftwarePackage>()?),
            StructType::SoftwarePackageCapability => Some(from.as_any_ref().downcast_ref::<SoftwarePackageCapability>()?),
            StructType::Relation => Some(from.as_any_ref().downcast_ref::<Relation>()?),
            StructType::HostSriovDevicePoolInfo => Some(from.as_any_ref().downcast_ref::<HostSriovDevicePoolInfo>()?),
            StructType::HostSriovNetworkDevicePoolInfo => Some(from.as_any_ref().downcast_ref::<HostSriovNetworkDevicePoolInfo>()?),
            StructType::HostSslThumbprintInfo => Some(from.as_any_ref().downcast_ref::<HostSslThumbprintInfo>()?),
            StructType::HostStorageArrayTypePolicyOption => Some(from.as_any_ref().downcast_ref::<HostStorageArrayTypePolicyOption>()?),
            StructType::HostStorageDeviceInfo => Some(from.as_any_ref().downcast_ref::<HostStorageDeviceInfo>()?),
            StructType::HostStorageSystemDiskLocatorLedResult => Some(from.as_any_ref().downcast_ref::<HostStorageSystemDiskLocatorLedResult>()?),
            StructType::HostStorageSystemScsiLunResult => Some(from.as_any_ref().downcast_ref::<HostStorageSystemScsiLunResult>()?),
            StructType::HostStorageSystemVmfsVolumeResult => Some(from.as_any_ref().downcast_ref::<HostStorageSystemVmfsVolumeResult>()?),
            StructType::HostListSummary => Some(from.as_any_ref().downcast_ref::<HostListSummary>()?),
            StructType::HostConfigSummary => Some(from.as_any_ref().downcast_ref::<HostConfigSummary>()?),
            StructType::HostListSummaryGatewaySummary => Some(from.as_any_ref().downcast_ref::<HostListSummaryGatewaySummary>()?),
            StructType::HostHardwareSummary => Some(from.as_any_ref().downcast_ref::<HostHardwareSummary>()?),
            StructType::HostListSummaryQuickStats => Some(from.as_any_ref().downcast_ref::<HostListSummaryQuickStats>()?),
            StructType::SystemEventInfo => Some(from.as_any_ref().downcast_ref::<SystemEventInfo>()?),
            StructType::HostSystemHealthInfo => Some(from.as_any_ref().downcast_ref::<HostSystemHealthInfo>()?),
            StructType::HostSystemIdentificationInfo => Some(from.as_any_ref().downcast_ref::<HostSystemIdentificationInfo>()?),
            StructType::HostSystemInfo => Some(from.as_any_ref().downcast_ref::<HostSystemInfo>()?),
            StructType::HostSystemResourceInfo => Some(from.as_any_ref().downcast_ref::<HostSystemResourceInfo>()?),
            StructType::HostSystemSwapConfiguration => Some(from.as_any_ref().downcast_ref::<HostSystemSwapConfiguration>()?),
            StructType::HostSystemSwapConfigurationSystemSwapOption => Some(from.as_any_ref().downcast_ref::<HostSystemSwapConfigurationSystemSwapOption>()?),
            StructType::HostSystemSwapConfigurationDatastoreOption => Some(from.as_any_ref().downcast_ref::<HostSystemSwapConfigurationDatastoreOption>()?),
            StructType::HostSystemSwapConfigurationDisabledOption => Some(from.as_any_ref().downcast_ref::<HostSystemSwapConfigurationDisabledOption>()?),
            StructType::HostSystemSwapConfigurationHostCacheOption => Some(from.as_any_ref().downcast_ref::<HostSystemSwapConfigurationHostCacheOption>()?),
            StructType::HostSystemSwapConfigurationHostLocalSwapOption => Some(from.as_any_ref().downcast_ref::<HostSystemSwapConfigurationHostLocalSwapOption>()?),
            StructType::HostTargetTransport => Some(from.as_any_ref().downcast_ref::<HostTargetTransport>()?),
            StructType::HostBlockAdapterTargetTransport => Some(from.as_any_ref().downcast_ref::<HostBlockAdapterTargetTransport>()?),
            StructType::HostFibreChannelTargetTransport => Some(from.as_any_ref().downcast_ref::<HostFibreChannelTargetTransport>()?),
            StructType::HostFibreChannelOverEthernetTargetTransport => Some(from.as_any_ref().downcast_ref::<HostFibreChannelOverEthernetTargetTransport>()?),
            StructType::HostInternetScsiTargetTransport => Some(from.as_any_ref().downcast_ref::<HostInternetScsiTargetTransport>()?),
            StructType::HostParallelScsiTargetTransport => Some(from.as_any_ref().downcast_ref::<HostParallelScsiTargetTransport>()?),
            StructType::HostPcieTargetTransport => Some(from.as_any_ref().downcast_ref::<HostPcieTargetTransport>()?),
            StructType::HostRdmaTargetTransport => Some(from.as_any_ref().downcast_ref::<HostRdmaTargetTransport>()?),
            StructType::HostSerialAttachedTargetTransport => Some(from.as_any_ref().downcast_ref::<HostSerialAttachedTargetTransport>()?),
            StructType::HostTcpTargetTransport => Some(from.as_any_ref().downcast_ref::<HostTcpTargetTransport>()?),
            StructType::HostTpmAttestationInfo => Some(from.as_any_ref().downcast_ref::<HostTpmAttestationInfo>()?),
            StructType::HostTpmAttestationReport => Some(from.as_any_ref().downcast_ref::<HostTpmAttestationReport>()?),
            StructType::HostTpmEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmEventDetails>()?),
            StructType::HostTpmBootCompleteEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmBootCompleteEventDetails>()?),
            StructType::HostTpmBootSecurityOptionEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmBootSecurityOptionEventDetails>()?),
            StructType::HostTpmNvTagEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmNvTagEventDetails>()?),
            StructType::HostTpmSignerEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmSignerEventDetails>()?),
            StructType::HostTpmCommandEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmCommandEventDetails>()?),
            StructType::HostTpmOptionEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmOptionEventDetails>()?),
            StructType::HostTpmSoftwareComponentEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmSoftwareComponentEventDetails>()?),
            StructType::HostTpmVersionEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmVersionEventDetails>()?),
            StructType::HostTpmEventLogEntry => Some(from.as_any_ref().downcast_ref::<HostTpmEventLogEntry>()?),
            StructType::HostTrustAuthorityAttestationInfo => Some(from.as_any_ref().downcast_ref::<HostTrustAuthorityAttestationInfo>()?),
            StructType::HostUnresolvedVmfsExtent => Some(from.as_any_ref().downcast_ref::<HostUnresolvedVmfsExtent>()?),
            StructType::HostUnresolvedVmfsResignatureSpec => Some(from.as_any_ref().downcast_ref::<HostUnresolvedVmfsResignatureSpec>()?),
            StructType::HostUnresolvedVmfsResolutionResult => Some(from.as_any_ref().downcast_ref::<HostUnresolvedVmfsResolutionResult>()?),
            StructType::HostUnresolvedVmfsResolutionSpec => Some(from.as_any_ref().downcast_ref::<HostUnresolvedVmfsResolutionSpec>()?),
            StructType::HostUnresolvedVmfsVolume => Some(from.as_any_ref().downcast_ref::<HostUnresolvedVmfsVolume>()?),
            StructType::HostUnresolvedVmfsVolumeResolveStatus => Some(from.as_any_ref().downcast_ref::<HostUnresolvedVmfsVolumeResolveStatus>()?),
            StructType::HostVFlashManagerVFlashCacheConfigInfo => Some(from.as_any_ref().downcast_ref::<HostVFlashManagerVFlashCacheConfigInfo>()?),
            StructType::HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption => Some(from.as_any_ref().downcast_ref::<HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption>()?),
            StructType::HostVFlashManagerVFlashCacheConfigSpec => Some(from.as_any_ref().downcast_ref::<HostVFlashManagerVFlashCacheConfigSpec>()?),
            StructType::HostVFlashManagerVFlashConfigInfo => Some(from.as_any_ref().downcast_ref::<HostVFlashManagerVFlashConfigInfo>()?),
            StructType::HostVFlashManagerVFlashResourceConfigInfo => Some(from.as_any_ref().downcast_ref::<HostVFlashManagerVFlashResourceConfigInfo>()?),
            StructType::HostVFlashManagerVFlashResourceConfigSpec => Some(from.as_any_ref().downcast_ref::<HostVFlashManagerVFlashResourceConfigSpec>()?),
            StructType::HostVFlashManagerVFlashResourceRunTimeInfo => Some(from.as_any_ref().downcast_ref::<HostVFlashManagerVFlashResourceRunTimeInfo>()?),
            StructType::HostVFlashResourceConfigurationResult => Some(from.as_any_ref().downcast_ref::<HostVFlashResourceConfigurationResult>()?),
            StructType::HostVMotionConfig => Some(from.as_any_ref().downcast_ref::<HostVMotionConfig>()?),
            StructType::HostVMotionInfo => Some(from.as_any_ref().downcast_ref::<HostVMotionInfo>()?),
            StructType::HostVMotionManagerDstInstantCloneResult => Some(from.as_any_ref().downcast_ref::<HostVMotionManagerDstInstantCloneResult>()?),
            StructType::HostVMotionManagerSrcInstantCloneResult => Some(from.as_any_ref().downcast_ref::<HostVMotionManagerSrcInstantCloneResult>()?),
            StructType::HostVMotionNetConfig => Some(from.as_any_ref().downcast_ref::<HostVMotionNetConfig>()?),
            StructType::HostVffsSpec => Some(from.as_any_ref().downcast_ref::<HostVffsSpec>()?),
            StructType::HostVirtualNic => Some(from.as_any_ref().downcast_ref::<HostVirtualNic>()?),
            StructType::HostVirtualNicConfig => Some(from.as_any_ref().downcast_ref::<HostVirtualNicConfig>()?),
            StructType::HostVirtualNicIpRouteSpec => Some(from.as_any_ref().downcast_ref::<HostVirtualNicIpRouteSpec>()?),
            StructType::HostVirtualNicOpaqueNetworkSpec => Some(from.as_any_ref().downcast_ref::<HostVirtualNicOpaqueNetworkSpec>()?),
            StructType::HostVirtualNicSpec => Some(from.as_any_ref().downcast_ref::<HostVirtualNicSpec>()?),
            StructType::HostVirtualNicConnection => Some(from.as_any_ref().downcast_ref::<HostVirtualNicConnection>()?),
            StructType::VirtualNicManagerNetConfig => Some(from.as_any_ref().downcast_ref::<VirtualNicManagerNetConfig>()?),
            StructType::HostVirtualNicManagerNicTypeSelection => Some(from.as_any_ref().downcast_ref::<HostVirtualNicManagerNicTypeSelection>()?),
            StructType::HostVirtualNicManagerInfo => Some(from.as_any_ref().downcast_ref::<HostVirtualNicManagerInfo>()?),
            StructType::HostVirtualSwitch => Some(from.as_any_ref().downcast_ref::<HostVirtualSwitch>()?),
            StructType::HostVirtualSwitchBeaconConfig => Some(from.as_any_ref().downcast_ref::<HostVirtualSwitchBeaconConfig>()?),
            StructType::HostVirtualSwitchBridge => Some(from.as_any_ref().downcast_ref::<HostVirtualSwitchBridge>()?),
            StructType::HostVirtualSwitchAutoBridge => Some(from.as_any_ref().downcast_ref::<HostVirtualSwitchAutoBridge>()?),
            StructType::HostVirtualSwitchBondBridge => Some(from.as_any_ref().downcast_ref::<HostVirtualSwitchBondBridge>()?),
            StructType::HostVirtualSwitchSimpleBridge => Some(from.as_any_ref().downcast_ref::<HostVirtualSwitchSimpleBridge>()?),
            StructType::HostVirtualSwitchConfig => Some(from.as_any_ref().downcast_ref::<HostVirtualSwitchConfig>()?),
            StructType::HostVirtualSwitchSpec => Some(from.as_any_ref().downcast_ref::<HostVirtualSwitchSpec>()?),
            StructType::HostVmciAccessManagerAccessSpec => Some(from.as_any_ref().downcast_ref::<HostVmciAccessManagerAccessSpec>()?),
            StructType::VmfsDatastoreOption => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreOption>()?),
            StructType::VmfsDatastoreBaseOption => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreBaseOption>()?),
            StructType::VmfsDatastoreMultipleExtentOption => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreMultipleExtentOption>()?),
            StructType::VmfsDatastoreSingleExtentOption => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreSingleExtentOption>()?),
            StructType::VmfsDatastoreAllExtentOption => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreAllExtentOption>()?),
            StructType::VmfsDatastoreSpec => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreSpec>()?),
            StructType::VmfsDatastoreCreateSpec => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreCreateSpec>()?),
            StructType::VmfsDatastoreExpandSpec => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreExpandSpec>()?),
            StructType::VmfsDatastoreExtendSpec => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreExtendSpec>()?),
            StructType::HostVmfsRescanResult => Some(from.as_any_ref().downcast_ref::<HostVmfsRescanResult>()?),
            StructType::VmfsConfigOption => Some(from.as_any_ref().downcast_ref::<VmfsConfigOption>()?),
            StructType::HostVmfsSpec => Some(from.as_any_ref().downcast_ref::<HostVmfsSpec>()?),
            StructType::VmfsUnmapBandwidthSpec => Some(from.as_any_ref().downcast_ref::<VmfsUnmapBandwidthSpec>()?),
            StructType::HostVsanInternalSystemCmmdsQuery => Some(from.as_any_ref().downcast_ref::<HostVsanInternalSystemCmmdsQuery>()?),
            StructType::HostVsanInternalSystemDeleteVsanObjectsResult => Some(from.as_any_ref().downcast_ref::<HostVsanInternalSystemDeleteVsanObjectsResult>()?),
            StructType::VsanNewPolicyBatch => Some(from.as_any_ref().downcast_ref::<VsanNewPolicyBatch>()?),
            StructType::VsanPolicyChangeBatch => Some(from.as_any_ref().downcast_ref::<VsanPolicyChangeBatch>()?),
            StructType::VsanPolicyCost => Some(from.as_any_ref().downcast_ref::<VsanPolicyCost>()?),
            StructType::VsanPolicySatisfiability => Some(from.as_any_ref().downcast_ref::<VsanPolicySatisfiability>()?),
            StructType::HostVsanInternalSystemVsanObjectOperationResult => Some(from.as_any_ref().downcast_ref::<HostVsanInternalSystemVsanObjectOperationResult>()?),
            StructType::HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult => Some(from.as_any_ref().downcast_ref::<HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult>()?),
            StructType::HostVvolNqn => Some(from.as_any_ref().downcast_ref::<HostVvolNqn>()?),
            StructType::VVolHostPe => Some(from.as_any_ref().downcast_ref::<VVolHostPe>()?),
            StructType::HostVvolVolumeHostVvolNqn => Some(from.as_any_ref().downcast_ref::<HostVvolVolumeHostVvolNqn>()?),
            StructType::HostVvolVolumeSpecification => Some(from.as_any_ref().downcast_ref::<HostVvolVolumeSpecification>()?),
            StructType::NetDhcpConfigInfo => Some(from.as_any_ref().downcast_ref::<NetDhcpConfigInfo>()?),
            StructType::NetDhcpConfigInfoDhcpOptions => Some(from.as_any_ref().downcast_ref::<NetDhcpConfigInfoDhcpOptions>()?),
            StructType::NetDhcpConfigSpec => Some(from.as_any_ref().downcast_ref::<NetDhcpConfigSpec>()?),
            StructType::NetDhcpConfigSpecDhcpOptionsSpec => Some(from.as_any_ref().downcast_ref::<NetDhcpConfigSpecDhcpOptionsSpec>()?),
            StructType::NetDnsConfigInfo => Some(from.as_any_ref().downcast_ref::<NetDnsConfigInfo>()?),
            StructType::NetDnsConfigSpec => Some(from.as_any_ref().downcast_ref::<NetDnsConfigSpec>()?),
            StructType::NetIpConfigInfo => Some(from.as_any_ref().downcast_ref::<NetIpConfigInfo>()?),
            StructType::NetIpConfigInfoIpAddress => Some(from.as_any_ref().downcast_ref::<NetIpConfigInfoIpAddress>()?),
            StructType::NetIpConfigSpec => Some(from.as_any_ref().downcast_ref::<NetIpConfigSpec>()?),
            StructType::NetIpConfigSpecIpAddressSpec => Some(from.as_any_ref().downcast_ref::<NetIpConfigSpecIpAddressSpec>()?),
            StructType::NetIpRouteConfigInfo => Some(from.as_any_ref().downcast_ref::<NetIpRouteConfigInfo>()?),
            StructType::NetIpRouteConfigInfoGateway => Some(from.as_any_ref().downcast_ref::<NetIpRouteConfigInfoGateway>()?),
            StructType::NetIpRouteConfigInfoIpRoute => Some(from.as_any_ref().downcast_ref::<NetIpRouteConfigInfoIpRoute>()?),
            StructType::NetIpRouteConfigSpec => Some(from.as_any_ref().downcast_ref::<NetIpRouteConfigSpec>()?),
            StructType::NetIpRouteConfigSpecGatewaySpec => Some(from.as_any_ref().downcast_ref::<NetIpRouteConfigSpecGatewaySpec>()?),
            StructType::NetIpRouteConfigSpecIpRouteSpec => Some(from.as_any_ref().downcast_ref::<NetIpRouteConfigSpecIpRouteSpec>()?),
            StructType::NetIpStackInfo => Some(from.as_any_ref().downcast_ref::<NetIpStackInfo>()?),
            StructType::NetIpStackInfoDefaultRouter => Some(from.as_any_ref().downcast_ref::<NetIpStackInfoDefaultRouter>()?),
            StructType::NetIpStackInfoNetToMedia => Some(from.as_any_ref().downcast_ref::<NetIpStackInfoNetToMedia>()?),
            StructType::NetBiosConfigInfo => Some(from.as_any_ref().downcast_ref::<NetBiosConfigInfo>()?),
            StructType::WinNetBiosConfigInfo => Some(from.as_any_ref().downcast_ref::<WinNetBiosConfigInfo>()?),
            StructType::ArrayUpdateSpec => Some(from.as_any_ref().downcast_ref::<ArrayUpdateSpec>()?),
            StructType::ClusterDasVmConfigSpec => Some(from.as_any_ref().downcast_ref::<ClusterDasVmConfigSpec>()?),
            StructType::ClusterDatastoreUpdateSpec => Some(from.as_any_ref().downcast_ref::<ClusterDatastoreUpdateSpec>()?),
            StructType::ClusterDpmHostConfigSpec => Some(from.as_any_ref().downcast_ref::<ClusterDpmHostConfigSpec>()?),
            StructType::ClusterDrsVmConfigSpec => Some(from.as_any_ref().downcast_ref::<ClusterDrsVmConfigSpec>()?),
            StructType::ClusterGroupSpec => Some(from.as_any_ref().downcast_ref::<ClusterGroupSpec>()?),
            StructType::ClusterPreemptibleVmPairSpec => Some(from.as_any_ref().downcast_ref::<ClusterPreemptibleVmPairSpec>()?),
            StructType::ClusterRuleSpec => Some(from.as_any_ref().downcast_ref::<ClusterRuleSpec>()?),
            StructType::ClusterTagCategoryUpdateSpec => Some(from.as_any_ref().downcast_ref::<ClusterTagCategoryUpdateSpec>()?),
            StructType::ClusterVmOrchestrationSpec => Some(from.as_any_ref().downcast_ref::<ClusterVmOrchestrationSpec>()?),
            StructType::StorageDrsOptionSpec => Some(from.as_any_ref().downcast_ref::<StorageDrsOptionSpec>()?),
            StructType::StorageDrsVmConfigSpec => Some(from.as_any_ref().downcast_ref::<StorageDrsVmConfigSpec>()?),
            StructType::VAppOvfSectionSpec => Some(from.as_any_ref().downcast_ref::<VAppOvfSectionSpec>()?),
            StructType::VAppProductSpec => Some(from.as_any_ref().downcast_ref::<VAppProductSpec>()?),
            StructType::VAppPropertySpec => Some(from.as_any_ref().downcast_ref::<VAppPropertySpec>()?),
            StructType::VirtualMachineCpuIdInfoSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineCpuIdInfoSpec>()?),
            StructType::OptionType => Some(from.as_any_ref().downcast_ref::<OptionType>()?),
            StructType::BoolOption => Some(from.as_any_ref().downcast_ref::<BoolOption>()?),
            StructType::ChoiceOption => Some(from.as_any_ref().downcast_ref::<ChoiceOption>()?),
            StructType::FloatOption => Some(from.as_any_ref().downcast_ref::<FloatOption>()?),
            StructType::IntOption => Some(from.as_any_ref().downcast_ref::<IntOption>()?),
            StructType::LongOption => Some(from.as_any_ref().downcast_ref::<LongOption>()?),
            StructType::StringOption => Some(from.as_any_ref().downcast_ref::<StringOption>()?),
            StructType::OptionValue => Some(from.as_any_ref().downcast_ref::<OptionValue>()?),
            StructType::HostInternetScsiHbaParamValue => Some(from.as_any_ref().downcast_ref::<HostInternetScsiHbaParamValue>()?),
            StructType::ApplyProfile => Some(from.as_any_ref().downcast_ref::<ApplyProfile>()?),
            StructType::ProfileApplyProfileElement => Some(from.as_any_ref().downcast_ref::<ProfileApplyProfileElement>()?),
            StructType::ActiveDirectoryProfile => Some(from.as_any_ref().downcast_ref::<ActiveDirectoryProfile>()?),
            StructType::AuthenticationProfile => Some(from.as_any_ref().downcast_ref::<AuthenticationProfile>()?),
            StructType::DateTimeProfile => Some(from.as_any_ref().downcast_ref::<DateTimeProfile>()?),
            StructType::DvsProfile => Some(from.as_any_ref().downcast_ref::<DvsProfile>()?),
            StructType::DvsVNicProfile => Some(from.as_any_ref().downcast_ref::<DvsVNicProfile>()?),
            StructType::DvsHostVNicProfile => Some(from.as_any_ref().downcast_ref::<DvsHostVNicProfile>()?),
            StructType::DvsServiceConsoleVNicProfile => Some(from.as_any_ref().downcast_ref::<DvsServiceConsoleVNicProfile>()?),
            StructType::FirewallProfile => Some(from.as_any_ref().downcast_ref::<FirewallProfile>()?),
            StructType::FirewallProfileRulesetProfile => Some(from.as_any_ref().downcast_ref::<FirewallProfileRulesetProfile>()?),
            StructType::HostApplyProfile => Some(from.as_any_ref().downcast_ref::<HostApplyProfile>()?),
            StructType::HostMemoryProfile => Some(from.as_any_ref().downcast_ref::<HostMemoryProfile>()?),
            StructType::IpAddressProfile => Some(from.as_any_ref().downcast_ref::<IpAddressProfile>()?),
            StructType::IpRouteProfile => Some(from.as_any_ref().downcast_ref::<IpRouteProfile>()?),
            StructType::NasStorageProfile => Some(from.as_any_ref().downcast_ref::<NasStorageProfile>()?),
            StructType::NetStackInstanceProfile => Some(from.as_any_ref().downcast_ref::<NetStackInstanceProfile>()?),
            StructType::NetworkPolicyProfile => Some(from.as_any_ref().downcast_ref::<NetworkPolicyProfile>()?),
            StructType::NetworkProfile => Some(from.as_any_ref().downcast_ref::<NetworkProfile>()?),
            StructType::NetworkProfileDnsConfigProfile => Some(from.as_any_ref().downcast_ref::<NetworkProfileDnsConfigProfile>()?),
            StructType::NsxHostVNicProfile => Some(from.as_any_ref().downcast_ref::<NsxHostVNicProfile>()?),
            StructType::OpaqueSwitchProfile => Some(from.as_any_ref().downcast_ref::<OpaqueSwitchProfile>()?),
            StructType::OptionProfile => Some(from.as_any_ref().downcast_ref::<OptionProfile>()?),
            StructType::PermissionProfile => Some(from.as_any_ref().downcast_ref::<PermissionProfile>()?),
            StructType::PhysicalNicProfile => Some(from.as_any_ref().downcast_ref::<PhysicalNicProfile>()?),
            StructType::PnicUplinkProfile => Some(from.as_any_ref().downcast_ref::<PnicUplinkProfile>()?),
            StructType::PortGroupProfile => Some(from.as_any_ref().downcast_ref::<PortGroupProfile>()?),
            StructType::HostPortGroupProfile => Some(from.as_any_ref().downcast_ref::<HostPortGroupProfile>()?),
            StructType::ServiceConsolePortGroupProfile => Some(from.as_any_ref().downcast_ref::<ServiceConsolePortGroupProfile>()?),
            StructType::VmPortGroupProfile => Some(from.as_any_ref().downcast_ref::<VmPortGroupProfile>()?),
            StructType::VirtualSwitchSelectionProfile => Some(from.as_any_ref().downcast_ref::<VirtualSwitchSelectionProfile>()?),
            StructType::VlanProfile => Some(from.as_any_ref().downcast_ref::<VlanProfile>()?),
            StructType::SecurityProfile => Some(from.as_any_ref().downcast_ref::<SecurityProfile>()?),
            StructType::ServiceProfile => Some(from.as_any_ref().downcast_ref::<ServiceProfile>()?),
            StructType::StaticRouteProfile => Some(from.as_any_ref().downcast_ref::<StaticRouteProfile>()?),
            StructType::StorageProfile => Some(from.as_any_ref().downcast_ref::<StorageProfile>()?),
            StructType::UserGroupProfile => Some(from.as_any_ref().downcast_ref::<UserGroupProfile>()?),
            StructType::UserProfile => Some(from.as_any_ref().downcast_ref::<UserProfile>()?),
            StructType::VirtualSwitchProfile => Some(from.as_any_ref().downcast_ref::<VirtualSwitchProfile>()?),
            StructType::LinkProfile => Some(from.as_any_ref().downcast_ref::<LinkProfile>()?),
            StructType::NumPortsProfile => Some(from.as_any_ref().downcast_ref::<NumPortsProfile>()?),
            StructType::ProfileApplyProfileProperty => Some(from.as_any_ref().downcast_ref::<ProfileApplyProfileProperty>()?),
            StructType::ComplianceLocator => Some(from.as_any_ref().downcast_ref::<ComplianceLocator>()?),
            StructType::ComplianceProfile => Some(from.as_any_ref().downcast_ref::<ComplianceProfile>()?),
            StructType::ComplianceResult => Some(from.as_any_ref().downcast_ref::<ComplianceResult>()?),
            StructType::ComplianceFailure => Some(from.as_any_ref().downcast_ref::<ComplianceFailure>()?),
            StructType::ComplianceFailureComplianceFailureValues => Some(from.as_any_ref().downcast_ref::<ComplianceFailureComplianceFailureValues>()?),
            StructType::ProfileDeferredPolicyOptionParameter => Some(from.as_any_ref().downcast_ref::<ProfileDeferredPolicyOptionParameter>()?),
            StructType::ProfileExpression => Some(from.as_any_ref().downcast_ref::<ProfileExpression>()?),
            StructType::ProfileCompositeExpression => Some(from.as_any_ref().downcast_ref::<ProfileCompositeExpression>()?),
            StructType::ProfileSimpleExpression => Some(from.as_any_ref().downcast_ref::<ProfileSimpleExpression>()?),
            StructType::ProfileExpressionMetadata => Some(from.as_any_ref().downcast_ref::<ProfileExpressionMetadata>()?),
            StructType::ProfileParameterMetadata => Some(from.as_any_ref().downcast_ref::<ProfileParameterMetadata>()?),
            StructType::ProfileParameterMetadataParameterRelationMetadata => Some(from.as_any_ref().downcast_ref::<ProfileParameterMetadataParameterRelationMetadata>()?),
            StructType::ProfilePolicy => Some(from.as_any_ref().downcast_ref::<ProfilePolicy>()?),
            StructType::ProfilePolicyMetadata => Some(from.as_any_ref().downcast_ref::<ProfilePolicyMetadata>()?),
            StructType::PolicyOption => Some(from.as_any_ref().downcast_ref::<PolicyOption>()?),
            StructType::CompositePolicyOption => Some(from.as_any_ref().downcast_ref::<CompositePolicyOption>()?),
            StructType::ProfilePolicyOptionMetadata => Some(from.as_any_ref().downcast_ref::<ProfilePolicyOptionMetadata>()?),
            StructType::ProfileCompositePolicyOptionMetadata => Some(from.as_any_ref().downcast_ref::<ProfileCompositePolicyOptionMetadata>()?),
            StructType::UserInputRequiredParameterMetadata => Some(from.as_any_ref().downcast_ref::<UserInputRequiredParameterMetadata>()?),
            StructType::ProfileConfigInfo => Some(from.as_any_ref().downcast_ref::<ProfileConfigInfo>()?),
            StructType::ClusterProfileConfigInfo => Some(from.as_any_ref().downcast_ref::<ClusterProfileConfigInfo>()?),
            StructType::HostProfileConfigInfo => Some(from.as_any_ref().downcast_ref::<HostProfileConfigInfo>()?),
            StructType::ProfileCreateSpec => Some(from.as_any_ref().downcast_ref::<ProfileCreateSpec>()?),
            StructType::ProfileSerializedCreateSpec => Some(from.as_any_ref().downcast_ref::<ProfileSerializedCreateSpec>()?),
            StructType::HostProfileSerializedHostProfileSpec => Some(from.as_any_ref().downcast_ref::<HostProfileSerializedHostProfileSpec>()?),
            StructType::ClusterProfileCreateSpec => Some(from.as_any_ref().downcast_ref::<ClusterProfileCreateSpec>()?),
            StructType::ClusterProfileConfigSpec => Some(from.as_any_ref().downcast_ref::<ClusterProfileConfigSpec>()?),
            StructType::ClusterProfileCompleteConfigSpec => Some(from.as_any_ref().downcast_ref::<ClusterProfileCompleteConfigSpec>()?),
            StructType::ClusterProfileConfigServiceCreateSpec => Some(from.as_any_ref().downcast_ref::<ClusterProfileConfigServiceCreateSpec>()?),
            StructType::HostProfileConfigSpec => Some(from.as_any_ref().downcast_ref::<HostProfileConfigSpec>()?),
            StructType::HostProfileCompleteConfigSpec => Some(from.as_any_ref().downcast_ref::<HostProfileCompleteConfigSpec>()?),
            StructType::HostProfileHostBasedConfigSpec => Some(from.as_any_ref().downcast_ref::<HostProfileHostBasedConfigSpec>()?),
            StructType::ProfileDescription => Some(from.as_any_ref().downcast_ref::<ProfileDescription>()?),
            StructType::ProfileDescriptionSection => Some(from.as_any_ref().downcast_ref::<ProfileDescriptionSection>()?),
            StructType::ProfileMetadata => Some(from.as_any_ref().downcast_ref::<ProfileMetadata>()?),
            StructType::ProfileMetadataProfileOperationMessage => Some(from.as_any_ref().downcast_ref::<ProfileMetadataProfileOperationMessage>()?),
            StructType::ProfileMetadataProfileSortSpec => Some(from.as_any_ref().downcast_ref::<ProfileMetadataProfileSortSpec>()?),
            StructType::ProfilePropertyPath => Some(from.as_any_ref().downcast_ref::<ProfilePropertyPath>()?),
            StructType::ProfileProfileStructure => Some(from.as_any_ref().downcast_ref::<ProfileProfileStructure>()?),
            StructType::ProfileProfileStructureProperty => Some(from.as_any_ref().downcast_ref::<ProfileProfileStructureProperty>()?),
            StructType::AnswerFile => Some(from.as_any_ref().downcast_ref::<AnswerFile>()?),
            StructType::AnswerFileStatusResult => Some(from.as_any_ref().downcast_ref::<AnswerFileStatusResult>()?),
            StructType::AnswerFileStatusError => Some(from.as_any_ref().downcast_ref::<AnswerFileStatusError>()?),
            StructType::ProfileExecuteResult => Some(from.as_any_ref().downcast_ref::<ProfileExecuteResult>()?),
            StructType::ApplyHostProfileConfigurationSpec => Some(from.as_any_ref().downcast_ref::<ApplyHostProfileConfigurationSpec>()?),
            StructType::ProfileExecuteError => Some(from.as_any_ref().downcast_ref::<ProfileExecuteError>()?),
            StructType::HostProfileValidationFailureInfo => Some(from.as_any_ref().downcast_ref::<HostProfileValidationFailureInfo>()?),
            StructType::HostSpecification => Some(from.as_any_ref().downcast_ref::<HostSpecification>()?),
            StructType::HostSubSpecification => Some(from.as_any_ref().downcast_ref::<HostSubSpecification>()?),
            StructType::AnswerFileCreateSpec => Some(from.as_any_ref().downcast_ref::<AnswerFileCreateSpec>()?),
            StructType::AnswerFileOptionsCreateSpec => Some(from.as_any_ref().downcast_ref::<AnswerFileOptionsCreateSpec>()?),
            StructType::AnswerFileSerializedCreateSpec => Some(from.as_any_ref().downcast_ref::<AnswerFileSerializedCreateSpec>()?),
            StructType::ApplyHostProfileConfigurationResult => Some(from.as_any_ref().downcast_ref::<ApplyHostProfileConfigurationResult>()?),
            StructType::HostProfileManagerCompositionResult => Some(from.as_any_ref().downcast_ref::<HostProfileManagerCompositionResult>()?),
            StructType::HostProfileManagerCompositionResultResultElement => Some(from.as_any_ref().downcast_ref::<HostProfileManagerCompositionResultResultElement>()?),
            StructType::HostProfileManagerCompositionValidationResult => Some(from.as_any_ref().downcast_ref::<HostProfileManagerCompositionValidationResult>()?),
            StructType::HostProfileManagerCompositionValidationResultResultElement => Some(from.as_any_ref().downcast_ref::<HostProfileManagerCompositionValidationResultResultElement>()?),
            StructType::HostProfileManagerConfigTaskList => Some(from.as_any_ref().downcast_ref::<HostProfileManagerConfigTaskList>()?),
            StructType::HostProfilesEntityCustomizations => Some(from.as_any_ref().downcast_ref::<HostProfilesEntityCustomizations>()?),
            StructType::StructuredCustomizations => Some(from.as_any_ref().downcast_ref::<StructuredCustomizations>()?),
            StructType::HostProfileManagerHostToConfigSpecMap => Some(from.as_any_ref().downcast_ref::<HostProfileManagerHostToConfigSpecMap>()?),
            StructType::ScheduledTaskDescription => Some(from.as_any_ref().downcast_ref::<ScheduledTaskDescription>()?),
            StructType::ScheduledTaskSpec => Some(from.as_any_ref().downcast_ref::<ScheduledTaskSpec>()?),
            StructType::ScheduledTaskInfo => Some(from.as_any_ref().downcast_ref::<ScheduledTaskInfo>()?),
            StructType::TaskScheduler => Some(from.as_any_ref().downcast_ref::<TaskScheduler>()?),
            StructType::AfterStartupTaskScheduler => Some(from.as_any_ref().downcast_ref::<AfterStartupTaskScheduler>()?),
            StructType::OnceTaskScheduler => Some(from.as_any_ref().downcast_ref::<OnceTaskScheduler>()?),
            StructType::RecurrentTaskScheduler => Some(from.as_any_ref().downcast_ref::<RecurrentTaskScheduler>()?),
            StructType::HourlyTaskScheduler => Some(from.as_any_ref().downcast_ref::<HourlyTaskScheduler>()?),
            StructType::DailyTaskScheduler => Some(from.as_any_ref().downcast_ref::<DailyTaskScheduler>()?),
            StructType::MonthlyTaskScheduler => Some(from.as_any_ref().downcast_ref::<MonthlyTaskScheduler>()?),
            StructType::MonthlyByDayTaskScheduler => Some(from.as_any_ref().downcast_ref::<MonthlyByDayTaskScheduler>()?),
            StructType::MonthlyByWeekdayTaskScheduler => Some(from.as_any_ref().downcast_ref::<MonthlyByWeekdayTaskScheduler>()?),
            StructType::WeeklyTaskScheduler => Some(from.as_any_ref().downcast_ref::<WeeklyTaskScheduler>()?),
            StructType::ApplyStorageRecommendationResult => Some(from.as_any_ref().downcast_ref::<ApplyStorageRecommendationResult>()?),
            StructType::StorageDrsAutomationConfig => Some(from.as_any_ref().downcast_ref::<StorageDrsAutomationConfig>()?),
            StructType::StorageDrsConfigInfo => Some(from.as_any_ref().downcast_ref::<StorageDrsConfigInfo>()?),
            StructType::StorageDrsConfigSpec => Some(from.as_any_ref().downcast_ref::<StorageDrsConfigSpec>()?),
            StructType::StorageDrsIoLoadBalanceConfig => Some(from.as_any_ref().downcast_ref::<StorageDrsIoLoadBalanceConfig>()?),
            StructType::PlacementAffinityRule => Some(from.as_any_ref().downcast_ref::<PlacementAffinityRule>()?),
            StructType::PlacementRankResult => Some(from.as_any_ref().downcast_ref::<PlacementRankResult>()?),
            StructType::PlacementRankSpec => Some(from.as_any_ref().downcast_ref::<PlacementRankSpec>()?),
            StructType::StorageDrsPlacementRankVmSpec => Some(from.as_any_ref().downcast_ref::<StorageDrsPlacementRankVmSpec>()?),
            StructType::StorageDrsPodConfigInfo => Some(from.as_any_ref().downcast_ref::<StorageDrsPodConfigInfo>()?),
            StructType::StorageDrsPodConfigSpec => Some(from.as_any_ref().downcast_ref::<StorageDrsPodConfigSpec>()?),
            StructType::StorageDrsPodSelectionSpec => Some(from.as_any_ref().downcast_ref::<StorageDrsPodSelectionSpec>()?),
            StructType::PodDiskLocator => Some(from.as_any_ref().downcast_ref::<PodDiskLocator>()?),
            StructType::VmPodConfigForPlacement => Some(from.as_any_ref().downcast_ref::<VmPodConfigForPlacement>()?),
            StructType::StorageDrsSpaceLoadBalanceConfig => Some(from.as_any_ref().downcast_ref::<StorageDrsSpaceLoadBalanceConfig>()?),
            StructType::StoragePlacementResult => Some(from.as_any_ref().downcast_ref::<StoragePlacementResult>()?),
            StructType::StoragePlacementSpec => Some(from.as_any_ref().downcast_ref::<StoragePlacementSpec>()?),
            StructType::StorageDrsVmConfigInfo => Some(from.as_any_ref().downcast_ref::<StorageDrsVmConfigInfo>()?),
            StructType::VAppCloneSpec => Some(from.as_any_ref().downcast_ref::<VAppCloneSpec>()?),
            StructType::VAppCloneSpecNetworkMappingPair => Some(from.as_any_ref().downcast_ref::<VAppCloneSpecNetworkMappingPair>()?),
            StructType::VAppCloneSpecResourceMap => Some(from.as_any_ref().downcast_ref::<VAppCloneSpecResourceMap>()?),
            StructType::VAppEntityConfigInfo => Some(from.as_any_ref().downcast_ref::<VAppEntityConfigInfo>()?),
            StructType::VAppIpAssignmentInfo => Some(from.as_any_ref().downcast_ref::<VAppIpAssignmentInfo>()?),
            StructType::IpPool => Some(from.as_any_ref().downcast_ref::<IpPool>()?),
            StructType::IpPoolAssociation => Some(from.as_any_ref().downcast_ref::<IpPoolAssociation>()?),
            StructType::IpPoolIpPoolConfigInfo => Some(from.as_any_ref().downcast_ref::<IpPoolIpPoolConfigInfo>()?),
            StructType::VAppOvfSectionInfo => Some(from.as_any_ref().downcast_ref::<VAppOvfSectionInfo>()?),
            StructType::VAppProductInfo => Some(from.as_any_ref().downcast_ref::<VAppProductInfo>()?),
            StructType::VAppPropertyInfo => Some(from.as_any_ref().downcast_ref::<VAppPropertyInfo>()?),
            StructType::VmConfigInfo => Some(from.as_any_ref().downcast_ref::<VmConfigInfo>()?),
            StructType::VAppConfigInfo => Some(from.as_any_ref().downcast_ref::<VAppConfigInfo>()?),
            StructType::VmConfigSpec => Some(from.as_any_ref().downcast_ref::<VmConfigSpec>()?),
            StructType::VAppConfigSpec => Some(from.as_any_ref().downcast_ref::<VAppConfigSpec>()?),
            StructType::ClusterNetworkConfigSpec => Some(from.as_any_ref().downcast_ref::<ClusterNetworkConfigSpec>()?),
            StructType::FailoverNodeInfo => Some(from.as_any_ref().downcast_ref::<FailoverNodeInfo>()?),
            StructType::NodeDeploymentSpec => Some(from.as_any_ref().downcast_ref::<NodeDeploymentSpec>()?),
            StructType::PassiveNodeDeploymentSpec => Some(from.as_any_ref().downcast_ref::<PassiveNodeDeploymentSpec>()?),
            StructType::NodeNetworkSpec => Some(from.as_any_ref().downcast_ref::<NodeNetworkSpec>()?),
            StructType::PassiveNodeNetworkSpec => Some(from.as_any_ref().downcast_ref::<PassiveNodeNetworkSpec>()?),
            StructType::SourceNodeSpec => Some(from.as_any_ref().downcast_ref::<SourceNodeSpec>()?),
            StructType::VchaClusterConfigInfo => Some(from.as_any_ref().downcast_ref::<VchaClusterConfigInfo>()?),
            StructType::VchaClusterConfigSpec => Some(from.as_any_ref().downcast_ref::<VchaClusterConfigSpec>()?),
            StructType::VchaClusterDeploymentSpec => Some(from.as_any_ref().downcast_ref::<VchaClusterDeploymentSpec>()?),
            StructType::VchaClusterNetworkSpec => Some(from.as_any_ref().downcast_ref::<VchaClusterNetworkSpec>()?),
            StructType::WitnessNodeInfo => Some(from.as_any_ref().downcast_ref::<WitnessNodeInfo>()?),
            StructType::VchaClusterHealth => Some(from.as_any_ref().downcast_ref::<VchaClusterHealth>()?),
            StructType::VchaClusterRuntimeInfo => Some(from.as_any_ref().downcast_ref::<VchaClusterRuntimeInfo>()?),
            StructType::VchaNodeRuntimeInfo => Some(from.as_any_ref().downcast_ref::<VchaNodeRuntimeInfo>()?),
            StructType::VirtualMachineAffinityInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineAffinityInfo>()?),
            StructType::VirtualMachineBaseIndependentFilterSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineBaseIndependentFilterSpec>()?),
            StructType::VirtualMachineEmptyIndependentFilterSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineEmptyIndependentFilterSpec>()?),
            StructType::VirtualMachineIndependentFilterSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineIndependentFilterSpec>()?),
            StructType::VirtualMachineBootOptions => Some(from.as_any_ref().downcast_ref::<VirtualMachineBootOptions>()?),
            StructType::VirtualMachineBootOptionsBootableDevice => Some(from.as_any_ref().downcast_ref::<VirtualMachineBootOptionsBootableDevice>()?),
            StructType::VirtualMachineBootOptionsBootableCdromDevice => Some(from.as_any_ref().downcast_ref::<VirtualMachineBootOptionsBootableCdromDevice>()?),
            StructType::VirtualMachineBootOptionsBootableDiskDevice => Some(from.as_any_ref().downcast_ref::<VirtualMachineBootOptionsBootableDiskDevice>()?),
            StructType::VirtualMachineBootOptionsBootableEthernetDevice => Some(from.as_any_ref().downcast_ref::<VirtualMachineBootOptionsBootableEthernetDevice>()?),
            StructType::VirtualMachineBootOptionsBootableFloppyDevice => Some(from.as_any_ref().downcast_ref::<VirtualMachineBootOptionsBootableFloppyDevice>()?),
            StructType::VirtualMachineCapability => Some(from.as_any_ref().downcast_ref::<VirtualMachineCapability>()?),
            StructType::VirtualMachineCertThumbprint => Some(from.as_any_ref().downcast_ref::<VirtualMachineCertThumbprint>()?),
            StructType::VirtualMachineCloneSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineCloneSpec>()?),
            StructType::VirtualMachineConfigInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineConfigInfo>()?),
            StructType::VirtualMachineConfigInfoDatastoreUrlPair => Some(from.as_any_ref().downcast_ref::<VirtualMachineConfigInfoDatastoreUrlPair>()?),
            StructType::VirtualMachineConfigInfoOverheadInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineConfigInfoOverheadInfo>()?),
            StructType::VirtualMachineConfigOption => Some(from.as_any_ref().downcast_ref::<VirtualMachineConfigOption>()?),
            StructType::VirtualMachineConfigOptionDescriptor => Some(from.as_any_ref().downcast_ref::<VirtualMachineConfigOptionDescriptor>()?),
            StructType::VirtualMachineConfigSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineConfigSpec>()?),
            StructType::ConfigTarget => Some(from.as_any_ref().downcast_ref::<ConfigTarget>()?),
            StructType::VirtualMachineConsolePreferences => Some(from.as_any_ref().downcast_ref::<VirtualMachineConsolePreferences>()?),
            StructType::VirtualMachineContentLibraryItemInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineContentLibraryItemInfo>()?),
            StructType::DatastoreOption => Some(from.as_any_ref().downcast_ref::<DatastoreOption>()?),
            StructType::VirtualMachineDatastoreVolumeOption => Some(from.as_any_ref().downcast_ref::<VirtualMachineDatastoreVolumeOption>()?),
            StructType::VirtualMachineDefaultPowerOpInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineDefaultPowerOpInfo>()?),
            StructType::VirtualMachineDeviceRuntimeInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineDeviceRuntimeInfo>()?),
            StructType::VirtualMachineDeviceRuntimeInfoDeviceRuntimeState => Some(from.as_any_ref().downcast_ref::<VirtualMachineDeviceRuntimeInfoDeviceRuntimeState>()?),
            StructType::VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState => Some(from.as_any_ref().downcast_ref::<VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState>()?),
            StructType::VirtualMachineDvxClassInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineDvxClassInfo>()?),
            StructType::FaultToleranceConfigInfo => Some(from.as_any_ref().downcast_ref::<FaultToleranceConfigInfo>()?),
            StructType::FaultTolerancePrimaryConfigInfo => Some(from.as_any_ref().downcast_ref::<FaultTolerancePrimaryConfigInfo>()?),
            StructType::FaultToleranceSecondaryConfigInfo => Some(from.as_any_ref().downcast_ref::<FaultToleranceSecondaryConfigInfo>()?),
            StructType::FaultToleranceConfigSpec => Some(from.as_any_ref().downcast_ref::<FaultToleranceConfigSpec>()?),
            StructType::FaultToleranceMetaSpec => Some(from.as_any_ref().downcast_ref::<FaultToleranceMetaSpec>()?),
            StructType::FaultToleranceSecondaryOpResult => Some(from.as_any_ref().downcast_ref::<FaultToleranceSecondaryOpResult>()?),
            StructType::FaultToleranceVmConfigSpec => Some(from.as_any_ref().downcast_ref::<FaultToleranceVmConfigSpec>()?),
            StructType::FaultToleranceDiskSpec => Some(from.as_any_ref().downcast_ref::<FaultToleranceDiskSpec>()?),
            StructType::VirtualMachineFeatureRequirement => Some(from.as_any_ref().downcast_ref::<VirtualMachineFeatureRequirement>()?),
            StructType::VirtualMachineFileInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineFileInfo>()?),
            StructType::VirtualMachineFileLayout => Some(from.as_any_ref().downcast_ref::<VirtualMachineFileLayout>()?),
            StructType::VirtualMachineFileLayoutDiskLayout => Some(from.as_any_ref().downcast_ref::<VirtualMachineFileLayoutDiskLayout>()?),
            StructType::VirtualMachineFileLayoutSnapshotLayout => Some(from.as_any_ref().downcast_ref::<VirtualMachineFileLayoutSnapshotLayout>()?),
            StructType::VirtualMachineFileLayoutEx => Some(from.as_any_ref().downcast_ref::<VirtualMachineFileLayoutEx>()?),
            StructType::VirtualMachineFileLayoutExDiskLayout => Some(from.as_any_ref().downcast_ref::<VirtualMachineFileLayoutExDiskLayout>()?),
            StructType::VirtualMachineFileLayoutExDiskUnit => Some(from.as_any_ref().downcast_ref::<VirtualMachineFileLayoutExDiskUnit>()?),
            StructType::VirtualMachineFileLayoutExFileInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineFileLayoutExFileInfo>()?),
            StructType::VirtualMachineFileLayoutExSnapshotLayout => Some(from.as_any_ref().downcast_ref::<VirtualMachineFileLayoutExSnapshotLayout>()?),
            StructType::VirtualMachineFlagInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineFlagInfo>()?),
            StructType::VirtualMachineForkConfigInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineForkConfigInfo>()?),
            StructType::GuestInfo => Some(from.as_any_ref().downcast_ref::<GuestInfo>()?),
            StructType::GuestInfoCustomizationInfo => Some(from.as_any_ref().downcast_ref::<GuestInfoCustomizationInfo>()?),
            StructType::GuestDiskInfo => Some(from.as_any_ref().downcast_ref::<GuestDiskInfo>()?),
            StructType::GuestInfoNamespaceGenerationInfo => Some(from.as_any_ref().downcast_ref::<GuestInfoNamespaceGenerationInfo>()?),
            StructType::GuestNicInfo => Some(from.as_any_ref().downcast_ref::<GuestNicInfo>()?),
            StructType::GuestScreenInfo => Some(from.as_any_ref().downcast_ref::<GuestScreenInfo>()?),
            StructType::GuestStackInfo => Some(from.as_any_ref().downcast_ref::<GuestStackInfo>()?),
            StructType::GuestInfoVirtualDiskMapping => Some(from.as_any_ref().downcast_ref::<GuestInfoVirtualDiskMapping>()?),
            StructType::VirtualMachineGuestIntegrityInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineGuestIntegrityInfo>()?),
            StructType::VirtualMachineGuestMonitoringModeInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineGuestMonitoringModeInfo>()?),
            StructType::GuestOsDescriptor => Some(from.as_any_ref().downcast_ref::<GuestOsDescriptor>()?),
            StructType::VirtualMachineGuestQuiesceSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineGuestQuiesceSpec>()?),
            StructType::VirtualMachineWindowsQuiesceSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineWindowsQuiesceSpec>()?),
            StructType::VirtualMachineIdeDiskDevicePartitionInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineIdeDiskDevicePartitionInfo>()?),
            StructType::VirtualMachineInstantCloneSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineInstantCloneSpec>()?),
            StructType::VirtualMachineLegacyNetworkSwitchInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineLegacyNetworkSwitchInfo>()?),
            StructType::VirtualMachineMessage => Some(from.as_any_ref().downcast_ref::<VirtualMachineMessage>()?),
            StructType::VirtualMachineMetadataManagerVmMetadata => Some(from.as_any_ref().downcast_ref::<VirtualMachineMetadataManagerVmMetadata>()?),
            StructType::VirtualMachineMetadataManagerVmMetadataInput => Some(from.as_any_ref().downcast_ref::<VirtualMachineMetadataManagerVmMetadataInput>()?),
            StructType::VirtualMachineMetadataManagerVmMetadataOwner => Some(from.as_any_ref().downcast_ref::<VirtualMachineMetadataManagerVmMetadataOwner>()?),
            StructType::VirtualMachineMetadataManagerVmMetadataResult => Some(from.as_any_ref().downcast_ref::<VirtualMachineMetadataManagerVmMetadataResult>()?),
            StructType::VirtualMachineNetworkShaperInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineNetworkShaperInfo>()?),
            StructType::VirtualMachineProfileDetails => Some(from.as_any_ref().downcast_ref::<VirtualMachineProfileDetails>()?),
            StructType::VirtualMachineProfileDetailsDiskProfileDetails => Some(from.as_any_ref().downcast_ref::<VirtualMachineProfileDetailsDiskProfileDetails>()?),
            StructType::VirtualMachineProfileRawData => Some(from.as_any_ref().downcast_ref::<VirtualMachineProfileRawData>()?),
            StructType::VirtualMachineProfileSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineProfileSpec>()?),
            StructType::VirtualMachineDefaultProfileSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineDefaultProfileSpec>()?),
            StructType::VirtualMachineDefinedProfileSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineDefinedProfileSpec>()?),
            StructType::VirtualMachineEmptyProfileSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineEmptyProfileSpec>()?),
            StructType::VirtualMachinePropertyRelation => Some(from.as_any_ref().downcast_ref::<VirtualMachinePropertyRelation>()?),
            StructType::VirtualMachineQuestionInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineQuestionInfo>()?),
            StructType::VirtualMachineRelocateSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineRelocateSpec>()?),
            StructType::VirtualMachineRelocateSpecDiskLocator => Some(from.as_any_ref().downcast_ref::<VirtualMachineRelocateSpecDiskLocator>()?),
            StructType::VirtualMachineRelocateSpecDiskLocatorBackingSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineRelocateSpecDiskLocatorBackingSpec>()?),
            StructType::ReplicationConfigSpec => Some(from.as_any_ref().downcast_ref::<ReplicationConfigSpec>()?),
            StructType::ReplicationInfoDiskSettings => Some(from.as_any_ref().downcast_ref::<ReplicationInfoDiskSettings>()?),
            StructType::VirtualMachineRuntimeInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineRuntimeInfo>()?),
            StructType::VirtualMachineRuntimeInfoDasProtectionState => Some(from.as_any_ref().downcast_ref::<VirtualMachineRuntimeInfoDasProtectionState>()?),
            StructType::ScheduledHardwareUpgradeInfo => Some(from.as_any_ref().downcast_ref::<ScheduledHardwareUpgradeInfo>()?),
            StructType::VirtualMachineSgxInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineSgxInfo>()?),
            StructType::VirtualMachineSnapshotInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineSnapshotInfo>()?),
            StructType::VirtualMachineSnapshotTree => Some(from.as_any_ref().downcast_ref::<VirtualMachineSnapshotTree>()?),
            StructType::VirtualMachineSriovDevicePoolInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineSriovDevicePoolInfo>()?),
            StructType::VirtualMachineSriovNetworkDevicePoolInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineSriovNetworkDevicePoolInfo>()?),
            StructType::VirtualMachineStorageInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineStorageInfo>()?),
            StructType::VirtualMachineUsageOnDatastore => Some(from.as_any_ref().downcast_ref::<VirtualMachineUsageOnDatastore>()?),
            StructType::VirtualMachineSummary => Some(from.as_any_ref().downcast_ref::<VirtualMachineSummary>()?),
            StructType::VirtualMachineConfigSummary => Some(from.as_any_ref().downcast_ref::<VirtualMachineConfigSummary>()?),
            StructType::VirtualMachineGuestSummary => Some(from.as_any_ref().downcast_ref::<VirtualMachineGuestSummary>()?),
            StructType::VirtualMachineQuickStats => Some(from.as_any_ref().downcast_ref::<VirtualMachineQuickStats>()?),
            StructType::VirtualMachineQuickStatsMemoryTierStats => Some(from.as_any_ref().downcast_ref::<VirtualMachineQuickStatsMemoryTierStats>()?),
            StructType::VirtualMachineStorageSummary => Some(from.as_any_ref().downcast_ref::<VirtualMachineStorageSummary>()?),
            StructType::VirtualMachineTargetInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineTargetInfo>()?),
            StructType::VirtualMachineCdromInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineCdromInfo>()?),
            StructType::VirtualMachineDatastoreInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineDatastoreInfo>()?),
            StructType::VirtualMachineDiskDeviceInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineDiskDeviceInfo>()?),
            StructType::VirtualMachineIdeDiskDeviceInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineIdeDiskDeviceInfo>()?),
            StructType::VirtualMachineScsiDiskDeviceInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineScsiDiskDeviceInfo>()?),
            StructType::VirtualMachineDynamicPassthroughInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineDynamicPassthroughInfo>()?),
            StructType::VirtualMachineFloppyInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineFloppyInfo>()?),
            StructType::VirtualMachineNetworkInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineNetworkInfo>()?),
            StructType::OpaqueNetworkTargetInfo => Some(from.as_any_ref().downcast_ref::<OpaqueNetworkTargetInfo>()?),
            StructType::VirtualMachineParallelInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineParallelInfo>()?),
            StructType::VirtualMachinePciPassthroughInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachinePciPassthroughInfo>()?),
            StructType::VirtualMachineSriovInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineSriovInfo>()?),
            StructType::VirtualMachinePciSharedGpuPassthroughInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachinePciSharedGpuPassthroughInfo>()?),
            StructType::VirtualMachinePrecisionClockInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachinePrecisionClockInfo>()?),
            StructType::VirtualMachineScsiPassthroughInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineScsiPassthroughInfo>()?),
            StructType::VirtualMachineSerialInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineSerialInfo>()?),
            StructType::VirtualMachineSgxTargetInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineSgxTargetInfo>()?),
            StructType::VirtualMachineSoundInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineSoundInfo>()?),
            StructType::VirtualMachineUsbInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineUsbInfo>()?),
            StructType::VirtualMachineVFlashModuleInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineVFlashModuleInfo>()?),
            StructType::VirtualMachineVMotionStunTimeInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineVMotionStunTimeInfo>()?),
            StructType::VirtualMachineVendorDeviceGroupInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineVendorDeviceGroupInfo>()?),
            StructType::VirtualMachineVgpuDeviceInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineVgpuDeviceInfo>()?),
            StructType::VirtualMachineVgpuProfileInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineVgpuProfileInfo>()?),
            StructType::ToolsConfigInfo => Some(from.as_any_ref().downcast_ref::<ToolsConfigInfo>()?),
            StructType::ToolsConfigInfoToolsLastInstallInfo => Some(from.as_any_ref().downcast_ref::<ToolsConfigInfoToolsLastInstallInfo>()?),
            StructType::UsbScanCodeSpec => Some(from.as_any_ref().downcast_ref::<UsbScanCodeSpec>()?),
            StructType::UsbScanCodeSpecKeyEvent => Some(from.as_any_ref().downcast_ref::<UsbScanCodeSpecKeyEvent>()?),
            StructType::UsbScanCodeSpecModifierType => Some(from.as_any_ref().downcast_ref::<UsbScanCodeSpecModifierType>()?),
            StructType::VirtualMachineVcpuConfig => Some(from.as_any_ref().downcast_ref::<VirtualMachineVcpuConfig>()?),
            StructType::VirtualMachineVendorDeviceGroupInfoComponentDeviceInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineVendorDeviceGroupInfoComponentDeviceInfo>()?),
            StructType::VirtualMachineVirtualDeviceGroups => Some(from.as_any_ref().downcast_ref::<VirtualMachineVirtualDeviceGroups>()?),
            StructType::VirtualMachineVirtualDeviceGroupsDeviceGroup => Some(from.as_any_ref().downcast_ref::<VirtualMachineVirtualDeviceGroupsDeviceGroup>()?),
            StructType::VirtualMachineVirtualDeviceGroupsVendorDeviceGroup => Some(from.as_any_ref().downcast_ref::<VirtualMachineVirtualDeviceGroupsVendorDeviceGroup>()?),
            StructType::VirtualMachineVirtualDeviceSwap => Some(from.as_any_ref().downcast_ref::<VirtualMachineVirtualDeviceSwap>()?),
            StructType::VirtualMachineVirtualDeviceSwapDeviceSwapInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineVirtualDeviceSwapDeviceSwapInfo>()?),
            StructType::VirtualHardware => Some(from.as_any_ref().downcast_ref::<VirtualHardware>()?),
            StructType::VirtualHardwareOption => Some(from.as_any_ref().downcast_ref::<VirtualHardwareOption>()?),
            StructType::VirtualMachineVirtualNuma => Some(from.as_any_ref().downcast_ref::<VirtualMachineVirtualNuma>()?),
            StructType::VirtualMachineVirtualNumaInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineVirtualNumaInfo>()?),
            StructType::VirtualMachineVirtualPMem => Some(from.as_any_ref().downcast_ref::<VirtualMachineVirtualPMem>()?),
            StructType::CheckResult => Some(from.as_any_ref().downcast_ref::<CheckResult>()?),
            StructType::CustomizationAdapterMapping => Some(from.as_any_ref().downcast_ref::<CustomizationAdapterMapping>()?),
            StructType::CustomizationGlobalIpSettings => Some(from.as_any_ref().downcast_ref::<CustomizationGlobalIpSettings>()?),
            StructType::CustomizationGuiRunOnce => Some(from.as_any_ref().downcast_ref::<CustomizationGuiRunOnce>()?),
            StructType::CustomizationGuiUnattended => Some(from.as_any_ref().downcast_ref::<CustomizationGuiUnattended>()?),
            StructType::CustomizationIpSettings => Some(from.as_any_ref().downcast_ref::<CustomizationIpSettings>()?),
            StructType::CustomizationIpSettingsIpV6AddressSpec => Some(from.as_any_ref().downcast_ref::<CustomizationIpSettingsIpV6AddressSpec>()?),
            StructType::CustomizationIdentification => Some(from.as_any_ref().downcast_ref::<CustomizationIdentification>()?),
            StructType::CustomizationIdentitySettings => Some(from.as_any_ref().downcast_ref::<CustomizationIdentitySettings>()?),
            StructType::CustomizationCloudinitPrep => Some(from.as_any_ref().downcast_ref::<CustomizationCloudinitPrep>()?),
            StructType::CustomizationLinuxPrep => Some(from.as_any_ref().downcast_ref::<CustomizationLinuxPrep>()?),
            StructType::CustomizationSysprep => Some(from.as_any_ref().downcast_ref::<CustomizationSysprep>()?),
            StructType::CustomizationSysprepText => Some(from.as_any_ref().downcast_ref::<CustomizationSysprepText>()?),
            StructType::CustomizationIpGenerator => Some(from.as_any_ref().downcast_ref::<CustomizationIpGenerator>()?),
            StructType::CustomizationCustomIpGenerator => Some(from.as_any_ref().downcast_ref::<CustomizationCustomIpGenerator>()?),
            StructType::CustomizationDhcpIpGenerator => Some(from.as_any_ref().downcast_ref::<CustomizationDhcpIpGenerator>()?),
            StructType::CustomizationFixedIp => Some(from.as_any_ref().downcast_ref::<CustomizationFixedIp>()?),
            StructType::CustomizationUnknownIpGenerator => Some(from.as_any_ref().downcast_ref::<CustomizationUnknownIpGenerator>()?),
            StructType::CustomizationIpV6Generator => Some(from.as_any_ref().downcast_ref::<CustomizationIpV6Generator>()?),
            StructType::CustomizationAutoIpV6Generator => Some(from.as_any_ref().downcast_ref::<CustomizationAutoIpV6Generator>()?),
            StructType::CustomizationCustomIpV6Generator => Some(from.as_any_ref().downcast_ref::<CustomizationCustomIpV6Generator>()?),
            StructType::CustomizationDhcpIpV6Generator => Some(from.as_any_ref().downcast_ref::<CustomizationDhcpIpV6Generator>()?),
            StructType::CustomizationFixedIpV6 => Some(from.as_any_ref().downcast_ref::<CustomizationFixedIpV6>()?),
            StructType::CustomizationStatelessIpV6Generator => Some(from.as_any_ref().downcast_ref::<CustomizationStatelessIpV6Generator>()?),
            StructType::CustomizationUnknownIpV6Generator => Some(from.as_any_ref().downcast_ref::<CustomizationUnknownIpV6Generator>()?),
            StructType::CustomizationLicenseFilePrintData => Some(from.as_any_ref().downcast_ref::<CustomizationLicenseFilePrintData>()?),
            StructType::CustomizationName => Some(from.as_any_ref().downcast_ref::<CustomizationName>()?),
            StructType::CustomizationCustomName => Some(from.as_any_ref().downcast_ref::<CustomizationCustomName>()?),
            StructType::CustomizationFixedName => Some(from.as_any_ref().downcast_ref::<CustomizationFixedName>()?),
            StructType::CustomizationPrefixName => Some(from.as_any_ref().downcast_ref::<CustomizationPrefixName>()?),
            StructType::CustomizationUnknownName => Some(from.as_any_ref().downcast_ref::<CustomizationUnknownName>()?),
            StructType::CustomizationVirtualMachineName => Some(from.as_any_ref().downcast_ref::<CustomizationVirtualMachineName>()?),
            StructType::CustomizationOptions => Some(from.as_any_ref().downcast_ref::<CustomizationOptions>()?),
            StructType::CustomizationLinuxOptions => Some(from.as_any_ref().downcast_ref::<CustomizationLinuxOptions>()?),
            StructType::CustomizationWinOptions => Some(from.as_any_ref().downcast_ref::<CustomizationWinOptions>()?),
            StructType::CustomizationPassword => Some(from.as_any_ref().downcast_ref::<CustomizationPassword>()?),
            StructType::CustomizationSpec => Some(from.as_any_ref().downcast_ref::<CustomizationSpec>()?),
            StructType::CustomizationUserData => Some(from.as_any_ref().downcast_ref::<CustomizationUserData>()?),
            StructType::HostDiskMappingInfo => Some(from.as_any_ref().downcast_ref::<HostDiskMappingInfo>()?),
            StructType::HostDiskMappingPartitionInfo => Some(from.as_any_ref().downcast_ref::<HostDiskMappingPartitionInfo>()?),
            StructType::HostDiskMappingOption => Some(from.as_any_ref().downcast_ref::<HostDiskMappingOption>()?),
            StructType::HostDiskMappingPartitionOption => Some(from.as_any_ref().downcast_ref::<HostDiskMappingPartitionOption>()?),
            StructType::VirtualDevice => Some(from.as_any_ref().downcast_ref::<VirtualDevice>()?),
            StructType::VirtualCdrom => Some(from.as_any_ref().downcast_ref::<VirtualCdrom>()?),
            StructType::VirtualController => Some(from.as_any_ref().downcast_ref::<VirtualController>()?),
            StructType::VirtualIdeController => Some(from.as_any_ref().downcast_ref::<VirtualIdeController>()?),
            StructType::VirtualNvdimmController => Some(from.as_any_ref().downcast_ref::<VirtualNvdimmController>()?),
            StructType::VirtualNvmeController => Some(from.as_any_ref().downcast_ref::<VirtualNvmeController>()?),
            StructType::VirtualPciController => Some(from.as_any_ref().downcast_ref::<VirtualPciController>()?),
            StructType::VirtualPs2Controller => Some(from.as_any_ref().downcast_ref::<VirtualPs2Controller>()?),
            StructType::VirtualSataController => Some(from.as_any_ref().downcast_ref::<VirtualSataController>()?),
            StructType::VirtualAhciController => Some(from.as_any_ref().downcast_ref::<VirtualAhciController>()?),
            StructType::VirtualScsiController => Some(from.as_any_ref().downcast_ref::<VirtualScsiController>()?),
            StructType::ParaVirtualScsiController => Some(from.as_any_ref().downcast_ref::<ParaVirtualScsiController>()?),
            StructType::VirtualBusLogicController => Some(from.as_any_ref().downcast_ref::<VirtualBusLogicController>()?),
            StructType::VirtualLsiLogicController => Some(from.as_any_ref().downcast_ref::<VirtualLsiLogicController>()?),
            StructType::VirtualLsiLogicSasController => Some(from.as_any_ref().downcast_ref::<VirtualLsiLogicSasController>()?),
            StructType::VirtualSioController => Some(from.as_any_ref().downcast_ref::<VirtualSioController>()?),
            StructType::VirtualUsbController => Some(from.as_any_ref().downcast_ref::<VirtualUsbController>()?),
            StructType::VirtualUsbxhciController => Some(from.as_any_ref().downcast_ref::<VirtualUsbxhciController>()?),
            StructType::VirtualDisk => Some(from.as_any_ref().downcast_ref::<VirtualDisk>()?),
            StructType::VirtualEthernetCard => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCard>()?),
            StructType::VirtualE1000 => Some(from.as_any_ref().downcast_ref::<VirtualE1000>()?),
            StructType::VirtualE1000E => Some(from.as_any_ref().downcast_ref::<VirtualE1000E>()?),
            StructType::VirtualPcNet32 => Some(from.as_any_ref().downcast_ref::<VirtualPcNet32>()?),
            StructType::VirtualSriovEthernetCard => Some(from.as_any_ref().downcast_ref::<VirtualSriovEthernetCard>()?),
            StructType::VirtualVmxnet => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet>()?),
            StructType::VirtualVmxnet2 => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet2>()?),
            StructType::VirtualVmxnet3 => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3>()?),
            StructType::VirtualVmxnet3Vrdma => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3Vrdma>()?),
            StructType::VirtualFloppy => Some(from.as_any_ref().downcast_ref::<VirtualFloppy>()?),
            StructType::VirtualKeyboard => Some(from.as_any_ref().downcast_ref::<VirtualKeyboard>()?),
            StructType::VirtualNvdimm => Some(from.as_any_ref().downcast_ref::<VirtualNvdimm>()?),
            StructType::VirtualPciPassthrough => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthrough>()?),
            StructType::VirtualParallelPort => Some(from.as_any_ref().downcast_ref::<VirtualParallelPort>()?),
            StructType::VirtualPointingDevice => Some(from.as_any_ref().downcast_ref::<VirtualPointingDevice>()?),
            StructType::VirtualPrecisionClock => Some(from.as_any_ref().downcast_ref::<VirtualPrecisionClock>()?),
            StructType::VirtualScsiPassthrough => Some(from.as_any_ref().downcast_ref::<VirtualScsiPassthrough>()?),
            StructType::VirtualSerialPort => Some(from.as_any_ref().downcast_ref::<VirtualSerialPort>()?),
            StructType::VirtualSoundCard => Some(from.as_any_ref().downcast_ref::<VirtualSoundCard>()?),
            StructType::VirtualEnsoniq1371 => Some(from.as_any_ref().downcast_ref::<VirtualEnsoniq1371>()?),
            StructType::VirtualHdAudioCard => Some(from.as_any_ref().downcast_ref::<VirtualHdAudioCard>()?),
            StructType::VirtualSoundBlaster16 => Some(from.as_any_ref().downcast_ref::<VirtualSoundBlaster16>()?),
            StructType::VirtualTpm => Some(from.as_any_ref().downcast_ref::<VirtualTpm>()?),
            StructType::VirtualUsb => Some(from.as_any_ref().downcast_ref::<VirtualUsb>()?),
            StructType::VirtualMachineVmciDevice => Some(from.as_any_ref().downcast_ref::<VirtualMachineVmciDevice>()?),
            StructType::VirtualMachineVmirom => Some(from.as_any_ref().downcast_ref::<VirtualMachineVmirom>()?),
            StructType::VirtualMachineVideoCard => Some(from.as_any_ref().downcast_ref::<VirtualMachineVideoCard>()?),
            StructType::VirtualWdt => Some(from.as_any_ref().downcast_ref::<VirtualWdt>()?),
            StructType::VirtualDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDeviceBackingInfo>()?),
            StructType::VirtualDeviceDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDeviceDeviceBackingInfo>()?),
            StructType::VirtualCdromAtapiBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualCdromAtapiBackingInfo>()?),
            StructType::VirtualCdromPassthroughBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualCdromPassthroughBackingInfo>()?),
            StructType::VirtualDiskRawDiskVer2BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskRawDiskVer2BackingInfo>()?),
            StructType::VirtualDiskPartitionedRawDiskVer2BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskPartitionedRawDiskVer2BackingInfo>()?),
            StructType::VirtualEthernetCardLegacyNetworkBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardLegacyNetworkBackingInfo>()?),
            StructType::VirtualEthernetCardNetworkBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardNetworkBackingInfo>()?),
            StructType::VirtualFloppyDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualFloppyDeviceBackingInfo>()?),
            StructType::VirtualPciPassthroughDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughDeviceBackingInfo>()?),
            StructType::VirtualPciPassthroughDynamicBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughDynamicBackingInfo>()?),
            StructType::VirtualParallelPortDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualParallelPortDeviceBackingInfo>()?),
            StructType::VirtualPointingDeviceDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPointingDeviceDeviceBackingInfo>()?),
            StructType::VirtualScsiPassthroughDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualScsiPassthroughDeviceBackingInfo>()?),
            StructType::VirtualSerialPortDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortDeviceBackingInfo>()?),
            StructType::VirtualSoundCardDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSoundCardDeviceBackingInfo>()?),
            StructType::VirtualUsbRemoteHostBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualUsbRemoteHostBackingInfo>()?),
            StructType::VirtualUsbusbBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualUsbusbBackingInfo>()?),
            StructType::VirtualDeviceFileBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDeviceFileBackingInfo>()?),
            StructType::VirtualCdromIsoBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualCdromIsoBackingInfo>()?),
            StructType::VirtualDiskFlatVer1BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskFlatVer1BackingInfo>()?),
            StructType::VirtualDiskFlatVer2BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskFlatVer2BackingInfo>()?),
            StructType::VirtualDiskLocalPMemBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskLocalPMemBackingInfo>()?),
            StructType::VirtualDiskRawDiskMappingVer1BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskRawDiskMappingVer1BackingInfo>()?),
            StructType::VirtualDiskSeSparseBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskSeSparseBackingInfo>()?),
            StructType::VirtualDiskSparseVer1BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskSparseVer1BackingInfo>()?),
            StructType::VirtualDiskSparseVer2BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskSparseVer2BackingInfo>()?),
            StructType::VirtualFloppyImageBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualFloppyImageBackingInfo>()?),
            StructType::VirtualNvdimmBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualNvdimmBackingInfo>()?),
            StructType::VirtualParallelPortFileBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualParallelPortFileBackingInfo>()?),
            StructType::VirtualSerialPortFileBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortFileBackingInfo>()?),
            StructType::VirtualDevicePipeBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDevicePipeBackingInfo>()?),
            StructType::VirtualSerialPortPipeBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortPipeBackingInfo>()?),
            StructType::VirtualDeviceRemoteDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDeviceRemoteDeviceBackingInfo>()?),
            StructType::VirtualCdromRemoteAtapiBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualCdromRemoteAtapiBackingInfo>()?),
            StructType::VirtualCdromRemotePassthroughBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualCdromRemotePassthroughBackingInfo>()?),
            StructType::VirtualFloppyRemoteDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualFloppyRemoteDeviceBackingInfo>()?),
            StructType::VirtualUsbRemoteClientBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualUsbRemoteClientBackingInfo>()?),
            StructType::VirtualDeviceUriBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDeviceUriBackingInfo>()?),
            StructType::VirtualSerialPortUriBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortUriBackingInfo>()?),
            StructType::VirtualEthernetCardDistributedVirtualPortBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardDistributedVirtualPortBackingInfo>()?),
            StructType::VirtualEthernetCardOpaqueNetworkBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardOpaqueNetworkBackingInfo>()?),
            StructType::VirtualPciPassthroughDvxBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughDvxBackingInfo>()?),
            StructType::VirtualPciPassthroughPluginBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughPluginBackingInfo>()?),
            StructType::VirtualPciPassthroughVmiopBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughVmiopBackingInfo>()?),
            StructType::VirtualPrecisionClockSystemClockBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPrecisionClockSystemClockBackingInfo>()?),
            StructType::VirtualSerialPortThinPrintBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortThinPrintBackingInfo>()?),
            StructType::VirtualSriovEthernetCardSriovBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSriovEthernetCardSriovBackingInfo>()?),
            StructType::VirtualDeviceBusSlotInfo => Some(from.as_any_ref().downcast_ref::<VirtualDeviceBusSlotInfo>()?),
            StructType::VirtualDevicePciBusSlotInfo => Some(from.as_any_ref().downcast_ref::<VirtualDevicePciBusSlotInfo>()?),
            StructType::VirtualUsbControllerPciBusSlotInfo => Some(from.as_any_ref().downcast_ref::<VirtualUsbControllerPciBusSlotInfo>()?),
            StructType::VirtualDeviceConnectInfo => Some(from.as_any_ref().downcast_ref::<VirtualDeviceConnectInfo>()?),
            StructType::VirtualDeviceDeviceGroupInfo => Some(from.as_any_ref().downcast_ref::<VirtualDeviceDeviceGroupInfo>()?),
            StructType::VirtualDeviceOption => Some(from.as_any_ref().downcast_ref::<VirtualDeviceOption>()?),
            StructType::VirtualCdromOption => Some(from.as_any_ref().downcast_ref::<VirtualCdromOption>()?),
            StructType::VirtualControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualControllerOption>()?),
            StructType::VirtualIdeControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualIdeControllerOption>()?),
            StructType::VirtualNvdimmControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualNvdimmControllerOption>()?),
            StructType::VirtualNvmeControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualNvmeControllerOption>()?),
            StructType::VirtualPciControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualPciControllerOption>()?),
            StructType::VirtualPs2ControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualPs2ControllerOption>()?),
            StructType::VirtualSataControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualSataControllerOption>()?),
            StructType::VirtualAhciControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualAhciControllerOption>()?),
            StructType::VirtualScsiControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualScsiControllerOption>()?),
            StructType::ParaVirtualScsiControllerOption => Some(from.as_any_ref().downcast_ref::<ParaVirtualScsiControllerOption>()?),
            StructType::VirtualBusLogicControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualBusLogicControllerOption>()?),
            StructType::VirtualLsiLogicControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualLsiLogicControllerOption>()?),
            StructType::VirtualLsiLogicSasControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualLsiLogicSasControllerOption>()?),
            StructType::VirtualSioControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualSioControllerOption>()?),
            StructType::VirtualUsbControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualUsbControllerOption>()?),
            StructType::VirtualUsbxhciControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualUsbxhciControllerOption>()?),
            StructType::VirtualDiskOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskOption>()?),
            StructType::VirtualEthernetCardOption => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardOption>()?),
            StructType::VirtualE1000Option => Some(from.as_any_ref().downcast_ref::<VirtualE1000Option>()?),
            StructType::VirtualE1000EOption => Some(from.as_any_ref().downcast_ref::<VirtualE1000EOption>()?),
            StructType::VirtualPcNet32Option => Some(from.as_any_ref().downcast_ref::<VirtualPcNet32Option>()?),
            StructType::VirtualSriovEthernetCardOption => Some(from.as_any_ref().downcast_ref::<VirtualSriovEthernetCardOption>()?),
            StructType::VirtualVmxnetOption => Some(from.as_any_ref().downcast_ref::<VirtualVmxnetOption>()?),
            StructType::VirtualVmxnet2Option => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet2Option>()?),
            StructType::VirtualVmxnet3Option => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3Option>()?),
            StructType::VirtualVmxnet3VrdmaOption => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3VrdmaOption>()?),
            StructType::VirtualFloppyOption => Some(from.as_any_ref().downcast_ref::<VirtualFloppyOption>()?),
            StructType::VirtualKeyboardOption => Some(from.as_any_ref().downcast_ref::<VirtualKeyboardOption>()?),
            StructType::VirtualNvdimmOption => Some(from.as_any_ref().downcast_ref::<VirtualNvdimmOption>()?),
            StructType::VirtualPciPassthroughOption => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughOption>()?),
            StructType::VirtualParallelPortOption => Some(from.as_any_ref().downcast_ref::<VirtualParallelPortOption>()?),
            StructType::VirtualPointingDeviceOption => Some(from.as_any_ref().downcast_ref::<VirtualPointingDeviceOption>()?),
            StructType::VirtualPrecisionClockOption => Some(from.as_any_ref().downcast_ref::<VirtualPrecisionClockOption>()?),
            StructType::VirtualScsiPassthroughOption => Some(from.as_any_ref().downcast_ref::<VirtualScsiPassthroughOption>()?),
            StructType::VirtualSerialPortOption => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortOption>()?),
            StructType::VirtualSoundCardOption => Some(from.as_any_ref().downcast_ref::<VirtualSoundCardOption>()?),
            StructType::VirtualEnsoniq1371Option => Some(from.as_any_ref().downcast_ref::<VirtualEnsoniq1371Option>()?),
            StructType::VirtualHdAudioCardOption => Some(from.as_any_ref().downcast_ref::<VirtualHdAudioCardOption>()?),
            StructType::VirtualSoundBlaster16Option => Some(from.as_any_ref().downcast_ref::<VirtualSoundBlaster16Option>()?),
            StructType::VirtualTpmOption => Some(from.as_any_ref().downcast_ref::<VirtualTpmOption>()?),
            StructType::VirtualUsbOption => Some(from.as_any_ref().downcast_ref::<VirtualUsbOption>()?),
            StructType::VirtualMachineVmciDeviceOption => Some(from.as_any_ref().downcast_ref::<VirtualMachineVmciDeviceOption>()?),
            StructType::VirtualVmiromOption => Some(from.as_any_ref().downcast_ref::<VirtualVmiromOption>()?),
            StructType::VirtualVideoCardOption => Some(from.as_any_ref().downcast_ref::<VirtualVideoCardOption>()?),
            StructType::VirtualWdtOption => Some(from.as_any_ref().downcast_ref::<VirtualWdtOption>()?),
            StructType::VirtualDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDeviceBackingOption>()?),
            StructType::VirtualDeviceDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDeviceDeviceBackingOption>()?),
            StructType::VirtualCdromAtapiBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualCdromAtapiBackingOption>()?),
            StructType::VirtualCdromPassthroughBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualCdromPassthroughBackingOption>()?),
            StructType::VirtualCdromRemoteAtapiBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualCdromRemoteAtapiBackingOption>()?),
            StructType::VirtualDiskRawDiskMappingVer1BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskRawDiskMappingVer1BackingOption>()?),
            StructType::VirtualDiskRawDiskVer2BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskRawDiskVer2BackingOption>()?),
            StructType::VirtualDiskPartitionedRawDiskVer2BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskPartitionedRawDiskVer2BackingOption>()?),
            StructType::VirtualEthernetCardLegacyNetworkBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardLegacyNetworkBackingOption>()?),
            StructType::VirtualEthernetCardNetworkBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardNetworkBackingOption>()?),
            StructType::VirtualFloppyDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualFloppyDeviceBackingOption>()?),
            StructType::VirtualPciPassthroughDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughDeviceBackingOption>()?),
            StructType::VirtualPciPassthroughDynamicBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughDynamicBackingOption>()?),
            StructType::VirtualParallelPortDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualParallelPortDeviceBackingOption>()?),
            StructType::VirtualPointingDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPointingDeviceBackingOption>()?),
            StructType::VirtualScsiPassthroughDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualScsiPassthroughDeviceBackingOption>()?),
            StructType::VirtualSerialPortDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortDeviceBackingOption>()?),
            StructType::VirtualSoundCardDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSoundCardDeviceBackingOption>()?),
            StructType::VirtualUsbRemoteHostBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualUsbRemoteHostBackingOption>()?),
            StructType::VirtualUsbusbBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualUsbusbBackingOption>()?),
            StructType::VirtualDeviceFileBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDeviceFileBackingOption>()?),
            StructType::VirtualCdromIsoBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualCdromIsoBackingOption>()?),
            StructType::VirtualDiskFlatVer1BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskFlatVer1BackingOption>()?),
            StructType::VirtualDiskFlatVer2BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskFlatVer2BackingOption>()?),
            StructType::VirtualDiskLocalPMemBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskLocalPMemBackingOption>()?),
            StructType::VirtualDiskSeSparseBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskSeSparseBackingOption>()?),
            StructType::VirtualDiskSparseVer1BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskSparseVer1BackingOption>()?),
            StructType::VirtualDiskSparseVer2BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskSparseVer2BackingOption>()?),
            StructType::VirtualFloppyImageBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualFloppyImageBackingOption>()?),
            StructType::VirtualParallelPortFileBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualParallelPortFileBackingOption>()?),
            StructType::VirtualSerialPortFileBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortFileBackingOption>()?),
            StructType::VirtualDevicePipeBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDevicePipeBackingOption>()?),
            StructType::VirtualSerialPortPipeBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortPipeBackingOption>()?),
            StructType::VirtualDeviceRemoteDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDeviceRemoteDeviceBackingOption>()?),
            StructType::VirtualCdromRemotePassthroughBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualCdromRemotePassthroughBackingOption>()?),
            StructType::VirtualFloppyRemoteDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualFloppyRemoteDeviceBackingOption>()?),
            StructType::VirtualUsbRemoteClientBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualUsbRemoteClientBackingOption>()?),
            StructType::VirtualDeviceUriBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDeviceUriBackingOption>()?),
            StructType::VirtualSerialPortUriBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortUriBackingOption>()?),
            StructType::VirtualEthernetCardDvPortBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardDvPortBackingOption>()?),
            StructType::VirtualEthernetCardOpaqueNetworkBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardOpaqueNetworkBackingOption>()?),
            StructType::VirtualPciPassthroughDvxBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughDvxBackingOption>()?),
            StructType::VirtualPciPassthroughPluginBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughPluginBackingOption>()?),
            StructType::VirtualPciPassthroughVmiopBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughVmiopBackingOption>()?),
            StructType::VirtualPrecisionClockSystemClockBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPrecisionClockSystemClockBackingOption>()?),
            StructType::VirtualSerialPortThinPrintBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortThinPrintBackingOption>()?),
            StructType::VirtualSriovEthernetCardSriovBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSriovEthernetCardSriovBackingOption>()?),
            StructType::VirtualDeviceBusSlotOption => Some(from.as_any_ref().downcast_ref::<VirtualDeviceBusSlotOption>()?),
            StructType::VirtualDeviceConnectOption => Some(from.as_any_ref().downcast_ref::<VirtualDeviceConnectOption>()?),
            StructType::VirtualDeviceConfigSpec => Some(from.as_any_ref().downcast_ref::<VirtualDeviceConfigSpec>()?),
            StructType::VirtualDiskConfigSpec => Some(from.as_any_ref().downcast_ref::<VirtualDiskConfigSpec>()?),
            StructType::VirtualDeviceConfigSpecBackingSpec => Some(from.as_any_ref().downcast_ref::<VirtualDeviceConfigSpecBackingSpec>()?),
            StructType::VirtualDiskVFlashCacheConfigInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskVFlashCacheConfigInfo>()?),
            StructType::VirtualDiskId => Some(from.as_any_ref().downcast_ref::<VirtualDiskId>()?),
            StructType::VirtualDiskDeltaDiskFormatsSupported => Some(from.as_any_ref().downcast_ref::<VirtualDiskDeltaDiskFormatsSupported>()?),
            StructType::VirtualDiskOptionVFlashCacheConfigOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskOptionVFlashCacheConfigOption>()?),
            StructType::VirtualEthernetCardResourceAllocation => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardResourceAllocation>()?),
            StructType::VirtualPciPassthroughAllowedDevice => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughAllowedDevice>()?),
            StructType::VirtualMachineVmciDeviceFilterInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineVmciDeviceFilterInfo>()?),
            StructType::VirtualMachineVmciDeviceFilterSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineVmciDeviceFilterSpec>()?),
            StructType::VirtualMachineVmciDeviceOptionFilterSpecOption => Some(from.as_any_ref().downcast_ref::<VirtualMachineVmciDeviceOptionFilterSpecOption>()?),
            StructType::GuestAliases => Some(from.as_any_ref().downcast_ref::<GuestAliases>()?),
            StructType::GuestAuthAliasInfo => Some(from.as_any_ref().downcast_ref::<GuestAuthAliasInfo>()?),
            StructType::GuestAuthSubject => Some(from.as_any_ref().downcast_ref::<GuestAuthSubject>()?),
            StructType::GuestAuthAnySubject => Some(from.as_any_ref().downcast_ref::<GuestAuthAnySubject>()?),
            StructType::GuestAuthNamedSubject => Some(from.as_any_ref().downcast_ref::<GuestAuthNamedSubject>()?),
            StructType::GuestMappedAliases => Some(from.as_any_ref().downcast_ref::<GuestMappedAliases>()?),
            StructType::GuestFileAttributes => Some(from.as_any_ref().downcast_ref::<GuestFileAttributes>()?),
            StructType::GuestPosixFileAttributes => Some(from.as_any_ref().downcast_ref::<GuestPosixFileAttributes>()?),
            StructType::GuestWindowsFileAttributes => Some(from.as_any_ref().downcast_ref::<GuestWindowsFileAttributes>()?),
            StructType::GuestFileInfo => Some(from.as_any_ref().downcast_ref::<GuestFileInfo>()?),
            StructType::FileTransferInformation => Some(from.as_any_ref().downcast_ref::<FileTransferInformation>()?),
            StructType::GuestListFileInfo => Some(from.as_any_ref().downcast_ref::<GuestListFileInfo>()?),
            StructType::GuestAuthentication => Some(from.as_any_ref().downcast_ref::<GuestAuthentication>()?),
            StructType::NamePasswordAuthentication => Some(from.as_any_ref().downcast_ref::<NamePasswordAuthentication>()?),
            StructType::SamlTokenAuthentication => Some(from.as_any_ref().downcast_ref::<SamlTokenAuthentication>()?),
            StructType::SspiAuthentication => Some(from.as_any_ref().downcast_ref::<SspiAuthentication>()?),
            StructType::TicketedSessionAuthentication => Some(from.as_any_ref().downcast_ref::<TicketedSessionAuthentication>()?),
            StructType::GuestProcessInfo => Some(from.as_any_ref().downcast_ref::<GuestProcessInfo>()?),
            StructType::GuestProgramSpec => Some(from.as_any_ref().downcast_ref::<GuestProgramSpec>()?),
            StructType::GuestWindowsProgramSpec => Some(from.as_any_ref().downcast_ref::<GuestWindowsProgramSpec>()?),
            StructType::GuestRegKeySpec => Some(from.as_any_ref().downcast_ref::<GuestRegKeySpec>()?),
            StructType::GuestRegKeyNameSpec => Some(from.as_any_ref().downcast_ref::<GuestRegKeyNameSpec>()?),
            StructType::GuestRegKeyRecordSpec => Some(from.as_any_ref().downcast_ref::<GuestRegKeyRecordSpec>()?),
            StructType::GuestRegValueSpec => Some(from.as_any_ref().downcast_ref::<GuestRegValueSpec>()?),
            StructType::GuestRegValueDataSpec => Some(from.as_any_ref().downcast_ref::<GuestRegValueDataSpec>()?),
            StructType::GuestRegValueBinarySpec => Some(from.as_any_ref().downcast_ref::<GuestRegValueBinarySpec>()?),
            StructType::GuestRegValueDwordSpec => Some(from.as_any_ref().downcast_ref::<GuestRegValueDwordSpec>()?),
            StructType::GuestRegValueExpandStringSpec => Some(from.as_any_ref().downcast_ref::<GuestRegValueExpandStringSpec>()?),
            StructType::GuestRegValueMultiStringSpec => Some(from.as_any_ref().downcast_ref::<GuestRegValueMultiStringSpec>()?),
            StructType::GuestRegValueQwordSpec => Some(from.as_any_ref().downcast_ref::<GuestRegValueQwordSpec>()?),
            StructType::GuestRegValueStringSpec => Some(from.as_any_ref().downcast_ref::<GuestRegValueStringSpec>()?),
            StructType::GuestRegValueNameSpec => Some(from.as_any_ref().downcast_ref::<GuestRegValueNameSpec>()?),
            StructType::DeviceGroupId => Some(from.as_any_ref().downcast_ref::<DeviceGroupId>()?),
            StructType::FaultDomainId => Some(from.as_any_ref().downcast_ref::<FaultDomainId>()?),
            StructType::ReplicationGroupId => Some(from.as_any_ref().downcast_ref::<ReplicationGroupId>()?),
            StructType::ReplicationSpec => Some(from.as_any_ref().downcast_ref::<ReplicationSpec>()?),
            StructType::VsanClusterConfigInfo => Some(from.as_any_ref().downcast_ref::<VsanClusterConfigInfo>()?),
            StructType::VsanClusterConfigInfoHostDefaultInfo => Some(from.as_any_ref().downcast_ref::<VsanClusterConfigInfoHostDefaultInfo>()?),
            StructType::VsanHostClusterStatus => Some(from.as_any_ref().downcast_ref::<VsanHostClusterStatus>()?),
            StructType::VsanHostClusterStatusState => Some(from.as_any_ref().downcast_ref::<VsanHostClusterStatusState>()?),
            StructType::VsanHostClusterStatusStateCompletionEstimate => Some(from.as_any_ref().downcast_ref::<VsanHostClusterStatusStateCompletionEstimate>()?),
            StructType::VsanHostConfigInfo => Some(from.as_any_ref().downcast_ref::<VsanHostConfigInfo>()?),
            StructType::VsanHostConfigInfoClusterInfo => Some(from.as_any_ref().downcast_ref::<VsanHostConfigInfoClusterInfo>()?),
            StructType::VsanHostFaultDomainInfo => Some(from.as_any_ref().downcast_ref::<VsanHostFaultDomainInfo>()?),
            StructType::VsanHostConfigInfoNetworkInfo => Some(from.as_any_ref().downcast_ref::<VsanHostConfigInfoNetworkInfo>()?),
            StructType::VsanHostConfigInfoNetworkInfoPortConfig => Some(from.as_any_ref().downcast_ref::<VsanHostConfigInfoNetworkInfoPortConfig>()?),
            StructType::VsanHostConfigInfoStorageInfo => Some(from.as_any_ref().downcast_ref::<VsanHostConfigInfoStorageInfo>()?),
            StructType::VsanHostDecommissionMode => Some(from.as_any_ref().downcast_ref::<VsanHostDecommissionMode>()?),
            StructType::VsanHostDiskMapInfo => Some(from.as_any_ref().downcast_ref::<VsanHostDiskMapInfo>()?),
            StructType::VsanHostDiskMapResult => Some(from.as_any_ref().downcast_ref::<VsanHostDiskMapResult>()?),
            StructType::VsanHostDiskMapping => Some(from.as_any_ref().downcast_ref::<VsanHostDiskMapping>()?),
            StructType::VsanHostDiskResult => Some(from.as_any_ref().downcast_ref::<VsanHostDiskResult>()?),
            StructType::VsanHostIpConfig => Some(from.as_any_ref().downcast_ref::<VsanHostIpConfig>()?),
            StructType::VsanHostMembershipInfo => Some(from.as_any_ref().downcast_ref::<VsanHostMembershipInfo>()?),
            StructType::VsanHostVsanDiskInfo => Some(from.as_any_ref().downcast_ref::<VsanHostVsanDiskInfo>()?),
            StructType::VsanHostRuntimeInfo => Some(from.as_any_ref().downcast_ref::<VsanHostRuntimeInfo>()?),
            StructType::VsanHostRuntimeInfoDiskIssue => Some(from.as_any_ref().downcast_ref::<VsanHostRuntimeInfoDiskIssue>()?),
            StructType::BaseConfigInfo => Some(from.as_any_ref().downcast_ref::<BaseConfigInfo>()?),
            StructType::VStorageObjectConfigInfo => Some(from.as_any_ref().downcast_ref::<VStorageObjectConfigInfo>()?),
            StructType::BaseConfigInfoBackingInfo => Some(from.as_any_ref().downcast_ref::<BaseConfigInfoBackingInfo>()?),
            StructType::BaseConfigInfoFileBackingInfo => Some(from.as_any_ref().downcast_ref::<BaseConfigInfoFileBackingInfo>()?),
            StructType::BaseConfigInfoDiskFileBackingInfo => Some(from.as_any_ref().downcast_ref::<BaseConfigInfoDiskFileBackingInfo>()?),
            StructType::BaseConfigInfoRawDiskMappingBackingInfo => Some(from.as_any_ref().downcast_ref::<BaseConfigInfoRawDiskMappingBackingInfo>()?),
            StructType::VslmCreateSpec => Some(from.as_any_ref().downcast_ref::<VslmCreateSpec>()?),
            StructType::VslmCreateSpecBackingSpec => Some(from.as_any_ref().downcast_ref::<VslmCreateSpecBackingSpec>()?),
            StructType::VslmCreateSpecDiskFileBackingSpec => Some(from.as_any_ref().downcast_ref::<VslmCreateSpecDiskFileBackingSpec>()?),
            StructType::VslmCreateSpecRawDiskMappingBackingSpec => Some(from.as_any_ref().downcast_ref::<VslmCreateSpecRawDiskMappingBackingSpec>()?),
            StructType::DiskCryptoSpec => Some(from.as_any_ref().downcast_ref::<DiskCryptoSpec>()?),
            StructType::Id => Some(from.as_any_ref().downcast_ref::<Id>()?),
            StructType::VslmInfrastructureObjectPolicy => Some(from.as_any_ref().downcast_ref::<VslmInfrastructureObjectPolicy>()?),
            StructType::VslmInfrastructureObjectPolicySpec => Some(from.as_any_ref().downcast_ref::<VslmInfrastructureObjectPolicySpec>()?),
            StructType::VslmMigrateSpec => Some(from.as_any_ref().downcast_ref::<VslmMigrateSpec>()?),
            StructType::VslmCloneSpec => Some(from.as_any_ref().downcast_ref::<VslmCloneSpec>()?),
            StructType::VslmRelocateSpec => Some(from.as_any_ref().downcast_ref::<VslmRelocateSpec>()?),
            StructType::VStorageObjectStateInfo => Some(from.as_any_ref().downcast_ref::<VStorageObjectStateInfo>()?),
            StructType::VslmTagEntry => Some(from.as_any_ref().downcast_ref::<VslmTagEntry>()?),
            StructType::VslmVClockInfo => Some(from.as_any_ref().downcast_ref::<VslmVClockInfo>()?),
            StructType::VStorageObject => Some(from.as_any_ref().downcast_ref::<VStorageObject>()?),
            StructType::VStorageObjectSnapshot => Some(from.as_any_ref().downcast_ref::<VStorageObjectSnapshot>()?),
            StructType::VStorageObjectSnapshotDetails => Some(from.as_any_ref().downcast_ref::<VStorageObjectSnapshotDetails>()?),
            StructType::VStorageObjectSnapshotInfo => Some(from.as_any_ref().downcast_ref::<VStorageObjectSnapshotInfo>()?),
            StructType::VStorageObjectSnapshotInfoVStorageObjectSnapshot => Some(from.as_any_ref().downcast_ref::<VStorageObjectSnapshotInfoVStorageObjectSnapshot>()?),
            StructType::RetrieveVStorageObjSpec => Some(from.as_any_ref().downcast_ref::<RetrieveVStorageObjSpec>()?),
            StructType::VStorageObjectAssociations => Some(from.as_any_ref().downcast_ref::<VStorageObjectAssociations>()?),
            StructType::VStorageObjectAssociationsVmDiskAssociations => Some(from.as_any_ref().downcast_ref::<VStorageObjectAssociationsVmDiskAssociations>()?),
            StructType::DynamicArray => Some(from.as_any_ref().downcast_ref::<DynamicArray>()?),
            StructType::DynamicProperty => Some(from.as_any_ref().downcast_ref::<DynamicProperty>()?),
            StructType::KeyAnyValue => Some(from.as_any_ref().downcast_ref::<KeyAnyValue>()?),
            StructType::LocalizableMessage => Some(from.as_any_ref().downcast_ref::<LocalizableMessage>()?),
            StructType::LocalizedMethodFault => Some(from.as_any_ref().downcast_ref::<LocalizedMethodFault>()?),
            StructType::PropertyChange => Some(from.as_any_ref().downcast_ref::<PropertyChange>()?),
            StructType::PropertyFilterSpec => Some(from.as_any_ref().downcast_ref::<PropertyFilterSpec>()?),
            StructType::PropertyFilterUpdate => Some(from.as_any_ref().downcast_ref::<PropertyFilterUpdate>()?),
            StructType::MissingObject => Some(from.as_any_ref().downcast_ref::<MissingObject>()?),
            StructType::MissingProperty => Some(from.as_any_ref().downcast_ref::<MissingProperty>()?),
            StructType::ObjectContent => Some(from.as_any_ref().downcast_ref::<ObjectContent>()?),
            StructType::ObjectSpec => Some(from.as_any_ref().downcast_ref::<ObjectSpec>()?),
            StructType::ObjectUpdate => Some(from.as_any_ref().downcast_ref::<ObjectUpdate>()?),
            StructType::PropertySpec => Some(from.as_any_ref().downcast_ref::<PropertySpec>()?),
            StructType::RetrieveOptions => Some(from.as_any_ref().downcast_ref::<RetrieveOptions>()?),
            StructType::RetrieveResult => Some(from.as_any_ref().downcast_ref::<RetrieveResult>()?),
            StructType::SelectionSpec => Some(from.as_any_ref().downcast_ref::<SelectionSpec>()?),
            StructType::TraversalSpec => Some(from.as_any_ref().downcast_ref::<TraversalSpec>()?),
            StructType::UpdateSet => Some(from.as_any_ref().downcast_ref::<UpdateSet>()?),
            StructType::WaitOptions => Some(from.as_any_ref().downcast_ref::<WaitOptions>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DataObject => Ok(from.as_any_box().downcast::<DataObject>()?),
            StructType::AboutInfo => Ok(from.as_any_box().downcast::<AboutInfo>()?),
            StructType::AuthorizationDescription => Ok(from.as_any_box().downcast::<AuthorizationDescription>()?),
            StructType::EntityPrivilege => Ok(from.as_any_box().downcast::<EntityPrivilege>()?),
            StructType::Permission => Ok(from.as_any_box().downcast::<Permission>()?),
            StructType::AuthorizationPrivilege => Ok(from.as_any_box().downcast::<AuthorizationPrivilege>()?),
            StructType::PrivilegeAvailability => Ok(from.as_any_box().downcast::<PrivilegeAvailability>()?),
            StructType::AuthorizationRole => Ok(from.as_any_box().downcast::<AuthorizationRole>()?),
            StructType::UserPrivilegeResult => Ok(from.as_any_box().downcast::<UserPrivilegeResult>()?),
            StructType::BatchResult => Ok(from.as_any_box().downcast::<BatchResult>()?),
            StructType::Capability => Ok(from.as_any_box().downcast::<Capability>()?),
            StructType::ClusterComputeResourceClusterConfigResult => Ok(from.as_any_box().downcast::<ClusterComputeResourceClusterConfigResult>()?),
            StructType::ClusterComputeResourceDvsSetting => Ok(from.as_any_box().downcast::<ClusterComputeResourceDvsSetting>()?),
            StructType::ClusterComputeResourceDvsSettingDvPortgroupToServiceMapping => Ok(from.as_any_box().downcast::<ClusterComputeResourceDvsSettingDvPortgroupToServiceMapping>()?),
            StructType::ClusterComputeResourceDvsProfile => Ok(from.as_any_box().downcast::<ClusterComputeResourceDvsProfile>()?),
            StructType::ClusterComputeResourceDvsProfileDvPortgroupSpecToServiceMapping => Ok(from.as_any_box().downcast::<ClusterComputeResourceDvsProfileDvPortgroupSpecToServiceMapping>()?),
            StructType::ClusterComputeResourceHciConfigInfo => Ok(from.as_any_box().downcast::<ClusterComputeResourceHciConfigInfo>()?),
            StructType::ClusterComputeResourceHciConfigSpec => Ok(from.as_any_box().downcast::<ClusterComputeResourceHciConfigSpec>()?),
            StructType::ClusterComputeResourceHostConfigurationInput => Ok(from.as_any_box().downcast::<ClusterComputeResourceHostConfigurationInput>()?),
            StructType::ClusterComputeResourceHostConfigurationProfile => Ok(from.as_any_box().downcast::<ClusterComputeResourceHostConfigurationProfile>()?),
            StructType::ClusterComputeResourceHostVmkNicInfo => Ok(from.as_any_box().downcast::<ClusterComputeResourceHostVmkNicInfo>()?),
            StructType::ClusterComputeResourceVcProfile => Ok(from.as_any_box().downcast::<ClusterComputeResourceVcProfile>()?),
            StructType::ClusterComputeResourceValidationResultBase => Ok(from.as_any_box().downcast::<ClusterComputeResourceValidationResultBase>()?),
            StructType::ClusterComputeResourceDvsConfigurationValidation => Ok(from.as_any_box().downcast::<ClusterComputeResourceDvsConfigurationValidation>()?),
            StructType::ClusterComputeResourceHostConfigurationValidation => Ok(from.as_any_box().downcast::<ClusterComputeResourceHostConfigurationValidation>()?),
            StructType::ClusterComputeResourceVcsSlots => Ok(from.as_any_box().downcast::<ClusterComputeResourceVcsSlots>()?),
            StructType::ComputeResourceConfigInfo => Ok(from.as_any_box().downcast::<ComputeResourceConfigInfo>()?),
            StructType::ClusterConfigInfoEx => Ok(from.as_any_box().downcast::<ClusterConfigInfoEx>()?),
            StructType::ComputeResourceConfigSpec => Ok(from.as_any_box().downcast::<ComputeResourceConfigSpec>()?),
            StructType::ClusterConfigSpecEx => Ok(from.as_any_box().downcast::<ClusterConfigSpecEx>()?),
            StructType::ComputeResourceHostSpbmLicenseInfo => Ok(from.as_any_box().downcast::<ComputeResourceHostSpbmLicenseInfo>()?),
            StructType::ComputeResourceSummary => Ok(from.as_any_box().downcast::<ComputeResourceSummary>()?),
            StructType::ClusterComputeResourceSummary => Ok(from.as_any_box().downcast::<ClusterComputeResourceSummary>()?),
            StructType::CustomFieldDef => Ok(from.as_any_box().downcast::<CustomFieldDef>()?),
            StructType::CustomFieldValue => Ok(from.as_any_box().downcast::<CustomFieldValue>()?),
            StructType::CustomFieldStringValue => Ok(from.as_any_box().downcast::<CustomFieldStringValue>()?),
            StructType::CustomizationSpecInfo => Ok(from.as_any_box().downcast::<CustomizationSpecInfo>()?),
            StructType::CustomizationSpecItem => Ok(from.as_any_box().downcast::<CustomizationSpecItem>()?),
            StructType::DatacenterBasicConnectInfo => Ok(from.as_any_box().downcast::<DatacenterBasicConnectInfo>()?),
            StructType::DatacenterConfigInfo => Ok(from.as_any_box().downcast::<DatacenterConfigInfo>()?),
            StructType::DatacenterConfigSpec => Ok(from.as_any_box().downcast::<DatacenterConfigSpec>()?),
            StructType::DatastoreCapability => Ok(from.as_any_box().downcast::<DatastoreCapability>()?),
            StructType::DatastoreHostMount => Ok(from.as_any_box().downcast::<DatastoreHostMount>()?),
            StructType::DatastoreInfo => Ok(from.as_any_box().downcast::<DatastoreInfo>()?),
            StructType::LocalDatastoreInfo => Ok(from.as_any_box().downcast::<LocalDatastoreInfo>()?),
            StructType::NasDatastoreInfo => Ok(from.as_any_box().downcast::<NasDatastoreInfo>()?),
            StructType::PMemDatastoreInfo => Ok(from.as_any_box().downcast::<PMemDatastoreInfo>()?),
            StructType::VmfsDatastoreInfo => Ok(from.as_any_box().downcast::<VmfsDatastoreInfo>()?),
            StructType::VsanDatastoreInfo => Ok(from.as_any_box().downcast::<VsanDatastoreInfo>()?),
            StructType::VvolDatastoreInfo => Ok(from.as_any_box().downcast::<VvolDatastoreInfo>()?),
            StructType::DatastoreMountPathDatastorePair => Ok(from.as_any_box().downcast::<DatastoreMountPathDatastorePair>()?),
            StructType::DatastoreSummary => Ok(from.as_any_box().downcast::<DatastoreSummary>()?),
            StructType::DatastoreVVolContainerFailoverPair => Ok(from.as_any_box().downcast::<DatastoreVVolContainerFailoverPair>()?),
            StructType::DatastoreNamespaceManagerDirectoryInfo => Ok(from.as_any_box().downcast::<DatastoreNamespaceManagerDirectoryInfo>()?),
            StructType::Description => Ok(from.as_any_box().downcast::<Description>()?),
            StructType::ElementDescription => Ok(from.as_any_box().downcast::<ElementDescription>()?),
            StructType::EvcMode => Ok(from.as_any_box().downcast::<EvcMode>()?),
            StructType::ExtendedElementDescription => Ok(from.as_any_box().downcast::<ExtendedElementDescription>()?),
            StructType::FeatureEvcMode => Ok(from.as_any_box().downcast::<FeatureEvcMode>()?),
            StructType::OptionDef => Ok(from.as_any_box().downcast::<OptionDef>()?),
            StructType::ExtendedDescription => Ok(from.as_any_box().downcast::<ExtendedDescription>()?),
            StructType::MethodDescription => Ok(from.as_any_box().downcast::<MethodDescription>()?),
            StructType::TypeDescription => Ok(from.as_any_box().downcast::<TypeDescription>()?),
            StructType::ScheduledTaskDetail => Ok(from.as_any_box().downcast::<ScheduledTaskDetail>()?),
            StructType::DesiredSoftwareSpec => Ok(from.as_any_box().downcast::<DesiredSoftwareSpec>()?),
            StructType::DesiredSoftwareSpecBaseImageSpec => Ok(from.as_any_box().downcast::<DesiredSoftwareSpecBaseImageSpec>()?),
            StructType::DesiredSoftwareSpecComponentSpec => Ok(from.as_any_box().downcast::<DesiredSoftwareSpecComponentSpec>()?),
            StructType::DesiredSoftwareSpecVendorAddOnSpec => Ok(from.as_any_box().downcast::<DesiredSoftwareSpecVendorAddOnSpec>()?),
            StructType::DiagnosticManagerAuditRecordResult => Ok(from.as_any_box().downcast::<DiagnosticManagerAuditRecordResult>()?),
            StructType::DiagnosticManagerBundleInfo => Ok(from.as_any_box().downcast::<DiagnosticManagerBundleInfo>()?),
            StructType::DiagnosticManagerLogDescriptor => Ok(from.as_any_box().downcast::<DiagnosticManagerLogDescriptor>()?),
            StructType::DiagnosticManagerLogHeader => Ok(from.as_any_box().downcast::<DiagnosticManagerLogHeader>()?),
            StructType::DvsBackupRestoreCapability => Ok(from.as_any_box().downcast::<DvsBackupRestoreCapability>()?),
            StructType::DvsCapability => Ok(from.as_any_box().downcast::<DvsCapability>()?),
            StructType::DvsConfigInfo => Ok(from.as_any_box().downcast::<DvsConfigInfo>()?),
            StructType::VMwareDvsConfigInfo => Ok(from.as_any_box().downcast::<VMwareDvsConfigInfo>()?),
            StructType::DvsConfigSpec => Ok(from.as_any_box().downcast::<DvsConfigSpec>()?),
            StructType::VMwareDvsConfigSpec => Ok(from.as_any_box().downcast::<VMwareDvsConfigSpec>()?),
            StructType::DvsContactInfo => Ok(from.as_any_box().downcast::<DvsContactInfo>()?),
            StructType::DvsCreateSpec => Ok(from.as_any_box().downcast::<DvsCreateSpec>()?),
            StructType::DvsFeatureCapability => Ok(from.as_any_box().downcast::<DvsFeatureCapability>()?),
            StructType::VMwareDvsFeatureCapability => Ok(from.as_any_box().downcast::<VMwareDvsFeatureCapability>()?),
            StructType::DvsHealthCheckConfig => Ok(from.as_any_box().downcast::<DvsHealthCheckConfig>()?),
            StructType::VMwareDvsHealthCheckConfig => Ok(from.as_any_box().downcast::<VMwareDvsHealthCheckConfig>()?),
            StructType::VMwareDvsTeamingHealthCheckConfig => Ok(from.as_any_box().downcast::<VMwareDvsTeamingHealthCheckConfig>()?),
            StructType::VMwareDvsVlanMtuHealthCheckConfig => Ok(from.as_any_box().downcast::<VMwareDvsVlanMtuHealthCheckConfig>()?),
            StructType::DvsHealthCheckCapability => Ok(from.as_any_box().downcast::<DvsHealthCheckCapability>()?),
            StructType::VMwareDvsHealthCheckCapability => Ok(from.as_any_box().downcast::<VMwareDvsHealthCheckCapability>()?),
            StructType::DvsHostInfrastructureTrafficResource => Ok(from.as_any_box().downcast::<DvsHostInfrastructureTrafficResource>()?),
            StructType::DvsHostInfrastructureTrafficResourceAllocation => Ok(from.as_any_box().downcast::<DvsHostInfrastructureTrafficResourceAllocation>()?),
            StructType::DvsNetworkResourceManagementCapability => Ok(from.as_any_box().downcast::<DvsNetworkResourceManagementCapability>()?),
            StructType::DvsResourceRuntimeInfo => Ok(from.as_any_box().downcast::<DvsResourceRuntimeInfo>()?),
            StructType::DvsRollbackCapability => Ok(from.as_any_box().downcast::<DvsRollbackCapability>()?),
            StructType::DvsRuntimeInfo => Ok(from.as_any_box().downcast::<DvsRuntimeInfo>()?),
            StructType::DvsSummary => Ok(from.as_any_box().downcast::<DvsSummary>()?),
            StructType::DvsPolicy => Ok(from.as_any_box().downcast::<DvsPolicy>()?),
            StructType::DvsUplinkPortPolicy => Ok(from.as_any_box().downcast::<DvsUplinkPortPolicy>()?),
            StructType::DvsNameArrayUplinkPortPolicy => Ok(from.as_any_box().downcast::<DvsNameArrayUplinkPortPolicy>()?),
            StructType::EnumDescription => Ok(from.as_any_box().downcast::<EnumDescription>()?),
            StructType::EnvironmentBrowserConfigOptionQuerySpec => Ok(from.as_any_box().downcast::<EnvironmentBrowserConfigOptionQuerySpec>()?),
            StructType::Extension => Ok(from.as_any_box().downcast::<Extension>()?),
            StructType::ExtensionClientInfo => Ok(from.as_any_box().downcast::<ExtensionClientInfo>()?),
            StructType::ExtensionEventTypeInfo => Ok(from.as_any_box().downcast::<ExtensionEventTypeInfo>()?),
            StructType::ExtensionFaultTypeInfo => Ok(from.as_any_box().downcast::<ExtensionFaultTypeInfo>()?),
            StructType::ExtensionHealthInfo => Ok(from.as_any_box().downcast::<ExtensionHealthInfo>()?),
            StructType::ExtensionOvfConsumerInfo => Ok(from.as_any_box().downcast::<ExtensionOvfConsumerInfo>()?),
            StructType::ExtensionPrivilegeInfo => Ok(from.as_any_box().downcast::<ExtensionPrivilegeInfo>()?),
            StructType::ExtensionResourceInfo => Ok(from.as_any_box().downcast::<ExtensionResourceInfo>()?),
            StructType::ExtensionServerInfo => Ok(from.as_any_box().downcast::<ExtensionServerInfo>()?),
            StructType::ExtensionTaskTypeInfo => Ok(from.as_any_box().downcast::<ExtensionTaskTypeInfo>()?),
            StructType::ExtensionManagerIpAllocationUsage => Ok(from.as_any_box().downcast::<ExtensionManagerIpAllocationUsage>()?),
            StructType::FaultsByHost => Ok(from.as_any_box().downcast::<FaultsByHost>()?),
            StructType::FaultsByVm => Ok(from.as_any_box().downcast::<FaultsByVm>()?),
            StructType::FileLockInfo => Ok(from.as_any_box().downcast::<FileLockInfo>()?),
            StructType::FileLockInfoResult => Ok(from.as_any_box().downcast::<FileLockInfoResult>()?),
            StructType::FolderBatchAddHostsToClusterResult => Ok(from.as_any_box().downcast::<FolderBatchAddHostsToClusterResult>()?),
            StructType::FolderBatchAddStandaloneHostsResult => Ok(from.as_any_box().downcast::<FolderBatchAddStandaloneHostsResult>()?),
            StructType::FolderFailedHostResult => Ok(from.as_any_box().downcast::<FolderFailedHostResult>()?),
            StructType::FolderNewHostSpec => Ok(from.as_any_box().downcast::<FolderNewHostSpec>()?),
            StructType::HbrManagerReplicationVmInfo => Ok(from.as_any_box().downcast::<HbrManagerReplicationVmInfo>()?),
            StructType::ReplicationVmProgressInfo => Ok(from.as_any_box().downcast::<ReplicationVmProgressInfo>()?),
            StructType::HbrManagerVmReplicationCapability => Ok(from.as_any_box().downcast::<HbrManagerVmReplicationCapability>()?),
            StructType::HealthUpdate => Ok(from.as_any_box().downcast::<HealthUpdate>()?),
            StructType::HealthUpdateInfo => Ok(from.as_any_box().downcast::<HealthUpdateInfo>()?),
            StructType::PerfInterval => Ok(from.as_any_box().downcast::<PerfInterval>()?),
            StructType::HostServiceTicket => Ok(from.as_any_box().downcast::<HostServiceTicket>()?),
            StructType::HostSystemComplianceCheckState => Ok(from.as_any_box().downcast::<HostSystemComplianceCheckState>()?),
            StructType::HostSystemReconnectSpec => Ok(from.as_any_box().downcast::<HostSystemReconnectSpec>()?),
            StructType::HostSystemRemediationState => Ok(from.as_any_box().downcast::<HostSystemRemediationState>()?),
            StructType::HttpNfcLeaseCapabilities => Ok(from.as_any_box().downcast::<HttpNfcLeaseCapabilities>()?),
            StructType::HttpNfcLeaseDatastoreLeaseInfo => Ok(from.as_any_box().downcast::<HttpNfcLeaseDatastoreLeaseInfo>()?),
            StructType::HttpNfcLeaseDeviceUrl => Ok(from.as_any_box().downcast::<HttpNfcLeaseDeviceUrl>()?),
            StructType::HttpNfcLeaseHostInfo => Ok(from.as_any_box().downcast::<HttpNfcLeaseHostInfo>()?),
            StructType::HttpNfcLeaseInfo => Ok(from.as_any_box().downcast::<HttpNfcLeaseInfo>()?),
            StructType::HttpNfcLeaseManifestEntry => Ok(from.as_any_box().downcast::<HttpNfcLeaseManifestEntry>()?),
            StructType::HttpNfcLeaseProbeResult => Ok(from.as_any_box().downcast::<HttpNfcLeaseProbeResult>()?),
            StructType::HttpNfcLeaseSourceFile => Ok(from.as_any_box().downcast::<HttpNfcLeaseSourceFile>()?),
            StructType::ImportSpec => Ok(from.as_any_box().downcast::<ImportSpec>()?),
            StructType::VirtualAppImportSpec => Ok(from.as_any_box().downcast::<VirtualAppImportSpec>()?),
            StructType::VirtualMachineImportSpec => Ok(from.as_any_box().downcast::<VirtualMachineImportSpec>()?),
            StructType::InheritablePolicy => Ok(from.as_any_box().downcast::<InheritablePolicy>()?),
            StructType::BoolPolicy => Ok(from.as_any_box().downcast::<BoolPolicy>()?),
            StructType::IntPolicy => Ok(from.as_any_box().downcast::<IntPolicy>()?),
            StructType::LongPolicy => Ok(from.as_any_box().downcast::<LongPolicy>()?),
            StructType::StringPolicy => Ok(from.as_any_box().downcast::<StringPolicy>()?),
            StructType::DvsFilterConfig => Ok(from.as_any_box().downcast::<DvsFilterConfig>()?),
            StructType::DvsFilterConfigSpec => Ok(from.as_any_box().downcast::<DvsFilterConfigSpec>()?),
            StructType::DvsTrafficFilterConfig => Ok(from.as_any_box().downcast::<DvsTrafficFilterConfig>()?),
            StructType::DvsTrafficFilterConfigSpec => Ok(from.as_any_box().downcast::<DvsTrafficFilterConfigSpec>()?),
            StructType::DvsFilterPolicy => Ok(from.as_any_box().downcast::<DvsFilterPolicy>()?),
            StructType::DvsTrafficShapingPolicy => Ok(from.as_any_box().downcast::<DvsTrafficShapingPolicy>()?),
            StructType::DvsVendorSpecificConfig => Ok(from.as_any_box().downcast::<DvsVendorSpecificConfig>()?),
            StructType::DvsFailureCriteria => Ok(from.as_any_box().downcast::<DvsFailureCriteria>()?),
            StructType::DvsMacLearningPolicy => Ok(from.as_any_box().downcast::<DvsMacLearningPolicy>()?),
            StructType::DvsMacManagementPolicy => Ok(from.as_any_box().downcast::<DvsMacManagementPolicy>()?),
            StructType::DvsSecurityPolicy => Ok(from.as_any_box().downcast::<DvsSecurityPolicy>()?),
            StructType::VMwareUplinkLacpPolicy => Ok(from.as_any_box().downcast::<VMwareUplinkLacpPolicy>()?),
            StructType::VMwareUplinkPortOrderPolicy => Ok(from.as_any_box().downcast::<VMwareUplinkPortOrderPolicy>()?),
            StructType::VmwareUplinkPortTeamingPolicy => Ok(from.as_any_box().downcast::<VmwareUplinkPortTeamingPolicy>()?),
            StructType::VmwareDistributedVirtualSwitchVlanSpec => Ok(from.as_any_box().downcast::<VmwareDistributedVirtualSwitchVlanSpec>()?),
            StructType::VmwareDistributedVirtualSwitchPvlanSpec => Ok(from.as_any_box().downcast::<VmwareDistributedVirtualSwitchPvlanSpec>()?),
            StructType::VmwareDistributedVirtualSwitchTrunkVlanSpec => Ok(from.as_any_box().downcast::<VmwareDistributedVirtualSwitchTrunkVlanSpec>()?),
            StructType::VmwareDistributedVirtualSwitchVlanIdSpec => Ok(from.as_any_box().downcast::<VmwareDistributedVirtualSwitchVlanIdSpec>()?),
            StructType::IoFilterInfo => Ok(from.as_any_box().downcast::<IoFilterInfo>()?),
            StructType::ClusterIoFilterInfo => Ok(from.as_any_box().downcast::<ClusterIoFilterInfo>()?),
            StructType::HostIoFilterInfo => Ok(from.as_any_box().downcast::<HostIoFilterInfo>()?),
            StructType::IoFilterQueryIssueResult => Ok(from.as_any_box().downcast::<IoFilterQueryIssueResult>()?),
            StructType::IoFilterHostIssue => Ok(from.as_any_box().downcast::<IoFilterHostIssue>()?),
            StructType::IpPoolManagerIpAllocation => Ok(from.as_any_box().downcast::<IpPoolManagerIpAllocation>()?),
            StructType::KeyValue => Ok(from.as_any_box().downcast::<KeyValue>()?),
            StructType::LatencySensitivity => Ok(from.as_any_box().downcast::<LatencySensitivity>()?),
            StructType::LicenseAssignmentManagerLicenseAssignment => Ok(from.as_any_box().downcast::<LicenseAssignmentManagerLicenseAssignment>()?),
            StructType::LicenseAvailabilityInfo => Ok(from.as_any_box().downcast::<LicenseAvailabilityInfo>()?),
            StructType::LicenseDiagnostics => Ok(from.as_any_box().downcast::<LicenseDiagnostics>()?),
            StructType::LicenseManagerEvaluationInfo => Ok(from.as_any_box().downcast::<LicenseManagerEvaluationInfo>()?),
            StructType::LicenseFeatureInfo => Ok(from.as_any_box().downcast::<LicenseFeatureInfo>()?),
            StructType::HostLicensableResourceInfo => Ok(from.as_any_box().downcast::<HostLicensableResourceInfo>()?),
            StructType::LicenseManagerLicenseInfo => Ok(from.as_any_box().downcast::<LicenseManagerLicenseInfo>()?),
            StructType::LicenseSource => Ok(from.as_any_box().downcast::<LicenseSource>()?),
            StructType::EvaluationLicenseSource => Ok(from.as_any_box().downcast::<EvaluationLicenseSource>()?),
            StructType::LicenseServerSource => Ok(from.as_any_box().downcast::<LicenseServerSource>()?),
            StructType::LocalLicenseSource => Ok(from.as_any_box().downcast::<LocalLicenseSource>()?),
            StructType::LicenseUsageInfo => Ok(from.as_any_box().downcast::<LicenseUsageInfo>()?),
            StructType::LicenseReservationInfo => Ok(from.as_any_box().downcast::<LicenseReservationInfo>()?),
            StructType::LocalizationManagerMessageCatalog => Ok(from.as_any_box().downcast::<LocalizationManagerMessageCatalog>()?),
            StructType::NegatableExpression => Ok(from.as_any_box().downcast::<NegatableExpression>()?),
            StructType::IntExpression => Ok(from.as_any_box().downcast::<IntExpression>()?),
            StructType::IpAddress => Ok(from.as_any_box().downcast::<IpAddress>()?),
            StructType::IpRange => Ok(from.as_any_box().downcast::<IpRange>()?),
            StructType::SingleIp => Ok(from.as_any_box().downcast::<SingleIp>()?),
            StructType::MacAddress => Ok(from.as_any_box().downcast::<MacAddress>()?),
            StructType::MacRange => Ok(from.as_any_box().downcast::<MacRange>()?),
            StructType::SingleMac => Ok(from.as_any_box().downcast::<SingleMac>()?),
            StructType::StringExpression => Ok(from.as_any_box().downcast::<StringExpression>()?),
            StructType::DvsIpPort => Ok(from.as_any_box().downcast::<DvsIpPort>()?),
            StructType::DvsIpPortRange => Ok(from.as_any_box().downcast::<DvsIpPortRange>()?),
            StructType::DvsSingleIpPort => Ok(from.as_any_box().downcast::<DvsSingleIpPort>()?),
            StructType::NetworkSummary => Ok(from.as_any_box().downcast::<NetworkSummary>()?),
            StructType::OpaqueNetworkSummary => Ok(from.as_any_box().downcast::<OpaqueNetworkSummary>()?),
            StructType::NumericRange => Ok(from.as_any_box().downcast::<NumericRange>()?),
            StructType::OpaqueNetworkCapability => Ok(from.as_any_box().downcast::<OpaqueNetworkCapability>()?),
            StructType::OvfConsumerOstNode => Ok(from.as_any_box().downcast::<OvfConsumerOstNode>()?),
            StructType::OvfConsumerOvfSection => Ok(from.as_any_box().downcast::<OvfConsumerOvfSection>()?),
            StructType::OvfManagerCommonParams => Ok(from.as_any_box().downcast::<OvfManagerCommonParams>()?),
            StructType::OvfCreateImportSpecParams => Ok(from.as_any_box().downcast::<OvfCreateImportSpecParams>()?),
            StructType::OvfParseDescriptorParams => Ok(from.as_any_box().downcast::<OvfParseDescriptorParams>()?),
            StructType::OvfValidateHostParams => Ok(from.as_any_box().downcast::<OvfValidateHostParams>()?),
            StructType::OvfCreateDescriptorParams => Ok(from.as_any_box().downcast::<OvfCreateDescriptorParams>()?),
            StructType::OvfCreateDescriptorResult => Ok(from.as_any_box().downcast::<OvfCreateDescriptorResult>()?),
            StructType::OvfCreateImportSpecResult => Ok(from.as_any_box().downcast::<OvfCreateImportSpecResult>()?),
            StructType::OvfDeploymentOption => Ok(from.as_any_box().downcast::<OvfDeploymentOption>()?),
            StructType::OvfFileItem => Ok(from.as_any_box().downcast::<OvfFileItem>()?),
            StructType::OvfNetworkInfo => Ok(from.as_any_box().downcast::<OvfNetworkInfo>()?),
            StructType::OvfNetworkMapping => Ok(from.as_any_box().downcast::<OvfNetworkMapping>()?),
            StructType::OvfFile => Ok(from.as_any_box().downcast::<OvfFile>()?),
            StructType::OvfOptionInfo => Ok(from.as_any_box().downcast::<OvfOptionInfo>()?),
            StructType::OvfParseDescriptorResult => Ok(from.as_any_box().downcast::<OvfParseDescriptorResult>()?),
            StructType::OvfResourceMap => Ok(from.as_any_box().downcast::<OvfResourceMap>()?),
            StructType::OvfValidateHostResult => Ok(from.as_any_box().downcast::<OvfValidateHostResult>()?),
            StructType::PasswordField => Ok(from.as_any_box().downcast::<PasswordField>()?),
            StructType::PerformanceDescription => Ok(from.as_any_box().downcast::<PerformanceDescription>()?),
            StructType::PerfCompositeMetric => Ok(from.as_any_box().downcast::<PerfCompositeMetric>()?),
            StructType::PerfCounterInfo => Ok(from.as_any_box().downcast::<PerfCounterInfo>()?),
            StructType::PerformanceManagerCounterLevelMapping => Ok(from.as_any_box().downcast::<PerformanceManagerCounterLevelMapping>()?),
            StructType::PerfEntityMetricBase => Ok(from.as_any_box().downcast::<PerfEntityMetricBase>()?),
            StructType::PerfEntityMetric => Ok(from.as_any_box().downcast::<PerfEntityMetric>()?),
            StructType::PerfEntityMetricCsv => Ok(from.as_any_box().downcast::<PerfEntityMetricCsv>()?),
            StructType::PerfMetricId => Ok(from.as_any_box().downcast::<PerfMetricId>()?),
            StructType::PerfMetricSeries => Ok(from.as_any_box().downcast::<PerfMetricSeries>()?),
            StructType::PerfMetricIntSeries => Ok(from.as_any_box().downcast::<PerfMetricIntSeries>()?),
            StructType::PerfMetricSeriesCsv => Ok(from.as_any_box().downcast::<PerfMetricSeriesCsv>()?),
            StructType::PerfProviderSummary => Ok(from.as_any_box().downcast::<PerfProviderSummary>()?),
            StructType::PerfQuerySpec => Ok(from.as_any_box().downcast::<PerfQuerySpec>()?),
            StructType::PerfSampleInfo => Ok(from.as_any_box().downcast::<PerfSampleInfo>()?),
            StructType::PrivilegePolicyDef => Ok(from.as_any_box().downcast::<PrivilegePolicyDef>()?),
            StructType::ResourceAllocationInfo => Ok(from.as_any_box().downcast::<ResourceAllocationInfo>()?),
            StructType::ResourceAllocationOption => Ok(from.as_any_box().downcast::<ResourceAllocationOption>()?),
            StructType::ResourceConfigOption => Ok(from.as_any_box().downcast::<ResourceConfigOption>()?),
            StructType::ResourceConfigSpec => Ok(from.as_any_box().downcast::<ResourceConfigSpec>()?),
            StructType::DatabaseSizeEstimate => Ok(from.as_any_box().downcast::<DatabaseSizeEstimate>()?),
            StructType::DatabaseSizeParam => Ok(from.as_any_box().downcast::<DatabaseSizeParam>()?),
            StructType::InventoryDescription => Ok(from.as_any_box().downcast::<InventoryDescription>()?),
            StructType::PerformanceStatisticsDescription => Ok(from.as_any_box().downcast::<PerformanceStatisticsDescription>()?),
            StructType::ResourcePoolResourceUsage => Ok(from.as_any_box().downcast::<ResourcePoolResourceUsage>()?),
            StructType::ResourcePoolRuntimeInfo => Ok(from.as_any_box().downcast::<ResourcePoolRuntimeInfo>()?),
            StructType::ResourcePoolSummary => Ok(from.as_any_box().downcast::<ResourcePoolSummary>()?),
            StructType::VirtualAppSummary => Ok(from.as_any_box().downcast::<VirtualAppSummary>()?),
            StructType::ResourcePoolQuickStats => Ok(from.as_any_box().downcast::<ResourcePoolQuickStats>()?),
            StructType::SddcBase => Ok(from.as_any_box().downcast::<SddcBase>()?),
            StructType::SelectionSet => Ok(from.as_any_box().downcast::<SelectionSet>()?),
            StructType::DvPortgroupSelection => Ok(from.as_any_box().downcast::<DvPortgroupSelection>()?),
            StructType::DvsSelection => Ok(from.as_any_box().downcast::<DvsSelection>()?),
            StructType::HostVMotionCompatibility => Ok(from.as_any_box().downcast::<HostVMotionCompatibility>()?),
            StructType::ProductComponentInfo => Ok(from.as_any_box().downcast::<ProductComponentInfo>()?),
            StructType::ServiceContent => Ok(from.as_any_box().downcast::<ServiceContent>()?),
            StructType::ServiceLocator => Ok(from.as_any_box().downcast::<ServiceLocator>()?),
            StructType::ServiceLocatorCredential => Ok(from.as_any_box().downcast::<ServiceLocatorCredential>()?),
            StructType::ServiceLocatorNamePassword => Ok(from.as_any_box().downcast::<ServiceLocatorNamePassword>()?),
            StructType::ServiceLocatorSamlCredential => Ok(from.as_any_box().downcast::<ServiceLocatorSamlCredential>()?),
            StructType::ServiceManagerServiceInfo => Ok(from.as_any_box().downcast::<ServiceManagerServiceInfo>()?),
            StructType::SessionManagerGenericServiceTicket => Ok(from.as_any_box().downcast::<SessionManagerGenericServiceTicket>()?),
            StructType::SessionManagerLocalTicket => Ok(from.as_any_box().downcast::<SessionManagerLocalTicket>()?),
            StructType::SessionManagerServiceRequestSpec => Ok(from.as_any_box().downcast::<SessionManagerServiceRequestSpec>()?),
            StructType::SessionManagerHttpServiceRequestSpec => Ok(from.as_any_box().downcast::<SessionManagerHttpServiceRequestSpec>()?),
            StructType::SessionManagerVmomiServiceRequestSpec => Ok(from.as_any_box().downcast::<SessionManagerVmomiServiceRequestSpec>()?),
            StructType::SharesInfo => Ok(from.as_any_box().downcast::<SharesInfo>()?),
            StructType::SharesOption => Ok(from.as_any_box().downcast::<SharesOption>()?),
            StructType::SiteInfo => Ok(from.as_any_box().downcast::<SiteInfo>()?),
            StructType::StoragePodSummary => Ok(from.as_any_box().downcast::<StoragePodSummary>()?),
            StructType::StorageIoAllocationInfo => Ok(from.as_any_box().downcast::<StorageIoAllocationInfo>()?),
            StructType::StorageIoAllocationOption => Ok(from.as_any_box().downcast::<StorageIoAllocationOption>()?),
            StructType::StorageIormInfo => Ok(from.as_any_box().downcast::<StorageIormInfo>()?),
            StructType::StorageIormConfigOption => Ok(from.as_any_box().downcast::<StorageIormConfigOption>()?),
            StructType::StorageIormConfigSpec => Ok(from.as_any_box().downcast::<StorageIormConfigSpec>()?),
            StructType::PodStorageDrsEntry => Ok(from.as_any_box().downcast::<PodStorageDrsEntry>()?),
            StructType::StoragePerformanceSummary => Ok(from.as_any_box().downcast::<StoragePerformanceSummary>()?),
            StructType::StorageResourceManagerStorageProfileStatistics => Ok(from.as_any_box().downcast::<StorageResourceManagerStorageProfileStatistics>()?),
            StructType::Tag => Ok(from.as_any_box().downcast::<Tag>()?),
            StructType::TaskDescription => Ok(from.as_any_box().downcast::<TaskDescription>()?),
            StructType::TaskFilterSpec => Ok(from.as_any_box().downcast::<TaskFilterSpec>()?),
            StructType::TaskFilterSpecByEntity => Ok(from.as_any_box().downcast::<TaskFilterSpecByEntity>()?),
            StructType::TaskFilterSpecByTime => Ok(from.as_any_box().downcast::<TaskFilterSpecByTime>()?),
            StructType::TaskFilterSpecByUsername => Ok(from.as_any_box().downcast::<TaskFilterSpecByUsername>()?),
            StructType::TaskInfo => Ok(from.as_any_box().downcast::<TaskInfo>()?),
            StructType::TaskReason => Ok(from.as_any_box().downcast::<TaskReason>()?),
            StructType::TaskReasonAlarm => Ok(from.as_any_box().downcast::<TaskReasonAlarm>()?),
            StructType::TaskReasonSchedule => Ok(from.as_any_box().downcast::<TaskReasonSchedule>()?),
            StructType::TaskReasonSystem => Ok(from.as_any_box().downcast::<TaskReasonSystem>()?),
            StructType::TaskReasonUser => Ok(from.as_any_box().downcast::<TaskReasonUser>()?),
            StructType::UpdateVirtualMachineFilesResult => Ok(from.as_any_box().downcast::<UpdateVirtualMachineFilesResult>()?),
            StructType::UpdateVirtualMachineFilesResultFailedVmFileInfo => Ok(from.as_any_box().downcast::<UpdateVirtualMachineFilesResultFailedVmFileInfo>()?),
            StructType::UserSearchResult => Ok(from.as_any_box().downcast::<UserSearchResult>()?),
            StructType::PosixUserSearchResult => Ok(from.as_any_box().downcast::<PosixUserSearchResult>()?),
            StructType::UserSession => Ok(from.as_any_box().downcast::<UserSession>()?),
            StructType::VVolVmConfigFileUpdateResult => Ok(from.as_any_box().downcast::<VVolVmConfigFileUpdateResult>()?),
            StructType::VVolVmConfigFileUpdateResultFailedVmConfigFileInfo => Ok(from.as_any_box().downcast::<VVolVmConfigFileUpdateResultFailedVmConfigFileInfo>()?),
            StructType::VasaStorageArray => Ok(from.as_any_box().downcast::<VasaStorageArray>()?),
            StructType::VasaStorageArrayDiscoveryFcTransport => Ok(from.as_any_box().downcast::<VasaStorageArrayDiscoveryFcTransport>()?),
            StructType::VasaStorageArrayDiscoveryIpTransport => Ok(from.as_any_box().downcast::<VasaStorageArrayDiscoveryIpTransport>()?),
            StructType::VasaStorageArrayDiscoverySvcInfo => Ok(from.as_any_box().downcast::<VasaStorageArrayDiscoverySvcInfo>()?),
            StructType::VasaProviderContainerSpec => Ok(from.as_any_box().downcast::<VasaProviderContainerSpec>()?),
            StructType::VimVasaProvider => Ok(from.as_any_box().downcast::<VimVasaProvider>()?),
            StructType::VimVasaProviderStatePerArray => Ok(from.as_any_box().downcast::<VimVasaProviderStatePerArray>()?),
            StructType::VimVasaProviderVirtualHostConfig => Ok(from.as_any_box().downcast::<VimVasaProviderVirtualHostConfig>()?),
            StructType::VimVasaProviderInfo => Ok(from.as_any_box().downcast::<VimVasaProviderInfo>()?),
            StructType::VirtualAppLinkInfo => Ok(from.as_any_box().downcast::<VirtualAppLinkInfo>()?),
            StructType::VirtualDiskSpec => Ok(from.as_any_box().downcast::<VirtualDiskSpec>()?),
            StructType::DeviceBackedVirtualDiskSpec => Ok(from.as_any_box().downcast::<DeviceBackedVirtualDiskSpec>()?),
            StructType::FileBackedVirtualDiskSpec => Ok(from.as_any_box().downcast::<FileBackedVirtualDiskSpec>()?),
            StructType::SeSparseVirtualDiskSpec => Ok(from.as_any_box().downcast::<SeSparseVirtualDiskSpec>()?),
            StructType::VirtualMachineConnection => Ok(from.as_any_box().downcast::<VirtualMachineConnection>()?),
            StructType::VirtualMachineMksConnection => Ok(from.as_any_box().downcast::<VirtualMachineMksConnection>()?),
            StructType::DiskChangeInfo => Ok(from.as_any_box().downcast::<DiskChangeInfo>()?),
            StructType::DiskChangeExtent => Ok(from.as_any_box().downcast::<DiskChangeExtent>()?),
            StructType::VirtualMachineDisplayTopology => Ok(from.as_any_box().downcast::<VirtualMachineDisplayTopology>()?),
            StructType::VirtualMachineMksTicket => Ok(from.as_any_box().downcast::<VirtualMachineMksTicket>()?),
            StructType::StorageRequirement => Ok(from.as_any_box().downcast::<StorageRequirement>()?),
            StructType::VirtualMachineTicket => Ok(from.as_any_box().downcast::<VirtualMachineTicket>()?),
            StructType::VirtualMachineWipeResult => Ok(from.as_any_box().downcast::<VirtualMachineWipeResult>()?),
            StructType::VsanUpgradeSystemNetworkPartitionInfo => Ok(from.as_any_box().downcast::<VsanUpgradeSystemNetworkPartitionInfo>()?),
            StructType::VsanUpgradeSystemPreflightCheckIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemPreflightCheckIssue>()?),
            StructType::VsanUpgradeSystemApiBrokenIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemApiBrokenIssue>()?),
            StructType::VsanUpgradeSystemAutoClaimEnabledOnHostsIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemAutoClaimEnabledOnHostsIssue>()?),
            StructType::VsanUpgradeSystemHostsDisconnectedIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemHostsDisconnectedIssue>()?),
            StructType::VsanUpgradeSystemMissingHostsInClusterIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemMissingHostsInClusterIssue>()?),
            StructType::VsanUpgradeSystemNetworkPartitionIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemNetworkPartitionIssue>()?),
            StructType::VsanUpgradeSystemNotEnoughFreeCapacityIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemNotEnoughFreeCapacityIssue>()?),
            StructType::VsanUpgradeSystemRogueHostsInClusterIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemRogueHostsInClusterIssue>()?),
            StructType::VsanUpgradeSystemV2ObjectsPresentDuringDowngradeIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemV2ObjectsPresentDuringDowngradeIssue>()?),
            StructType::VsanUpgradeSystemWrongEsxVersionIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemWrongEsxVersionIssue>()?),
            StructType::VsanUpgradeSystemPreflightCheckResult => Ok(from.as_any_box().downcast::<VsanUpgradeSystemPreflightCheckResult>()?),
            StructType::VsanUpgradeSystemUpgradeHistoryItem => Ok(from.as_any_box().downcast::<VsanUpgradeSystemUpgradeHistoryItem>()?),
            StructType::VsanUpgradeSystemUpgradeHistoryDiskGroupOp => Ok(from.as_any_box().downcast::<VsanUpgradeSystemUpgradeHistoryDiskGroupOp>()?),
            StructType::VsanUpgradeSystemUpgradeHistoryPreflightFail => Ok(from.as_any_box().downcast::<VsanUpgradeSystemUpgradeHistoryPreflightFail>()?),
            StructType::VsanUpgradeSystemUpgradeStatus => Ok(from.as_any_box().downcast::<VsanUpgradeSystemUpgradeStatus>()?),
            StructType::Action => Ok(from.as_any_box().downcast::<Action>()?),
            StructType::CreateTaskAction => Ok(from.as_any_box().downcast::<CreateTaskAction>()?),
            StructType::MethodAction => Ok(from.as_any_box().downcast::<MethodAction>()?),
            StructType::RunScriptAction => Ok(from.as_any_box().downcast::<RunScriptAction>()?),
            StructType::SendEmailAction => Ok(from.as_any_box().downcast::<SendEmailAction>()?),
            StructType::SendSnmpAction => Ok(from.as_any_box().downcast::<SendSnmpAction>()?),
            StructType::MethodActionArgument => Ok(from.as_any_box().downcast::<MethodActionArgument>()?),
            StructType::AlarmAction => Ok(from.as_any_box().downcast::<AlarmAction>()?),
            StructType::AlarmTriggeringAction => Ok(from.as_any_box().downcast::<AlarmTriggeringAction>()?),
            StructType::GroupAlarmAction => Ok(from.as_any_box().downcast::<GroupAlarmAction>()?),
            StructType::AlarmDescription => Ok(from.as_any_box().downcast::<AlarmDescription>()?),
            StructType::AlarmExpression => Ok(from.as_any_box().downcast::<AlarmExpression>()?),
            StructType::AndAlarmExpression => Ok(from.as_any_box().downcast::<AndAlarmExpression>()?),
            StructType::EventAlarmExpression => Ok(from.as_any_box().downcast::<EventAlarmExpression>()?),
            StructType::MetricAlarmExpression => Ok(from.as_any_box().downcast::<MetricAlarmExpression>()?),
            StructType::OrAlarmExpression => Ok(from.as_any_box().downcast::<OrAlarmExpression>()?),
            StructType::StateAlarmExpression => Ok(from.as_any_box().downcast::<StateAlarmExpression>()?),
            StructType::AlarmFilterSpec => Ok(from.as_any_box().downcast::<AlarmFilterSpec>()?),
            StructType::AlarmSetting => Ok(from.as_any_box().downcast::<AlarmSetting>()?),
            StructType::AlarmSpec => Ok(from.as_any_box().downcast::<AlarmSpec>()?),
            StructType::AlarmInfo => Ok(from.as_any_box().downcast::<AlarmInfo>()?),
            StructType::AlarmState => Ok(from.as_any_box().downcast::<AlarmState>()?),
            StructType::AlarmTriggeringActionTransitionSpec => Ok(from.as_any_box().downcast::<AlarmTriggeringActionTransitionSpec>()?),
            StructType::EventAlarmExpressionComparison => Ok(from.as_any_box().downcast::<EventAlarmExpressionComparison>()?),
            StructType::ClusterAction => Ok(from.as_any_box().downcast::<ClusterAction>()?),
            StructType::ClusterClusterInitialPlacementAction => Ok(from.as_any_box().downcast::<ClusterClusterInitialPlacementAction>()?),
            StructType::ClusterHostInfraUpdateHaModeAction => Ok(from.as_any_box().downcast::<ClusterHostInfraUpdateHaModeAction>()?),
            StructType::ClusterHostPowerAction => Ok(from.as_any_box().downcast::<ClusterHostPowerAction>()?),
            StructType::ClusterInitialPlacementAction => Ok(from.as_any_box().downcast::<ClusterInitialPlacementAction>()?),
            StructType::ClusterMigrationAction => Ok(from.as_any_box().downcast::<ClusterMigrationAction>()?),
            StructType::PlacementAction => Ok(from.as_any_box().downcast::<PlacementAction>()?),
            StructType::HbrDiskMigrationAction => Ok(from.as_any_box().downcast::<HbrDiskMigrationAction>()?),
            StructType::StorageMigrationAction => Ok(from.as_any_box().downcast::<StorageMigrationAction>()?),
            StructType::StoragePlacementAction => Ok(from.as_any_box().downcast::<StoragePlacementAction>()?),
            StructType::ClusterActionHistory => Ok(from.as_any_box().downcast::<ClusterActionHistory>()?),
            StructType::ClusterAttemptedVmInfo => Ok(from.as_any_box().downcast::<ClusterAttemptedVmInfo>()?),
            StructType::ClusterConfigInfo => Ok(from.as_any_box().downcast::<ClusterConfigInfo>()?),
            StructType::ClusterConfigSpec => Ok(from.as_any_box().downcast::<ClusterConfigSpec>()?),
            StructType::ClusterCryptoConfigInfo => Ok(from.as_any_box().downcast::<ClusterCryptoConfigInfo>()?),
            StructType::ClusterDasAamNodeState => Ok(from.as_any_box().downcast::<ClusterDasAamNodeState>()?),
            StructType::ClusterDasAdmissionControlInfo => Ok(from.as_any_box().downcast::<ClusterDasAdmissionControlInfo>()?),
            StructType::ClusterFailoverHostAdmissionControlInfo => Ok(from.as_any_box().downcast::<ClusterFailoverHostAdmissionControlInfo>()?),
            StructType::ClusterFailoverLevelAdmissionControlInfo => Ok(from.as_any_box().downcast::<ClusterFailoverLevelAdmissionControlInfo>()?),
            StructType::ClusterFailoverResourcesAdmissionControlInfo => Ok(from.as_any_box().downcast::<ClusterFailoverResourcesAdmissionControlInfo>()?),
            StructType::ClusterDasAdmissionControlPolicy => Ok(from.as_any_box().downcast::<ClusterDasAdmissionControlPolicy>()?),
            StructType::ClusterFailoverHostAdmissionControlPolicy => Ok(from.as_any_box().downcast::<ClusterFailoverHostAdmissionControlPolicy>()?),
            StructType::ClusterFailoverLevelAdmissionControlPolicy => Ok(from.as_any_box().downcast::<ClusterFailoverLevelAdmissionControlPolicy>()?),
            StructType::ClusterFailoverResourcesAdmissionControlPolicy => Ok(from.as_any_box().downcast::<ClusterFailoverResourcesAdmissionControlPolicy>()?),
            StructType::ClusterDasAdvancedRuntimeInfo => Ok(from.as_any_box().downcast::<ClusterDasAdvancedRuntimeInfo>()?),
            StructType::ClusterDasFailoverLevelAdvancedRuntimeInfo => Ok(from.as_any_box().downcast::<ClusterDasFailoverLevelAdvancedRuntimeInfo>()?),
            StructType::DasHeartbeatDatastoreInfo => Ok(from.as_any_box().downcast::<DasHeartbeatDatastoreInfo>()?),
            StructType::ClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo => Ok(from.as_any_box().downcast::<ClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo>()?),
            StructType::ClusterDasConfigInfo => Ok(from.as_any_box().downcast::<ClusterDasConfigInfo>()?),
            StructType::ClusterDasData => Ok(from.as_any_box().downcast::<ClusterDasData>()?),
            StructType::ClusterDasDataSummary => Ok(from.as_any_box().downcast::<ClusterDasDataSummary>()?),
            StructType::ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots => Ok(from.as_any_box().downcast::<ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots>()?),
            StructType::ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo => Ok(from.as_any_box().downcast::<ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo>()?),
            StructType::ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots => Ok(from.as_any_box().downcast::<ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots>()?),
            StructType::ClusterDasFdmHostState => Ok(from.as_any_box().downcast::<ClusterDasFdmHostState>()?),
            StructType::ClusterDasHostInfo => Ok(from.as_any_box().downcast::<ClusterDasHostInfo>()?),
            StructType::ClusterDasAamHostInfo => Ok(from.as_any_box().downcast::<ClusterDasAamHostInfo>()?),
            StructType::ClusterDasHostRecommendation => Ok(from.as_any_box().downcast::<ClusterDasHostRecommendation>()?),
            StructType::ClusterDasVmConfigInfo => Ok(from.as_any_box().downcast::<ClusterDasVmConfigInfo>()?),
            StructType::ClusterDasVmSettings => Ok(from.as_any_box().downcast::<ClusterDasVmSettings>()?),
            StructType::ClusterDpmConfigInfo => Ok(from.as_any_box().downcast::<ClusterDpmConfigInfo>()?),
            StructType::ClusterDpmHostConfigInfo => Ok(from.as_any_box().downcast::<ClusterDpmHostConfigInfo>()?),
            StructType::ClusterDrsConfigInfo => Ok(from.as_any_box().downcast::<ClusterDrsConfigInfo>()?),
            StructType::ClusterDrsFaults => Ok(from.as_any_box().downcast::<ClusterDrsFaults>()?),
            StructType::ClusterDrsFaultsFaultsByVm => Ok(from.as_any_box().downcast::<ClusterDrsFaultsFaultsByVm>()?),
            StructType::ClusterDrsFaultsFaultsByVirtualDisk => Ok(from.as_any_box().downcast::<ClusterDrsFaultsFaultsByVirtualDisk>()?),
            StructType::ClusterDrsMigration => Ok(from.as_any_box().downcast::<ClusterDrsMigration>()?),
            StructType::ClusterDrsRecommendation => Ok(from.as_any_box().downcast::<ClusterDrsRecommendation>()?),
            StructType::ClusterDrsVmConfigInfo => Ok(from.as_any_box().downcast::<ClusterDrsVmConfigInfo>()?),
            StructType::ClusterEvcManagerCheckResult => Ok(from.as_any_box().downcast::<ClusterEvcManagerCheckResult>()?),
            StructType::ClusterEvcManagerEvcState => Ok(from.as_any_box().downcast::<ClusterEvcManagerEvcState>()?),
            StructType::ClusterEnterMaintenanceResult => Ok(from.as_any_box().downcast::<ClusterEnterMaintenanceResult>()?),
            StructType::ClusterFailoverHostAdmissionControlInfoHostStatus => Ok(from.as_any_box().downcast::<ClusterFailoverHostAdmissionControlInfoHostStatus>()?),
            StructType::ClusterGroupInfo => Ok(from.as_any_box().downcast::<ClusterGroupInfo>()?),
            StructType::ClusterHostGroup => Ok(from.as_any_box().downcast::<ClusterHostGroup>()?),
            StructType::ClusterVmGroup => Ok(from.as_any_box().downcast::<ClusterVmGroup>()?),
            StructType::ClusterHostRecommendation => Ok(from.as_any_box().downcast::<ClusterHostRecommendation>()?),
            StructType::ClusterInfraUpdateHaConfigInfo => Ok(from.as_any_box().downcast::<ClusterInfraUpdateHaConfigInfo>()?),
            StructType::ClusterNotAttemptedVmInfo => Ok(from.as_any_box().downcast::<ClusterNotAttemptedVmInfo>()?),
            StructType::ClusterOrchestrationInfo => Ok(from.as_any_box().downcast::<ClusterOrchestrationInfo>()?),
            StructType::PlacementResult => Ok(from.as_any_box().downcast::<PlacementResult>()?),
            StructType::PlacementSpec => Ok(from.as_any_box().downcast::<PlacementSpec>()?),
            StructType::ClusterPowerOnVmResult => Ok(from.as_any_box().downcast::<ClusterPowerOnVmResult>()?),
            StructType::ClusterPreemptibleVmPairInfo => Ok(from.as_any_box().downcast::<ClusterPreemptibleVmPairInfo>()?),
            StructType::ClusterProactiveDrsConfigInfo => Ok(from.as_any_box().downcast::<ClusterProactiveDrsConfigInfo>()?),
            StructType::ClusterRecommendation => Ok(from.as_any_box().downcast::<ClusterRecommendation>()?),
            StructType::ClusterResourceUsageSummary => Ok(from.as_any_box().downcast::<ClusterResourceUsageSummary>()?),
            StructType::ClusterRuleInfo => Ok(from.as_any_box().downcast::<ClusterRuleInfo>()?),
            StructType::ClusterAffinityRuleSpec => Ok(from.as_any_box().downcast::<ClusterAffinityRuleSpec>()?),
            StructType::ClusterAntiAffinityRuleSpec => Ok(from.as_any_box().downcast::<ClusterAntiAffinityRuleSpec>()?),
            StructType::ClusterDependencyRuleInfo => Ok(from.as_any_box().downcast::<ClusterDependencyRuleInfo>()?),
            StructType::ClusterVmHostRuleInfo => Ok(from.as_any_box().downcast::<ClusterVmHostRuleInfo>()?),
            StructType::VirtualDiskAntiAffinityRuleSpec => Ok(from.as_any_box().downcast::<VirtualDiskAntiAffinityRuleSpec>()?),
            StructType::VirtualDiskRuleSpec => Ok(from.as_any_box().downcast::<VirtualDiskRuleSpec>()?),
            StructType::ClusterSlotPolicy => Ok(from.as_any_box().downcast::<ClusterSlotPolicy>()?),
            StructType::ClusterFixedSizeSlotPolicy => Ok(from.as_any_box().downcast::<ClusterFixedSizeSlotPolicy>()?),
            StructType::ClusterSystemVMsConfigInfo => Ok(from.as_any_box().downcast::<ClusterSystemVMsConfigInfo>()?),
            StructType::ClusterSystemVMsConfigSpec => Ok(from.as_any_box().downcast::<ClusterSystemVMsConfigSpec>()?),
            StructType::ClusterUsageSummary => Ok(from.as_any_box().downcast::<ClusterUsageSummary>()?),
            StructType::ClusterVmComponentProtectionSettings => Ok(from.as_any_box().downcast::<ClusterVmComponentProtectionSettings>()?),
            StructType::ClusterVmOrchestrationInfo => Ok(from.as_any_box().downcast::<ClusterVmOrchestrationInfo>()?),
            StructType::ClusterVmReadiness => Ok(from.as_any_box().downcast::<ClusterVmReadiness>()?),
            StructType::ClusterVmToolsMonitoringSettings => Ok(from.as_any_box().downcast::<ClusterVmToolsMonitoringSettings>()?),
            StructType::DistributedVirtualPort => Ok(from.as_any_box().downcast::<DistributedVirtualPort>()?),
            StructType::DvPortConfigInfo => Ok(from.as_any_box().downcast::<DvPortConfigInfo>()?),
            StructType::DvPortConfigSpec => Ok(from.as_any_box().downcast::<DvPortConfigSpec>()?),
            StructType::DvsFilterParameter => Ok(from.as_any_box().downcast::<DvsFilterParameter>()?),
            StructType::DvsHostLocalPortInfo => Ok(from.as_any_box().downcast::<DvsHostLocalPortInfo>()?),
            StructType::DvPortStatus => Ok(from.as_any_box().downcast::<DvPortStatus>()?),
            StructType::DvPortSetting => Ok(from.as_any_box().downcast::<DvPortSetting>()?),
            StructType::VMwareDvsPortSetting => Ok(from.as_any_box().downcast::<VMwareDvsPortSetting>()?),
            StructType::DvPortState => Ok(from.as_any_box().downcast::<DvPortState>()?),
            StructType::DvPortgroupConfigInfo => Ok(from.as_any_box().downcast::<DvPortgroupConfigInfo>()?),
            StructType::DvPortgroupConfigSpec => Ok(from.as_any_box().downcast::<DvPortgroupConfigSpec>()?),
            StructType::DistributedVirtualPortgroupNsxPortgroupOperationResult => Ok(from.as_any_box().downcast::<DistributedVirtualPortgroupNsxPortgroupOperationResult>()?),
            StructType::DvPortgroupPolicy => Ok(from.as_any_box().downcast::<DvPortgroupPolicy>()?),
            StructType::VMwareDvsPortgroupPolicy => Ok(from.as_any_box().downcast::<VMwareDvsPortgroupPolicy>()?),
            StructType::DistributedVirtualPortgroupProblem => Ok(from.as_any_box().downcast::<DistributedVirtualPortgroupProblem>()?),
            StructType::DistributedVirtualPortgroupInfo => Ok(from.as_any_box().downcast::<DistributedVirtualPortgroupInfo>()?),
            StructType::DistributedVirtualSwitchInfo => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchInfo>()?),
            StructType::DistributedVirtualSwitchManagerCompatibilityResult => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchManagerCompatibilityResult>()?),
            StructType::DvsManagerDvsConfigTarget => Ok(from.as_any_box().downcast::<DvsManagerDvsConfigTarget>()?),
            StructType::DistributedVirtualSwitchManagerDvsProductSpec => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchManagerDvsProductSpec>()?),
            StructType::DistributedVirtualSwitchManagerHostContainer => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchManagerHostContainer>()?),
            StructType::DistributedVirtualSwitchManagerHostDvsFilterSpec => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchManagerHostDvsFilterSpec>()?),
            StructType::DistributedVirtualSwitchManagerHostArrayFilter => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchManagerHostArrayFilter>()?),
            StructType::DistributedVirtualSwitchManagerHostContainerFilter => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchManagerHostContainerFilter>()?),
            StructType::DistributedVirtualSwitchManagerHostDvsMembershipFilter => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchManagerHostDvsMembershipFilter>()?),
            StructType::DistributedVirtualSwitchManagerImportResult => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchManagerImportResult>()?),
            StructType::DvsManagerPhysicalNicsList => Ok(from.as_any_box().downcast::<DvsManagerPhysicalNicsList>()?),
            StructType::EntityBackup => Ok(from.as_any_box().downcast::<EntityBackup>()?),
            StructType::EntityBackupConfig => Ok(from.as_any_box().downcast::<EntityBackupConfig>()?),
            StructType::DistributedVirtualSwitchHostMember => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchHostMember>()?),
            StructType::DistributedVirtualSwitchHostMemberBacking => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchHostMemberBacking>()?),
            StructType::DistributedVirtualSwitchHostMemberPnicBacking => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchHostMemberPnicBacking>()?),
            StructType::DistributedVirtualSwitchHostMemberConfigInfo => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchHostMemberConfigInfo>()?),
            StructType::DistributedVirtualSwitchHostMemberConfigSpec => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchHostMemberConfigSpec>()?),
            StructType::HostMemberHealthCheckResult => Ok(from.as_any_box().downcast::<HostMemberHealthCheckResult>()?),
            StructType::HostMemberUplinkHealthCheckResult => Ok(from.as_any_box().downcast::<HostMemberUplinkHealthCheckResult>()?),
            StructType::VMwareDvsMtuHealthCheckResult => Ok(from.as_any_box().downcast::<VMwareDvsMtuHealthCheckResult>()?),
            StructType::VMwareDvsVlanHealthCheckResult => Ok(from.as_any_box().downcast::<VMwareDvsVlanHealthCheckResult>()?),
            StructType::VMwareDvsTeamingHealthCheckResult => Ok(from.as_any_box().downcast::<VMwareDvsTeamingHealthCheckResult>()?),
            StructType::DistributedVirtualSwitchHostMemberPnicSpec => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchHostMemberPnicSpec>()?),
            StructType::HostMemberRuntimeInfo => Ok(from.as_any_box().downcast::<HostMemberRuntimeInfo>()?),
            StructType::DistributedVirtualSwitchHostMemberRuntimeState => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchHostMemberRuntimeState>()?),
            StructType::DistributedVirtualSwitchHostMemberTransportZoneInfo => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchHostMemberTransportZoneInfo>()?),
            StructType::DistributedVirtualSwitchHostProductSpec => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchHostProductSpec>()?),
            StructType::DistributedVirtualSwitchKeyedOpaqueBlob => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchKeyedOpaqueBlob>()?),
            StructType::DistributedVirtualSwitchNetworkOffloadSpec => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchNetworkOffloadSpec>()?),
            StructType::DvsNetworkResourcePool => Ok(from.as_any_box().downcast::<DvsNetworkResourcePool>()?),
            StructType::DvsNetworkResourcePoolAllocationInfo => Ok(from.as_any_box().downcast::<DvsNetworkResourcePoolAllocationInfo>()?),
            StructType::DvsNetworkResourcePoolConfigSpec => Ok(from.as_any_box().downcast::<DvsNetworkResourcePoolConfigSpec>()?),
            StructType::DistributedVirtualSwitchPortConnectee => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchPortConnectee>()?),
            StructType::DistributedVirtualSwitchPortConnection => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchPortConnection>()?),
            StructType::DistributedVirtualSwitchPortCriteria => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchPortCriteria>()?),
            StructType::DistributedVirtualSwitchPortStatistics => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchPortStatistics>()?),
            StructType::DistributedVirtualSwitchProductSpec => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchProductSpec>()?),
            StructType::DvsTrafficRule => Ok(from.as_any_box().downcast::<DvsTrafficRule>()?),
            StructType::DvsNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsNetworkRuleAction>()?),
            StructType::DvsAcceptNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsAcceptNetworkRuleAction>()?),
            StructType::DvsCopyNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsCopyNetworkRuleAction>()?),
            StructType::DvsDropNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsDropNetworkRuleAction>()?),
            StructType::DvsGreEncapNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsGreEncapNetworkRuleAction>()?),
            StructType::DvsLogNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsLogNetworkRuleAction>()?),
            StructType::DvsMacRewriteNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsMacRewriteNetworkRuleAction>()?),
            StructType::DvsPuntNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsPuntNetworkRuleAction>()?),
            StructType::DvsRateLimitNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsRateLimitNetworkRuleAction>()?),
            StructType::DvsUpdateTagNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsUpdateTagNetworkRuleAction>()?),
            StructType::DvsNetworkRuleQualifier => Ok(from.as_any_box().downcast::<DvsNetworkRuleQualifier>()?),
            StructType::DvsIpNetworkRuleQualifier => Ok(from.as_any_box().downcast::<DvsIpNetworkRuleQualifier>()?),
            StructType::DvsMacNetworkRuleQualifier => Ok(from.as_any_box().downcast::<DvsMacNetworkRuleQualifier>()?),
            StructType::DvsSystemTrafficNetworkRuleQualifier => Ok(from.as_any_box().downcast::<DvsSystemTrafficNetworkRuleQualifier>()?),
            StructType::DvsTrafficRuleset => Ok(from.as_any_box().downcast::<DvsTrafficRuleset>()?),
            StructType::DvsVmVnicNetworkResourcePool => Ok(from.as_any_box().downcast::<DvsVmVnicNetworkResourcePool>()?),
            StructType::DvsVmVnicResourcePoolConfigSpec => Ok(from.as_any_box().downcast::<DvsVmVnicResourcePoolConfigSpec>()?),
            StructType::DvsVmVnicResourceAllocation => Ok(from.as_any_box().downcast::<DvsVmVnicResourceAllocation>()?),
            StructType::DvsVmVnicNetworkResourcePoolRuntimeInfo => Ok(from.as_any_box().downcast::<DvsVmVnicNetworkResourcePoolRuntimeInfo>()?),
            StructType::DvsVnicAllocatedResource => Ok(from.as_any_box().downcast::<DvsVnicAllocatedResource>()?),
            StructType::VMwareDvsDpuCapability => Ok(from.as_any_box().downcast::<VMwareDvsDpuCapability>()?),
            StructType::VMwareIpfixConfig => Ok(from.as_any_box().downcast::<VMwareIpfixConfig>()?),
            StructType::VMwareDvsIpfixCapability => Ok(from.as_any_box().downcast::<VMwareDvsIpfixCapability>()?),
            StructType::VMwareDvsLacpCapability => Ok(from.as_any_box().downcast::<VMwareDvsLacpCapability>()?),
            StructType::VMwareDvsLacpGroupConfig => Ok(from.as_any_box().downcast::<VMwareDvsLacpGroupConfig>()?),
            StructType::VMwareDvsLacpGroupSpec => Ok(from.as_any_box().downcast::<VMwareDvsLacpGroupSpec>()?),
            StructType::VMwareDvsLagIpfixConfig => Ok(from.as_any_box().downcast::<VMwareDvsLagIpfixConfig>()?),
            StructType::VMwareDvsLagVlanConfig => Ok(from.as_any_box().downcast::<VMwareDvsLagVlanConfig>()?),
            StructType::VMwareDvsMtuCapability => Ok(from.as_any_box().downcast::<VMwareDvsMtuCapability>()?),
            StructType::VMwareDvsPvlanConfigSpec => Ok(from.as_any_box().downcast::<VMwareDvsPvlanConfigSpec>()?),
            StructType::VMwareDvsPvlanMapEntry => Ok(from.as_any_box().downcast::<VMwareDvsPvlanMapEntry>()?),
            StructType::VMwareDvsVspanConfigSpec => Ok(from.as_any_box().downcast::<VMwareDvsVspanConfigSpec>()?),
            StructType::VMwareDvsVspanCapability => Ok(from.as_any_box().downcast::<VMwareDvsVspanCapability>()?),
            StructType::VMwareVspanPort => Ok(from.as_any_box().downcast::<VMwareVspanPort>()?),
            StructType::VMwareVspanSession => Ok(from.as_any_box().downcast::<VMwareVspanSession>()?),
            StructType::CryptoKeyId => Ok(from.as_any_box().downcast::<CryptoKeyId>()?),
            StructType::CryptoKeyPlain => Ok(from.as_any_box().downcast::<CryptoKeyPlain>()?),
            StructType::CryptoKeyResult => Ok(from.as_any_box().downcast::<CryptoKeyResult>()?),
            StructType::CryptoManagerHostKeyStatus => Ok(from.as_any_box().downcast::<CryptoManagerHostKeyStatus>()?),
            StructType::CryptoManagerKmipCertSignRequest => Ok(from.as_any_box().downcast::<CryptoManagerKmipCertSignRequest>()?),
            StructType::CryptoManagerKmipCertificateInfo => Ok(from.as_any_box().downcast::<CryptoManagerKmipCertificateInfo>()?),
            StructType::CryptoManagerKmipClusterStatus => Ok(from.as_any_box().downcast::<CryptoManagerKmipClusterStatus>()?),
            StructType::CryptoManagerKmipCryptoKeyStatus => Ok(from.as_any_box().downcast::<CryptoManagerKmipCryptoKeyStatus>()?),
            StructType::CryptoManagerKmipCustomAttributeSpec => Ok(from.as_any_box().downcast::<CryptoManagerKmipCustomAttributeSpec>()?),
            StructType::CryptoManagerKmipServerCertInfo => Ok(from.as_any_box().downcast::<CryptoManagerKmipServerCertInfo>()?),
            StructType::CryptoManagerKmipServerStatus => Ok(from.as_any_box().downcast::<CryptoManagerKmipServerStatus>()?),
            StructType::CryptoSpec => Ok(from.as_any_box().downcast::<CryptoSpec>()?),
            StructType::CryptoSpecDecrypt => Ok(from.as_any_box().downcast::<CryptoSpecDecrypt>()?),
            StructType::CryptoSpecDeepRecrypt => Ok(from.as_any_box().downcast::<CryptoSpecDeepRecrypt>()?),
            StructType::CryptoSpecEncrypt => Ok(from.as_any_box().downcast::<CryptoSpecEncrypt>()?),
            StructType::CryptoSpecNoOp => Ok(from.as_any_box().downcast::<CryptoSpecNoOp>()?),
            StructType::CryptoSpecRegister => Ok(from.as_any_box().downcast::<CryptoSpecRegister>()?),
            StructType::CryptoSpecShallowRecrypt => Ok(from.as_any_box().downcast::<CryptoSpecShallowRecrypt>()?),
            StructType::KeyProviderId => Ok(from.as_any_box().downcast::<KeyProviderId>()?),
            StructType::KmipClusterInfo => Ok(from.as_any_box().downcast::<KmipClusterInfo>()?),
            StructType::KmipServerInfo => Ok(from.as_any_box().downcast::<KmipServerInfo>()?),
            StructType::KmipServerSpec => Ok(from.as_any_box().downcast::<KmipServerSpec>()?),
            StructType::KmipServerStatus => Ok(from.as_any_box().downcast::<KmipServerStatus>()?),
            StructType::ChangesInfoEventArgument => Ok(from.as_any_box().downcast::<ChangesInfoEventArgument>()?),
            StructType::DvsOutOfSyncHostArgument => Ok(from.as_any_box().downcast::<DvsOutOfSyncHostArgument>()?),
            StructType::Event => Ok(from.as_any_box().downcast::<Event>()?),
            StructType::EventArgument => Ok(from.as_any_box().downcast::<EventArgument>()?),
            StructType::EntityEventArgument => Ok(from.as_any_box().downcast::<EntityEventArgument>()?),
            StructType::AlarmEventArgument => Ok(from.as_any_box().downcast::<AlarmEventArgument>()?),
            StructType::ComputeResourceEventArgument => Ok(from.as_any_box().downcast::<ComputeResourceEventArgument>()?),
            StructType::DatacenterEventArgument => Ok(from.as_any_box().downcast::<DatacenterEventArgument>()?),
            StructType::DatastoreEventArgument => Ok(from.as_any_box().downcast::<DatastoreEventArgument>()?),
            StructType::DvsEventArgument => Ok(from.as_any_box().downcast::<DvsEventArgument>()?),
            StructType::FolderEventArgument => Ok(from.as_any_box().downcast::<FolderEventArgument>()?),
            StructType::HostEventArgument => Ok(from.as_any_box().downcast::<HostEventArgument>()?),
            StructType::ManagedEntityEventArgument => Ok(from.as_any_box().downcast::<ManagedEntityEventArgument>()?),
            StructType::NetworkEventArgument => Ok(from.as_any_box().downcast::<NetworkEventArgument>()?),
            StructType::ResourcePoolEventArgument => Ok(from.as_any_box().downcast::<ResourcePoolEventArgument>()?),
            StructType::ScheduledTaskEventArgument => Ok(from.as_any_box().downcast::<ScheduledTaskEventArgument>()?),
            StructType::VmEventArgument => Ok(from.as_any_box().downcast::<VmEventArgument>()?),
            StructType::ProfileEventArgument => Ok(from.as_any_box().downcast::<ProfileEventArgument>()?),
            StructType::RoleEventArgument => Ok(from.as_any_box().downcast::<RoleEventArgument>()?),
            StructType::EventDescription => Ok(from.as_any_box().downcast::<EventDescription>()?),
            StructType::EventArgDesc => Ok(from.as_any_box().downcast::<EventArgDesc>()?),
            StructType::EventDescriptionEventDetail => Ok(from.as_any_box().downcast::<EventDescriptionEventDetail>()?),
            StructType::EventFilterSpec => Ok(from.as_any_box().downcast::<EventFilterSpec>()?),
            StructType::EventFilterSpecByEntity => Ok(from.as_any_box().downcast::<EventFilterSpecByEntity>()?),
            StructType::EventFilterSpecByTime => Ok(from.as_any_box().downcast::<EventFilterSpecByTime>()?),
            StructType::EventFilterSpecByUsername => Ok(from.as_any_box().downcast::<EventFilterSpecByUsername>()?),
            StructType::ExtendedEventPair => Ok(from.as_any_box().downcast::<ExtendedEventPair>()?),
            StructType::VnicPortArgument => Ok(from.as_any_box().downcast::<VnicPortArgument>()?),
            StructType::ExtExtendedProductInfo => Ok(from.as_any_box().downcast::<ExtExtendedProductInfo>()?),
            StructType::ManagedByInfo => Ok(from.as_any_box().downcast::<ManagedByInfo>()?),
            StructType::ExtManagedEntityInfo => Ok(from.as_any_box().downcast::<ExtManagedEntityInfo>()?),
            StructType::ExtSolutionManagerInfo => Ok(from.as_any_box().downcast::<ExtSolutionManagerInfo>()?),
            StructType::ExtSolutionManagerInfoTabInfo => Ok(from.as_any_box().downcast::<ExtSolutionManagerInfoTabInfo>()?),
            StructType::AnswerFileUpdateFailure => Ok(from.as_any_box().downcast::<AnswerFileUpdateFailure>()?),
            StructType::ConflictingConfigurationConfig => Ok(from.as_any_box().downcast::<ConflictingConfigurationConfig>()?),
            StructType::DatacenterMismatchArgument => Ok(from.as_any_box().downcast::<DatacenterMismatchArgument>()?),
            StructType::DvsApplyOperationFaultFaultOnObject => Ok(from.as_any_box().downcast::<DvsApplyOperationFaultFaultOnObject>()?),
            StructType::DvsOperationBulkFaultFaultOnHost => Ok(from.as_any_box().downcast::<DvsOperationBulkFaultFaultOnHost>()?),
            StructType::ImportOperationBulkFaultFaultOnImport => Ok(from.as_any_box().downcast::<ImportOperationBulkFaultFaultOnImport>()?),
            StructType::MultipleCertificatesVerifyFaultThumbprintData => Ok(from.as_any_box().downcast::<MultipleCertificatesVerifyFaultThumbprintData>()?),
            StructType::NoPermissionEntityPrivileges => Ok(from.as_any_box().downcast::<NoPermissionEntityPrivileges>()?),
            StructType::ProfileUpdateFailedUpdateFailure => Ok(from.as_any_box().downcast::<ProfileUpdateFailedUpdateFailure>()?),
            StructType::HostActiveDirectory => Ok(from.as_any_box().downcast::<HostActiveDirectory>()?),
            StructType::HostActiveDirectorySpec => Ok(from.as_any_box().downcast::<HostActiveDirectorySpec>()?),
            StructType::HostAssignableHardwareBinding => Ok(from.as_any_box().downcast::<HostAssignableHardwareBinding>()?),
            StructType::HostAssignableHardwareConfig => Ok(from.as_any_box().downcast::<HostAssignableHardwareConfig>()?),
            StructType::HostAssignableHardwareConfigAttributeOverride => Ok(from.as_any_box().downcast::<HostAssignableHardwareConfigAttributeOverride>()?),
            StructType::HostAuthenticationManagerInfo => Ok(from.as_any_box().downcast::<HostAuthenticationManagerInfo>()?),
            StructType::HostAuthenticationStoreInfo => Ok(from.as_any_box().downcast::<HostAuthenticationStoreInfo>()?),
            StructType::HostDirectoryStoreInfo => Ok(from.as_any_box().downcast::<HostDirectoryStoreInfo>()?),
            StructType::HostActiveDirectoryInfo => Ok(from.as_any_box().downcast::<HostActiveDirectoryInfo>()?),
            StructType::HostLocalAuthenticationInfo => Ok(from.as_any_box().downcast::<HostLocalAuthenticationInfo>()?),
            StructType::AutoStartPowerInfo => Ok(from.as_any_box().downcast::<AutoStartPowerInfo>()?),
            StructType::HostAutoStartManagerConfig => Ok(from.as_any_box().downcast::<HostAutoStartManagerConfig>()?),
            StructType::AutoStartDefaults => Ok(from.as_any_box().downcast::<AutoStartDefaults>()?),
            StructType::HostBiosInfo => Ok(from.as_any_box().downcast::<HostBiosInfo>()?),
            StructType::HostBootDeviceInfo => Ok(from.as_any_box().downcast::<HostBootDeviceInfo>()?),
            StructType::HostBootDevice => Ok(from.as_any_box().downcast::<HostBootDevice>()?),
            StructType::HostCacheConfigurationInfo => Ok(from.as_any_box().downcast::<HostCacheConfigurationInfo>()?),
            StructType::HostCacheConfigurationSpec => Ok(from.as_any_box().downcast::<HostCacheConfigurationSpec>()?),
            StructType::HostCapability => Ok(from.as_any_box().downcast::<HostCapability>()?),
            StructType::HostCertificateManagerCertificateInfo => Ok(from.as_any_box().downcast::<HostCertificateManagerCertificateInfo>()?),
            StructType::HostCertificateManagerCertificateSpec => Ok(from.as_any_box().downcast::<HostCertificateManagerCertificateSpec>()?),
            StructType::HostConfigChange => Ok(from.as_any_box().downcast::<HostConfigChange>()?),
            StructType::HostConfigInfo => Ok(from.as_any_box().downcast::<HostConfigInfo>()?),
            StructType::HostConfigManager => Ok(from.as_any_box().downcast::<HostConfigManager>()?),
            StructType::HostConfigSpec => Ok(from.as_any_box().downcast::<HostConfigSpec>()?),
            StructType::HostConnectInfo => Ok(from.as_any_box().downcast::<HostConnectInfo>()?),
            StructType::HostDatastoreConnectInfo => Ok(from.as_any_box().downcast::<HostDatastoreConnectInfo>()?),
            StructType::HostDatastoreExistsConnectInfo => Ok(from.as_any_box().downcast::<HostDatastoreExistsConnectInfo>()?),
            StructType::HostDatastoreNameConflictConnectInfo => Ok(from.as_any_box().downcast::<HostDatastoreNameConflictConnectInfo>()?),
            StructType::HostLicenseConnectInfo => Ok(from.as_any_box().downcast::<HostLicenseConnectInfo>()?),
            StructType::HostConnectInfoNetworkInfo => Ok(from.as_any_box().downcast::<HostConnectInfoNetworkInfo>()?),
            StructType::HostNewNetworkConnectInfo => Ok(from.as_any_box().downcast::<HostNewNetworkConnectInfo>()?),
            StructType::HostConnectSpec => Ok(from.as_any_box().downcast::<HostConnectSpec>()?),
            StructType::HostCpuIdInfo => Ok(from.as_any_box().downcast::<HostCpuIdInfo>()?),
            StructType::HostCpuInfo => Ok(from.as_any_box().downcast::<HostCpuInfo>()?),
            StructType::HostCpuPackage => Ok(from.as_any_box().downcast::<HostCpuPackage>()?),
            StructType::HostCpuPowerManagementInfo => Ok(from.as_any_box().downcast::<HostCpuPowerManagementInfo>()?),
            StructType::HostHyperThreadScheduleInfo => Ok(from.as_any_box().downcast::<HostHyperThreadScheduleInfo>()?),
            StructType::HostDataTransportConnectionInfo => Ok(from.as_any_box().downcast::<HostDataTransportConnectionInfo>()?),
            StructType::HostNfcConnectionInfo => Ok(from.as_any_box().downcast::<HostNfcConnectionInfo>()?),
            StructType::FileInfo => Ok(from.as_any_box().downcast::<FileInfo>()?),
            StructType::FloppyImageFileInfo => Ok(from.as_any_box().downcast::<FloppyImageFileInfo>()?),
            StructType::FolderFileInfo => Ok(from.as_any_box().downcast::<FolderFileInfo>()?),
            StructType::IsoImageFileInfo => Ok(from.as_any_box().downcast::<IsoImageFileInfo>()?),
            StructType::VmConfigFileInfo => Ok(from.as_any_box().downcast::<VmConfigFileInfo>()?),
            StructType::TemplateConfigFileInfo => Ok(from.as_any_box().downcast::<TemplateConfigFileInfo>()?),
            StructType::VmDiskFileInfo => Ok(from.as_any_box().downcast::<VmDiskFileInfo>()?),
            StructType::VmLogFileInfo => Ok(from.as_any_box().downcast::<VmLogFileInfo>()?),
            StructType::VmNvramFileInfo => Ok(from.as_any_box().downcast::<VmNvramFileInfo>()?),
            StructType::VmSnapshotFileInfo => Ok(from.as_any_box().downcast::<VmSnapshotFileInfo>()?),
            StructType::FileQueryFlags => Ok(from.as_any_box().downcast::<FileQueryFlags>()?),
            StructType::FileQuery => Ok(from.as_any_box().downcast::<FileQuery>()?),
            StructType::FloppyImageFileQuery => Ok(from.as_any_box().downcast::<FloppyImageFileQuery>()?),
            StructType::FolderFileQuery => Ok(from.as_any_box().downcast::<FolderFileQuery>()?),
            StructType::IsoImageFileQuery => Ok(from.as_any_box().downcast::<IsoImageFileQuery>()?),
            StructType::VmConfigFileQuery => Ok(from.as_any_box().downcast::<VmConfigFileQuery>()?),
            StructType::TemplateConfigFileQuery => Ok(from.as_any_box().downcast::<TemplateConfigFileQuery>()?),
            StructType::VmDiskFileQuery => Ok(from.as_any_box().downcast::<VmDiskFileQuery>()?),
            StructType::VmLogFileQuery => Ok(from.as_any_box().downcast::<VmLogFileQuery>()?),
            StructType::VmNvramFileQuery => Ok(from.as_any_box().downcast::<VmNvramFileQuery>()?),
            StructType::VmSnapshotFileQuery => Ok(from.as_any_box().downcast::<VmSnapshotFileQuery>()?),
            StructType::HostDatastoreBrowserSearchResults => Ok(from.as_any_box().downcast::<HostDatastoreBrowserSearchResults>()?),
            StructType::HostDatastoreBrowserSearchSpec => Ok(from.as_any_box().downcast::<HostDatastoreBrowserSearchSpec>()?),
            StructType::VmConfigFileEncryptionInfo => Ok(from.as_any_box().downcast::<VmConfigFileEncryptionInfo>()?),
            StructType::VmConfigFileQueryFlags => Ok(from.as_any_box().downcast::<VmConfigFileQueryFlags>()?),
            StructType::VmConfigFileQueryFilter => Ok(from.as_any_box().downcast::<VmConfigFileQueryFilter>()?),
            StructType::VmDiskFileEncryptionInfo => Ok(from.as_any_box().downcast::<VmDiskFileEncryptionInfo>()?),
            StructType::VmDiskFileQueryFlags => Ok(from.as_any_box().downcast::<VmDiskFileQueryFlags>()?),
            StructType::VmDiskFileQueryFilter => Ok(from.as_any_box().downcast::<VmDiskFileQueryFilter>()?),
            StructType::HostDatastoreSystemCapabilities => Ok(from.as_any_box().downcast::<HostDatastoreSystemCapabilities>()?),
            StructType::HostDatastoreSystemDatastoreResult => Ok(from.as_any_box().downcast::<HostDatastoreSystemDatastoreResult>()?),
            StructType::HostDatastoreSystemVvolDatastoreSpec => Ok(from.as_any_box().downcast::<HostDatastoreSystemVvolDatastoreSpec>()?),
            StructType::HostDateTimeConfig => Ok(from.as_any_box().downcast::<HostDateTimeConfig>()?),
            StructType::HostDateTimeInfo => Ok(from.as_any_box().downcast::<HostDateTimeInfo>()?),
            StructType::HostDateTimeSystemServiceTestResult => Ok(from.as_any_box().downcast::<HostDateTimeSystemServiceTestResult>()?),
            StructType::HostDateTimeSystemTimeZone => Ok(from.as_any_box().downcast::<HostDateTimeSystemTimeZone>()?),
            StructType::HostDeploymentInfo => Ok(from.as_any_box().downcast::<HostDeploymentInfo>()?),
            StructType::HostDevice => Ok(from.as_any_box().downcast::<HostDevice>()?),
            StructType::ScsiLun => Ok(from.as_any_box().downcast::<ScsiLun>()?),
            StructType::HostScsiDisk => Ok(from.as_any_box().downcast::<HostScsiDisk>()?),
            StructType::HostDhcpService => Ok(from.as_any_box().downcast::<HostDhcpService>()?),
            StructType::HostDhcpServiceConfig => Ok(from.as_any_box().downcast::<HostDhcpServiceConfig>()?),
            StructType::HostDhcpServiceSpec => Ok(from.as_any_box().downcast::<HostDhcpServiceSpec>()?),
            StructType::HostDiagnosticPartition => Ok(from.as_any_box().downcast::<HostDiagnosticPartition>()?),
            StructType::HostDiagnosticPartitionCreateDescription => Ok(from.as_any_box().downcast::<HostDiagnosticPartitionCreateDescription>()?),
            StructType::HostDiagnosticPartitionCreateOption => Ok(from.as_any_box().downcast::<HostDiagnosticPartitionCreateOption>()?),
            StructType::HostDiagnosticPartitionCreateSpec => Ok(from.as_any_box().downcast::<HostDiagnosticPartitionCreateSpec>()?),
            StructType::HostDigestInfo => Ok(from.as_any_box().downcast::<HostDigestInfo>()?),
            StructType::HostTpmDigestInfo => Ok(from.as_any_box().downcast::<HostTpmDigestInfo>()?),
            StructType::HostDiskConfigurationResult => Ok(from.as_any_box().downcast::<HostDiskConfigurationResult>()?),
            StructType::HostDiskDimensions => Ok(from.as_any_box().downcast::<HostDiskDimensions>()?),
            StructType::HostDiskDimensionsChs => Ok(from.as_any_box().downcast::<HostDiskDimensionsChs>()?),
            StructType::HostDiskDimensionsLba => Ok(from.as_any_box().downcast::<HostDiskDimensionsLba>()?),
            StructType::HostDiskPartitionInfo => Ok(from.as_any_box().downcast::<HostDiskPartitionInfo>()?),
            StructType::HostDiskPartitionBlockRange => Ok(from.as_any_box().downcast::<HostDiskPartitionBlockRange>()?),
            StructType::HostDiskPartitionLayout => Ok(from.as_any_box().downcast::<HostDiskPartitionLayout>()?),
            StructType::HostDiskPartitionAttributes => Ok(from.as_any_box().downcast::<HostDiskPartitionAttributes>()?),
            StructType::HostDiskPartitionSpec => Ok(from.as_any_box().downcast::<HostDiskPartitionSpec>()?),
            StructType::HostDnsConfig => Ok(from.as_any_box().downcast::<HostDnsConfig>()?),
            StructType::HostDnsConfigSpec => Ok(from.as_any_box().downcast::<HostDnsConfigSpec>()?),
            StructType::HostDvxClass => Ok(from.as_any_box().downcast::<HostDvxClass>()?),
            StructType::HostEnterMaintenanceResult => Ok(from.as_any_box().downcast::<HostEnterMaintenanceResult>()?),
            StructType::HostEsxAgentHostManagerConfigInfo => Ok(from.as_any_box().downcast::<HostEsxAgentHostManagerConfigInfo>()?),
            StructType::HostFaultToleranceManagerComponentHealthInfo => Ok(from.as_any_box().downcast::<HostFaultToleranceManagerComponentHealthInfo>()?),
            StructType::FcoeConfig => Ok(from.as_any_box().downcast::<FcoeConfig>()?),
            StructType::FcoeConfigFcoeCapabilities => Ok(from.as_any_box().downcast::<FcoeConfigFcoeCapabilities>()?),
            StructType::FcoeConfigFcoeSpecification => Ok(from.as_any_box().downcast::<FcoeConfigFcoeSpecification>()?),
            StructType::FcoeConfigVlanRange => Ok(from.as_any_box().downcast::<FcoeConfigVlanRange>()?),
            StructType::HostFeatureCapability => Ok(from.as_any_box().downcast::<HostFeatureCapability>()?),
            StructType::HostFeatureMask => Ok(from.as_any_box().downcast::<HostFeatureMask>()?),
            StructType::HostFeatureVersionInfo => Ok(from.as_any_box().downcast::<HostFeatureVersionInfo>()?),
            StructType::HostFibreChannelOverEthernetHbaLinkInfo => Ok(from.as_any_box().downcast::<HostFibreChannelOverEthernetHbaLinkInfo>()?),
            StructType::HostFileAccess => Ok(from.as_any_box().downcast::<HostFileAccess>()?),
            StructType::ModeInfo => Ok(from.as_any_box().downcast::<ModeInfo>()?),
            StructType::HostFileSystemMountInfo => Ok(from.as_any_box().downcast::<HostFileSystemMountInfo>()?),
            StructType::HostFileSystemVolume => Ok(from.as_any_box().downcast::<HostFileSystemVolume>()?),
            StructType::HostLocalFileSystemVolume => Ok(from.as_any_box().downcast::<HostLocalFileSystemVolume>()?),
            StructType::HostNasVolume => Ok(from.as_any_box().downcast::<HostNasVolume>()?),
            StructType::HostPMemVolume => Ok(from.as_any_box().downcast::<HostPMemVolume>()?),
            StructType::HostVfatVolume => Ok(from.as_any_box().downcast::<HostVfatVolume>()?),
            StructType::HostVffsVolume => Ok(from.as_any_box().downcast::<HostVffsVolume>()?),
            StructType::HostVmfsVolume => Ok(from.as_any_box().downcast::<HostVmfsVolume>()?),
            StructType::HostVvolVolume => Ok(from.as_any_box().downcast::<HostVvolVolume>()?),
            StructType::HostFileSystemVolumeInfo => Ok(from.as_any_box().downcast::<HostFileSystemVolumeInfo>()?),
            StructType::HostFirewallConfig => Ok(from.as_any_box().downcast::<HostFirewallConfig>()?),
            StructType::HostFirewallConfigRuleSetConfig => Ok(from.as_any_box().downcast::<HostFirewallConfigRuleSetConfig>()?),
            StructType::HostFirewallInfo => Ok(from.as_any_box().downcast::<HostFirewallInfo>()?),
            StructType::HostFirewallDefaultPolicy => Ok(from.as_any_box().downcast::<HostFirewallDefaultPolicy>()?),
            StructType::HostFlagInfo => Ok(from.as_any_box().downcast::<HostFlagInfo>()?),
            StructType::HostForceMountedInfo => Ok(from.as_any_box().downcast::<HostForceMountedInfo>()?),
            StructType::HostFru => Ok(from.as_any_box().downcast::<HostFru>()?),
            StructType::HostGatewaySpec => Ok(from.as_any_box().downcast::<HostGatewaySpec>()?),
            StructType::HostGraphicsConfig => Ok(from.as_any_box().downcast::<HostGraphicsConfig>()?),
            StructType::HostGraphicsConfigDeviceType => Ok(from.as_any_box().downcast::<HostGraphicsConfigDeviceType>()?),
            StructType::HostGraphicsInfo => Ok(from.as_any_box().downcast::<HostGraphicsInfo>()?),
            StructType::HostHardwareInfo => Ok(from.as_any_box().downcast::<HostHardwareInfo>()?),
            StructType::HostHardwareStatusInfo => Ok(from.as_any_box().downcast::<HostHardwareStatusInfo>()?),
            StructType::DpuStatusInfoOperationalInfo => Ok(from.as_any_box().downcast::<DpuStatusInfoOperationalInfo>()?),
            StructType::HostHardwareElementInfo => Ok(from.as_any_box().downcast::<HostHardwareElementInfo>()?),
            StructType::DpuStatusInfo => Ok(from.as_any_box().downcast::<DpuStatusInfo>()?),
            StructType::HostStorageElementInfo => Ok(from.as_any_box().downcast::<HostStorageElementInfo>()?),
            StructType::HostStorageOperationalInfo => Ok(from.as_any_box().downcast::<HostStorageOperationalInfo>()?),
            StructType::HostHbaCreateSpec => Ok(from.as_any_box().downcast::<HostHbaCreateSpec>()?),
            StructType::HostTcpHbaCreateSpec => Ok(from.as_any_box().downcast::<HostTcpHbaCreateSpec>()?),
            StructType::HealthSystemRuntime => Ok(from.as_any_box().downcast::<HealthSystemRuntime>()?),
            StructType::HostAccessControlEntry => Ok(from.as_any_box().downcast::<HostAccessControlEntry>()?),
            StructType::HostHostBusAdapter => Ok(from.as_any_box().downcast::<HostHostBusAdapter>()?),
            StructType::HostBlockHba => Ok(from.as_any_box().downcast::<HostBlockHba>()?),
            StructType::HostFibreChannelHba => Ok(from.as_any_box().downcast::<HostFibreChannelHba>()?),
            StructType::HostFibreChannelOverEthernetHba => Ok(from.as_any_box().downcast::<HostFibreChannelOverEthernetHba>()?),
            StructType::HostInternetScsiHba => Ok(from.as_any_box().downcast::<HostInternetScsiHba>()?),
            StructType::HostParallelScsiHba => Ok(from.as_any_box().downcast::<HostParallelScsiHba>()?),
            StructType::HostPcieHba => Ok(from.as_any_box().downcast::<HostPcieHba>()?),
            StructType::HostRdmaHba => Ok(from.as_any_box().downcast::<HostRdmaHba>()?),
            StructType::HostSerialAttachedHba => Ok(from.as_any_box().downcast::<HostSerialAttachedHba>()?),
            StructType::HostTcpHba => Ok(from.as_any_box().downcast::<HostTcpHba>()?),
            StructType::HostProxySwitch => Ok(from.as_any_box().downcast::<HostProxySwitch>()?),
            StructType::HostProxySwitchConfig => Ok(from.as_any_box().downcast::<HostProxySwitchConfig>()?),
            StructType::HostProxySwitchEnsInfo => Ok(from.as_any_box().downcast::<HostProxySwitchEnsInfo>()?),
            StructType::HostProxySwitchHostLagConfig => Ok(from.as_any_box().downcast::<HostProxySwitchHostLagConfig>()?),
            StructType::HostProxySwitchSpec => Ok(from.as_any_box().downcast::<HostProxySwitchSpec>()?),
            StructType::HostImageProfileSummary => Ok(from.as_any_box().downcast::<HostImageProfileSummary>()?),
            StructType::HostInternetScsiHbaAuthenticationCapabilities => Ok(from.as_any_box().downcast::<HostInternetScsiHbaAuthenticationCapabilities>()?),
            StructType::HostInternetScsiHbaAuthenticationProperties => Ok(from.as_any_box().downcast::<HostInternetScsiHbaAuthenticationProperties>()?),
            StructType::HostInternetScsiHbaDigestCapabilities => Ok(from.as_any_box().downcast::<HostInternetScsiHbaDigestCapabilities>()?),
            StructType::HostInternetScsiHbaDigestProperties => Ok(from.as_any_box().downcast::<HostInternetScsiHbaDigestProperties>()?),
            StructType::HostInternetScsiHbaDiscoveryCapabilities => Ok(from.as_any_box().downcast::<HostInternetScsiHbaDiscoveryCapabilities>()?),
            StructType::HostInternetScsiHbaDiscoveryProperties => Ok(from.as_any_box().downcast::<HostInternetScsiHbaDiscoveryProperties>()?),
            StructType::HostInternetScsiHbaIpCapabilities => Ok(from.as_any_box().downcast::<HostInternetScsiHbaIpCapabilities>()?),
            StructType::HostInternetScsiHbaIpProperties => Ok(from.as_any_box().downcast::<HostInternetScsiHbaIpProperties>()?),
            StructType::HostInternetScsiHbaIPv6Properties => Ok(from.as_any_box().downcast::<HostInternetScsiHbaIPv6Properties>()?),
            StructType::HostInternetScsiHbaIscsiIpv6Address => Ok(from.as_any_box().downcast::<HostInternetScsiHbaIscsiIpv6Address>()?),
            StructType::HostInternetScsiHbaSendTarget => Ok(from.as_any_box().downcast::<HostInternetScsiHbaSendTarget>()?),
            StructType::HostInternetScsiHbaStaticTarget => Ok(from.as_any_box().downcast::<HostInternetScsiHbaStaticTarget>()?),
            StructType::HostInternetScsiHbaTargetSet => Ok(from.as_any_box().downcast::<HostInternetScsiHbaTargetSet>()?),
            StructType::HostIpConfig => Ok(from.as_any_box().downcast::<HostIpConfig>()?),
            StructType::HostIpConfigIpV6Address => Ok(from.as_any_box().downcast::<HostIpConfigIpV6Address>()?),
            StructType::HostIpConfigIpV6AddressConfiguration => Ok(from.as_any_box().downcast::<HostIpConfigIpV6AddressConfiguration>()?),
            StructType::HostIpRouteConfig => Ok(from.as_any_box().downcast::<HostIpRouteConfig>()?),
            StructType::HostIpRouteConfigSpec => Ok(from.as_any_box().downcast::<HostIpRouteConfigSpec>()?),
            StructType::HostIpRouteEntry => Ok(from.as_any_box().downcast::<HostIpRouteEntry>()?),
            StructType::HostIpRouteOp => Ok(from.as_any_box().downcast::<HostIpRouteOp>()?),
            StructType::HostIpRouteTableConfig => Ok(from.as_any_box().downcast::<HostIpRouteTableConfig>()?),
            StructType::HostIpRouteTableInfo => Ok(from.as_any_box().downcast::<HostIpRouteTableInfo>()?),
            StructType::HostIpmiInfo => Ok(from.as_any_box().downcast::<HostIpmiInfo>()?),
            StructType::IscsiDependencyEntity => Ok(from.as_any_box().downcast::<IscsiDependencyEntity>()?),
            StructType::IscsiMigrationDependency => Ok(from.as_any_box().downcast::<IscsiMigrationDependency>()?),
            StructType::IscsiPortInfo => Ok(from.as_any_box().downcast::<IscsiPortInfo>()?),
            StructType::IscsiStatus => Ok(from.as_any_box().downcast::<IscsiStatus>()?),
            StructType::KernelModuleInfo => Ok(from.as_any_box().downcast::<KernelModuleInfo>()?),
            StructType::KernelModuleSectionInfo => Ok(from.as_any_box().downcast::<KernelModuleSectionInfo>()?),
            StructType::HostLicenseSpec => Ok(from.as_any_box().downcast::<HostLicenseSpec>()?),
            StructType::LinkDiscoveryProtocolConfig => Ok(from.as_any_box().downcast::<LinkDiscoveryProtocolConfig>()?),
            StructType::HostAccountSpec => Ok(from.as_any_box().downcast::<HostAccountSpec>()?),
            StructType::HostPosixAccountSpec => Ok(from.as_any_box().downcast::<HostPosixAccountSpec>()?),
            StructType::HostLocalFileSystemVolumeSpec => Ok(from.as_any_box().downcast::<HostLocalFileSystemVolumeSpec>()?),
            StructType::HostLowLevelProvisioningManagerDiskLayoutSpec => Ok(from.as_any_box().downcast::<HostLowLevelProvisioningManagerDiskLayoutSpec>()?),
            StructType::HostLowLevelProvisioningManagerFileDeleteResult => Ok(from.as_any_box().downcast::<HostLowLevelProvisioningManagerFileDeleteResult>()?),
            StructType::HostLowLevelProvisioningManagerFileDeleteSpec => Ok(from.as_any_box().downcast::<HostLowLevelProvisioningManagerFileDeleteSpec>()?),
            StructType::HostLowLevelProvisioningManagerFileReserveResult => Ok(from.as_any_box().downcast::<HostLowLevelProvisioningManagerFileReserveResult>()?),
            StructType::HostLowLevelProvisioningManagerFileReserveSpec => Ok(from.as_any_box().downcast::<HostLowLevelProvisioningManagerFileReserveSpec>()?),
            StructType::HostLowLevelProvisioningManagerSnapshotLayoutSpec => Ok(from.as_any_box().downcast::<HostLowLevelProvisioningManagerSnapshotLayoutSpec>()?),
            StructType::HostLowLevelProvisioningManagerVmMigrationStatus => Ok(from.as_any_box().downcast::<HostLowLevelProvisioningManagerVmMigrationStatus>()?),
            StructType::HostLowLevelProvisioningManagerVmRecoveryInfo => Ok(from.as_any_box().downcast::<HostLowLevelProvisioningManagerVmRecoveryInfo>()?),
            StructType::HostMaintenanceSpec => Ok(from.as_any_box().downcast::<HostMaintenanceSpec>()?),
            StructType::ServiceConsoleReservationInfo => Ok(from.as_any_box().downcast::<ServiceConsoleReservationInfo>()?),
            StructType::VirtualMachineMemoryReservationInfo => Ok(from.as_any_box().downcast::<VirtualMachineMemoryReservationInfo>()?),
            StructType::VirtualMachineMemoryReservationSpec => Ok(from.as_any_box().downcast::<VirtualMachineMemoryReservationSpec>()?),
            StructType::HostMemorySpec => Ok(from.as_any_box().downcast::<HostMemorySpec>()?),
            StructType::HostMemoryTierInfo => Ok(from.as_any_box().downcast::<HostMemoryTierInfo>()?),
            StructType::HostMountInfo => Ok(from.as_any_box().downcast::<HostMountInfo>()?),
            StructType::HostMultipathInfo => Ok(from.as_any_box().downcast::<HostMultipathInfo>()?),
            StructType::HostMultipathInfoLogicalUnit => Ok(from.as_any_box().downcast::<HostMultipathInfoLogicalUnit>()?),
            StructType::HostMultipathInfoLogicalUnitPolicy => Ok(from.as_any_box().downcast::<HostMultipathInfoLogicalUnitPolicy>()?),
            StructType::HostMultipathInfoFixedLogicalUnitPolicy => Ok(from.as_any_box().downcast::<HostMultipathInfoFixedLogicalUnitPolicy>()?),
            StructType::HostMultipathInfoHppLogicalUnitPolicy => Ok(from.as_any_box().downcast::<HostMultipathInfoHppLogicalUnitPolicy>()?),
            StructType::HostMultipathInfoLogicalUnitStorageArrayTypePolicy => Ok(from.as_any_box().downcast::<HostMultipathInfoLogicalUnitStorageArrayTypePolicy>()?),
            StructType::HostMultipathInfoPath => Ok(from.as_any_box().downcast::<HostMultipathInfoPath>()?),
            StructType::HostMultipathStateInfo => Ok(from.as_any_box().downcast::<HostMultipathStateInfo>()?),
            StructType::HostMultipathStateInfoPath => Ok(from.as_any_box().downcast::<HostMultipathStateInfoPath>()?),
            StructType::HostNasVolumeConfig => Ok(from.as_any_box().downcast::<HostNasVolumeConfig>()?),
            StructType::HostNasVolumeSpec => Ok(from.as_any_box().downcast::<HostNasVolumeSpec>()?),
            StructType::HostNasVolumeUserInfo => Ok(from.as_any_box().downcast::<HostNasVolumeUserInfo>()?),
            StructType::HostNatService => Ok(from.as_any_box().downcast::<HostNatService>()?),
            StructType::HostNatServiceConfig => Ok(from.as_any_box().downcast::<HostNatServiceConfig>()?),
            StructType::HostNatServiceNameServiceSpec => Ok(from.as_any_box().downcast::<HostNatServiceNameServiceSpec>()?),
            StructType::HostNatServicePortForwardSpec => Ok(from.as_any_box().downcast::<HostNatServicePortForwardSpec>()?),
            StructType::HostNatServiceSpec => Ok(from.as_any_box().downcast::<HostNatServiceSpec>()?),
            StructType::HostNetCapabilities => Ok(from.as_any_box().downcast::<HostNetCapabilities>()?),
            StructType::HostNetOffloadCapabilities => Ok(from.as_any_box().downcast::<HostNetOffloadCapabilities>()?),
            StructType::HostNetStackInstance => Ok(from.as_any_box().downcast::<HostNetStackInstance>()?),
            StructType::HostNetworkConfig => Ok(from.as_any_box().downcast::<HostNetworkConfig>()?),
            StructType::HostNetworkConfigNetStackSpec => Ok(from.as_any_box().downcast::<HostNetworkConfigNetStackSpec>()?),
            StructType::HostNetworkConfigResult => Ok(from.as_any_box().downcast::<HostNetworkConfigResult>()?),
            StructType::HostNetworkInfo => Ok(from.as_any_box().downcast::<HostNetworkInfo>()?),
            StructType::HostNetworkPolicy => Ok(from.as_any_box().downcast::<HostNetworkPolicy>()?),
            StructType::HostNicFailureCriteria => Ok(from.as_any_box().downcast::<HostNicFailureCriteria>()?),
            StructType::HostNicOrderPolicy => Ok(from.as_any_box().downcast::<HostNicOrderPolicy>()?),
            StructType::HostNicTeamingPolicy => Ok(from.as_any_box().downcast::<HostNicTeamingPolicy>()?),
            StructType::HostNetworkSecurityPolicy => Ok(from.as_any_box().downcast::<HostNetworkSecurityPolicy>()?),
            StructType::HostNetworkTrafficShapingPolicy => Ok(from.as_any_box().downcast::<HostNetworkTrafficShapingPolicy>()?),
            StructType::HostNtpConfig => Ok(from.as_any_box().downcast::<HostNtpConfig>()?),
            StructType::HostNumaInfo => Ok(from.as_any_box().downcast::<HostNumaInfo>()?),
            StructType::HostNumaNode => Ok(from.as_any_box().downcast::<HostNumaNode>()?),
            StructType::HostNumericSensorInfo => Ok(from.as_any_box().downcast::<HostNumericSensorInfo>()?),
            StructType::NvdimmDimmInfo => Ok(from.as_any_box().downcast::<NvdimmDimmInfo>()?),
            StructType::NvdimmGuid => Ok(from.as_any_box().downcast::<NvdimmGuid>()?),
            StructType::NvdimmHealthInfo => Ok(from.as_any_box().downcast::<NvdimmHealthInfo>()?),
            StructType::NvdimmInterleaveSetInfo => Ok(from.as_any_box().downcast::<NvdimmInterleaveSetInfo>()?),
            StructType::NvdimmNamespaceCreateSpec => Ok(from.as_any_box().downcast::<NvdimmNamespaceCreateSpec>()?),
            StructType::NvdimmNamespaceDeleteSpec => Ok(from.as_any_box().downcast::<NvdimmNamespaceDeleteSpec>()?),
            StructType::NvdimmNamespaceDetails => Ok(from.as_any_box().downcast::<NvdimmNamespaceDetails>()?),
            StructType::NvdimmNamespaceInfo => Ok(from.as_any_box().downcast::<NvdimmNamespaceInfo>()?),
            StructType::NvdimmSystemInfo => Ok(from.as_any_box().downcast::<NvdimmSystemInfo>()?),
            StructType::NvdimmPMemNamespaceCreateSpec => Ok(from.as_any_box().downcast::<NvdimmPMemNamespaceCreateSpec>()?),
            StructType::NvdimmRegionInfo => Ok(from.as_any_box().downcast::<NvdimmRegionInfo>()?),
            StructType::NvdimmSummary => Ok(from.as_any_box().downcast::<NvdimmSummary>()?),
            StructType::HostNvmeController => Ok(from.as_any_box().downcast::<HostNvmeController>()?),
            StructType::HostNvmeDisconnectSpec => Ok(from.as_any_box().downcast::<HostNvmeDisconnectSpec>()?),
            StructType::HostNvmeDiscoveryLog => Ok(from.as_any_box().downcast::<HostNvmeDiscoveryLog>()?),
            StructType::HostNvmeDiscoveryLogEntry => Ok(from.as_any_box().downcast::<HostNvmeDiscoveryLogEntry>()?),
            StructType::HostNvmeNamespace => Ok(from.as_any_box().downcast::<HostNvmeNamespace>()?),
            StructType::HostNvmeSpec => Ok(from.as_any_box().downcast::<HostNvmeSpec>()?),
            StructType::HostNvmeConnectSpec => Ok(from.as_any_box().downcast::<HostNvmeConnectSpec>()?),
            StructType::HostNvmeDiscoverSpec => Ok(from.as_any_box().downcast::<HostNvmeDiscoverSpec>()?),
            StructType::HostNvmeTopology => Ok(from.as_any_box().downcast::<HostNvmeTopology>()?),
            StructType::HostNvmeTopologyInterface => Ok(from.as_any_box().downcast::<HostNvmeTopologyInterface>()?),
            StructType::HostNvmeTransportParameters => Ok(from.as_any_box().downcast::<HostNvmeTransportParameters>()?),
            StructType::HostNvmeOpaqueTransportParameters => Ok(from.as_any_box().downcast::<HostNvmeOpaqueTransportParameters>()?),
            StructType::HostNvmeOverFibreChannelParameters => Ok(from.as_any_box().downcast::<HostNvmeOverFibreChannelParameters>()?),
            StructType::HostNvmeOverRdmaParameters => Ok(from.as_any_box().downcast::<HostNvmeOverRdmaParameters>()?),
            StructType::HostNvmeOverTcpParameters => Ok(from.as_any_box().downcast::<HostNvmeOverTcpParameters>()?),
            StructType::HostOpaqueNetworkInfo => Ok(from.as_any_box().downcast::<HostOpaqueNetworkInfo>()?),
            StructType::HostOpaqueSwitch => Ok(from.as_any_box().downcast::<HostOpaqueSwitch>()?),
            StructType::HostOpaqueSwitchPhysicalNicZone => Ok(from.as_any_box().downcast::<HostOpaqueSwitchPhysicalNicZone>()?),
            StructType::HostPatchManagerLocator => Ok(from.as_any_box().downcast::<HostPatchManagerLocator>()?),
            StructType::HostPatchManagerPatchManagerOperationSpec => Ok(from.as_any_box().downcast::<HostPatchManagerPatchManagerOperationSpec>()?),
            StructType::HostPatchManagerResult => Ok(from.as_any_box().downcast::<HostPatchManagerResult>()?),
            StructType::HostPatchManagerStatus => Ok(from.as_any_box().downcast::<HostPatchManagerStatus>()?),
            StructType::HostPatchManagerStatusPrerequisitePatch => Ok(from.as_any_box().downcast::<HostPatchManagerStatusPrerequisitePatch>()?),
            StructType::HostPathSelectionPolicyOption => Ok(from.as_any_box().downcast::<HostPathSelectionPolicyOption>()?),
            StructType::HostPciDevice => Ok(from.as_any_box().downcast::<HostPciDevice>()?),
            StructType::HostPciPassthruConfig => Ok(from.as_any_box().downcast::<HostPciPassthruConfig>()?),
            StructType::HostSriovConfig => Ok(from.as_any_box().downcast::<HostSriovConfig>()?),
            StructType::HostPciPassthruInfo => Ok(from.as_any_box().downcast::<HostPciPassthruInfo>()?),
            StructType::HostSriovInfo => Ok(from.as_any_box().downcast::<HostSriovInfo>()?),
            StructType::HostPersistentMemoryInfo => Ok(from.as_any_box().downcast::<HostPersistentMemoryInfo>()?),
            StructType::PhysicalNic => Ok(from.as_any_box().downcast::<PhysicalNic>()?),
            StructType::PhysicalNicCdpDeviceCapability => Ok(from.as_any_box().downcast::<PhysicalNicCdpDeviceCapability>()?),
            StructType::PhysicalNicCdpInfo => Ok(from.as_any_box().downcast::<PhysicalNicCdpInfo>()?),
            StructType::PhysicalNicConfig => Ok(from.as_any_box().downcast::<PhysicalNicConfig>()?),
            StructType::PhysicalNicLinkInfo => Ok(from.as_any_box().downcast::<PhysicalNicLinkInfo>()?),
            StructType::LinkLayerDiscoveryProtocolInfo => Ok(from.as_any_box().downcast::<LinkLayerDiscoveryProtocolInfo>()?),
            StructType::PhysicalNicHintInfo => Ok(from.as_any_box().downcast::<PhysicalNicHintInfo>()?),
            StructType::PhysicalNicHint => Ok(from.as_any_box().downcast::<PhysicalNicHint>()?),
            StructType::PhysicalNicIpHint => Ok(from.as_any_box().downcast::<PhysicalNicIpHint>()?),
            StructType::PhysicalNicNameHint => Ok(from.as_any_box().downcast::<PhysicalNicNameHint>()?),
            StructType::PhysicalNicSpec => Ok(from.as_any_box().downcast::<PhysicalNicSpec>()?),
            StructType::HostPlugStoreTopology => Ok(from.as_any_box().downcast::<HostPlugStoreTopology>()?),
            StructType::HostPlugStoreTopologyAdapter => Ok(from.as_any_box().downcast::<HostPlugStoreTopologyAdapter>()?),
            StructType::HostPlugStoreTopologyDevice => Ok(from.as_any_box().downcast::<HostPlugStoreTopologyDevice>()?),
            StructType::HostPlugStoreTopologyPath => Ok(from.as_any_box().downcast::<HostPlugStoreTopologyPath>()?),
            StructType::HostPlugStoreTopologyPlugin => Ok(from.as_any_box().downcast::<HostPlugStoreTopologyPlugin>()?),
            StructType::HostPlugStoreTopologyTarget => Ok(from.as_any_box().downcast::<HostPlugStoreTopologyTarget>()?),
            StructType::HostPortGroup => Ok(from.as_any_box().downcast::<HostPortGroup>()?),
            StructType::HostPortGroupConfig => Ok(from.as_any_box().downcast::<HostPortGroupConfig>()?),
            StructType::HostPortGroupPort => Ok(from.as_any_box().downcast::<HostPortGroupPort>()?),
            StructType::HostPortGroupSpec => Ok(from.as_any_box().downcast::<HostPortGroupSpec>()?),
            StructType::PowerSystemCapability => Ok(from.as_any_box().downcast::<PowerSystemCapability>()?),
            StructType::PowerSystemInfo => Ok(from.as_any_box().downcast::<PowerSystemInfo>()?),
            StructType::HostPowerPolicy => Ok(from.as_any_box().downcast::<HostPowerPolicy>()?),
            StructType::HostProtocolEndpoint => Ok(from.as_any_box().downcast::<HostProtocolEndpoint>()?),
            StructType::HostPtpConfig => Ok(from.as_any_box().downcast::<HostPtpConfig>()?),
            StructType::HostPtpConfigPtpPort => Ok(from.as_any_box().downcast::<HostPtpConfigPtpPort>()?),
            StructType::HostQualifiedName => Ok(from.as_any_box().downcast::<HostQualifiedName>()?),
            StructType::HostRdmaDevice => Ok(from.as_any_box().downcast::<HostRdmaDevice>()?),
            StructType::HostRdmaDeviceBacking => Ok(from.as_any_box().downcast::<HostRdmaDeviceBacking>()?),
            StructType::HostRdmaDevicePnicBacking => Ok(from.as_any_box().downcast::<HostRdmaDevicePnicBacking>()?),
            StructType::HostRdmaDeviceCapability => Ok(from.as_any_box().downcast::<HostRdmaDeviceCapability>()?),
            StructType::HostRdmaDeviceConnectionInfo => Ok(from.as_any_box().downcast::<HostRdmaDeviceConnectionInfo>()?),
            StructType::HostReliableMemoryInfo => Ok(from.as_any_box().downcast::<HostReliableMemoryInfo>()?),
            StructType::HostResignatureRescanResult => Ok(from.as_any_box().downcast::<HostResignatureRescanResult>()?),
            StructType::HostFirewallRuleset => Ok(from.as_any_box().downcast::<HostFirewallRuleset>()?),
            StructType::HostFirewallRulesetIpList => Ok(from.as_any_box().downcast::<HostFirewallRulesetIpList>()?),
            StructType::HostFirewallRulesetIpNetwork => Ok(from.as_any_box().downcast::<HostFirewallRulesetIpNetwork>()?),
            StructType::HostFirewallRule => Ok(from.as_any_box().downcast::<HostFirewallRule>()?),
            StructType::HostFirewallRulesetRulesetSpec => Ok(from.as_any_box().downcast::<HostFirewallRulesetRulesetSpec>()?),
            StructType::HostRuntimeInfo => Ok(from.as_any_box().downcast::<HostRuntimeInfo>()?),
            StructType::HostRuntimeInfoNetStackInstanceRuntimeInfo => Ok(from.as_any_box().downcast::<HostRuntimeInfoNetStackInstanceRuntimeInfo>()?),
            StructType::HostNetworkResourceRuntime => Ok(from.as_any_box().downcast::<HostNetworkResourceRuntime>()?),
            StructType::HostRuntimeInfoNetworkRuntimeInfo => Ok(from.as_any_box().downcast::<HostRuntimeInfoNetworkRuntimeInfo>()?),
            StructType::HostPlacedVirtualNicIdentifier => Ok(from.as_any_box().downcast::<HostPlacedVirtualNicIdentifier>()?),
            StructType::HostPnicNetworkResourceInfo => Ok(from.as_any_box().downcast::<HostPnicNetworkResourceInfo>()?),
            StructType::HostRuntimeInfoStateEncryptionInfo => Ok(from.as_any_box().downcast::<HostRuntimeInfoStateEncryptionInfo>()?),
            StructType::HostScsiDiskPartition => Ok(from.as_any_box().downcast::<HostScsiDiskPartition>()?),
            StructType::ScsiLunCapabilities => Ok(from.as_any_box().downcast::<ScsiLunCapabilities>()?),
            StructType::ScsiLunDescriptor => Ok(from.as_any_box().downcast::<ScsiLunDescriptor>()?),
            StructType::ScsiLunDurableName => Ok(from.as_any_box().downcast::<ScsiLunDurableName>()?),
            StructType::HostScsiTopology => Ok(from.as_any_box().downcast::<HostScsiTopology>()?),
            StructType::HostScsiTopologyInterface => Ok(from.as_any_box().downcast::<HostScsiTopologyInterface>()?),
            StructType::HostScsiTopologyLun => Ok(from.as_any_box().downcast::<HostScsiTopologyLun>()?),
            StructType::HostScsiTopologyTarget => Ok(from.as_any_box().downcast::<HostScsiTopologyTarget>()?),
            StructType::HostSecuritySpec => Ok(from.as_any_box().downcast::<HostSecuritySpec>()?),
            StructType::HostService => Ok(from.as_any_box().downcast::<HostService>()?),
            StructType::HostServiceSourcePackage => Ok(from.as_any_box().downcast::<HostServiceSourcePackage>()?),
            StructType::HostServiceConfig => Ok(from.as_any_box().downcast::<HostServiceConfig>()?),
            StructType::HostServiceInfo => Ok(from.as_any_box().downcast::<HostServiceInfo>()?),
            StructType::HostSevInfo => Ok(from.as_any_box().downcast::<HostSevInfo>()?),
            StructType::HostSgxInfo => Ok(from.as_any_box().downcast::<HostSgxInfo>()?),
            StructType::HostSgxRegistrationInfo => Ok(from.as_any_box().downcast::<HostSgxRegistrationInfo>()?),
            StructType::HostSharedGpuCapabilities => Ok(from.as_any_box().downcast::<HostSharedGpuCapabilities>()?),
            StructType::HostSnmpSystemAgentLimits => Ok(from.as_any_box().downcast::<HostSnmpSystemAgentLimits>()?),
            StructType::HostSnmpConfigSpec => Ok(from.as_any_box().downcast::<HostSnmpConfigSpec>()?),
            StructType::HostSnmpDestination => Ok(from.as_any_box().downcast::<HostSnmpDestination>()?),
            StructType::SoftwarePackage => Ok(from.as_any_box().downcast::<SoftwarePackage>()?),
            StructType::SoftwarePackageCapability => Ok(from.as_any_box().downcast::<SoftwarePackageCapability>()?),
            StructType::Relation => Ok(from.as_any_box().downcast::<Relation>()?),
            StructType::HostSriovDevicePoolInfo => Ok(from.as_any_box().downcast::<HostSriovDevicePoolInfo>()?),
            StructType::HostSriovNetworkDevicePoolInfo => Ok(from.as_any_box().downcast::<HostSriovNetworkDevicePoolInfo>()?),
            StructType::HostSslThumbprintInfo => Ok(from.as_any_box().downcast::<HostSslThumbprintInfo>()?),
            StructType::HostStorageArrayTypePolicyOption => Ok(from.as_any_box().downcast::<HostStorageArrayTypePolicyOption>()?),
            StructType::HostStorageDeviceInfo => Ok(from.as_any_box().downcast::<HostStorageDeviceInfo>()?),
            StructType::HostStorageSystemDiskLocatorLedResult => Ok(from.as_any_box().downcast::<HostStorageSystemDiskLocatorLedResult>()?),
            StructType::HostStorageSystemScsiLunResult => Ok(from.as_any_box().downcast::<HostStorageSystemScsiLunResult>()?),
            StructType::HostStorageSystemVmfsVolumeResult => Ok(from.as_any_box().downcast::<HostStorageSystemVmfsVolumeResult>()?),
            StructType::HostListSummary => Ok(from.as_any_box().downcast::<HostListSummary>()?),
            StructType::HostConfigSummary => Ok(from.as_any_box().downcast::<HostConfigSummary>()?),
            StructType::HostListSummaryGatewaySummary => Ok(from.as_any_box().downcast::<HostListSummaryGatewaySummary>()?),
            StructType::HostHardwareSummary => Ok(from.as_any_box().downcast::<HostHardwareSummary>()?),
            StructType::HostListSummaryQuickStats => Ok(from.as_any_box().downcast::<HostListSummaryQuickStats>()?),
            StructType::SystemEventInfo => Ok(from.as_any_box().downcast::<SystemEventInfo>()?),
            StructType::HostSystemHealthInfo => Ok(from.as_any_box().downcast::<HostSystemHealthInfo>()?),
            StructType::HostSystemIdentificationInfo => Ok(from.as_any_box().downcast::<HostSystemIdentificationInfo>()?),
            StructType::HostSystemInfo => Ok(from.as_any_box().downcast::<HostSystemInfo>()?),
            StructType::HostSystemResourceInfo => Ok(from.as_any_box().downcast::<HostSystemResourceInfo>()?),
            StructType::HostSystemSwapConfiguration => Ok(from.as_any_box().downcast::<HostSystemSwapConfiguration>()?),
            StructType::HostSystemSwapConfigurationSystemSwapOption => Ok(from.as_any_box().downcast::<HostSystemSwapConfigurationSystemSwapOption>()?),
            StructType::HostSystemSwapConfigurationDatastoreOption => Ok(from.as_any_box().downcast::<HostSystemSwapConfigurationDatastoreOption>()?),
            StructType::HostSystemSwapConfigurationDisabledOption => Ok(from.as_any_box().downcast::<HostSystemSwapConfigurationDisabledOption>()?),
            StructType::HostSystemSwapConfigurationHostCacheOption => Ok(from.as_any_box().downcast::<HostSystemSwapConfigurationHostCacheOption>()?),
            StructType::HostSystemSwapConfigurationHostLocalSwapOption => Ok(from.as_any_box().downcast::<HostSystemSwapConfigurationHostLocalSwapOption>()?),
            StructType::HostTargetTransport => Ok(from.as_any_box().downcast::<HostTargetTransport>()?),
            StructType::HostBlockAdapterTargetTransport => Ok(from.as_any_box().downcast::<HostBlockAdapterTargetTransport>()?),
            StructType::HostFibreChannelTargetTransport => Ok(from.as_any_box().downcast::<HostFibreChannelTargetTransport>()?),
            StructType::HostFibreChannelOverEthernetTargetTransport => Ok(from.as_any_box().downcast::<HostFibreChannelOverEthernetTargetTransport>()?),
            StructType::HostInternetScsiTargetTransport => Ok(from.as_any_box().downcast::<HostInternetScsiTargetTransport>()?),
            StructType::HostParallelScsiTargetTransport => Ok(from.as_any_box().downcast::<HostParallelScsiTargetTransport>()?),
            StructType::HostPcieTargetTransport => Ok(from.as_any_box().downcast::<HostPcieTargetTransport>()?),
            StructType::HostRdmaTargetTransport => Ok(from.as_any_box().downcast::<HostRdmaTargetTransport>()?),
            StructType::HostSerialAttachedTargetTransport => Ok(from.as_any_box().downcast::<HostSerialAttachedTargetTransport>()?),
            StructType::HostTcpTargetTransport => Ok(from.as_any_box().downcast::<HostTcpTargetTransport>()?),
            StructType::HostTpmAttestationInfo => Ok(from.as_any_box().downcast::<HostTpmAttestationInfo>()?),
            StructType::HostTpmAttestationReport => Ok(from.as_any_box().downcast::<HostTpmAttestationReport>()?),
            StructType::HostTpmEventDetails => Ok(from.as_any_box().downcast::<HostTpmEventDetails>()?),
            StructType::HostTpmBootCompleteEventDetails => Ok(from.as_any_box().downcast::<HostTpmBootCompleteEventDetails>()?),
            StructType::HostTpmBootSecurityOptionEventDetails => Ok(from.as_any_box().downcast::<HostTpmBootSecurityOptionEventDetails>()?),
            StructType::HostTpmNvTagEventDetails => Ok(from.as_any_box().downcast::<HostTpmNvTagEventDetails>()?),
            StructType::HostTpmSignerEventDetails => Ok(from.as_any_box().downcast::<HostTpmSignerEventDetails>()?),
            StructType::HostTpmCommandEventDetails => Ok(from.as_any_box().downcast::<HostTpmCommandEventDetails>()?),
            StructType::HostTpmOptionEventDetails => Ok(from.as_any_box().downcast::<HostTpmOptionEventDetails>()?),
            StructType::HostTpmSoftwareComponentEventDetails => Ok(from.as_any_box().downcast::<HostTpmSoftwareComponentEventDetails>()?),
            StructType::HostTpmVersionEventDetails => Ok(from.as_any_box().downcast::<HostTpmVersionEventDetails>()?),
            StructType::HostTpmEventLogEntry => Ok(from.as_any_box().downcast::<HostTpmEventLogEntry>()?),
            StructType::HostTrustAuthorityAttestationInfo => Ok(from.as_any_box().downcast::<HostTrustAuthorityAttestationInfo>()?),
            StructType::HostUnresolvedVmfsExtent => Ok(from.as_any_box().downcast::<HostUnresolvedVmfsExtent>()?),
            StructType::HostUnresolvedVmfsResignatureSpec => Ok(from.as_any_box().downcast::<HostUnresolvedVmfsResignatureSpec>()?),
            StructType::HostUnresolvedVmfsResolutionResult => Ok(from.as_any_box().downcast::<HostUnresolvedVmfsResolutionResult>()?),
            StructType::HostUnresolvedVmfsResolutionSpec => Ok(from.as_any_box().downcast::<HostUnresolvedVmfsResolutionSpec>()?),
            StructType::HostUnresolvedVmfsVolume => Ok(from.as_any_box().downcast::<HostUnresolvedVmfsVolume>()?),
            StructType::HostUnresolvedVmfsVolumeResolveStatus => Ok(from.as_any_box().downcast::<HostUnresolvedVmfsVolumeResolveStatus>()?),
            StructType::HostVFlashManagerVFlashCacheConfigInfo => Ok(from.as_any_box().downcast::<HostVFlashManagerVFlashCacheConfigInfo>()?),
            StructType::HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption => Ok(from.as_any_box().downcast::<HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption>()?),
            StructType::HostVFlashManagerVFlashCacheConfigSpec => Ok(from.as_any_box().downcast::<HostVFlashManagerVFlashCacheConfigSpec>()?),
            StructType::HostVFlashManagerVFlashConfigInfo => Ok(from.as_any_box().downcast::<HostVFlashManagerVFlashConfigInfo>()?),
            StructType::HostVFlashManagerVFlashResourceConfigInfo => Ok(from.as_any_box().downcast::<HostVFlashManagerVFlashResourceConfigInfo>()?),
            StructType::HostVFlashManagerVFlashResourceConfigSpec => Ok(from.as_any_box().downcast::<HostVFlashManagerVFlashResourceConfigSpec>()?),
            StructType::HostVFlashManagerVFlashResourceRunTimeInfo => Ok(from.as_any_box().downcast::<HostVFlashManagerVFlashResourceRunTimeInfo>()?),
            StructType::HostVFlashResourceConfigurationResult => Ok(from.as_any_box().downcast::<HostVFlashResourceConfigurationResult>()?),
            StructType::HostVMotionConfig => Ok(from.as_any_box().downcast::<HostVMotionConfig>()?),
            StructType::HostVMotionInfo => Ok(from.as_any_box().downcast::<HostVMotionInfo>()?),
            StructType::HostVMotionManagerDstInstantCloneResult => Ok(from.as_any_box().downcast::<HostVMotionManagerDstInstantCloneResult>()?),
            StructType::HostVMotionManagerSrcInstantCloneResult => Ok(from.as_any_box().downcast::<HostVMotionManagerSrcInstantCloneResult>()?),
            StructType::HostVMotionNetConfig => Ok(from.as_any_box().downcast::<HostVMotionNetConfig>()?),
            StructType::HostVffsSpec => Ok(from.as_any_box().downcast::<HostVffsSpec>()?),
            StructType::HostVirtualNic => Ok(from.as_any_box().downcast::<HostVirtualNic>()?),
            StructType::HostVirtualNicConfig => Ok(from.as_any_box().downcast::<HostVirtualNicConfig>()?),
            StructType::HostVirtualNicIpRouteSpec => Ok(from.as_any_box().downcast::<HostVirtualNicIpRouteSpec>()?),
            StructType::HostVirtualNicOpaqueNetworkSpec => Ok(from.as_any_box().downcast::<HostVirtualNicOpaqueNetworkSpec>()?),
            StructType::HostVirtualNicSpec => Ok(from.as_any_box().downcast::<HostVirtualNicSpec>()?),
            StructType::HostVirtualNicConnection => Ok(from.as_any_box().downcast::<HostVirtualNicConnection>()?),
            StructType::VirtualNicManagerNetConfig => Ok(from.as_any_box().downcast::<VirtualNicManagerNetConfig>()?),
            StructType::HostVirtualNicManagerNicTypeSelection => Ok(from.as_any_box().downcast::<HostVirtualNicManagerNicTypeSelection>()?),
            StructType::HostVirtualNicManagerInfo => Ok(from.as_any_box().downcast::<HostVirtualNicManagerInfo>()?),
            StructType::HostVirtualSwitch => Ok(from.as_any_box().downcast::<HostVirtualSwitch>()?),
            StructType::HostVirtualSwitchBeaconConfig => Ok(from.as_any_box().downcast::<HostVirtualSwitchBeaconConfig>()?),
            StructType::HostVirtualSwitchBridge => Ok(from.as_any_box().downcast::<HostVirtualSwitchBridge>()?),
            StructType::HostVirtualSwitchAutoBridge => Ok(from.as_any_box().downcast::<HostVirtualSwitchAutoBridge>()?),
            StructType::HostVirtualSwitchBondBridge => Ok(from.as_any_box().downcast::<HostVirtualSwitchBondBridge>()?),
            StructType::HostVirtualSwitchSimpleBridge => Ok(from.as_any_box().downcast::<HostVirtualSwitchSimpleBridge>()?),
            StructType::HostVirtualSwitchConfig => Ok(from.as_any_box().downcast::<HostVirtualSwitchConfig>()?),
            StructType::HostVirtualSwitchSpec => Ok(from.as_any_box().downcast::<HostVirtualSwitchSpec>()?),
            StructType::HostVmciAccessManagerAccessSpec => Ok(from.as_any_box().downcast::<HostVmciAccessManagerAccessSpec>()?),
            StructType::VmfsDatastoreOption => Ok(from.as_any_box().downcast::<VmfsDatastoreOption>()?),
            StructType::VmfsDatastoreBaseOption => Ok(from.as_any_box().downcast::<VmfsDatastoreBaseOption>()?),
            StructType::VmfsDatastoreMultipleExtentOption => Ok(from.as_any_box().downcast::<VmfsDatastoreMultipleExtentOption>()?),
            StructType::VmfsDatastoreSingleExtentOption => Ok(from.as_any_box().downcast::<VmfsDatastoreSingleExtentOption>()?),
            StructType::VmfsDatastoreAllExtentOption => Ok(from.as_any_box().downcast::<VmfsDatastoreAllExtentOption>()?),
            StructType::VmfsDatastoreSpec => Ok(from.as_any_box().downcast::<VmfsDatastoreSpec>()?),
            StructType::VmfsDatastoreCreateSpec => Ok(from.as_any_box().downcast::<VmfsDatastoreCreateSpec>()?),
            StructType::VmfsDatastoreExpandSpec => Ok(from.as_any_box().downcast::<VmfsDatastoreExpandSpec>()?),
            StructType::VmfsDatastoreExtendSpec => Ok(from.as_any_box().downcast::<VmfsDatastoreExtendSpec>()?),
            StructType::HostVmfsRescanResult => Ok(from.as_any_box().downcast::<HostVmfsRescanResult>()?),
            StructType::VmfsConfigOption => Ok(from.as_any_box().downcast::<VmfsConfigOption>()?),
            StructType::HostVmfsSpec => Ok(from.as_any_box().downcast::<HostVmfsSpec>()?),
            StructType::VmfsUnmapBandwidthSpec => Ok(from.as_any_box().downcast::<VmfsUnmapBandwidthSpec>()?),
            StructType::HostVsanInternalSystemCmmdsQuery => Ok(from.as_any_box().downcast::<HostVsanInternalSystemCmmdsQuery>()?),
            StructType::HostVsanInternalSystemDeleteVsanObjectsResult => Ok(from.as_any_box().downcast::<HostVsanInternalSystemDeleteVsanObjectsResult>()?),
            StructType::VsanNewPolicyBatch => Ok(from.as_any_box().downcast::<VsanNewPolicyBatch>()?),
            StructType::VsanPolicyChangeBatch => Ok(from.as_any_box().downcast::<VsanPolicyChangeBatch>()?),
            StructType::VsanPolicyCost => Ok(from.as_any_box().downcast::<VsanPolicyCost>()?),
            StructType::VsanPolicySatisfiability => Ok(from.as_any_box().downcast::<VsanPolicySatisfiability>()?),
            StructType::HostVsanInternalSystemVsanObjectOperationResult => Ok(from.as_any_box().downcast::<HostVsanInternalSystemVsanObjectOperationResult>()?),
            StructType::HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult => Ok(from.as_any_box().downcast::<HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult>()?),
            StructType::HostVvolNqn => Ok(from.as_any_box().downcast::<HostVvolNqn>()?),
            StructType::VVolHostPe => Ok(from.as_any_box().downcast::<VVolHostPe>()?),
            StructType::HostVvolVolumeHostVvolNqn => Ok(from.as_any_box().downcast::<HostVvolVolumeHostVvolNqn>()?),
            StructType::HostVvolVolumeSpecification => Ok(from.as_any_box().downcast::<HostVvolVolumeSpecification>()?),
            StructType::NetDhcpConfigInfo => Ok(from.as_any_box().downcast::<NetDhcpConfigInfo>()?),
            StructType::NetDhcpConfigInfoDhcpOptions => Ok(from.as_any_box().downcast::<NetDhcpConfigInfoDhcpOptions>()?),
            StructType::NetDhcpConfigSpec => Ok(from.as_any_box().downcast::<NetDhcpConfigSpec>()?),
            StructType::NetDhcpConfigSpecDhcpOptionsSpec => Ok(from.as_any_box().downcast::<NetDhcpConfigSpecDhcpOptionsSpec>()?),
            StructType::NetDnsConfigInfo => Ok(from.as_any_box().downcast::<NetDnsConfigInfo>()?),
            StructType::NetDnsConfigSpec => Ok(from.as_any_box().downcast::<NetDnsConfigSpec>()?),
            StructType::NetIpConfigInfo => Ok(from.as_any_box().downcast::<NetIpConfigInfo>()?),
            StructType::NetIpConfigInfoIpAddress => Ok(from.as_any_box().downcast::<NetIpConfigInfoIpAddress>()?),
            StructType::NetIpConfigSpec => Ok(from.as_any_box().downcast::<NetIpConfigSpec>()?),
            StructType::NetIpConfigSpecIpAddressSpec => Ok(from.as_any_box().downcast::<NetIpConfigSpecIpAddressSpec>()?),
            StructType::NetIpRouteConfigInfo => Ok(from.as_any_box().downcast::<NetIpRouteConfigInfo>()?),
            StructType::NetIpRouteConfigInfoGateway => Ok(from.as_any_box().downcast::<NetIpRouteConfigInfoGateway>()?),
            StructType::NetIpRouteConfigInfoIpRoute => Ok(from.as_any_box().downcast::<NetIpRouteConfigInfoIpRoute>()?),
            StructType::NetIpRouteConfigSpec => Ok(from.as_any_box().downcast::<NetIpRouteConfigSpec>()?),
            StructType::NetIpRouteConfigSpecGatewaySpec => Ok(from.as_any_box().downcast::<NetIpRouteConfigSpecGatewaySpec>()?),
            StructType::NetIpRouteConfigSpecIpRouteSpec => Ok(from.as_any_box().downcast::<NetIpRouteConfigSpecIpRouteSpec>()?),
            StructType::NetIpStackInfo => Ok(from.as_any_box().downcast::<NetIpStackInfo>()?),
            StructType::NetIpStackInfoDefaultRouter => Ok(from.as_any_box().downcast::<NetIpStackInfoDefaultRouter>()?),
            StructType::NetIpStackInfoNetToMedia => Ok(from.as_any_box().downcast::<NetIpStackInfoNetToMedia>()?),
            StructType::NetBiosConfigInfo => Ok(from.as_any_box().downcast::<NetBiosConfigInfo>()?),
            StructType::WinNetBiosConfigInfo => Ok(from.as_any_box().downcast::<WinNetBiosConfigInfo>()?),
            StructType::ArrayUpdateSpec => Ok(from.as_any_box().downcast::<ArrayUpdateSpec>()?),
            StructType::ClusterDasVmConfigSpec => Ok(from.as_any_box().downcast::<ClusterDasVmConfigSpec>()?),
            StructType::ClusterDatastoreUpdateSpec => Ok(from.as_any_box().downcast::<ClusterDatastoreUpdateSpec>()?),
            StructType::ClusterDpmHostConfigSpec => Ok(from.as_any_box().downcast::<ClusterDpmHostConfigSpec>()?),
            StructType::ClusterDrsVmConfigSpec => Ok(from.as_any_box().downcast::<ClusterDrsVmConfigSpec>()?),
            StructType::ClusterGroupSpec => Ok(from.as_any_box().downcast::<ClusterGroupSpec>()?),
            StructType::ClusterPreemptibleVmPairSpec => Ok(from.as_any_box().downcast::<ClusterPreemptibleVmPairSpec>()?),
            StructType::ClusterRuleSpec => Ok(from.as_any_box().downcast::<ClusterRuleSpec>()?),
            StructType::ClusterTagCategoryUpdateSpec => Ok(from.as_any_box().downcast::<ClusterTagCategoryUpdateSpec>()?),
            StructType::ClusterVmOrchestrationSpec => Ok(from.as_any_box().downcast::<ClusterVmOrchestrationSpec>()?),
            StructType::StorageDrsOptionSpec => Ok(from.as_any_box().downcast::<StorageDrsOptionSpec>()?),
            StructType::StorageDrsVmConfigSpec => Ok(from.as_any_box().downcast::<StorageDrsVmConfigSpec>()?),
            StructType::VAppOvfSectionSpec => Ok(from.as_any_box().downcast::<VAppOvfSectionSpec>()?),
            StructType::VAppProductSpec => Ok(from.as_any_box().downcast::<VAppProductSpec>()?),
            StructType::VAppPropertySpec => Ok(from.as_any_box().downcast::<VAppPropertySpec>()?),
            StructType::VirtualMachineCpuIdInfoSpec => Ok(from.as_any_box().downcast::<VirtualMachineCpuIdInfoSpec>()?),
            StructType::OptionType => Ok(from.as_any_box().downcast::<OptionType>()?),
            StructType::BoolOption => Ok(from.as_any_box().downcast::<BoolOption>()?),
            StructType::ChoiceOption => Ok(from.as_any_box().downcast::<ChoiceOption>()?),
            StructType::FloatOption => Ok(from.as_any_box().downcast::<FloatOption>()?),
            StructType::IntOption => Ok(from.as_any_box().downcast::<IntOption>()?),
            StructType::LongOption => Ok(from.as_any_box().downcast::<LongOption>()?),
            StructType::StringOption => Ok(from.as_any_box().downcast::<StringOption>()?),
            StructType::OptionValue => Ok(from.as_any_box().downcast::<OptionValue>()?),
            StructType::HostInternetScsiHbaParamValue => Ok(from.as_any_box().downcast::<HostInternetScsiHbaParamValue>()?),
            StructType::ApplyProfile => Ok(from.as_any_box().downcast::<ApplyProfile>()?),
            StructType::ProfileApplyProfileElement => Ok(from.as_any_box().downcast::<ProfileApplyProfileElement>()?),
            StructType::ActiveDirectoryProfile => Ok(from.as_any_box().downcast::<ActiveDirectoryProfile>()?),
            StructType::AuthenticationProfile => Ok(from.as_any_box().downcast::<AuthenticationProfile>()?),
            StructType::DateTimeProfile => Ok(from.as_any_box().downcast::<DateTimeProfile>()?),
            StructType::DvsProfile => Ok(from.as_any_box().downcast::<DvsProfile>()?),
            StructType::DvsVNicProfile => Ok(from.as_any_box().downcast::<DvsVNicProfile>()?),
            StructType::DvsHostVNicProfile => Ok(from.as_any_box().downcast::<DvsHostVNicProfile>()?),
            StructType::DvsServiceConsoleVNicProfile => Ok(from.as_any_box().downcast::<DvsServiceConsoleVNicProfile>()?),
            StructType::FirewallProfile => Ok(from.as_any_box().downcast::<FirewallProfile>()?),
            StructType::FirewallProfileRulesetProfile => Ok(from.as_any_box().downcast::<FirewallProfileRulesetProfile>()?),
            StructType::HostApplyProfile => Ok(from.as_any_box().downcast::<HostApplyProfile>()?),
            StructType::HostMemoryProfile => Ok(from.as_any_box().downcast::<HostMemoryProfile>()?),
            StructType::IpAddressProfile => Ok(from.as_any_box().downcast::<IpAddressProfile>()?),
            StructType::IpRouteProfile => Ok(from.as_any_box().downcast::<IpRouteProfile>()?),
            StructType::NasStorageProfile => Ok(from.as_any_box().downcast::<NasStorageProfile>()?),
            StructType::NetStackInstanceProfile => Ok(from.as_any_box().downcast::<NetStackInstanceProfile>()?),
            StructType::NetworkPolicyProfile => Ok(from.as_any_box().downcast::<NetworkPolicyProfile>()?),
            StructType::NetworkProfile => Ok(from.as_any_box().downcast::<NetworkProfile>()?),
            StructType::NetworkProfileDnsConfigProfile => Ok(from.as_any_box().downcast::<NetworkProfileDnsConfigProfile>()?),
            StructType::NsxHostVNicProfile => Ok(from.as_any_box().downcast::<NsxHostVNicProfile>()?),
            StructType::OpaqueSwitchProfile => Ok(from.as_any_box().downcast::<OpaqueSwitchProfile>()?),
            StructType::OptionProfile => Ok(from.as_any_box().downcast::<OptionProfile>()?),
            StructType::PermissionProfile => Ok(from.as_any_box().downcast::<PermissionProfile>()?),
            StructType::PhysicalNicProfile => Ok(from.as_any_box().downcast::<PhysicalNicProfile>()?),
            StructType::PnicUplinkProfile => Ok(from.as_any_box().downcast::<PnicUplinkProfile>()?),
            StructType::PortGroupProfile => Ok(from.as_any_box().downcast::<PortGroupProfile>()?),
            StructType::HostPortGroupProfile => Ok(from.as_any_box().downcast::<HostPortGroupProfile>()?),
            StructType::ServiceConsolePortGroupProfile => Ok(from.as_any_box().downcast::<ServiceConsolePortGroupProfile>()?),
            StructType::VmPortGroupProfile => Ok(from.as_any_box().downcast::<VmPortGroupProfile>()?),
            StructType::VirtualSwitchSelectionProfile => Ok(from.as_any_box().downcast::<VirtualSwitchSelectionProfile>()?),
            StructType::VlanProfile => Ok(from.as_any_box().downcast::<VlanProfile>()?),
            StructType::SecurityProfile => Ok(from.as_any_box().downcast::<SecurityProfile>()?),
            StructType::ServiceProfile => Ok(from.as_any_box().downcast::<ServiceProfile>()?),
            StructType::StaticRouteProfile => Ok(from.as_any_box().downcast::<StaticRouteProfile>()?),
            StructType::StorageProfile => Ok(from.as_any_box().downcast::<StorageProfile>()?),
            StructType::UserGroupProfile => Ok(from.as_any_box().downcast::<UserGroupProfile>()?),
            StructType::UserProfile => Ok(from.as_any_box().downcast::<UserProfile>()?),
            StructType::VirtualSwitchProfile => Ok(from.as_any_box().downcast::<VirtualSwitchProfile>()?),
            StructType::LinkProfile => Ok(from.as_any_box().downcast::<LinkProfile>()?),
            StructType::NumPortsProfile => Ok(from.as_any_box().downcast::<NumPortsProfile>()?),
            StructType::ProfileApplyProfileProperty => Ok(from.as_any_box().downcast::<ProfileApplyProfileProperty>()?),
            StructType::ComplianceLocator => Ok(from.as_any_box().downcast::<ComplianceLocator>()?),
            StructType::ComplianceProfile => Ok(from.as_any_box().downcast::<ComplianceProfile>()?),
            StructType::ComplianceResult => Ok(from.as_any_box().downcast::<ComplianceResult>()?),
            StructType::ComplianceFailure => Ok(from.as_any_box().downcast::<ComplianceFailure>()?),
            StructType::ComplianceFailureComplianceFailureValues => Ok(from.as_any_box().downcast::<ComplianceFailureComplianceFailureValues>()?),
            StructType::ProfileDeferredPolicyOptionParameter => Ok(from.as_any_box().downcast::<ProfileDeferredPolicyOptionParameter>()?),
            StructType::ProfileExpression => Ok(from.as_any_box().downcast::<ProfileExpression>()?),
            StructType::ProfileCompositeExpression => Ok(from.as_any_box().downcast::<ProfileCompositeExpression>()?),
            StructType::ProfileSimpleExpression => Ok(from.as_any_box().downcast::<ProfileSimpleExpression>()?),
            StructType::ProfileExpressionMetadata => Ok(from.as_any_box().downcast::<ProfileExpressionMetadata>()?),
            StructType::ProfileParameterMetadata => Ok(from.as_any_box().downcast::<ProfileParameterMetadata>()?),
            StructType::ProfileParameterMetadataParameterRelationMetadata => Ok(from.as_any_box().downcast::<ProfileParameterMetadataParameterRelationMetadata>()?),
            StructType::ProfilePolicy => Ok(from.as_any_box().downcast::<ProfilePolicy>()?),
            StructType::ProfilePolicyMetadata => Ok(from.as_any_box().downcast::<ProfilePolicyMetadata>()?),
            StructType::PolicyOption => Ok(from.as_any_box().downcast::<PolicyOption>()?),
            StructType::CompositePolicyOption => Ok(from.as_any_box().downcast::<CompositePolicyOption>()?),
            StructType::ProfilePolicyOptionMetadata => Ok(from.as_any_box().downcast::<ProfilePolicyOptionMetadata>()?),
            StructType::ProfileCompositePolicyOptionMetadata => Ok(from.as_any_box().downcast::<ProfileCompositePolicyOptionMetadata>()?),
            StructType::UserInputRequiredParameterMetadata => Ok(from.as_any_box().downcast::<UserInputRequiredParameterMetadata>()?),
            StructType::ProfileConfigInfo => Ok(from.as_any_box().downcast::<ProfileConfigInfo>()?),
            StructType::ClusterProfileConfigInfo => Ok(from.as_any_box().downcast::<ClusterProfileConfigInfo>()?),
            StructType::HostProfileConfigInfo => Ok(from.as_any_box().downcast::<HostProfileConfigInfo>()?),
            StructType::ProfileCreateSpec => Ok(from.as_any_box().downcast::<ProfileCreateSpec>()?),
            StructType::ProfileSerializedCreateSpec => Ok(from.as_any_box().downcast::<ProfileSerializedCreateSpec>()?),
            StructType::HostProfileSerializedHostProfileSpec => Ok(from.as_any_box().downcast::<HostProfileSerializedHostProfileSpec>()?),
            StructType::ClusterProfileCreateSpec => Ok(from.as_any_box().downcast::<ClusterProfileCreateSpec>()?),
            StructType::ClusterProfileConfigSpec => Ok(from.as_any_box().downcast::<ClusterProfileConfigSpec>()?),
            StructType::ClusterProfileCompleteConfigSpec => Ok(from.as_any_box().downcast::<ClusterProfileCompleteConfigSpec>()?),
            StructType::ClusterProfileConfigServiceCreateSpec => Ok(from.as_any_box().downcast::<ClusterProfileConfigServiceCreateSpec>()?),
            StructType::HostProfileConfigSpec => Ok(from.as_any_box().downcast::<HostProfileConfigSpec>()?),
            StructType::HostProfileCompleteConfigSpec => Ok(from.as_any_box().downcast::<HostProfileCompleteConfigSpec>()?),
            StructType::HostProfileHostBasedConfigSpec => Ok(from.as_any_box().downcast::<HostProfileHostBasedConfigSpec>()?),
            StructType::ProfileDescription => Ok(from.as_any_box().downcast::<ProfileDescription>()?),
            StructType::ProfileDescriptionSection => Ok(from.as_any_box().downcast::<ProfileDescriptionSection>()?),
            StructType::ProfileMetadata => Ok(from.as_any_box().downcast::<ProfileMetadata>()?),
            StructType::ProfileMetadataProfileOperationMessage => Ok(from.as_any_box().downcast::<ProfileMetadataProfileOperationMessage>()?),
            StructType::ProfileMetadataProfileSortSpec => Ok(from.as_any_box().downcast::<ProfileMetadataProfileSortSpec>()?),
            StructType::ProfilePropertyPath => Ok(from.as_any_box().downcast::<ProfilePropertyPath>()?),
            StructType::ProfileProfileStructure => Ok(from.as_any_box().downcast::<ProfileProfileStructure>()?),
            StructType::ProfileProfileStructureProperty => Ok(from.as_any_box().downcast::<ProfileProfileStructureProperty>()?),
            StructType::AnswerFile => Ok(from.as_any_box().downcast::<AnswerFile>()?),
            StructType::AnswerFileStatusResult => Ok(from.as_any_box().downcast::<AnswerFileStatusResult>()?),
            StructType::AnswerFileStatusError => Ok(from.as_any_box().downcast::<AnswerFileStatusError>()?),
            StructType::ProfileExecuteResult => Ok(from.as_any_box().downcast::<ProfileExecuteResult>()?),
            StructType::ApplyHostProfileConfigurationSpec => Ok(from.as_any_box().downcast::<ApplyHostProfileConfigurationSpec>()?),
            StructType::ProfileExecuteError => Ok(from.as_any_box().downcast::<ProfileExecuteError>()?),
            StructType::HostProfileValidationFailureInfo => Ok(from.as_any_box().downcast::<HostProfileValidationFailureInfo>()?),
            StructType::HostSpecification => Ok(from.as_any_box().downcast::<HostSpecification>()?),
            StructType::HostSubSpecification => Ok(from.as_any_box().downcast::<HostSubSpecification>()?),
            StructType::AnswerFileCreateSpec => Ok(from.as_any_box().downcast::<AnswerFileCreateSpec>()?),
            StructType::AnswerFileOptionsCreateSpec => Ok(from.as_any_box().downcast::<AnswerFileOptionsCreateSpec>()?),
            StructType::AnswerFileSerializedCreateSpec => Ok(from.as_any_box().downcast::<AnswerFileSerializedCreateSpec>()?),
            StructType::ApplyHostProfileConfigurationResult => Ok(from.as_any_box().downcast::<ApplyHostProfileConfigurationResult>()?),
            StructType::HostProfileManagerCompositionResult => Ok(from.as_any_box().downcast::<HostProfileManagerCompositionResult>()?),
            StructType::HostProfileManagerCompositionResultResultElement => Ok(from.as_any_box().downcast::<HostProfileManagerCompositionResultResultElement>()?),
            StructType::HostProfileManagerCompositionValidationResult => Ok(from.as_any_box().downcast::<HostProfileManagerCompositionValidationResult>()?),
            StructType::HostProfileManagerCompositionValidationResultResultElement => Ok(from.as_any_box().downcast::<HostProfileManagerCompositionValidationResultResultElement>()?),
            StructType::HostProfileManagerConfigTaskList => Ok(from.as_any_box().downcast::<HostProfileManagerConfigTaskList>()?),
            StructType::HostProfilesEntityCustomizations => Ok(from.as_any_box().downcast::<HostProfilesEntityCustomizations>()?),
            StructType::StructuredCustomizations => Ok(from.as_any_box().downcast::<StructuredCustomizations>()?),
            StructType::HostProfileManagerHostToConfigSpecMap => Ok(from.as_any_box().downcast::<HostProfileManagerHostToConfigSpecMap>()?),
            StructType::ScheduledTaskDescription => Ok(from.as_any_box().downcast::<ScheduledTaskDescription>()?),
            StructType::ScheduledTaskSpec => Ok(from.as_any_box().downcast::<ScheduledTaskSpec>()?),
            StructType::ScheduledTaskInfo => Ok(from.as_any_box().downcast::<ScheduledTaskInfo>()?),
            StructType::TaskScheduler => Ok(from.as_any_box().downcast::<TaskScheduler>()?),
            StructType::AfterStartupTaskScheduler => Ok(from.as_any_box().downcast::<AfterStartupTaskScheduler>()?),
            StructType::OnceTaskScheduler => Ok(from.as_any_box().downcast::<OnceTaskScheduler>()?),
            StructType::RecurrentTaskScheduler => Ok(from.as_any_box().downcast::<RecurrentTaskScheduler>()?),
            StructType::HourlyTaskScheduler => Ok(from.as_any_box().downcast::<HourlyTaskScheduler>()?),
            StructType::DailyTaskScheduler => Ok(from.as_any_box().downcast::<DailyTaskScheduler>()?),
            StructType::MonthlyTaskScheduler => Ok(from.as_any_box().downcast::<MonthlyTaskScheduler>()?),
            StructType::MonthlyByDayTaskScheduler => Ok(from.as_any_box().downcast::<MonthlyByDayTaskScheduler>()?),
            StructType::MonthlyByWeekdayTaskScheduler => Ok(from.as_any_box().downcast::<MonthlyByWeekdayTaskScheduler>()?),
            StructType::WeeklyTaskScheduler => Ok(from.as_any_box().downcast::<WeeklyTaskScheduler>()?),
            StructType::ApplyStorageRecommendationResult => Ok(from.as_any_box().downcast::<ApplyStorageRecommendationResult>()?),
            StructType::StorageDrsAutomationConfig => Ok(from.as_any_box().downcast::<StorageDrsAutomationConfig>()?),
            StructType::StorageDrsConfigInfo => Ok(from.as_any_box().downcast::<StorageDrsConfigInfo>()?),
            StructType::StorageDrsConfigSpec => Ok(from.as_any_box().downcast::<StorageDrsConfigSpec>()?),
            StructType::StorageDrsIoLoadBalanceConfig => Ok(from.as_any_box().downcast::<StorageDrsIoLoadBalanceConfig>()?),
            StructType::PlacementAffinityRule => Ok(from.as_any_box().downcast::<PlacementAffinityRule>()?),
            StructType::PlacementRankResult => Ok(from.as_any_box().downcast::<PlacementRankResult>()?),
            StructType::PlacementRankSpec => Ok(from.as_any_box().downcast::<PlacementRankSpec>()?),
            StructType::StorageDrsPlacementRankVmSpec => Ok(from.as_any_box().downcast::<StorageDrsPlacementRankVmSpec>()?),
            StructType::StorageDrsPodConfigInfo => Ok(from.as_any_box().downcast::<StorageDrsPodConfigInfo>()?),
            StructType::StorageDrsPodConfigSpec => Ok(from.as_any_box().downcast::<StorageDrsPodConfigSpec>()?),
            StructType::StorageDrsPodSelectionSpec => Ok(from.as_any_box().downcast::<StorageDrsPodSelectionSpec>()?),
            StructType::PodDiskLocator => Ok(from.as_any_box().downcast::<PodDiskLocator>()?),
            StructType::VmPodConfigForPlacement => Ok(from.as_any_box().downcast::<VmPodConfigForPlacement>()?),
            StructType::StorageDrsSpaceLoadBalanceConfig => Ok(from.as_any_box().downcast::<StorageDrsSpaceLoadBalanceConfig>()?),
            StructType::StoragePlacementResult => Ok(from.as_any_box().downcast::<StoragePlacementResult>()?),
            StructType::StoragePlacementSpec => Ok(from.as_any_box().downcast::<StoragePlacementSpec>()?),
            StructType::StorageDrsVmConfigInfo => Ok(from.as_any_box().downcast::<StorageDrsVmConfigInfo>()?),
            StructType::VAppCloneSpec => Ok(from.as_any_box().downcast::<VAppCloneSpec>()?),
            StructType::VAppCloneSpecNetworkMappingPair => Ok(from.as_any_box().downcast::<VAppCloneSpecNetworkMappingPair>()?),
            StructType::VAppCloneSpecResourceMap => Ok(from.as_any_box().downcast::<VAppCloneSpecResourceMap>()?),
            StructType::VAppEntityConfigInfo => Ok(from.as_any_box().downcast::<VAppEntityConfigInfo>()?),
            StructType::VAppIpAssignmentInfo => Ok(from.as_any_box().downcast::<VAppIpAssignmentInfo>()?),
            StructType::IpPool => Ok(from.as_any_box().downcast::<IpPool>()?),
            StructType::IpPoolAssociation => Ok(from.as_any_box().downcast::<IpPoolAssociation>()?),
            StructType::IpPoolIpPoolConfigInfo => Ok(from.as_any_box().downcast::<IpPoolIpPoolConfigInfo>()?),
            StructType::VAppOvfSectionInfo => Ok(from.as_any_box().downcast::<VAppOvfSectionInfo>()?),
            StructType::VAppProductInfo => Ok(from.as_any_box().downcast::<VAppProductInfo>()?),
            StructType::VAppPropertyInfo => Ok(from.as_any_box().downcast::<VAppPropertyInfo>()?),
            StructType::VmConfigInfo => Ok(from.as_any_box().downcast::<VmConfigInfo>()?),
            StructType::VAppConfigInfo => Ok(from.as_any_box().downcast::<VAppConfigInfo>()?),
            StructType::VmConfigSpec => Ok(from.as_any_box().downcast::<VmConfigSpec>()?),
            StructType::VAppConfigSpec => Ok(from.as_any_box().downcast::<VAppConfigSpec>()?),
            StructType::ClusterNetworkConfigSpec => Ok(from.as_any_box().downcast::<ClusterNetworkConfigSpec>()?),
            StructType::FailoverNodeInfo => Ok(from.as_any_box().downcast::<FailoverNodeInfo>()?),
            StructType::NodeDeploymentSpec => Ok(from.as_any_box().downcast::<NodeDeploymentSpec>()?),
            StructType::PassiveNodeDeploymentSpec => Ok(from.as_any_box().downcast::<PassiveNodeDeploymentSpec>()?),
            StructType::NodeNetworkSpec => Ok(from.as_any_box().downcast::<NodeNetworkSpec>()?),
            StructType::PassiveNodeNetworkSpec => Ok(from.as_any_box().downcast::<PassiveNodeNetworkSpec>()?),
            StructType::SourceNodeSpec => Ok(from.as_any_box().downcast::<SourceNodeSpec>()?),
            StructType::VchaClusterConfigInfo => Ok(from.as_any_box().downcast::<VchaClusterConfigInfo>()?),
            StructType::VchaClusterConfigSpec => Ok(from.as_any_box().downcast::<VchaClusterConfigSpec>()?),
            StructType::VchaClusterDeploymentSpec => Ok(from.as_any_box().downcast::<VchaClusterDeploymentSpec>()?),
            StructType::VchaClusterNetworkSpec => Ok(from.as_any_box().downcast::<VchaClusterNetworkSpec>()?),
            StructType::WitnessNodeInfo => Ok(from.as_any_box().downcast::<WitnessNodeInfo>()?),
            StructType::VchaClusterHealth => Ok(from.as_any_box().downcast::<VchaClusterHealth>()?),
            StructType::VchaClusterRuntimeInfo => Ok(from.as_any_box().downcast::<VchaClusterRuntimeInfo>()?),
            StructType::VchaNodeRuntimeInfo => Ok(from.as_any_box().downcast::<VchaNodeRuntimeInfo>()?),
            StructType::VirtualMachineAffinityInfo => Ok(from.as_any_box().downcast::<VirtualMachineAffinityInfo>()?),
            StructType::VirtualMachineBaseIndependentFilterSpec => Ok(from.as_any_box().downcast::<VirtualMachineBaseIndependentFilterSpec>()?),
            StructType::VirtualMachineEmptyIndependentFilterSpec => Ok(from.as_any_box().downcast::<VirtualMachineEmptyIndependentFilterSpec>()?),
            StructType::VirtualMachineIndependentFilterSpec => Ok(from.as_any_box().downcast::<VirtualMachineIndependentFilterSpec>()?),
            StructType::VirtualMachineBootOptions => Ok(from.as_any_box().downcast::<VirtualMachineBootOptions>()?),
            StructType::VirtualMachineBootOptionsBootableDevice => Ok(from.as_any_box().downcast::<VirtualMachineBootOptionsBootableDevice>()?),
            StructType::VirtualMachineBootOptionsBootableCdromDevice => Ok(from.as_any_box().downcast::<VirtualMachineBootOptionsBootableCdromDevice>()?),
            StructType::VirtualMachineBootOptionsBootableDiskDevice => Ok(from.as_any_box().downcast::<VirtualMachineBootOptionsBootableDiskDevice>()?),
            StructType::VirtualMachineBootOptionsBootableEthernetDevice => Ok(from.as_any_box().downcast::<VirtualMachineBootOptionsBootableEthernetDevice>()?),
            StructType::VirtualMachineBootOptionsBootableFloppyDevice => Ok(from.as_any_box().downcast::<VirtualMachineBootOptionsBootableFloppyDevice>()?),
            StructType::VirtualMachineCapability => Ok(from.as_any_box().downcast::<VirtualMachineCapability>()?),
            StructType::VirtualMachineCertThumbprint => Ok(from.as_any_box().downcast::<VirtualMachineCertThumbprint>()?),
            StructType::VirtualMachineCloneSpec => Ok(from.as_any_box().downcast::<VirtualMachineCloneSpec>()?),
            StructType::VirtualMachineConfigInfo => Ok(from.as_any_box().downcast::<VirtualMachineConfigInfo>()?),
            StructType::VirtualMachineConfigInfoDatastoreUrlPair => Ok(from.as_any_box().downcast::<VirtualMachineConfigInfoDatastoreUrlPair>()?),
            StructType::VirtualMachineConfigInfoOverheadInfo => Ok(from.as_any_box().downcast::<VirtualMachineConfigInfoOverheadInfo>()?),
            StructType::VirtualMachineConfigOption => Ok(from.as_any_box().downcast::<VirtualMachineConfigOption>()?),
            StructType::VirtualMachineConfigOptionDescriptor => Ok(from.as_any_box().downcast::<VirtualMachineConfigOptionDescriptor>()?),
            StructType::VirtualMachineConfigSpec => Ok(from.as_any_box().downcast::<VirtualMachineConfigSpec>()?),
            StructType::ConfigTarget => Ok(from.as_any_box().downcast::<ConfigTarget>()?),
            StructType::VirtualMachineConsolePreferences => Ok(from.as_any_box().downcast::<VirtualMachineConsolePreferences>()?),
            StructType::VirtualMachineContentLibraryItemInfo => Ok(from.as_any_box().downcast::<VirtualMachineContentLibraryItemInfo>()?),
            StructType::DatastoreOption => Ok(from.as_any_box().downcast::<DatastoreOption>()?),
            StructType::VirtualMachineDatastoreVolumeOption => Ok(from.as_any_box().downcast::<VirtualMachineDatastoreVolumeOption>()?),
            StructType::VirtualMachineDefaultPowerOpInfo => Ok(from.as_any_box().downcast::<VirtualMachineDefaultPowerOpInfo>()?),
            StructType::VirtualMachineDeviceRuntimeInfo => Ok(from.as_any_box().downcast::<VirtualMachineDeviceRuntimeInfo>()?),
            StructType::VirtualMachineDeviceRuntimeInfoDeviceRuntimeState => Ok(from.as_any_box().downcast::<VirtualMachineDeviceRuntimeInfoDeviceRuntimeState>()?),
            StructType::VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState => Ok(from.as_any_box().downcast::<VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState>()?),
            StructType::VirtualMachineDvxClassInfo => Ok(from.as_any_box().downcast::<VirtualMachineDvxClassInfo>()?),
            StructType::FaultToleranceConfigInfo => Ok(from.as_any_box().downcast::<FaultToleranceConfigInfo>()?),
            StructType::FaultTolerancePrimaryConfigInfo => Ok(from.as_any_box().downcast::<FaultTolerancePrimaryConfigInfo>()?),
            StructType::FaultToleranceSecondaryConfigInfo => Ok(from.as_any_box().downcast::<FaultToleranceSecondaryConfigInfo>()?),
            StructType::FaultToleranceConfigSpec => Ok(from.as_any_box().downcast::<FaultToleranceConfigSpec>()?),
            StructType::FaultToleranceMetaSpec => Ok(from.as_any_box().downcast::<FaultToleranceMetaSpec>()?),
            StructType::FaultToleranceSecondaryOpResult => Ok(from.as_any_box().downcast::<FaultToleranceSecondaryOpResult>()?),
            StructType::FaultToleranceVmConfigSpec => Ok(from.as_any_box().downcast::<FaultToleranceVmConfigSpec>()?),
            StructType::FaultToleranceDiskSpec => Ok(from.as_any_box().downcast::<FaultToleranceDiskSpec>()?),
            StructType::VirtualMachineFeatureRequirement => Ok(from.as_any_box().downcast::<VirtualMachineFeatureRequirement>()?),
            StructType::VirtualMachineFileInfo => Ok(from.as_any_box().downcast::<VirtualMachineFileInfo>()?),
            StructType::VirtualMachineFileLayout => Ok(from.as_any_box().downcast::<VirtualMachineFileLayout>()?),
            StructType::VirtualMachineFileLayoutDiskLayout => Ok(from.as_any_box().downcast::<VirtualMachineFileLayoutDiskLayout>()?),
            StructType::VirtualMachineFileLayoutSnapshotLayout => Ok(from.as_any_box().downcast::<VirtualMachineFileLayoutSnapshotLayout>()?),
            StructType::VirtualMachineFileLayoutEx => Ok(from.as_any_box().downcast::<VirtualMachineFileLayoutEx>()?),
            StructType::VirtualMachineFileLayoutExDiskLayout => Ok(from.as_any_box().downcast::<VirtualMachineFileLayoutExDiskLayout>()?),
            StructType::VirtualMachineFileLayoutExDiskUnit => Ok(from.as_any_box().downcast::<VirtualMachineFileLayoutExDiskUnit>()?),
            StructType::VirtualMachineFileLayoutExFileInfo => Ok(from.as_any_box().downcast::<VirtualMachineFileLayoutExFileInfo>()?),
            StructType::VirtualMachineFileLayoutExSnapshotLayout => Ok(from.as_any_box().downcast::<VirtualMachineFileLayoutExSnapshotLayout>()?),
            StructType::VirtualMachineFlagInfo => Ok(from.as_any_box().downcast::<VirtualMachineFlagInfo>()?),
            StructType::VirtualMachineForkConfigInfo => Ok(from.as_any_box().downcast::<VirtualMachineForkConfigInfo>()?),
            StructType::GuestInfo => Ok(from.as_any_box().downcast::<GuestInfo>()?),
            StructType::GuestInfoCustomizationInfo => Ok(from.as_any_box().downcast::<GuestInfoCustomizationInfo>()?),
            StructType::GuestDiskInfo => Ok(from.as_any_box().downcast::<GuestDiskInfo>()?),
            StructType::GuestInfoNamespaceGenerationInfo => Ok(from.as_any_box().downcast::<GuestInfoNamespaceGenerationInfo>()?),
            StructType::GuestNicInfo => Ok(from.as_any_box().downcast::<GuestNicInfo>()?),
            StructType::GuestScreenInfo => Ok(from.as_any_box().downcast::<GuestScreenInfo>()?),
            StructType::GuestStackInfo => Ok(from.as_any_box().downcast::<GuestStackInfo>()?),
            StructType::GuestInfoVirtualDiskMapping => Ok(from.as_any_box().downcast::<GuestInfoVirtualDiskMapping>()?),
            StructType::VirtualMachineGuestIntegrityInfo => Ok(from.as_any_box().downcast::<VirtualMachineGuestIntegrityInfo>()?),
            StructType::VirtualMachineGuestMonitoringModeInfo => Ok(from.as_any_box().downcast::<VirtualMachineGuestMonitoringModeInfo>()?),
            StructType::GuestOsDescriptor => Ok(from.as_any_box().downcast::<GuestOsDescriptor>()?),
            StructType::VirtualMachineGuestQuiesceSpec => Ok(from.as_any_box().downcast::<VirtualMachineGuestQuiesceSpec>()?),
            StructType::VirtualMachineWindowsQuiesceSpec => Ok(from.as_any_box().downcast::<VirtualMachineWindowsQuiesceSpec>()?),
            StructType::VirtualMachineIdeDiskDevicePartitionInfo => Ok(from.as_any_box().downcast::<VirtualMachineIdeDiskDevicePartitionInfo>()?),
            StructType::VirtualMachineInstantCloneSpec => Ok(from.as_any_box().downcast::<VirtualMachineInstantCloneSpec>()?),
            StructType::VirtualMachineLegacyNetworkSwitchInfo => Ok(from.as_any_box().downcast::<VirtualMachineLegacyNetworkSwitchInfo>()?),
            StructType::VirtualMachineMessage => Ok(from.as_any_box().downcast::<VirtualMachineMessage>()?),
            StructType::VirtualMachineMetadataManagerVmMetadata => Ok(from.as_any_box().downcast::<VirtualMachineMetadataManagerVmMetadata>()?),
            StructType::VirtualMachineMetadataManagerVmMetadataInput => Ok(from.as_any_box().downcast::<VirtualMachineMetadataManagerVmMetadataInput>()?),
            StructType::VirtualMachineMetadataManagerVmMetadataOwner => Ok(from.as_any_box().downcast::<VirtualMachineMetadataManagerVmMetadataOwner>()?),
            StructType::VirtualMachineMetadataManagerVmMetadataResult => Ok(from.as_any_box().downcast::<VirtualMachineMetadataManagerVmMetadataResult>()?),
            StructType::VirtualMachineNetworkShaperInfo => Ok(from.as_any_box().downcast::<VirtualMachineNetworkShaperInfo>()?),
            StructType::VirtualMachineProfileDetails => Ok(from.as_any_box().downcast::<VirtualMachineProfileDetails>()?),
            StructType::VirtualMachineProfileDetailsDiskProfileDetails => Ok(from.as_any_box().downcast::<VirtualMachineProfileDetailsDiskProfileDetails>()?),
            StructType::VirtualMachineProfileRawData => Ok(from.as_any_box().downcast::<VirtualMachineProfileRawData>()?),
            StructType::VirtualMachineProfileSpec => Ok(from.as_any_box().downcast::<VirtualMachineProfileSpec>()?),
            StructType::VirtualMachineDefaultProfileSpec => Ok(from.as_any_box().downcast::<VirtualMachineDefaultProfileSpec>()?),
            StructType::VirtualMachineDefinedProfileSpec => Ok(from.as_any_box().downcast::<VirtualMachineDefinedProfileSpec>()?),
            StructType::VirtualMachineEmptyProfileSpec => Ok(from.as_any_box().downcast::<VirtualMachineEmptyProfileSpec>()?),
            StructType::VirtualMachinePropertyRelation => Ok(from.as_any_box().downcast::<VirtualMachinePropertyRelation>()?),
            StructType::VirtualMachineQuestionInfo => Ok(from.as_any_box().downcast::<VirtualMachineQuestionInfo>()?),
            StructType::VirtualMachineRelocateSpec => Ok(from.as_any_box().downcast::<VirtualMachineRelocateSpec>()?),
            StructType::VirtualMachineRelocateSpecDiskLocator => Ok(from.as_any_box().downcast::<VirtualMachineRelocateSpecDiskLocator>()?),
            StructType::VirtualMachineRelocateSpecDiskLocatorBackingSpec => Ok(from.as_any_box().downcast::<VirtualMachineRelocateSpecDiskLocatorBackingSpec>()?),
            StructType::ReplicationConfigSpec => Ok(from.as_any_box().downcast::<ReplicationConfigSpec>()?),
            StructType::ReplicationInfoDiskSettings => Ok(from.as_any_box().downcast::<ReplicationInfoDiskSettings>()?),
            StructType::VirtualMachineRuntimeInfo => Ok(from.as_any_box().downcast::<VirtualMachineRuntimeInfo>()?),
            StructType::VirtualMachineRuntimeInfoDasProtectionState => Ok(from.as_any_box().downcast::<VirtualMachineRuntimeInfoDasProtectionState>()?),
            StructType::ScheduledHardwareUpgradeInfo => Ok(from.as_any_box().downcast::<ScheduledHardwareUpgradeInfo>()?),
            StructType::VirtualMachineSgxInfo => Ok(from.as_any_box().downcast::<VirtualMachineSgxInfo>()?),
            StructType::VirtualMachineSnapshotInfo => Ok(from.as_any_box().downcast::<VirtualMachineSnapshotInfo>()?),
            StructType::VirtualMachineSnapshotTree => Ok(from.as_any_box().downcast::<VirtualMachineSnapshotTree>()?),
            StructType::VirtualMachineSriovDevicePoolInfo => Ok(from.as_any_box().downcast::<VirtualMachineSriovDevicePoolInfo>()?),
            StructType::VirtualMachineSriovNetworkDevicePoolInfo => Ok(from.as_any_box().downcast::<VirtualMachineSriovNetworkDevicePoolInfo>()?),
            StructType::VirtualMachineStorageInfo => Ok(from.as_any_box().downcast::<VirtualMachineStorageInfo>()?),
            StructType::VirtualMachineUsageOnDatastore => Ok(from.as_any_box().downcast::<VirtualMachineUsageOnDatastore>()?),
            StructType::VirtualMachineSummary => Ok(from.as_any_box().downcast::<VirtualMachineSummary>()?),
            StructType::VirtualMachineConfigSummary => Ok(from.as_any_box().downcast::<VirtualMachineConfigSummary>()?),
            StructType::VirtualMachineGuestSummary => Ok(from.as_any_box().downcast::<VirtualMachineGuestSummary>()?),
            StructType::VirtualMachineQuickStats => Ok(from.as_any_box().downcast::<VirtualMachineQuickStats>()?),
            StructType::VirtualMachineQuickStatsMemoryTierStats => Ok(from.as_any_box().downcast::<VirtualMachineQuickStatsMemoryTierStats>()?),
            StructType::VirtualMachineStorageSummary => Ok(from.as_any_box().downcast::<VirtualMachineStorageSummary>()?),
            StructType::VirtualMachineTargetInfo => Ok(from.as_any_box().downcast::<VirtualMachineTargetInfo>()?),
            StructType::VirtualMachineCdromInfo => Ok(from.as_any_box().downcast::<VirtualMachineCdromInfo>()?),
            StructType::VirtualMachineDatastoreInfo => Ok(from.as_any_box().downcast::<VirtualMachineDatastoreInfo>()?),
            StructType::VirtualMachineDiskDeviceInfo => Ok(from.as_any_box().downcast::<VirtualMachineDiskDeviceInfo>()?),
            StructType::VirtualMachineIdeDiskDeviceInfo => Ok(from.as_any_box().downcast::<VirtualMachineIdeDiskDeviceInfo>()?),
            StructType::VirtualMachineScsiDiskDeviceInfo => Ok(from.as_any_box().downcast::<VirtualMachineScsiDiskDeviceInfo>()?),
            StructType::VirtualMachineDynamicPassthroughInfo => Ok(from.as_any_box().downcast::<VirtualMachineDynamicPassthroughInfo>()?),
            StructType::VirtualMachineFloppyInfo => Ok(from.as_any_box().downcast::<VirtualMachineFloppyInfo>()?),
            StructType::VirtualMachineNetworkInfo => Ok(from.as_any_box().downcast::<VirtualMachineNetworkInfo>()?),
            StructType::OpaqueNetworkTargetInfo => Ok(from.as_any_box().downcast::<OpaqueNetworkTargetInfo>()?),
            StructType::VirtualMachineParallelInfo => Ok(from.as_any_box().downcast::<VirtualMachineParallelInfo>()?),
            StructType::VirtualMachinePciPassthroughInfo => Ok(from.as_any_box().downcast::<VirtualMachinePciPassthroughInfo>()?),
            StructType::VirtualMachineSriovInfo => Ok(from.as_any_box().downcast::<VirtualMachineSriovInfo>()?),
            StructType::VirtualMachinePciSharedGpuPassthroughInfo => Ok(from.as_any_box().downcast::<VirtualMachinePciSharedGpuPassthroughInfo>()?),
            StructType::VirtualMachinePrecisionClockInfo => Ok(from.as_any_box().downcast::<VirtualMachinePrecisionClockInfo>()?),
            StructType::VirtualMachineScsiPassthroughInfo => Ok(from.as_any_box().downcast::<VirtualMachineScsiPassthroughInfo>()?),
            StructType::VirtualMachineSerialInfo => Ok(from.as_any_box().downcast::<VirtualMachineSerialInfo>()?),
            StructType::VirtualMachineSgxTargetInfo => Ok(from.as_any_box().downcast::<VirtualMachineSgxTargetInfo>()?),
            StructType::VirtualMachineSoundInfo => Ok(from.as_any_box().downcast::<VirtualMachineSoundInfo>()?),
            StructType::VirtualMachineUsbInfo => Ok(from.as_any_box().downcast::<VirtualMachineUsbInfo>()?),
            StructType::VirtualMachineVFlashModuleInfo => Ok(from.as_any_box().downcast::<VirtualMachineVFlashModuleInfo>()?),
            StructType::VirtualMachineVMotionStunTimeInfo => Ok(from.as_any_box().downcast::<VirtualMachineVMotionStunTimeInfo>()?),
            StructType::VirtualMachineVendorDeviceGroupInfo => Ok(from.as_any_box().downcast::<VirtualMachineVendorDeviceGroupInfo>()?),
            StructType::VirtualMachineVgpuDeviceInfo => Ok(from.as_any_box().downcast::<VirtualMachineVgpuDeviceInfo>()?),
            StructType::VirtualMachineVgpuProfileInfo => Ok(from.as_any_box().downcast::<VirtualMachineVgpuProfileInfo>()?),
            StructType::ToolsConfigInfo => Ok(from.as_any_box().downcast::<ToolsConfigInfo>()?),
            StructType::ToolsConfigInfoToolsLastInstallInfo => Ok(from.as_any_box().downcast::<ToolsConfigInfoToolsLastInstallInfo>()?),
            StructType::UsbScanCodeSpec => Ok(from.as_any_box().downcast::<UsbScanCodeSpec>()?),
            StructType::UsbScanCodeSpecKeyEvent => Ok(from.as_any_box().downcast::<UsbScanCodeSpecKeyEvent>()?),
            StructType::UsbScanCodeSpecModifierType => Ok(from.as_any_box().downcast::<UsbScanCodeSpecModifierType>()?),
            StructType::VirtualMachineVcpuConfig => Ok(from.as_any_box().downcast::<VirtualMachineVcpuConfig>()?),
            StructType::VirtualMachineVendorDeviceGroupInfoComponentDeviceInfo => Ok(from.as_any_box().downcast::<VirtualMachineVendorDeviceGroupInfoComponentDeviceInfo>()?),
            StructType::VirtualMachineVirtualDeviceGroups => Ok(from.as_any_box().downcast::<VirtualMachineVirtualDeviceGroups>()?),
            StructType::VirtualMachineVirtualDeviceGroupsDeviceGroup => Ok(from.as_any_box().downcast::<VirtualMachineVirtualDeviceGroupsDeviceGroup>()?),
            StructType::VirtualMachineVirtualDeviceGroupsVendorDeviceGroup => Ok(from.as_any_box().downcast::<VirtualMachineVirtualDeviceGroupsVendorDeviceGroup>()?),
            StructType::VirtualMachineVirtualDeviceSwap => Ok(from.as_any_box().downcast::<VirtualMachineVirtualDeviceSwap>()?),
            StructType::VirtualMachineVirtualDeviceSwapDeviceSwapInfo => Ok(from.as_any_box().downcast::<VirtualMachineVirtualDeviceSwapDeviceSwapInfo>()?),
            StructType::VirtualHardware => Ok(from.as_any_box().downcast::<VirtualHardware>()?),
            StructType::VirtualHardwareOption => Ok(from.as_any_box().downcast::<VirtualHardwareOption>()?),
            StructType::VirtualMachineVirtualNuma => Ok(from.as_any_box().downcast::<VirtualMachineVirtualNuma>()?),
            StructType::VirtualMachineVirtualNumaInfo => Ok(from.as_any_box().downcast::<VirtualMachineVirtualNumaInfo>()?),
            StructType::VirtualMachineVirtualPMem => Ok(from.as_any_box().downcast::<VirtualMachineVirtualPMem>()?),
            StructType::CheckResult => Ok(from.as_any_box().downcast::<CheckResult>()?),
            StructType::CustomizationAdapterMapping => Ok(from.as_any_box().downcast::<CustomizationAdapterMapping>()?),
            StructType::CustomizationGlobalIpSettings => Ok(from.as_any_box().downcast::<CustomizationGlobalIpSettings>()?),
            StructType::CustomizationGuiRunOnce => Ok(from.as_any_box().downcast::<CustomizationGuiRunOnce>()?),
            StructType::CustomizationGuiUnattended => Ok(from.as_any_box().downcast::<CustomizationGuiUnattended>()?),
            StructType::CustomizationIpSettings => Ok(from.as_any_box().downcast::<CustomizationIpSettings>()?),
            StructType::CustomizationIpSettingsIpV6AddressSpec => Ok(from.as_any_box().downcast::<CustomizationIpSettingsIpV6AddressSpec>()?),
            StructType::CustomizationIdentification => Ok(from.as_any_box().downcast::<CustomizationIdentification>()?),
            StructType::CustomizationIdentitySettings => Ok(from.as_any_box().downcast::<CustomizationIdentitySettings>()?),
            StructType::CustomizationCloudinitPrep => Ok(from.as_any_box().downcast::<CustomizationCloudinitPrep>()?),
            StructType::CustomizationLinuxPrep => Ok(from.as_any_box().downcast::<CustomizationLinuxPrep>()?),
            StructType::CustomizationSysprep => Ok(from.as_any_box().downcast::<CustomizationSysprep>()?),
            StructType::CustomizationSysprepText => Ok(from.as_any_box().downcast::<CustomizationSysprepText>()?),
            StructType::CustomizationIpGenerator => Ok(from.as_any_box().downcast::<CustomizationIpGenerator>()?),
            StructType::CustomizationCustomIpGenerator => Ok(from.as_any_box().downcast::<CustomizationCustomIpGenerator>()?),
            StructType::CustomizationDhcpIpGenerator => Ok(from.as_any_box().downcast::<CustomizationDhcpIpGenerator>()?),
            StructType::CustomizationFixedIp => Ok(from.as_any_box().downcast::<CustomizationFixedIp>()?),
            StructType::CustomizationUnknownIpGenerator => Ok(from.as_any_box().downcast::<CustomizationUnknownIpGenerator>()?),
            StructType::CustomizationIpV6Generator => Ok(from.as_any_box().downcast::<CustomizationIpV6Generator>()?),
            StructType::CustomizationAutoIpV6Generator => Ok(from.as_any_box().downcast::<CustomizationAutoIpV6Generator>()?),
            StructType::CustomizationCustomIpV6Generator => Ok(from.as_any_box().downcast::<CustomizationCustomIpV6Generator>()?),
            StructType::CustomizationDhcpIpV6Generator => Ok(from.as_any_box().downcast::<CustomizationDhcpIpV6Generator>()?),
            StructType::CustomizationFixedIpV6 => Ok(from.as_any_box().downcast::<CustomizationFixedIpV6>()?),
            StructType::CustomizationStatelessIpV6Generator => Ok(from.as_any_box().downcast::<CustomizationStatelessIpV6Generator>()?),
            StructType::CustomizationUnknownIpV6Generator => Ok(from.as_any_box().downcast::<CustomizationUnknownIpV6Generator>()?),
            StructType::CustomizationLicenseFilePrintData => Ok(from.as_any_box().downcast::<CustomizationLicenseFilePrintData>()?),
            StructType::CustomizationName => Ok(from.as_any_box().downcast::<CustomizationName>()?),
            StructType::CustomizationCustomName => Ok(from.as_any_box().downcast::<CustomizationCustomName>()?),
            StructType::CustomizationFixedName => Ok(from.as_any_box().downcast::<CustomizationFixedName>()?),
            StructType::CustomizationPrefixName => Ok(from.as_any_box().downcast::<CustomizationPrefixName>()?),
            StructType::CustomizationUnknownName => Ok(from.as_any_box().downcast::<CustomizationUnknownName>()?),
            StructType::CustomizationVirtualMachineName => Ok(from.as_any_box().downcast::<CustomizationVirtualMachineName>()?),
            StructType::CustomizationOptions => Ok(from.as_any_box().downcast::<CustomizationOptions>()?),
            StructType::CustomizationLinuxOptions => Ok(from.as_any_box().downcast::<CustomizationLinuxOptions>()?),
            StructType::CustomizationWinOptions => Ok(from.as_any_box().downcast::<CustomizationWinOptions>()?),
            StructType::CustomizationPassword => Ok(from.as_any_box().downcast::<CustomizationPassword>()?),
            StructType::CustomizationSpec => Ok(from.as_any_box().downcast::<CustomizationSpec>()?),
            StructType::CustomizationUserData => Ok(from.as_any_box().downcast::<CustomizationUserData>()?),
            StructType::HostDiskMappingInfo => Ok(from.as_any_box().downcast::<HostDiskMappingInfo>()?),
            StructType::HostDiskMappingPartitionInfo => Ok(from.as_any_box().downcast::<HostDiskMappingPartitionInfo>()?),
            StructType::HostDiskMappingOption => Ok(from.as_any_box().downcast::<HostDiskMappingOption>()?),
            StructType::HostDiskMappingPartitionOption => Ok(from.as_any_box().downcast::<HostDiskMappingPartitionOption>()?),
            StructType::VirtualDevice => Ok(from.as_any_box().downcast::<VirtualDevice>()?),
            StructType::VirtualCdrom => Ok(from.as_any_box().downcast::<VirtualCdrom>()?),
            StructType::VirtualController => Ok(from.as_any_box().downcast::<VirtualController>()?),
            StructType::VirtualIdeController => Ok(from.as_any_box().downcast::<VirtualIdeController>()?),
            StructType::VirtualNvdimmController => Ok(from.as_any_box().downcast::<VirtualNvdimmController>()?),
            StructType::VirtualNvmeController => Ok(from.as_any_box().downcast::<VirtualNvmeController>()?),
            StructType::VirtualPciController => Ok(from.as_any_box().downcast::<VirtualPciController>()?),
            StructType::VirtualPs2Controller => Ok(from.as_any_box().downcast::<VirtualPs2Controller>()?),
            StructType::VirtualSataController => Ok(from.as_any_box().downcast::<VirtualSataController>()?),
            StructType::VirtualAhciController => Ok(from.as_any_box().downcast::<VirtualAhciController>()?),
            StructType::VirtualScsiController => Ok(from.as_any_box().downcast::<VirtualScsiController>()?),
            StructType::ParaVirtualScsiController => Ok(from.as_any_box().downcast::<ParaVirtualScsiController>()?),
            StructType::VirtualBusLogicController => Ok(from.as_any_box().downcast::<VirtualBusLogicController>()?),
            StructType::VirtualLsiLogicController => Ok(from.as_any_box().downcast::<VirtualLsiLogicController>()?),
            StructType::VirtualLsiLogicSasController => Ok(from.as_any_box().downcast::<VirtualLsiLogicSasController>()?),
            StructType::VirtualSioController => Ok(from.as_any_box().downcast::<VirtualSioController>()?),
            StructType::VirtualUsbController => Ok(from.as_any_box().downcast::<VirtualUsbController>()?),
            StructType::VirtualUsbxhciController => Ok(from.as_any_box().downcast::<VirtualUsbxhciController>()?),
            StructType::VirtualDisk => Ok(from.as_any_box().downcast::<VirtualDisk>()?),
            StructType::VirtualEthernetCard => Ok(from.as_any_box().downcast::<VirtualEthernetCard>()?),
            StructType::VirtualE1000 => Ok(from.as_any_box().downcast::<VirtualE1000>()?),
            StructType::VirtualE1000E => Ok(from.as_any_box().downcast::<VirtualE1000E>()?),
            StructType::VirtualPcNet32 => Ok(from.as_any_box().downcast::<VirtualPcNet32>()?),
            StructType::VirtualSriovEthernetCard => Ok(from.as_any_box().downcast::<VirtualSriovEthernetCard>()?),
            StructType::VirtualVmxnet => Ok(from.as_any_box().downcast::<VirtualVmxnet>()?),
            StructType::VirtualVmxnet2 => Ok(from.as_any_box().downcast::<VirtualVmxnet2>()?),
            StructType::VirtualVmxnet3 => Ok(from.as_any_box().downcast::<VirtualVmxnet3>()?),
            StructType::VirtualVmxnet3Vrdma => Ok(from.as_any_box().downcast::<VirtualVmxnet3Vrdma>()?),
            StructType::VirtualFloppy => Ok(from.as_any_box().downcast::<VirtualFloppy>()?),
            StructType::VirtualKeyboard => Ok(from.as_any_box().downcast::<VirtualKeyboard>()?),
            StructType::VirtualNvdimm => Ok(from.as_any_box().downcast::<VirtualNvdimm>()?),
            StructType::VirtualPciPassthrough => Ok(from.as_any_box().downcast::<VirtualPciPassthrough>()?),
            StructType::VirtualParallelPort => Ok(from.as_any_box().downcast::<VirtualParallelPort>()?),
            StructType::VirtualPointingDevice => Ok(from.as_any_box().downcast::<VirtualPointingDevice>()?),
            StructType::VirtualPrecisionClock => Ok(from.as_any_box().downcast::<VirtualPrecisionClock>()?),
            StructType::VirtualScsiPassthrough => Ok(from.as_any_box().downcast::<VirtualScsiPassthrough>()?),
            StructType::VirtualSerialPort => Ok(from.as_any_box().downcast::<VirtualSerialPort>()?),
            StructType::VirtualSoundCard => Ok(from.as_any_box().downcast::<VirtualSoundCard>()?),
            StructType::VirtualEnsoniq1371 => Ok(from.as_any_box().downcast::<VirtualEnsoniq1371>()?),
            StructType::VirtualHdAudioCard => Ok(from.as_any_box().downcast::<VirtualHdAudioCard>()?),
            StructType::VirtualSoundBlaster16 => Ok(from.as_any_box().downcast::<VirtualSoundBlaster16>()?),
            StructType::VirtualTpm => Ok(from.as_any_box().downcast::<VirtualTpm>()?),
            StructType::VirtualUsb => Ok(from.as_any_box().downcast::<VirtualUsb>()?),
            StructType::VirtualMachineVmciDevice => Ok(from.as_any_box().downcast::<VirtualMachineVmciDevice>()?),
            StructType::VirtualMachineVmirom => Ok(from.as_any_box().downcast::<VirtualMachineVmirom>()?),
            StructType::VirtualMachineVideoCard => Ok(from.as_any_box().downcast::<VirtualMachineVideoCard>()?),
            StructType::VirtualWdt => Ok(from.as_any_box().downcast::<VirtualWdt>()?),
            StructType::VirtualDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualDeviceBackingInfo>()?),
            StructType::VirtualDeviceDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualDeviceDeviceBackingInfo>()?),
            StructType::VirtualCdromAtapiBackingInfo => Ok(from.as_any_box().downcast::<VirtualCdromAtapiBackingInfo>()?),
            StructType::VirtualCdromPassthroughBackingInfo => Ok(from.as_any_box().downcast::<VirtualCdromPassthroughBackingInfo>()?),
            StructType::VirtualDiskRawDiskVer2BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskRawDiskVer2BackingInfo>()?),
            StructType::VirtualDiskPartitionedRawDiskVer2BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskPartitionedRawDiskVer2BackingInfo>()?),
            StructType::VirtualEthernetCardLegacyNetworkBackingInfo => Ok(from.as_any_box().downcast::<VirtualEthernetCardLegacyNetworkBackingInfo>()?),
            StructType::VirtualEthernetCardNetworkBackingInfo => Ok(from.as_any_box().downcast::<VirtualEthernetCardNetworkBackingInfo>()?),
            StructType::VirtualFloppyDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualFloppyDeviceBackingInfo>()?),
            StructType::VirtualPciPassthroughDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualPciPassthroughDeviceBackingInfo>()?),
            StructType::VirtualPciPassthroughDynamicBackingInfo => Ok(from.as_any_box().downcast::<VirtualPciPassthroughDynamicBackingInfo>()?),
            StructType::VirtualParallelPortDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualParallelPortDeviceBackingInfo>()?),
            StructType::VirtualPointingDeviceDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualPointingDeviceDeviceBackingInfo>()?),
            StructType::VirtualScsiPassthroughDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualScsiPassthroughDeviceBackingInfo>()?),
            StructType::VirtualSerialPortDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualSerialPortDeviceBackingInfo>()?),
            StructType::VirtualSoundCardDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualSoundCardDeviceBackingInfo>()?),
            StructType::VirtualUsbRemoteHostBackingInfo => Ok(from.as_any_box().downcast::<VirtualUsbRemoteHostBackingInfo>()?),
            StructType::VirtualUsbusbBackingInfo => Ok(from.as_any_box().downcast::<VirtualUsbusbBackingInfo>()?),
            StructType::VirtualDeviceFileBackingInfo => Ok(from.as_any_box().downcast::<VirtualDeviceFileBackingInfo>()?),
            StructType::VirtualCdromIsoBackingInfo => Ok(from.as_any_box().downcast::<VirtualCdromIsoBackingInfo>()?),
            StructType::VirtualDiskFlatVer1BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskFlatVer1BackingInfo>()?),
            StructType::VirtualDiskFlatVer2BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskFlatVer2BackingInfo>()?),
            StructType::VirtualDiskLocalPMemBackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskLocalPMemBackingInfo>()?),
            StructType::VirtualDiskRawDiskMappingVer1BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskRawDiskMappingVer1BackingInfo>()?),
            StructType::VirtualDiskSeSparseBackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskSeSparseBackingInfo>()?),
            StructType::VirtualDiskSparseVer1BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskSparseVer1BackingInfo>()?),
            StructType::VirtualDiskSparseVer2BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskSparseVer2BackingInfo>()?),
            StructType::VirtualFloppyImageBackingInfo => Ok(from.as_any_box().downcast::<VirtualFloppyImageBackingInfo>()?),
            StructType::VirtualNvdimmBackingInfo => Ok(from.as_any_box().downcast::<VirtualNvdimmBackingInfo>()?),
            StructType::VirtualParallelPortFileBackingInfo => Ok(from.as_any_box().downcast::<VirtualParallelPortFileBackingInfo>()?),
            StructType::VirtualSerialPortFileBackingInfo => Ok(from.as_any_box().downcast::<VirtualSerialPortFileBackingInfo>()?),
            StructType::VirtualDevicePipeBackingInfo => Ok(from.as_any_box().downcast::<VirtualDevicePipeBackingInfo>()?),
            StructType::VirtualSerialPortPipeBackingInfo => Ok(from.as_any_box().downcast::<VirtualSerialPortPipeBackingInfo>()?),
            StructType::VirtualDeviceRemoteDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualDeviceRemoteDeviceBackingInfo>()?),
            StructType::VirtualCdromRemoteAtapiBackingInfo => Ok(from.as_any_box().downcast::<VirtualCdromRemoteAtapiBackingInfo>()?),
            StructType::VirtualCdromRemotePassthroughBackingInfo => Ok(from.as_any_box().downcast::<VirtualCdromRemotePassthroughBackingInfo>()?),
            StructType::VirtualFloppyRemoteDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualFloppyRemoteDeviceBackingInfo>()?),
            StructType::VirtualUsbRemoteClientBackingInfo => Ok(from.as_any_box().downcast::<VirtualUsbRemoteClientBackingInfo>()?),
            StructType::VirtualDeviceUriBackingInfo => Ok(from.as_any_box().downcast::<VirtualDeviceUriBackingInfo>()?),
            StructType::VirtualSerialPortUriBackingInfo => Ok(from.as_any_box().downcast::<VirtualSerialPortUriBackingInfo>()?),
            StructType::VirtualEthernetCardDistributedVirtualPortBackingInfo => Ok(from.as_any_box().downcast::<VirtualEthernetCardDistributedVirtualPortBackingInfo>()?),
            StructType::VirtualEthernetCardOpaqueNetworkBackingInfo => Ok(from.as_any_box().downcast::<VirtualEthernetCardOpaqueNetworkBackingInfo>()?),
            StructType::VirtualPciPassthroughDvxBackingInfo => Ok(from.as_any_box().downcast::<VirtualPciPassthroughDvxBackingInfo>()?),
            StructType::VirtualPciPassthroughPluginBackingInfo => Ok(from.as_any_box().downcast::<VirtualPciPassthroughPluginBackingInfo>()?),
            StructType::VirtualPciPassthroughVmiopBackingInfo => Ok(from.as_any_box().downcast::<VirtualPciPassthroughVmiopBackingInfo>()?),
            StructType::VirtualPrecisionClockSystemClockBackingInfo => Ok(from.as_any_box().downcast::<VirtualPrecisionClockSystemClockBackingInfo>()?),
            StructType::VirtualSerialPortThinPrintBackingInfo => Ok(from.as_any_box().downcast::<VirtualSerialPortThinPrintBackingInfo>()?),
            StructType::VirtualSriovEthernetCardSriovBackingInfo => Ok(from.as_any_box().downcast::<VirtualSriovEthernetCardSriovBackingInfo>()?),
            StructType::VirtualDeviceBusSlotInfo => Ok(from.as_any_box().downcast::<VirtualDeviceBusSlotInfo>()?),
            StructType::VirtualDevicePciBusSlotInfo => Ok(from.as_any_box().downcast::<VirtualDevicePciBusSlotInfo>()?),
            StructType::VirtualUsbControllerPciBusSlotInfo => Ok(from.as_any_box().downcast::<VirtualUsbControllerPciBusSlotInfo>()?),
            StructType::VirtualDeviceConnectInfo => Ok(from.as_any_box().downcast::<VirtualDeviceConnectInfo>()?),
            StructType::VirtualDeviceDeviceGroupInfo => Ok(from.as_any_box().downcast::<VirtualDeviceDeviceGroupInfo>()?),
            StructType::VirtualDeviceOption => Ok(from.as_any_box().downcast::<VirtualDeviceOption>()?),
            StructType::VirtualCdromOption => Ok(from.as_any_box().downcast::<VirtualCdromOption>()?),
            StructType::VirtualControllerOption => Ok(from.as_any_box().downcast::<VirtualControllerOption>()?),
            StructType::VirtualIdeControllerOption => Ok(from.as_any_box().downcast::<VirtualIdeControllerOption>()?),
            StructType::VirtualNvdimmControllerOption => Ok(from.as_any_box().downcast::<VirtualNvdimmControllerOption>()?),
            StructType::VirtualNvmeControllerOption => Ok(from.as_any_box().downcast::<VirtualNvmeControllerOption>()?),
            StructType::VirtualPciControllerOption => Ok(from.as_any_box().downcast::<VirtualPciControllerOption>()?),
            StructType::VirtualPs2ControllerOption => Ok(from.as_any_box().downcast::<VirtualPs2ControllerOption>()?),
            StructType::VirtualSataControllerOption => Ok(from.as_any_box().downcast::<VirtualSataControllerOption>()?),
            StructType::VirtualAhciControllerOption => Ok(from.as_any_box().downcast::<VirtualAhciControllerOption>()?),
            StructType::VirtualScsiControllerOption => Ok(from.as_any_box().downcast::<VirtualScsiControllerOption>()?),
            StructType::ParaVirtualScsiControllerOption => Ok(from.as_any_box().downcast::<ParaVirtualScsiControllerOption>()?),
            StructType::VirtualBusLogicControllerOption => Ok(from.as_any_box().downcast::<VirtualBusLogicControllerOption>()?),
            StructType::VirtualLsiLogicControllerOption => Ok(from.as_any_box().downcast::<VirtualLsiLogicControllerOption>()?),
            StructType::VirtualLsiLogicSasControllerOption => Ok(from.as_any_box().downcast::<VirtualLsiLogicSasControllerOption>()?),
            StructType::VirtualSioControllerOption => Ok(from.as_any_box().downcast::<VirtualSioControllerOption>()?),
            StructType::VirtualUsbControllerOption => Ok(from.as_any_box().downcast::<VirtualUsbControllerOption>()?),
            StructType::VirtualUsbxhciControllerOption => Ok(from.as_any_box().downcast::<VirtualUsbxhciControllerOption>()?),
            StructType::VirtualDiskOption => Ok(from.as_any_box().downcast::<VirtualDiskOption>()?),
            StructType::VirtualEthernetCardOption => Ok(from.as_any_box().downcast::<VirtualEthernetCardOption>()?),
            StructType::VirtualE1000Option => Ok(from.as_any_box().downcast::<VirtualE1000Option>()?),
            StructType::VirtualE1000EOption => Ok(from.as_any_box().downcast::<VirtualE1000EOption>()?),
            StructType::VirtualPcNet32Option => Ok(from.as_any_box().downcast::<VirtualPcNet32Option>()?),
            StructType::VirtualSriovEthernetCardOption => Ok(from.as_any_box().downcast::<VirtualSriovEthernetCardOption>()?),
            StructType::VirtualVmxnetOption => Ok(from.as_any_box().downcast::<VirtualVmxnetOption>()?),
            StructType::VirtualVmxnet2Option => Ok(from.as_any_box().downcast::<VirtualVmxnet2Option>()?),
            StructType::VirtualVmxnet3Option => Ok(from.as_any_box().downcast::<VirtualVmxnet3Option>()?),
            StructType::VirtualVmxnet3VrdmaOption => Ok(from.as_any_box().downcast::<VirtualVmxnet3VrdmaOption>()?),
            StructType::VirtualFloppyOption => Ok(from.as_any_box().downcast::<VirtualFloppyOption>()?),
            StructType::VirtualKeyboardOption => Ok(from.as_any_box().downcast::<VirtualKeyboardOption>()?),
            StructType::VirtualNvdimmOption => Ok(from.as_any_box().downcast::<VirtualNvdimmOption>()?),
            StructType::VirtualPciPassthroughOption => Ok(from.as_any_box().downcast::<VirtualPciPassthroughOption>()?),
            StructType::VirtualParallelPortOption => Ok(from.as_any_box().downcast::<VirtualParallelPortOption>()?),
            StructType::VirtualPointingDeviceOption => Ok(from.as_any_box().downcast::<VirtualPointingDeviceOption>()?),
            StructType::VirtualPrecisionClockOption => Ok(from.as_any_box().downcast::<VirtualPrecisionClockOption>()?),
            StructType::VirtualScsiPassthroughOption => Ok(from.as_any_box().downcast::<VirtualScsiPassthroughOption>()?),
            StructType::VirtualSerialPortOption => Ok(from.as_any_box().downcast::<VirtualSerialPortOption>()?),
            StructType::VirtualSoundCardOption => Ok(from.as_any_box().downcast::<VirtualSoundCardOption>()?),
            StructType::VirtualEnsoniq1371Option => Ok(from.as_any_box().downcast::<VirtualEnsoniq1371Option>()?),
            StructType::VirtualHdAudioCardOption => Ok(from.as_any_box().downcast::<VirtualHdAudioCardOption>()?),
            StructType::VirtualSoundBlaster16Option => Ok(from.as_any_box().downcast::<VirtualSoundBlaster16Option>()?),
            StructType::VirtualTpmOption => Ok(from.as_any_box().downcast::<VirtualTpmOption>()?),
            StructType::VirtualUsbOption => Ok(from.as_any_box().downcast::<VirtualUsbOption>()?),
            StructType::VirtualMachineVmciDeviceOption => Ok(from.as_any_box().downcast::<VirtualMachineVmciDeviceOption>()?),
            StructType::VirtualVmiromOption => Ok(from.as_any_box().downcast::<VirtualVmiromOption>()?),
            StructType::VirtualVideoCardOption => Ok(from.as_any_box().downcast::<VirtualVideoCardOption>()?),
            StructType::VirtualWdtOption => Ok(from.as_any_box().downcast::<VirtualWdtOption>()?),
            StructType::VirtualDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualDeviceBackingOption>()?),
            StructType::VirtualDeviceDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualDeviceDeviceBackingOption>()?),
            StructType::VirtualCdromAtapiBackingOption => Ok(from.as_any_box().downcast::<VirtualCdromAtapiBackingOption>()?),
            StructType::VirtualCdromPassthroughBackingOption => Ok(from.as_any_box().downcast::<VirtualCdromPassthroughBackingOption>()?),
            StructType::VirtualCdromRemoteAtapiBackingOption => Ok(from.as_any_box().downcast::<VirtualCdromRemoteAtapiBackingOption>()?),
            StructType::VirtualDiskRawDiskMappingVer1BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskRawDiskMappingVer1BackingOption>()?),
            StructType::VirtualDiskRawDiskVer2BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskRawDiskVer2BackingOption>()?),
            StructType::VirtualDiskPartitionedRawDiskVer2BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskPartitionedRawDiskVer2BackingOption>()?),
            StructType::VirtualEthernetCardLegacyNetworkBackingOption => Ok(from.as_any_box().downcast::<VirtualEthernetCardLegacyNetworkBackingOption>()?),
            StructType::VirtualEthernetCardNetworkBackingOption => Ok(from.as_any_box().downcast::<VirtualEthernetCardNetworkBackingOption>()?),
            StructType::VirtualFloppyDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualFloppyDeviceBackingOption>()?),
            StructType::VirtualPciPassthroughDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualPciPassthroughDeviceBackingOption>()?),
            StructType::VirtualPciPassthroughDynamicBackingOption => Ok(from.as_any_box().downcast::<VirtualPciPassthroughDynamicBackingOption>()?),
            StructType::VirtualParallelPortDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualParallelPortDeviceBackingOption>()?),
            StructType::VirtualPointingDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualPointingDeviceBackingOption>()?),
            StructType::VirtualScsiPassthroughDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualScsiPassthroughDeviceBackingOption>()?),
            StructType::VirtualSerialPortDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualSerialPortDeviceBackingOption>()?),
            StructType::VirtualSoundCardDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualSoundCardDeviceBackingOption>()?),
            StructType::VirtualUsbRemoteHostBackingOption => Ok(from.as_any_box().downcast::<VirtualUsbRemoteHostBackingOption>()?),
            StructType::VirtualUsbusbBackingOption => Ok(from.as_any_box().downcast::<VirtualUsbusbBackingOption>()?),
            StructType::VirtualDeviceFileBackingOption => Ok(from.as_any_box().downcast::<VirtualDeviceFileBackingOption>()?),
            StructType::VirtualCdromIsoBackingOption => Ok(from.as_any_box().downcast::<VirtualCdromIsoBackingOption>()?),
            StructType::VirtualDiskFlatVer1BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskFlatVer1BackingOption>()?),
            StructType::VirtualDiskFlatVer2BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskFlatVer2BackingOption>()?),
            StructType::VirtualDiskLocalPMemBackingOption => Ok(from.as_any_box().downcast::<VirtualDiskLocalPMemBackingOption>()?),
            StructType::VirtualDiskSeSparseBackingOption => Ok(from.as_any_box().downcast::<VirtualDiskSeSparseBackingOption>()?),
            StructType::VirtualDiskSparseVer1BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskSparseVer1BackingOption>()?),
            StructType::VirtualDiskSparseVer2BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskSparseVer2BackingOption>()?),
            StructType::VirtualFloppyImageBackingOption => Ok(from.as_any_box().downcast::<VirtualFloppyImageBackingOption>()?),
            StructType::VirtualParallelPortFileBackingOption => Ok(from.as_any_box().downcast::<VirtualParallelPortFileBackingOption>()?),
            StructType::VirtualSerialPortFileBackingOption => Ok(from.as_any_box().downcast::<VirtualSerialPortFileBackingOption>()?),
            StructType::VirtualDevicePipeBackingOption => Ok(from.as_any_box().downcast::<VirtualDevicePipeBackingOption>()?),
            StructType::VirtualSerialPortPipeBackingOption => Ok(from.as_any_box().downcast::<VirtualSerialPortPipeBackingOption>()?),
            StructType::VirtualDeviceRemoteDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualDeviceRemoteDeviceBackingOption>()?),
            StructType::VirtualCdromRemotePassthroughBackingOption => Ok(from.as_any_box().downcast::<VirtualCdromRemotePassthroughBackingOption>()?),
            StructType::VirtualFloppyRemoteDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualFloppyRemoteDeviceBackingOption>()?),
            StructType::VirtualUsbRemoteClientBackingOption => Ok(from.as_any_box().downcast::<VirtualUsbRemoteClientBackingOption>()?),
            StructType::VirtualDeviceUriBackingOption => Ok(from.as_any_box().downcast::<VirtualDeviceUriBackingOption>()?),
            StructType::VirtualSerialPortUriBackingOption => Ok(from.as_any_box().downcast::<VirtualSerialPortUriBackingOption>()?),
            StructType::VirtualEthernetCardDvPortBackingOption => Ok(from.as_any_box().downcast::<VirtualEthernetCardDvPortBackingOption>()?),
            StructType::VirtualEthernetCardOpaqueNetworkBackingOption => Ok(from.as_any_box().downcast::<VirtualEthernetCardOpaqueNetworkBackingOption>()?),
            StructType::VirtualPciPassthroughDvxBackingOption => Ok(from.as_any_box().downcast::<VirtualPciPassthroughDvxBackingOption>()?),
            StructType::VirtualPciPassthroughPluginBackingOption => Ok(from.as_any_box().downcast::<VirtualPciPassthroughPluginBackingOption>()?),
            StructType::VirtualPciPassthroughVmiopBackingOption => Ok(from.as_any_box().downcast::<VirtualPciPassthroughVmiopBackingOption>()?),
            StructType::VirtualPrecisionClockSystemClockBackingOption => Ok(from.as_any_box().downcast::<VirtualPrecisionClockSystemClockBackingOption>()?),
            StructType::VirtualSerialPortThinPrintBackingOption => Ok(from.as_any_box().downcast::<VirtualSerialPortThinPrintBackingOption>()?),
            StructType::VirtualSriovEthernetCardSriovBackingOption => Ok(from.as_any_box().downcast::<VirtualSriovEthernetCardSriovBackingOption>()?),
            StructType::VirtualDeviceBusSlotOption => Ok(from.as_any_box().downcast::<VirtualDeviceBusSlotOption>()?),
            StructType::VirtualDeviceConnectOption => Ok(from.as_any_box().downcast::<VirtualDeviceConnectOption>()?),
            StructType::VirtualDeviceConfigSpec => Ok(from.as_any_box().downcast::<VirtualDeviceConfigSpec>()?),
            StructType::VirtualDiskConfigSpec => Ok(from.as_any_box().downcast::<VirtualDiskConfigSpec>()?),
            StructType::VirtualDeviceConfigSpecBackingSpec => Ok(from.as_any_box().downcast::<VirtualDeviceConfigSpecBackingSpec>()?),
            StructType::VirtualDiskVFlashCacheConfigInfo => Ok(from.as_any_box().downcast::<VirtualDiskVFlashCacheConfigInfo>()?),
            StructType::VirtualDiskId => Ok(from.as_any_box().downcast::<VirtualDiskId>()?),
            StructType::VirtualDiskDeltaDiskFormatsSupported => Ok(from.as_any_box().downcast::<VirtualDiskDeltaDiskFormatsSupported>()?),
            StructType::VirtualDiskOptionVFlashCacheConfigOption => Ok(from.as_any_box().downcast::<VirtualDiskOptionVFlashCacheConfigOption>()?),
            StructType::VirtualEthernetCardResourceAllocation => Ok(from.as_any_box().downcast::<VirtualEthernetCardResourceAllocation>()?),
            StructType::VirtualPciPassthroughAllowedDevice => Ok(from.as_any_box().downcast::<VirtualPciPassthroughAllowedDevice>()?),
            StructType::VirtualMachineVmciDeviceFilterInfo => Ok(from.as_any_box().downcast::<VirtualMachineVmciDeviceFilterInfo>()?),
            StructType::VirtualMachineVmciDeviceFilterSpec => Ok(from.as_any_box().downcast::<VirtualMachineVmciDeviceFilterSpec>()?),
            StructType::VirtualMachineVmciDeviceOptionFilterSpecOption => Ok(from.as_any_box().downcast::<VirtualMachineVmciDeviceOptionFilterSpecOption>()?),
            StructType::GuestAliases => Ok(from.as_any_box().downcast::<GuestAliases>()?),
            StructType::GuestAuthAliasInfo => Ok(from.as_any_box().downcast::<GuestAuthAliasInfo>()?),
            StructType::GuestAuthSubject => Ok(from.as_any_box().downcast::<GuestAuthSubject>()?),
            StructType::GuestAuthAnySubject => Ok(from.as_any_box().downcast::<GuestAuthAnySubject>()?),
            StructType::GuestAuthNamedSubject => Ok(from.as_any_box().downcast::<GuestAuthNamedSubject>()?),
            StructType::GuestMappedAliases => Ok(from.as_any_box().downcast::<GuestMappedAliases>()?),
            StructType::GuestFileAttributes => Ok(from.as_any_box().downcast::<GuestFileAttributes>()?),
            StructType::GuestPosixFileAttributes => Ok(from.as_any_box().downcast::<GuestPosixFileAttributes>()?),
            StructType::GuestWindowsFileAttributes => Ok(from.as_any_box().downcast::<GuestWindowsFileAttributes>()?),
            StructType::GuestFileInfo => Ok(from.as_any_box().downcast::<GuestFileInfo>()?),
            StructType::FileTransferInformation => Ok(from.as_any_box().downcast::<FileTransferInformation>()?),
            StructType::GuestListFileInfo => Ok(from.as_any_box().downcast::<GuestListFileInfo>()?),
            StructType::GuestAuthentication => Ok(from.as_any_box().downcast::<GuestAuthentication>()?),
            StructType::NamePasswordAuthentication => Ok(from.as_any_box().downcast::<NamePasswordAuthentication>()?),
            StructType::SamlTokenAuthentication => Ok(from.as_any_box().downcast::<SamlTokenAuthentication>()?),
            StructType::SspiAuthentication => Ok(from.as_any_box().downcast::<SspiAuthentication>()?),
            StructType::TicketedSessionAuthentication => Ok(from.as_any_box().downcast::<TicketedSessionAuthentication>()?),
            StructType::GuestProcessInfo => Ok(from.as_any_box().downcast::<GuestProcessInfo>()?),
            StructType::GuestProgramSpec => Ok(from.as_any_box().downcast::<GuestProgramSpec>()?),
            StructType::GuestWindowsProgramSpec => Ok(from.as_any_box().downcast::<GuestWindowsProgramSpec>()?),
            StructType::GuestRegKeySpec => Ok(from.as_any_box().downcast::<GuestRegKeySpec>()?),
            StructType::GuestRegKeyNameSpec => Ok(from.as_any_box().downcast::<GuestRegKeyNameSpec>()?),
            StructType::GuestRegKeyRecordSpec => Ok(from.as_any_box().downcast::<GuestRegKeyRecordSpec>()?),
            StructType::GuestRegValueSpec => Ok(from.as_any_box().downcast::<GuestRegValueSpec>()?),
            StructType::GuestRegValueDataSpec => Ok(from.as_any_box().downcast::<GuestRegValueDataSpec>()?),
            StructType::GuestRegValueBinarySpec => Ok(from.as_any_box().downcast::<GuestRegValueBinarySpec>()?),
            StructType::GuestRegValueDwordSpec => Ok(from.as_any_box().downcast::<GuestRegValueDwordSpec>()?),
            StructType::GuestRegValueExpandStringSpec => Ok(from.as_any_box().downcast::<GuestRegValueExpandStringSpec>()?),
            StructType::GuestRegValueMultiStringSpec => Ok(from.as_any_box().downcast::<GuestRegValueMultiStringSpec>()?),
            StructType::GuestRegValueQwordSpec => Ok(from.as_any_box().downcast::<GuestRegValueQwordSpec>()?),
            StructType::GuestRegValueStringSpec => Ok(from.as_any_box().downcast::<GuestRegValueStringSpec>()?),
            StructType::GuestRegValueNameSpec => Ok(from.as_any_box().downcast::<GuestRegValueNameSpec>()?),
            StructType::DeviceGroupId => Ok(from.as_any_box().downcast::<DeviceGroupId>()?),
            StructType::FaultDomainId => Ok(from.as_any_box().downcast::<FaultDomainId>()?),
            StructType::ReplicationGroupId => Ok(from.as_any_box().downcast::<ReplicationGroupId>()?),
            StructType::ReplicationSpec => Ok(from.as_any_box().downcast::<ReplicationSpec>()?),
            StructType::VsanClusterConfigInfo => Ok(from.as_any_box().downcast::<VsanClusterConfigInfo>()?),
            StructType::VsanClusterConfigInfoHostDefaultInfo => Ok(from.as_any_box().downcast::<VsanClusterConfigInfoHostDefaultInfo>()?),
            StructType::VsanHostClusterStatus => Ok(from.as_any_box().downcast::<VsanHostClusterStatus>()?),
            StructType::VsanHostClusterStatusState => Ok(from.as_any_box().downcast::<VsanHostClusterStatusState>()?),
            StructType::VsanHostClusterStatusStateCompletionEstimate => Ok(from.as_any_box().downcast::<VsanHostClusterStatusStateCompletionEstimate>()?),
            StructType::VsanHostConfigInfo => Ok(from.as_any_box().downcast::<VsanHostConfigInfo>()?),
            StructType::VsanHostConfigInfoClusterInfo => Ok(from.as_any_box().downcast::<VsanHostConfigInfoClusterInfo>()?),
            StructType::VsanHostFaultDomainInfo => Ok(from.as_any_box().downcast::<VsanHostFaultDomainInfo>()?),
            StructType::VsanHostConfigInfoNetworkInfo => Ok(from.as_any_box().downcast::<VsanHostConfigInfoNetworkInfo>()?),
            StructType::VsanHostConfigInfoNetworkInfoPortConfig => Ok(from.as_any_box().downcast::<VsanHostConfigInfoNetworkInfoPortConfig>()?),
            StructType::VsanHostConfigInfoStorageInfo => Ok(from.as_any_box().downcast::<VsanHostConfigInfoStorageInfo>()?),
            StructType::VsanHostDecommissionMode => Ok(from.as_any_box().downcast::<VsanHostDecommissionMode>()?),
            StructType::VsanHostDiskMapInfo => Ok(from.as_any_box().downcast::<VsanHostDiskMapInfo>()?),
            StructType::VsanHostDiskMapResult => Ok(from.as_any_box().downcast::<VsanHostDiskMapResult>()?),
            StructType::VsanHostDiskMapping => Ok(from.as_any_box().downcast::<VsanHostDiskMapping>()?),
            StructType::VsanHostDiskResult => Ok(from.as_any_box().downcast::<VsanHostDiskResult>()?),
            StructType::VsanHostIpConfig => Ok(from.as_any_box().downcast::<VsanHostIpConfig>()?),
            StructType::VsanHostMembershipInfo => Ok(from.as_any_box().downcast::<VsanHostMembershipInfo>()?),
            StructType::VsanHostVsanDiskInfo => Ok(from.as_any_box().downcast::<VsanHostVsanDiskInfo>()?),
            StructType::VsanHostRuntimeInfo => Ok(from.as_any_box().downcast::<VsanHostRuntimeInfo>()?),
            StructType::VsanHostRuntimeInfoDiskIssue => Ok(from.as_any_box().downcast::<VsanHostRuntimeInfoDiskIssue>()?),
            StructType::BaseConfigInfo => Ok(from.as_any_box().downcast::<BaseConfigInfo>()?),
            StructType::VStorageObjectConfigInfo => Ok(from.as_any_box().downcast::<VStorageObjectConfigInfo>()?),
            StructType::BaseConfigInfoBackingInfo => Ok(from.as_any_box().downcast::<BaseConfigInfoBackingInfo>()?),
            StructType::BaseConfigInfoFileBackingInfo => Ok(from.as_any_box().downcast::<BaseConfigInfoFileBackingInfo>()?),
            StructType::BaseConfigInfoDiskFileBackingInfo => Ok(from.as_any_box().downcast::<BaseConfigInfoDiskFileBackingInfo>()?),
            StructType::BaseConfigInfoRawDiskMappingBackingInfo => Ok(from.as_any_box().downcast::<BaseConfigInfoRawDiskMappingBackingInfo>()?),
            StructType::VslmCreateSpec => Ok(from.as_any_box().downcast::<VslmCreateSpec>()?),
            StructType::VslmCreateSpecBackingSpec => Ok(from.as_any_box().downcast::<VslmCreateSpecBackingSpec>()?),
            StructType::VslmCreateSpecDiskFileBackingSpec => Ok(from.as_any_box().downcast::<VslmCreateSpecDiskFileBackingSpec>()?),
            StructType::VslmCreateSpecRawDiskMappingBackingSpec => Ok(from.as_any_box().downcast::<VslmCreateSpecRawDiskMappingBackingSpec>()?),
            StructType::DiskCryptoSpec => Ok(from.as_any_box().downcast::<DiskCryptoSpec>()?),
            StructType::Id => Ok(from.as_any_box().downcast::<Id>()?),
            StructType::VslmInfrastructureObjectPolicy => Ok(from.as_any_box().downcast::<VslmInfrastructureObjectPolicy>()?),
            StructType::VslmInfrastructureObjectPolicySpec => Ok(from.as_any_box().downcast::<VslmInfrastructureObjectPolicySpec>()?),
            StructType::VslmMigrateSpec => Ok(from.as_any_box().downcast::<VslmMigrateSpec>()?),
            StructType::VslmCloneSpec => Ok(from.as_any_box().downcast::<VslmCloneSpec>()?),
            StructType::VslmRelocateSpec => Ok(from.as_any_box().downcast::<VslmRelocateSpec>()?),
            StructType::VStorageObjectStateInfo => Ok(from.as_any_box().downcast::<VStorageObjectStateInfo>()?),
            StructType::VslmTagEntry => Ok(from.as_any_box().downcast::<VslmTagEntry>()?),
            StructType::VslmVClockInfo => Ok(from.as_any_box().downcast::<VslmVClockInfo>()?),
            StructType::VStorageObject => Ok(from.as_any_box().downcast::<VStorageObject>()?),
            StructType::VStorageObjectSnapshot => Ok(from.as_any_box().downcast::<VStorageObjectSnapshot>()?),
            StructType::VStorageObjectSnapshotDetails => Ok(from.as_any_box().downcast::<VStorageObjectSnapshotDetails>()?),
            StructType::VStorageObjectSnapshotInfo => Ok(from.as_any_box().downcast::<VStorageObjectSnapshotInfo>()?),
            StructType::VStorageObjectSnapshotInfoVStorageObjectSnapshot => Ok(from.as_any_box().downcast::<VStorageObjectSnapshotInfoVStorageObjectSnapshot>()?),
            StructType::RetrieveVStorageObjSpec => Ok(from.as_any_box().downcast::<RetrieveVStorageObjSpec>()?),
            StructType::VStorageObjectAssociations => Ok(from.as_any_box().downcast::<VStorageObjectAssociations>()?),
            StructType::VStorageObjectAssociationsVmDiskAssociations => Ok(from.as_any_box().downcast::<VStorageObjectAssociationsVmDiskAssociations>()?),
            StructType::DynamicArray => Ok(from.as_any_box().downcast::<DynamicArray>()?),
            StructType::DynamicProperty => Ok(from.as_any_box().downcast::<DynamicProperty>()?),
            StructType::KeyAnyValue => Ok(from.as_any_box().downcast::<KeyAnyValue>()?),
            StructType::LocalizableMessage => Ok(from.as_any_box().downcast::<LocalizableMessage>()?),
            StructType::LocalizedMethodFault => Ok(from.as_any_box().downcast::<LocalizedMethodFault>()?),
            StructType::PropertyChange => Ok(from.as_any_box().downcast::<PropertyChange>()?),
            StructType::PropertyFilterSpec => Ok(from.as_any_box().downcast::<PropertyFilterSpec>()?),
            StructType::PropertyFilterUpdate => Ok(from.as_any_box().downcast::<PropertyFilterUpdate>()?),
            StructType::MissingObject => Ok(from.as_any_box().downcast::<MissingObject>()?),
            StructType::MissingProperty => Ok(from.as_any_box().downcast::<MissingProperty>()?),
            StructType::ObjectContent => Ok(from.as_any_box().downcast::<ObjectContent>()?),
            StructType::ObjectSpec => Ok(from.as_any_box().downcast::<ObjectSpec>()?),
            StructType::ObjectUpdate => Ok(from.as_any_box().downcast::<ObjectUpdate>()?),
            StructType::PropertySpec => Ok(from.as_any_box().downcast::<PropertySpec>()?),
            StructType::RetrieveOptions => Ok(from.as_any_box().downcast::<RetrieveOptions>()?),
            StructType::RetrieveResult => Ok(from.as_any_box().downcast::<RetrieveResult>()?),
            StructType::SelectionSpec => Ok(from.as_any_box().downcast::<SelectionSpec>()?),
            StructType::TraversalSpec => Ok(from.as_any_box().downcast::<TraversalSpec>()?),
            StructType::UpdateSet => Ok(from.as_any_box().downcast::<UpdateSet>()?),
            StructType::WaitOptions => Ok(from.as_any_box().downcast::<WaitOptions>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Describes the validation results.
pub trait ClusterComputeResourceValidationResultBaseTrait : super::traits::DataObjectTrait {
    /// Describes the messages relevant to the validation result
    fn get_info(&self) -> &Option<Vec<LocalizableMessage>>;
}
impl<'s> serde::Serialize for dyn ClusterComputeResourceValidationResultBaseTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ClusterComputeResourceValidationResultBaseTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ClusterComputeResourceValidationResultBaseVisitor)
            }
        }

struct ClusterComputeResourceValidationResultBaseVisitor;

impl<'de> de::Visitor<'de> for ClusterComputeResourceValidationResultBaseVisitor {
    type Value = Box<dyn ClusterComputeResourceValidationResultBaseTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ClusterComputeResourceValidationResultBaseTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ClusterComputeResourceValidationResultBaseTrait for ClusterComputeResourceValidationResultBase {
    fn get_info(&self) -> &Option<Vec<LocalizableMessage>> { &self.info }
}
impl ClusterComputeResourceValidationResultBaseTrait for ClusterComputeResourceDvsConfigurationValidation {
    fn get_info(&self) -> &Option<Vec<LocalizableMessage>> { &self.info }
}
impl ClusterComputeResourceValidationResultBaseTrait for ClusterComputeResourceHostConfigurationValidation {
    fn get_info(&self) -> &Option<Vec<LocalizableMessage>> { &self.info }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ClusterComputeResourceValidationResultBaseTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterComputeResourceValidationResultBase => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceValidationResultBase>()?),
            StructType::ClusterComputeResourceDvsConfigurationValidation => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceDvsConfigurationValidation>()?),
            StructType::ClusterComputeResourceHostConfigurationValidation => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceHostConfigurationValidation>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterComputeResourceValidationResultBase => Ok(from.as_any_box().downcast::<ClusterComputeResourceValidationResultBase>()?),
            StructType::ClusterComputeResourceDvsConfigurationValidation => Ok(from.as_any_box().downcast::<ClusterComputeResourceDvsConfigurationValidation>()?),
            StructType::ClusterComputeResourceHostConfigurationValidation => Ok(from.as_any_box().downcast::<ClusterComputeResourceHostConfigurationValidation>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Configuration of the compute resource; applies to both standalone hosts
/// and clusters.
pub trait ComputeResourceConfigInfoTrait : super::traits::DataObjectTrait {
    /// Swapfile placement policy for virtual machines within this compute
    /// resource.
    /// 
    /// Any policy except for "inherit" is a valid value for this
    /// property; the default is "vmDirectory". This setting will be honored
    /// for each virtual machine within the compute resource for which the
    /// following is true:
    /// - The virtual machine is executing on a host that has the
    ///   *perVmSwapFiles* capability.
    /// - The virtual machine configuration's
    ///   *swapPlacement* property is set
    ///   to "inherit".
    ///   
    /// See also *VirtualMachineConfigInfoSwapPlacementType_enum*.
    fn get_vm_swap_placement(&self) -> &str;
    /// Flag indicating whether or not the SPBM(Storage Policy Based Management)
    /// feature is enabled on this compute resource
    fn get_spbm_enabled(&self) -> Option<bool>;
    /// Key for Default Hardware Version used on this compute resource
    /// in the format of *VirtualMachineConfigOptionDescriptor.key*.
    /// 
    /// This field affects
    /// *VirtualMachineConfigOptionDescriptor.defaultConfigOption* returned
    /// by *ComputeResource.environmentBrowser* of this object and all its children
    /// with this field unset.
    fn get_default_hardware_version_key(&self) -> &Option<String>;
    /// Key for Maximum Hardware Version used on this compute resource
    /// in the format of *VirtualMachineConfigOptionDescriptor.key*.
    /// 
    /// This field affects
    /// *VirtualMachineConfigOptionDescriptor.defaultConfigOption* returned
    /// by *ComputeResource.environmentBrowser* of this object and all its children
    /// with this field unset.
    /// 
    /// ***Since:*** vSphere API Release 7.0.2.0
    fn get_maximum_hardware_version_key(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn ComputeResourceConfigInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ComputeResourceConfigInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ComputeResourceConfigInfoVisitor)
            }
        }

struct ComputeResourceConfigInfoVisitor;

impl<'de> de::Visitor<'de> for ComputeResourceConfigInfoVisitor {
    type Value = Box<dyn ComputeResourceConfigInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ComputeResourceConfigInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ComputeResourceConfigInfoTrait for ComputeResourceConfigInfo {
    fn get_vm_swap_placement(&self) -> &str { &self.vm_swap_placement }
    fn get_spbm_enabled(&self) -> Option<bool> { self.spbm_enabled }
    fn get_default_hardware_version_key(&self) -> &Option<String> { &self.default_hardware_version_key }
    fn get_maximum_hardware_version_key(&self) -> &Option<String> { &self.maximum_hardware_version_key }
}
impl ComputeResourceConfigInfoTrait for ClusterConfigInfoEx {
    fn get_vm_swap_placement(&self) -> &str { &self.vm_swap_placement }
    fn get_spbm_enabled(&self) -> Option<bool> { self.spbm_enabled }
    fn get_default_hardware_version_key(&self) -> &Option<String> { &self.default_hardware_version_key }
    fn get_maximum_hardware_version_key(&self) -> &Option<String> { &self.maximum_hardware_version_key }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ComputeResourceConfigInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ComputeResourceConfigInfo => Some(from.as_any_ref().downcast_ref::<ComputeResourceConfigInfo>()?),
            StructType::ClusterConfigInfoEx => Some(from.as_any_ref().downcast_ref::<ClusterConfigInfoEx>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ComputeResourceConfigInfo => Ok(from.as_any_box().downcast::<ComputeResourceConfigInfo>()?),
            StructType::ClusterConfigInfoEx => Ok(from.as_any_box().downcast::<ClusterConfigInfoEx>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Changes to apply to the compute resource configuration.
pub trait ComputeResourceConfigSpecTrait : super::traits::DataObjectTrait {
    /// New setting for the swapfile placement policy.
    /// 
    /// Any change to this
    /// policy will affect virtual machines that subsequently power on or
    /// resume from a suspended state in this compute resource, or that
    /// migrate to a host in this compute resource while powered on; virtual
    /// machines that are currently powered on in this compute resource will
    /// not yet be affected.
    /// 
    /// See also *VirtualMachineConfigInfoSwapPlacementType_enum*.
    fn get_vm_swap_placement(&self) -> &Option<String>;
    /// Flag indicating whether or not the SPBM(Storage Policy Based Management)
    /// feature is enabled on this compute resource
    fn get_spbm_enabled(&self) -> Option<bool>;
    /// Key for Default Hardware Version to be used on this compute resource
    /// in the format of *VirtualMachineConfigOptionDescriptor.key*.
    /// 
    /// Setting this field affects
    /// *VirtualMachineConfigOptionDescriptor.defaultConfigOption* returned
    /// by *ComputeResource.environmentBrowser* of this object and all its children
    /// with this field unset.
    fn get_default_hardware_version_key(&self) -> &Option<String>;
    /// Desired software spec for the set of physical compute resources.
    /// 
    /// This
    /// parameter is only supported in vim.Folder#createClusterEx operation.
    fn get_desired_software_spec(&self) -> &Option<DesiredSoftwareSpec>;
    /// Key for Maximum Hardware Version to be used on this compute resource
    /// in the format of *VirtualMachineConfigOptionDescriptor.key*.
    /// 
    /// Setting this field affects
    /// *VirtualMachineConfigOptionDescriptor.defaultConfigOption* returned
    /// by *ComputeResource.environmentBrowser* of this object and all its children
    /// with this field unset.
    /// 
    /// ***Since:*** vSphere API Release 7.0.2.0
    fn get_maximum_hardware_version_key(&self) -> &Option<String>;
    /// Flag indicating whether or not the vLCM (vSphere Lifecycle Manager)
    /// Config Manager feature is enabled on this compute resource.
    /// 
    /// If the
    /// flag is not set, the Config Manager feature will be disabled by
    /// default. This parameter is only supported in *Folder.CreateClusterEx*
    /// operation.
    /// 
    /// ***Since:*** vSphere API Release 7.0.3.1
    fn get_enable_config_manager(&self) -> Option<bool>;
}
impl<'s> serde::Serialize for dyn ComputeResourceConfigSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ComputeResourceConfigSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ComputeResourceConfigSpecVisitor)
            }
        }

struct ComputeResourceConfigSpecVisitor;

impl<'de> de::Visitor<'de> for ComputeResourceConfigSpecVisitor {
    type Value = Box<dyn ComputeResourceConfigSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ComputeResourceConfigSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ComputeResourceConfigSpecTrait for ComputeResourceConfigSpec {
    fn get_vm_swap_placement(&self) -> &Option<String> { &self.vm_swap_placement }
    fn get_spbm_enabled(&self) -> Option<bool> { self.spbm_enabled }
    fn get_default_hardware_version_key(&self) -> &Option<String> { &self.default_hardware_version_key }
    fn get_desired_software_spec(&self) -> &Option<DesiredSoftwareSpec> { &self.desired_software_spec }
    fn get_maximum_hardware_version_key(&self) -> &Option<String> { &self.maximum_hardware_version_key }
    fn get_enable_config_manager(&self) -> Option<bool> { self.enable_config_manager }
}
impl ComputeResourceConfigSpecTrait for ClusterConfigSpecEx {
    fn get_vm_swap_placement(&self) -> &Option<String> { &self.vm_swap_placement }
    fn get_spbm_enabled(&self) -> Option<bool> { self.spbm_enabled }
    fn get_default_hardware_version_key(&self) -> &Option<String> { &self.default_hardware_version_key }
    fn get_desired_software_spec(&self) -> &Option<DesiredSoftwareSpec> { &self.desired_software_spec }
    fn get_maximum_hardware_version_key(&self) -> &Option<String> { &self.maximum_hardware_version_key }
    fn get_enable_config_manager(&self) -> Option<bool> { self.enable_config_manager }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ComputeResourceConfigSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ComputeResourceConfigSpec => Some(from.as_any_ref().downcast_ref::<ComputeResourceConfigSpec>()?),
            StructType::ClusterConfigSpecEx => Some(from.as_any_ref().downcast_ref::<ClusterConfigSpecEx>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ComputeResourceConfigSpec => Ok(from.as_any_box().downcast::<ComputeResourceConfigSpec>()?),
            StructType::ClusterConfigSpecEx => Ok(from.as_any_box().downcast::<ClusterConfigSpecEx>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type encapsulates a typical set of ComputeResource information
/// that is useful for list views and summary pages.
pub trait ComputeResourceSummaryTrait : super::traits::DataObjectTrait {
    /// Aggregated CPU resources of all hosts, in MHz.
    fn get_total_cpu(&self) -> i32;
    /// Aggregated memory resources of all hosts, in bytes.
    fn get_total_memory(&self) -> i64;
    /// Number of physical CPU cores.
    /// 
    /// Physical CPU cores are the processors contained
    /// by a CPU package.
    fn get_num_cpu_cores(&self) -> i16;
    /// Aggregated number of CPU threads.
    fn get_num_cpu_threads(&self) -> i16;
    /// Effective CPU resources (in MHz) available to run virtual machines.
    /// 
    /// This is the
    /// aggregated effective resource level from all running hosts. Hosts that are in
    /// maintenance mode or are unresponsive are not counted. Resources used by the
    /// VMware Service Console are not included in the aggregate. This value represents
    /// the amount of resources available for the root resource pool for running
    /// virtual machines.
    fn get_effective_cpu(&self) -> i32;
    /// Effective memory resources (in MB) available to run virtual machines.
    /// 
    /// This is the aggregated effective resource level from all running hosts. Hosts
    /// that are in maintenance mode or are unresponsive are not counted.
    /// Resources used by the VMware Service Console are not included in the aggregate.
    /// This value represents the amount of resources available for the root
    /// resource pool for running virtual machines.
    fn get_effective_memory(&self) -> i64;
    /// Total number of hosts.
    fn get_num_hosts(&self) -> i32;
    /// Total number of effective hosts.
    fn get_num_effective_hosts(&self) -> i32;
    /// Overall alarm status.
    /// 
    /// In releases after vSphere API 5.0, vSphere Servers might not
    /// generate property collector update notifications for this property.
    /// To obtain the latest value of the property, you can use
    /// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
    /// If you use the PropertyCollector.WaitForUpdatesEx method, specify
    /// an empty string for the version parameter.
    /// Since this property is on a DataObject, an update returned by WaitForUpdatesEx may
    /// contain values for this property when some other property on the DataObject changes.
    /// If this update is a result of a call to WaitForUpdatesEx with a non-empty
    /// version parameter, the value for this property may not be current.
    fn get_overall_status(&self) -> &super::enums::ManagedEntityStatusEnum;
}
impl<'s> serde::Serialize for dyn ComputeResourceSummaryTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ComputeResourceSummaryTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ComputeResourceSummaryVisitor)
            }
        }

struct ComputeResourceSummaryVisitor;

impl<'de> de::Visitor<'de> for ComputeResourceSummaryVisitor {
    type Value = Box<dyn ComputeResourceSummaryTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ComputeResourceSummaryTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ComputeResourceSummaryTrait for ComputeResourceSummary {
    fn get_total_cpu(&self) -> i32 { self.total_cpu }
    fn get_total_memory(&self) -> i64 { self.total_memory }
    fn get_num_cpu_cores(&self) -> i16 { self.num_cpu_cores }
    fn get_num_cpu_threads(&self) -> i16 { self.num_cpu_threads }
    fn get_effective_cpu(&self) -> i32 { self.effective_cpu }
    fn get_effective_memory(&self) -> i64 { self.effective_memory }
    fn get_num_hosts(&self) -> i32 { self.num_hosts }
    fn get_num_effective_hosts(&self) -> i32 { self.num_effective_hosts }
    fn get_overall_status(&self) -> &super::enums::ManagedEntityStatusEnum { &self.overall_status }
}
impl ComputeResourceSummaryTrait for ClusterComputeResourceSummary {
    fn get_total_cpu(&self) -> i32 { self.total_cpu }
    fn get_total_memory(&self) -> i64 { self.total_memory }
    fn get_num_cpu_cores(&self) -> i16 { self.num_cpu_cores }
    fn get_num_cpu_threads(&self) -> i16 { self.num_cpu_threads }
    fn get_effective_cpu(&self) -> i32 { self.effective_cpu }
    fn get_effective_memory(&self) -> i64 { self.effective_memory }
    fn get_num_hosts(&self) -> i32 { self.num_hosts }
    fn get_num_effective_hosts(&self) -> i32 { self.num_effective_hosts }
    fn get_overall_status(&self) -> &super::enums::ManagedEntityStatusEnum { &self.overall_status }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ComputeResourceSummaryTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ComputeResourceSummary => Some(from.as_any_ref().downcast_ref::<ComputeResourceSummary>()?),
            StructType::ClusterComputeResourceSummary => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceSummary>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ComputeResourceSummary => Ok(from.as_any_box().downcast::<ComputeResourceSummary>()?),
            StructType::ClusterComputeResourceSummary => Ok(from.as_any_box().downcast::<ClusterComputeResourceSummary>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base type for storing values.
pub trait CustomFieldValueTrait : super::traits::DataObjectTrait {
    /// The ID of the field to which this value belongs.
    fn get_key(&self) -> i32;
}
impl<'s> serde::Serialize for dyn CustomFieldValueTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn CustomFieldValueTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(CustomFieldValueVisitor)
            }
        }

struct CustomFieldValueVisitor;

impl<'de> de::Visitor<'de> for CustomFieldValueVisitor {
    type Value = Box<dyn CustomFieldValueTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid CustomFieldValueTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl CustomFieldValueTrait for CustomFieldValue {
    fn get_key(&self) -> i32 { self.key }
}
impl CustomFieldValueTrait for CustomFieldStringValue {
    fn get_key(&self) -> i32 { self.key }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn CustomFieldValueTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::CustomFieldValue => Some(from.as_any_ref().downcast_ref::<CustomFieldValue>()?),
            StructType::CustomFieldStringValue => Some(from.as_any_ref().downcast_ref::<CustomFieldStringValue>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::CustomFieldValue => Ok(from.as_any_box().downcast::<CustomFieldValue>()?),
            StructType::CustomFieldStringValue => Ok(from.as_any_box().downcast::<CustomFieldStringValue>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Detailed information about a datastore.
/// 
/// This is a base type for derived types
/// that have more specific details about a datastore.
/// 
/// See also *HostVmfsVolume*, *HostNasVolume*, *HostLocalFileSystemVolume*.
pub trait DatastoreInfoTrait : super::traits::DataObjectTrait {
    /// The name of the datastore.
    fn get_name(&self) -> &str;
    /// The unique locator for the datastore.
    fn get_url(&self) -> &str;
    /// Free space of this datastore, in bytes.
    /// 
    /// The server periodically updates this
    /// value. It can be explicitly refreshed with the Refresh operation.
    fn get_free_space(&self) -> i64;
    /// The maximum size of a file that can reside on this file system volume.
    fn get_max_file_size(&self) -> i64;
    /// The maximum capacity of a virtual disk which can be created on this volume.
    fn get_max_virtual_disk_capacity(&self) -> Option<i64>;
    /// The maximum size of a snapshot or a swap file that can reside on this file system volume.
    fn get_max_memory_file_size(&self) -> i64;
    /// Time when the free-space and capacity values in *DatastoreInfo* and
    /// *DatastoreSummary* were updated.
    fn get_timestamp(&self) -> &Option<String>;
    /// The unique container ID of the datastore, if applicable.
    fn get_container_id(&self) -> &Option<String>;
    /// vSAN datastore container that this datastore is alias of.
    /// 
    /// If this
    /// field is unset then this datastore is not alias of any other vSAN
    /// datastore.
    /// See *DatastoreInfo.containerId*.
    fn get_alias_of(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn DatastoreInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DatastoreInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DatastoreInfoVisitor)
            }
        }

struct DatastoreInfoVisitor;

impl<'de> de::Visitor<'de> for DatastoreInfoVisitor {
    type Value = Box<dyn DatastoreInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DatastoreInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DatastoreInfoTrait for DatastoreInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_url(&self) -> &str { &self.url }
    fn get_free_space(&self) -> i64 { self.free_space }
    fn get_max_file_size(&self) -> i64 { self.max_file_size }
    fn get_max_virtual_disk_capacity(&self) -> Option<i64> { self.max_virtual_disk_capacity }
    fn get_max_memory_file_size(&self) -> i64 { self.max_memory_file_size }
    fn get_timestamp(&self) -> &Option<String> { &self.timestamp }
    fn get_container_id(&self) -> &Option<String> { &self.container_id }
    fn get_alias_of(&self) -> &Option<String> { &self.alias_of }
}
impl DatastoreInfoTrait for LocalDatastoreInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_url(&self) -> &str { &self.url }
    fn get_free_space(&self) -> i64 { self.free_space }
    fn get_max_file_size(&self) -> i64 { self.max_file_size }
    fn get_max_virtual_disk_capacity(&self) -> Option<i64> { self.max_virtual_disk_capacity }
    fn get_max_memory_file_size(&self) -> i64 { self.max_memory_file_size }
    fn get_timestamp(&self) -> &Option<String> { &self.timestamp }
    fn get_container_id(&self) -> &Option<String> { &self.container_id }
    fn get_alias_of(&self) -> &Option<String> { &self.alias_of }
}
impl DatastoreInfoTrait for NasDatastoreInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_url(&self) -> &str { &self.url }
    fn get_free_space(&self) -> i64 { self.free_space }
    fn get_max_file_size(&self) -> i64 { self.max_file_size }
    fn get_max_virtual_disk_capacity(&self) -> Option<i64> { self.max_virtual_disk_capacity }
    fn get_max_memory_file_size(&self) -> i64 { self.max_memory_file_size }
    fn get_timestamp(&self) -> &Option<String> { &self.timestamp }
    fn get_container_id(&self) -> &Option<String> { &self.container_id }
    fn get_alias_of(&self) -> &Option<String> { &self.alias_of }
}
impl DatastoreInfoTrait for PMemDatastoreInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_url(&self) -> &str { &self.url }
    fn get_free_space(&self) -> i64 { self.free_space }
    fn get_max_file_size(&self) -> i64 { self.max_file_size }
    fn get_max_virtual_disk_capacity(&self) -> Option<i64> { self.max_virtual_disk_capacity }
    fn get_max_memory_file_size(&self) -> i64 { self.max_memory_file_size }
    fn get_timestamp(&self) -> &Option<String> { &self.timestamp }
    fn get_container_id(&self) -> &Option<String> { &self.container_id }
    fn get_alias_of(&self) -> &Option<String> { &self.alias_of }
}
impl DatastoreInfoTrait for VmfsDatastoreInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_url(&self) -> &str { &self.url }
    fn get_free_space(&self) -> i64 { self.free_space }
    fn get_max_file_size(&self) -> i64 { self.max_file_size }
    fn get_max_virtual_disk_capacity(&self) -> Option<i64> { self.max_virtual_disk_capacity }
    fn get_max_memory_file_size(&self) -> i64 { self.max_memory_file_size }
    fn get_timestamp(&self) -> &Option<String> { &self.timestamp }
    fn get_container_id(&self) -> &Option<String> { &self.container_id }
    fn get_alias_of(&self) -> &Option<String> { &self.alias_of }
}
impl DatastoreInfoTrait for VsanDatastoreInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_url(&self) -> &str { &self.url }
    fn get_free_space(&self) -> i64 { self.free_space }
    fn get_max_file_size(&self) -> i64 { self.max_file_size }
    fn get_max_virtual_disk_capacity(&self) -> Option<i64> { self.max_virtual_disk_capacity }
    fn get_max_memory_file_size(&self) -> i64 { self.max_memory_file_size }
    fn get_timestamp(&self) -> &Option<String> { &self.timestamp }
    fn get_container_id(&self) -> &Option<String> { &self.container_id }
    fn get_alias_of(&self) -> &Option<String> { &self.alias_of }
}
impl DatastoreInfoTrait for VvolDatastoreInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_url(&self) -> &str { &self.url }
    fn get_free_space(&self) -> i64 { self.free_space }
    fn get_max_file_size(&self) -> i64 { self.max_file_size }
    fn get_max_virtual_disk_capacity(&self) -> Option<i64> { self.max_virtual_disk_capacity }
    fn get_max_memory_file_size(&self) -> i64 { self.max_memory_file_size }
    fn get_timestamp(&self) -> &Option<String> { &self.timestamp }
    fn get_container_id(&self) -> &Option<String> { &self.container_id }
    fn get_alias_of(&self) -> &Option<String> { &self.alias_of }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DatastoreInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DatastoreInfo => Some(from.as_any_ref().downcast_ref::<DatastoreInfo>()?),
            StructType::LocalDatastoreInfo => Some(from.as_any_ref().downcast_ref::<LocalDatastoreInfo>()?),
            StructType::NasDatastoreInfo => Some(from.as_any_ref().downcast_ref::<NasDatastoreInfo>()?),
            StructType::PMemDatastoreInfo => Some(from.as_any_ref().downcast_ref::<PMemDatastoreInfo>()?),
            StructType::VmfsDatastoreInfo => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreInfo>()?),
            StructType::VsanDatastoreInfo => Some(from.as_any_ref().downcast_ref::<VsanDatastoreInfo>()?),
            StructType::VvolDatastoreInfo => Some(from.as_any_ref().downcast_ref::<VvolDatastoreInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DatastoreInfo => Ok(from.as_any_box().downcast::<DatastoreInfo>()?),
            StructType::LocalDatastoreInfo => Ok(from.as_any_box().downcast::<LocalDatastoreInfo>()?),
            StructType::NasDatastoreInfo => Ok(from.as_any_box().downcast::<NasDatastoreInfo>()?),
            StructType::PMemDatastoreInfo => Ok(from.as_any_box().downcast::<PMemDatastoreInfo>()?),
            StructType::VmfsDatastoreInfo => Ok(from.as_any_box().downcast::<VmfsDatastoreInfo>()?),
            StructType::VsanDatastoreInfo => Ok(from.as_any_box().downcast::<VsanDatastoreInfo>()?),
            StructType::VvolDatastoreInfo => Ok(from.as_any_box().downcast::<VvolDatastoreInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Static strings used for describing an object or property.
pub trait DescriptionTrait : super::traits::DataObjectTrait {
    /// Display label.
    fn get_label(&self) -> &str;
    /// Summary description.
    fn get_summary(&self) -> &str;
}
impl<'s> serde::Serialize for dyn DescriptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DescriptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DescriptionVisitor)
            }
        }

struct DescriptionVisitor;

impl<'de> de::Visitor<'de> for DescriptionVisitor {
    type Value = Box<dyn DescriptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DescriptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DescriptionTrait for Description {
    fn get_label(&self) -> &str { &self.label }
    fn get_summary(&self) -> &str { &self.summary }
}
impl DescriptionTrait for ElementDescription {
    fn get_label(&self) -> &str { &self.label }
    fn get_summary(&self) -> &str { &self.summary }
}
impl DescriptionTrait for EvcMode {
    fn get_label(&self) -> &str { &self.label }
    fn get_summary(&self) -> &str { &self.summary }
}
impl DescriptionTrait for ExtendedElementDescription {
    fn get_label(&self) -> &str { &self.label }
    fn get_summary(&self) -> &str { &self.summary }
}
impl DescriptionTrait for FeatureEvcMode {
    fn get_label(&self) -> &str { &self.label }
    fn get_summary(&self) -> &str { &self.summary }
}
impl DescriptionTrait for OptionDef {
    fn get_label(&self) -> &str { &self.label }
    fn get_summary(&self) -> &str { &self.summary }
}
impl DescriptionTrait for ExtendedDescription {
    fn get_label(&self) -> &str { &self.label }
    fn get_summary(&self) -> &str { &self.summary }
}
impl DescriptionTrait for MethodDescription {
    fn get_label(&self) -> &str { &self.label }
    fn get_summary(&self) -> &str { &self.summary }
}
impl DescriptionTrait for TypeDescription {
    fn get_label(&self) -> &str { &self.label }
    fn get_summary(&self) -> &str { &self.summary }
}
impl DescriptionTrait for ScheduledTaskDetail {
    fn get_label(&self) -> &str { &self.label }
    fn get_summary(&self) -> &str { &self.summary }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DescriptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::Description => Some(from.as_any_ref().downcast_ref::<Description>()?),
            StructType::ElementDescription => Some(from.as_any_ref().downcast_ref::<ElementDescription>()?),
            StructType::EvcMode => Some(from.as_any_ref().downcast_ref::<EvcMode>()?),
            StructType::ExtendedElementDescription => Some(from.as_any_ref().downcast_ref::<ExtendedElementDescription>()?),
            StructType::FeatureEvcMode => Some(from.as_any_ref().downcast_ref::<FeatureEvcMode>()?),
            StructType::OptionDef => Some(from.as_any_ref().downcast_ref::<OptionDef>()?),
            StructType::ExtendedDescription => Some(from.as_any_ref().downcast_ref::<ExtendedDescription>()?),
            StructType::MethodDescription => Some(from.as_any_ref().downcast_ref::<MethodDescription>()?),
            StructType::TypeDescription => Some(from.as_any_ref().downcast_ref::<TypeDescription>()?),
            StructType::ScheduledTaskDetail => Some(from.as_any_ref().downcast_ref::<ScheduledTaskDetail>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::Description => Ok(from.as_any_box().downcast::<Description>()?),
            StructType::ElementDescription => Ok(from.as_any_box().downcast::<ElementDescription>()?),
            StructType::EvcMode => Ok(from.as_any_box().downcast::<EvcMode>()?),
            StructType::ExtendedElementDescription => Ok(from.as_any_box().downcast::<ExtendedElementDescription>()?),
            StructType::FeatureEvcMode => Ok(from.as_any_box().downcast::<FeatureEvcMode>()?),
            StructType::OptionDef => Ok(from.as_any_box().downcast::<OptionDef>()?),
            StructType::ExtendedDescription => Ok(from.as_any_box().downcast::<ExtendedDescription>()?),
            StructType::MethodDescription => Ok(from.as_any_box().downcast::<MethodDescription>()?),
            StructType::TypeDescription => Ok(from.as_any_box().downcast::<TypeDescription>()?),
            StructType::ScheduledTaskDetail => Ok(from.as_any_box().downcast::<ScheduledTaskDetail>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Static strings used for describing an object model string or enumeration.
pub trait ElementDescriptionTrait : super::traits::DescriptionTrait {
    /// Enumeration or literal ID being described.
    fn get_key(&self) -> &str;
}
impl<'s> serde::Serialize for dyn ElementDescriptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ElementDescriptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ElementDescriptionVisitor)
            }
        }

struct ElementDescriptionVisitor;

impl<'de> de::Visitor<'de> for ElementDescriptionVisitor {
    type Value = Box<dyn ElementDescriptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ElementDescriptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ElementDescriptionTrait for ElementDescription {
    fn get_key(&self) -> &str { &self.key }
}
impl ElementDescriptionTrait for EvcMode {
    fn get_key(&self) -> &str { &self.key }
}
impl ElementDescriptionTrait for ExtendedElementDescription {
    fn get_key(&self) -> &str { &self.key }
}
impl ElementDescriptionTrait for FeatureEvcMode {
    fn get_key(&self) -> &str { &self.key }
}
impl ElementDescriptionTrait for OptionDef {
    fn get_key(&self) -> &str { &self.key }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ElementDescriptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ElementDescription => Some(from.as_any_ref().downcast_ref::<ElementDescription>()?),
            StructType::EvcMode => Some(from.as_any_ref().downcast_ref::<EvcMode>()?),
            StructType::ExtendedElementDescription => Some(from.as_any_ref().downcast_ref::<ExtendedElementDescription>()?),
            StructType::FeatureEvcMode => Some(from.as_any_ref().downcast_ref::<FeatureEvcMode>()?),
            StructType::OptionDef => Some(from.as_any_ref().downcast_ref::<OptionDef>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ElementDescription => Ok(from.as_any_box().downcast::<ElementDescription>()?),
            StructType::EvcMode => Ok(from.as_any_box().downcast::<EvcMode>()?),
            StructType::ExtendedElementDescription => Ok(from.as_any_box().downcast::<ExtendedElementDescription>()?),
            StructType::FeatureEvcMode => Ok(from.as_any_box().downcast::<FeatureEvcMode>()?),
            StructType::OptionDef => Ok(from.as_any_box().downcast::<OptionDef>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Static strings used for describing an object type.
pub trait TypeDescriptionTrait : super::traits::DescriptionTrait {
    /// Type being described
    fn get_key(&self) -> &str;
}
impl<'s> serde::Serialize for dyn TypeDescriptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn TypeDescriptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(TypeDescriptionVisitor)
            }
        }

struct TypeDescriptionVisitor;

impl<'de> de::Visitor<'de> for TypeDescriptionVisitor {
    type Value = Box<dyn TypeDescriptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid TypeDescriptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl TypeDescriptionTrait for TypeDescription {
    fn get_key(&self) -> &str { &self.key }
}
impl TypeDescriptionTrait for ScheduledTaskDetail {
    fn get_key(&self) -> &str { &self.key }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn TypeDescriptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::TypeDescription => Some(from.as_any_ref().downcast_ref::<TypeDescription>()?),
            StructType::ScheduledTaskDetail => Some(from.as_any_ref().downcast_ref::<ScheduledTaskDetail>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::TypeDescription => Ok(from.as_any_box().downcast::<TypeDescription>()?),
            StructType::ScheduledTaskDetail => Ok(from.as_any_box().downcast::<ScheduledTaskDetail>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Configuration of a *DistributedVirtualSwitch*.
pub trait DvsConfigInfoTrait : super::traits::DataObjectTrait {
    /// Generated UUID of the switch.
    /// 
    /// Unique across vCenter Server
    /// inventory and instances.
    fn get_uuid(&self) -> &str;
    /// Name of the switch.
    fn get_name(&self) -> &str;
    /// Number of standalone ports in the switch.
    /// 
    /// Standalone ports are
    /// ports that do not belong to any portgroup.
    fn get_num_standalone_ports(&self) -> i32;
    /// Current number of ports, not including conflict ports.
    fn get_num_ports(&self) -> i32;
    /// Maximum number of ports allowed in the switch,
    /// not including conflict ports.
    fn get_max_ports(&self) -> i32;
    /// Uplink port policy.
    fn get_uplink_port_policy(&self) -> &Box<dyn super::traits::DvsUplinkPortPolicyTrait>;
    /// List of uplink portgroups.
    /// 
    /// When adding host members, the server
    /// uses the *DVSConfigInfo.uplinkPortPolicy* to create a number of
    /// uplink ports for the host. If portgroups are shown here,
    /// those uplink ports will be added to the portgroups, with uplink ports
    /// evenly spread among the portgroups.
    /// 
    /// Refers instances of *DistributedVirtualPortgroup*.
    fn get_uplink_portgroup(&self) -> &Option<Vec<ManagedObjectReference>>;
    /// Default configuration for the ports in the switch, if the port
    /// does not inherit configuration from the parent portgroup or has
    /// its own configuration.
    fn get_default_port_config(&self) -> &Box<dyn super::traits::DvPortSettingTrait>;
    /// Hosts that join the switch.
    fn get_host(&self) -> &Option<Vec<DistributedVirtualSwitchHostMember>>;
    /// Vendor, product, and version information for the implementation
    /// module of the switch.
    fn get_product_info(&self) -> &DistributedVirtualSwitchProductSpec;
    /// Intended vendor, product, and version information for the
    /// implementation module of the switch.
    fn get_target_info(&self) -> &Option<DistributedVirtualSwitchProductSpec>;
    /// Key of the extension registered by the remote server that
    /// controls the switch.
    fn get_extension_key(&self) -> &Option<String>;
    /// Opaque binary blob that stores vendor specific configuration.
    fn get_vendor_specific_config(&self) -> &Option<Vec<DistributedVirtualSwitchKeyedOpaqueBlob>>;
    /// Usage policy of the switch.
    fn get_policy(&self) -> &Option<DvsPolicy>;
    /// Description string for the switch.
    fn get_description(&self) -> &Option<String>;
    /// Version string of the configuration.
    fn get_config_version(&self) -> &str;
    /// Human operator contact information.
    fn get_contact(&self) -> &DvsContactInfo;
    /// IP address for the switch, specified using IPv4 dot notation.
    /// 
    /// The
    /// utility of this address is defined by other switch features.
    fn get_switch_ip_address(&self) -> &Option<String>;
    /// Create time of the switch.
    fn get_create_time(&self) -> &str;
    /// Boolean to indicate if network I/O control is enabled on the
    /// switch.
    fn get_network_resource_management_enabled(&self) -> bool;
    /// Default host proxy switch maximum port number
    fn get_default_proxy_switch_max_num_ports(&self) -> Option<i32>;
    /// VDS health check configuration.
    fn get_health_check_config(&self) -> &Option<Vec<Box<dyn super::traits::DvsHealthCheckConfigTrait>>>;
    /// Host infrastructure traffic class resource configuration.
    fn get_infrastructure_traffic_resource_config(&self) -> &Option<Vec<DvsHostInfrastructureTrafficResource>>;
    /// Dynamic Host infrastructure traffic class resource configuration.
    fn get_net_resource_pool_traffic_resource_config(&self) -> &Option<Vec<DvsHostInfrastructureTrafficResource>>;
    /// Network resource control version of the switch.
    /// 
    /// Possible value can be of
    /// *DistributedVirtualSwitchNetworkResourceControlVersion_enum*.
    fn get_network_resource_control_version(&self) -> &Option<String>;
    /// The Virtual NIC network resource pool information for the switch.
    fn get_vm_vnic_network_resource_pool(&self) -> &Option<Vec<DvsVmVnicNetworkResourcePool>>;
    /// The percentage of physical nic link speed
    /// *PhysicalNicLinkInfo.speedMb*
    /// available for infrastructure traffic reservation.
    /// 
    /// If this value is 75, then for a 1Gbps physical nic, only
    /// 750Mbps is allowed for all infrastructure traffic reservations.
    fn get_pnic_capacity_ratio_for_reservation(&self) -> Option<i32>;
}
impl<'s> serde::Serialize for dyn DvsConfigInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DvsConfigInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DvsConfigInfoVisitor)
            }
        }

struct DvsConfigInfoVisitor;

impl<'de> de::Visitor<'de> for DvsConfigInfoVisitor {
    type Value = Box<dyn DvsConfigInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DvsConfigInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DvsConfigInfoTrait for DvsConfigInfo {
    fn get_uuid(&self) -> &str { &self.uuid }
    fn get_name(&self) -> &str { &self.name }
    fn get_num_standalone_ports(&self) -> i32 { self.num_standalone_ports }
    fn get_num_ports(&self) -> i32 { self.num_ports }
    fn get_max_ports(&self) -> i32 { self.max_ports }
    fn get_uplink_port_policy(&self) -> &Box<dyn super::traits::DvsUplinkPortPolicyTrait> { &self.uplink_port_policy }
    fn get_uplink_portgroup(&self) -> &Option<Vec<ManagedObjectReference>> { &self.uplink_portgroup }
    fn get_default_port_config(&self) -> &Box<dyn super::traits::DvPortSettingTrait> { &self.default_port_config }
    fn get_host(&self) -> &Option<Vec<DistributedVirtualSwitchHostMember>> { &self.host }
    fn get_product_info(&self) -> &DistributedVirtualSwitchProductSpec { &self.product_info }
    fn get_target_info(&self) -> &Option<DistributedVirtualSwitchProductSpec> { &self.target_info }
    fn get_extension_key(&self) -> &Option<String> { &self.extension_key }
    fn get_vendor_specific_config(&self) -> &Option<Vec<DistributedVirtualSwitchKeyedOpaqueBlob>> { &self.vendor_specific_config }
    fn get_policy(&self) -> &Option<DvsPolicy> { &self.policy }
    fn get_description(&self) -> &Option<String> { &self.description }
    fn get_config_version(&self) -> &str { &self.config_version }
    fn get_contact(&self) -> &DvsContactInfo { &self.contact }
    fn get_switch_ip_address(&self) -> &Option<String> { &self.switch_ip_address }
    fn get_create_time(&self) -> &str { &self.create_time }
    fn get_network_resource_management_enabled(&self) -> bool { self.network_resource_management_enabled }
    fn get_default_proxy_switch_max_num_ports(&self) -> Option<i32> { self.default_proxy_switch_max_num_ports }
    fn get_health_check_config(&self) -> &Option<Vec<Box<dyn super::traits::DvsHealthCheckConfigTrait>>> { &self.health_check_config }
    fn get_infrastructure_traffic_resource_config(&self) -> &Option<Vec<DvsHostInfrastructureTrafficResource>> { &self.infrastructure_traffic_resource_config }
    fn get_net_resource_pool_traffic_resource_config(&self) -> &Option<Vec<DvsHostInfrastructureTrafficResource>> { &self.net_resource_pool_traffic_resource_config }
    fn get_network_resource_control_version(&self) -> &Option<String> { &self.network_resource_control_version }
    fn get_vm_vnic_network_resource_pool(&self) -> &Option<Vec<DvsVmVnicNetworkResourcePool>> { &self.vm_vnic_network_resource_pool }
    fn get_pnic_capacity_ratio_for_reservation(&self) -> Option<i32> { self.pnic_capacity_ratio_for_reservation }
}
impl DvsConfigInfoTrait for VMwareDvsConfigInfo {
    fn get_uuid(&self) -> &str { &self.uuid }
    fn get_name(&self) -> &str { &self.name }
    fn get_num_standalone_ports(&self) -> i32 { self.num_standalone_ports }
    fn get_num_ports(&self) -> i32 { self.num_ports }
    fn get_max_ports(&self) -> i32 { self.max_ports }
    fn get_uplink_port_policy(&self) -> &Box<dyn super::traits::DvsUplinkPortPolicyTrait> { &self.uplink_port_policy }
    fn get_uplink_portgroup(&self) -> &Option<Vec<ManagedObjectReference>> { &self.uplink_portgroup }
    fn get_default_port_config(&self) -> &Box<dyn super::traits::DvPortSettingTrait> { &self.default_port_config }
    fn get_host(&self) -> &Option<Vec<DistributedVirtualSwitchHostMember>> { &self.host }
    fn get_product_info(&self) -> &DistributedVirtualSwitchProductSpec { &self.product_info }
    fn get_target_info(&self) -> &Option<DistributedVirtualSwitchProductSpec> { &self.target_info }
    fn get_extension_key(&self) -> &Option<String> { &self.extension_key }
    fn get_vendor_specific_config(&self) -> &Option<Vec<DistributedVirtualSwitchKeyedOpaqueBlob>> { &self.vendor_specific_config }
    fn get_policy(&self) -> &Option<DvsPolicy> { &self.policy }
    fn get_description(&self) -> &Option<String> { &self.description }
    fn get_config_version(&self) -> &str { &self.config_version }
    fn get_contact(&self) -> &DvsContactInfo { &self.contact }
    fn get_switch_ip_address(&self) -> &Option<String> { &self.switch_ip_address }
    fn get_create_time(&self) -> &str { &self.create_time }
    fn get_network_resource_management_enabled(&self) -> bool { self.network_resource_management_enabled }
    fn get_default_proxy_switch_max_num_ports(&self) -> Option<i32> { self.default_proxy_switch_max_num_ports }
    fn get_health_check_config(&self) -> &Option<Vec<Box<dyn super::traits::DvsHealthCheckConfigTrait>>> { &self.health_check_config }
    fn get_infrastructure_traffic_resource_config(&self) -> &Option<Vec<DvsHostInfrastructureTrafficResource>> { &self.infrastructure_traffic_resource_config }
    fn get_net_resource_pool_traffic_resource_config(&self) -> &Option<Vec<DvsHostInfrastructureTrafficResource>> { &self.net_resource_pool_traffic_resource_config }
    fn get_network_resource_control_version(&self) -> &Option<String> { &self.network_resource_control_version }
    fn get_vm_vnic_network_resource_pool(&self) -> &Option<Vec<DvsVmVnicNetworkResourcePool>> { &self.vm_vnic_network_resource_pool }
    fn get_pnic_capacity_ratio_for_reservation(&self) -> Option<i32> { self.pnic_capacity_ratio_for_reservation }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DvsConfigInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsConfigInfo => Some(from.as_any_ref().downcast_ref::<DvsConfigInfo>()?),
            StructType::VMwareDvsConfigInfo => Some(from.as_any_ref().downcast_ref::<VMwareDvsConfigInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsConfigInfo => Ok(from.as_any_box().downcast::<DvsConfigInfo>()?),
            StructType::VMwareDvsConfigInfo => Ok(from.as_any_box().downcast::<VMwareDvsConfigInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *DVSConfigSpec*
/// data object contains configuration data for a
/// *DistributedVirtualSwitch*.
/// 
/// Use the *DistributedVirtualSwitch.ReconfigureDvs_Task*
/// method to apply the configuration to the
/// switch.
pub trait DvsConfigSpecTrait : super::traits::DataObjectTrait {
    /// Set of dynamic properties.
    /// 
    /// This property is optional because only the
    /// properties of an object that are unknown to a client will be part of this set.
    /// This property is not readonly just in case we want to send such properties
    /// from a client in the future.
    fn get_dynamic_property(&self) -> &Option<Vec<DynamicProperty>>;
    /// The version string of the configuration that this spec is trying to
    /// change.
    /// 
    /// This property is required in reconfiguring a switch
    /// and should be set to the same value as
    /// *DVSConfigInfo.configVersion*.
    /// This property is ignored during switch creation.
    fn get_config_version(&self) -> &Option<String>;
    /// The name of the switch.
    /// 
    /// Must be unique in the parent folder.
    fn get_name(&self) -> &Option<String>;
    /// The number of standalone ports in the switch.
    /// 
    /// Standalone ports are
    /// ports that do not belong to any portgroup. If set to a number larger
    /// than number of existing standalone ports in the switch, new ports get
    /// created to meet the number. If set to a number smaller than the number
    /// of existing standalone ports, free ports (uplink ports excluded) are
    /// deleted to meet the number. If the set number cannot be met by
    /// deleting free standalone ports, a fault is raised.
    fn get_num_standalone_ports(&self) -> Option<i32>;
    /// Deprecated as of vSphere API 5.0
    /// The default value of this propoerty is maxint and there is no reason
    /// for users to change it to a lower value.
    /// 
    /// The maximum number of DistributedVirtualPorts allowed in the switch.
    /// 
    /// If specified in a reconfigure operation, this number cannot be smaller
    /// than the number of existing DistributedVirtualPorts.
    fn get_max_ports(&self) -> Option<i32>;
    /// The uplink port policy.
    fn get_uplink_port_policy(&self) -> &Option<Box<dyn super::traits::DvsUplinkPortPolicyTrait>>;
    /// The uplink portgroups.
    /// 
    /// Refers instances of *DistributedVirtualPortgroup*.
    fn get_uplink_portgroup(&self) -> &Option<Vec<ManagedObjectReference>>;
    /// The default configuration for ports.
    fn get_default_port_config(&self) -> &Option<Box<dyn super::traits::DvPortSettingTrait>>;
    /// The host member specification.
    /// 
    /// A particular host should have only one entry
    /// in this array. Duplicate entries for the same host will raise a fault.
    /// The host version should be compatible with the version of
    /// *DistributedVirtualSwitch*. Use
    /// *DistributedVirtualSwitchManager.QueryDvsCheckCompatibility*
    /// to check for compatibility.
    fn get_host(&self) -> &Option<Vec<DistributedVirtualSwitchHostMemberConfigSpec>>;
    /// The key of the extension registered by a remote server that
    /// controls the switch.
    fn get_extension_key(&self) -> &Option<String>;
    /// Set the description string of the switch.
    fn get_description(&self) -> &Option<String>;
    /// The usage policy of the switch.
    fn get_policy(&self) -> &Option<DvsPolicy>;
    /// Set the opaque blob that stores vendor specific configuration.
    fn get_vendor_specific_config(&self) -> &Option<Vec<DistributedVirtualSwitchKeyedOpaqueBlob>>;
    /// Set the human operator contact information.
    fn get_contact(&self) -> &Option<DvsContactInfo>;
    /// IP address for the switch, specified using IPv4 dot notation.
    /// 
    /// IPv6 address is not supported for this property.
    /// The utility of this address is defined by other switch features.
    /// switchIpAddress would be ignored when IPFIX collector uses IPv6.
    fn get_switch_ip_address(&self) -> &Option<String>;
    /// The default host proxy switch maximum port number
    fn get_default_proxy_switch_max_num_ports(&self) -> Option<i32>;
    /// The host infrastructure traffic resource allocation specification.
    /// 
    /// Only the traffic class resource allocations identified in the list
    /// will be updated. The other traffic class resource allocations that are not
    /// specified will not change.
    fn get_infrastructure_traffic_resource_config(&self) -> &Option<Vec<DvsHostInfrastructureTrafficResource>>;
    /// The dynamic host infrastructure traffic resource allocation
    /// specification.
    fn get_net_resource_pool_traffic_resource_config(&self) -> &Option<Vec<DvsHostInfrastructureTrafficResource>>;
    /// Indicates the Network Resource Control APIs that are supported on the switch.
    /// 
    /// Possible value can be of
    /// *DistributedVirtualSwitchNetworkResourceControlVersion_enum*.
    fn get_network_resource_control_version(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn DvsConfigSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DvsConfigSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DvsConfigSpecVisitor)
            }
        }

struct DvsConfigSpecVisitor;

impl<'de> de::Visitor<'de> for DvsConfigSpecVisitor {
    type Value = Box<dyn DvsConfigSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DvsConfigSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DvsConfigSpecTrait for DvsConfigSpec {
    fn get_dynamic_property(&self) -> &Option<Vec<DynamicProperty>> { &self.dynamic_property }
    fn get_config_version(&self) -> &Option<String> { &self.config_version }
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_num_standalone_ports(&self) -> Option<i32> { self.num_standalone_ports }
    fn get_max_ports(&self) -> Option<i32> { self.max_ports }
    fn get_uplink_port_policy(&self) -> &Option<Box<dyn super::traits::DvsUplinkPortPolicyTrait>> { &self.uplink_port_policy }
    fn get_uplink_portgroup(&self) -> &Option<Vec<ManagedObjectReference>> { &self.uplink_portgroup }
    fn get_default_port_config(&self) -> &Option<Box<dyn super::traits::DvPortSettingTrait>> { &self.default_port_config }
    fn get_host(&self) -> &Option<Vec<DistributedVirtualSwitchHostMemberConfigSpec>> { &self.host }
    fn get_extension_key(&self) -> &Option<String> { &self.extension_key }
    fn get_description(&self) -> &Option<String> { &self.description }
    fn get_policy(&self) -> &Option<DvsPolicy> { &self.policy }
    fn get_vendor_specific_config(&self) -> &Option<Vec<DistributedVirtualSwitchKeyedOpaqueBlob>> { &self.vendor_specific_config }
    fn get_contact(&self) -> &Option<DvsContactInfo> { &self.contact }
    fn get_switch_ip_address(&self) -> &Option<String> { &self.switch_ip_address }
    fn get_default_proxy_switch_max_num_ports(&self) -> Option<i32> { self.default_proxy_switch_max_num_ports }
    fn get_infrastructure_traffic_resource_config(&self) -> &Option<Vec<DvsHostInfrastructureTrafficResource>> { &self.infrastructure_traffic_resource_config }
    fn get_net_resource_pool_traffic_resource_config(&self) -> &Option<Vec<DvsHostInfrastructureTrafficResource>> { &self.net_resource_pool_traffic_resource_config }
    fn get_network_resource_control_version(&self) -> &Option<String> { &self.network_resource_control_version }
}
impl DvsConfigSpecTrait for VMwareDvsConfigSpec {
    fn get_dynamic_property(&self) -> &Option<Vec<DynamicProperty>> { &self.dynamic_property }
    fn get_config_version(&self) -> &Option<String> { &self.config_version }
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_num_standalone_ports(&self) -> Option<i32> { self.num_standalone_ports }
    fn get_max_ports(&self) -> Option<i32> { self.max_ports }
    fn get_uplink_port_policy(&self) -> &Option<Box<dyn super::traits::DvsUplinkPortPolicyTrait>> { &self.uplink_port_policy }
    fn get_uplink_portgroup(&self) -> &Option<Vec<ManagedObjectReference>> { &self.uplink_portgroup }
    fn get_default_port_config(&self) -> &Option<Box<dyn super::traits::DvPortSettingTrait>> { &self.default_port_config }
    fn get_host(&self) -> &Option<Vec<DistributedVirtualSwitchHostMemberConfigSpec>> { &self.host }
    fn get_extension_key(&self) -> &Option<String> { &self.extension_key }
    fn get_description(&self) -> &Option<String> { &self.description }
    fn get_policy(&self) -> &Option<DvsPolicy> { &self.policy }
    fn get_vendor_specific_config(&self) -> &Option<Vec<DistributedVirtualSwitchKeyedOpaqueBlob>> { &self.vendor_specific_config }
    fn get_contact(&self) -> &Option<DvsContactInfo> { &self.contact }
    fn get_switch_ip_address(&self) -> &Option<String> { &self.switch_ip_address }
    fn get_default_proxy_switch_max_num_ports(&self) -> Option<i32> { self.default_proxy_switch_max_num_ports }
    fn get_infrastructure_traffic_resource_config(&self) -> &Option<Vec<DvsHostInfrastructureTrafficResource>> { &self.infrastructure_traffic_resource_config }
    fn get_net_resource_pool_traffic_resource_config(&self) -> &Option<Vec<DvsHostInfrastructureTrafficResource>> { &self.net_resource_pool_traffic_resource_config }
    fn get_network_resource_control_version(&self) -> &Option<String> { &self.network_resource_control_version }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DvsConfigSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsConfigSpec => Some(from.as_any_ref().downcast_ref::<DvsConfigSpec>()?),
            StructType::VMwareDvsConfigSpec => Some(from.as_any_ref().downcast_ref::<VMwareDvsConfigSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsConfigSpec => Ok(from.as_any_box().downcast::<DvsConfigSpec>()?),
            StructType::VMwareDvsConfigSpec => Ok(from.as_any_box().downcast::<VMwareDvsConfigSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *DVSFeatureCapability* data object
/// represents the capabilities supported by a
/// *DistributedVirtualSwitch*.
/// 
/// These properties are read-only with
/// the exception of
/// *DVSFeatureCapability.vmDirectPathGen2Supported*.
pub trait DvsFeatureCapabilityTrait : super::traits::DataObjectTrait {
    /// Deprecated as of vSphere API 5.0, use
    /// <code>networkResourceManagementCapability</code>.*DVSNetworkResourceManagementCapability.networkResourceManagementSupported*.
    /// 
    /// Indicates whether network I/O control is
    /// supported on the vSphere Distributed Switch.
    fn get_network_resource_management_supported(&self) -> bool;
    /// Deprecated as of vSphere API 8.0. VMDirectPath Gen 2 is no longer supported and
    /// there is no replacement.
    /// 
    /// Indicates whether VMDirectPath Gen 2 is supported on the
    /// distributed virtual switch.
    /// 
    /// See
    /// *HostCapability*.*HostCapability.vmDirectPathGen2Supported*
    /// and *PhysicalNic*.*PhysicalNic.vmDirectPathGen2Supported*.
    /// 
    /// For a third-party distributed switch implementation, you can
    /// specify this property during switch creation or when you call the
    /// *DistributedVirtualSwitch.UpdateDvsCapability* method.
    /// 
    /// VMDirectPath Gen 2 is supported in
    /// vSphere Distributed Switch Version 4.1 or later.
    fn get_vm_direct_path_gen_2_supported(&self) -> Option<bool>;
    /// The available teaming modes for the vSphere Distributed Switch.
    /// 
    /// The
    /// value can be one or more of
    /// *DistributedVirtualSwitchNicTeamingPolicyMode_enum*.
    fn get_nic_teaming_policy(&self) -> &Option<Vec<String>>;
    /// Deprecated as of vSphere API 5.0, use
    /// <code>networkResourceManagementCapability</code>.*DVSNetworkResourceManagementCapability.networkResourcePoolHighShareValue*.
    /// 
    /// This is the value for *high*
    /// in *DVSNetworkResourcePoolAllocationInfo.shares*.
    /// 
    /// This
    /// implicitly defines the legal range of share values to be between 1 and this.
    /// This also defines values for other level types, such as
    /// *normal* being one half of this value and
    /// *low* being one fourth of this value.
    fn get_network_resource_pool_high_share_value(&self) -> Option<i32>;
    /// Network resource management capabilities supported by a
    /// distributed virtual switch.
    fn get_network_resource_management_capability(&self) -> &Option<DvsNetworkResourceManagementCapability>;
    /// Health check capabilities supported by a *VmwareDistributedVirtualSwitch*.
    fn get_health_check_capability(&self) -> &Option<Box<dyn super::traits::DvsHealthCheckCapabilityTrait>>;
    /// Host rollback capability.
    /// 
    /// If <code>rollbackCapability</code>.*DVSRollbackCapability.rollbackSupported*
    /// is true, network operations that disconnect the the host are rolled back.
    fn get_rollback_capability(&self) -> &Option<DvsRollbackCapability>;
    /// Backup, restore, and rollback capabilities.
    /// 
    /// Backup and restore
    /// are supported only for *VmwareDistributedVirtualSwitch*.
    /// Rollback is supported for *VmwareDistributedVirtualSwitch*
    /// and *DistributedVirtualPortgroup*.
    /// For information about backup and restore, see the
    /// *DistributedVirtualSwitchManager* methods
    /// *DistributedVirtualSwitchManager.DVSManagerExportEntity_Task* and
    /// *DistributedVirtualSwitchManager.DVSManagerImportEntity_Task*.
    /// For information about rollback, see the
    /// *DistributedVirtualSwitch*.*DistributedVirtualSwitch.DVSRollback_Task*
    /// and *DistributedVirtualPortgroup*.*DistributedVirtualPortgroup.DVPortgroupRollback_Task*
    /// methods.
    fn get_backup_restore_capability(&self) -> &Option<DvsBackupRestoreCapability>;
    /// Indicates whether Network Filter feature is
    /// supported in vSphere Distributed Switch.
    fn get_network_filter_supported(&self) -> Option<bool>;
    /// Indicates whether MAC learning feature is
    /// supported in vSphere Distributed Switch.
    fn get_mac_learning_supported(&self) -> Option<bool>;
}
impl<'s> serde::Serialize for dyn DvsFeatureCapabilityTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DvsFeatureCapabilityTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DvsFeatureCapabilityVisitor)
            }
        }

struct DvsFeatureCapabilityVisitor;

impl<'de> de::Visitor<'de> for DvsFeatureCapabilityVisitor {
    type Value = Box<dyn DvsFeatureCapabilityTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DvsFeatureCapabilityTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DvsFeatureCapabilityTrait for DvsFeatureCapability {
    fn get_network_resource_management_supported(&self) -> bool { self.network_resource_management_supported }
    fn get_vm_direct_path_gen_2_supported(&self) -> Option<bool> { self.vm_direct_path_gen_2_supported }
    fn get_nic_teaming_policy(&self) -> &Option<Vec<String>> { &self.nic_teaming_policy }
    fn get_network_resource_pool_high_share_value(&self) -> Option<i32> { self.network_resource_pool_high_share_value }
    fn get_network_resource_management_capability(&self) -> &Option<DvsNetworkResourceManagementCapability> { &self.network_resource_management_capability }
    fn get_health_check_capability(&self) -> &Option<Box<dyn super::traits::DvsHealthCheckCapabilityTrait>> { &self.health_check_capability }
    fn get_rollback_capability(&self) -> &Option<DvsRollbackCapability> { &self.rollback_capability }
    fn get_backup_restore_capability(&self) -> &Option<DvsBackupRestoreCapability> { &self.backup_restore_capability }
    fn get_network_filter_supported(&self) -> Option<bool> { self.network_filter_supported }
    fn get_mac_learning_supported(&self) -> Option<bool> { self.mac_learning_supported }
}
impl DvsFeatureCapabilityTrait for VMwareDvsFeatureCapability {
    fn get_network_resource_management_supported(&self) -> bool { self.network_resource_management_supported }
    fn get_vm_direct_path_gen_2_supported(&self) -> Option<bool> { self.vm_direct_path_gen_2_supported }
    fn get_nic_teaming_policy(&self) -> &Option<Vec<String>> { &self.nic_teaming_policy }
    fn get_network_resource_pool_high_share_value(&self) -> Option<i32> { self.network_resource_pool_high_share_value }
    fn get_network_resource_management_capability(&self) -> &Option<DvsNetworkResourceManagementCapability> { &self.network_resource_management_capability }
    fn get_health_check_capability(&self) -> &Option<Box<dyn super::traits::DvsHealthCheckCapabilityTrait>> { &self.health_check_capability }
    fn get_rollback_capability(&self) -> &Option<DvsRollbackCapability> { &self.rollback_capability }
    fn get_backup_restore_capability(&self) -> &Option<DvsBackupRestoreCapability> { &self.backup_restore_capability }
    fn get_network_filter_supported(&self) -> Option<bool> { self.network_filter_supported }
    fn get_mac_learning_supported(&self) -> Option<bool> { self.mac_learning_supported }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DvsFeatureCapabilityTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsFeatureCapability => Some(from.as_any_ref().downcast_ref::<DvsFeatureCapability>()?),
            StructType::VMwareDvsFeatureCapability => Some(from.as_any_ref().downcast_ref::<VMwareDvsFeatureCapability>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsFeatureCapability => Ok(from.as_any_box().downcast::<DvsFeatureCapability>()?),
            StructType::VMwareDvsFeatureCapability => Ok(from.as_any_box().downcast::<VMwareDvsFeatureCapability>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *DVSHealthCheckConfig* data object
/// defines vSphere Distributed Switch health check configuration.
pub trait DvsHealthCheckConfigTrait : super::traits::DataObjectTrait {
    /// True if enable health check.
    fn get_enable(&self) -> Option<bool>;
    /// Interval of health check, in minutes.
    fn get_interval(&self) -> Option<i32>;
}
impl<'s> serde::Serialize for dyn DvsHealthCheckConfigTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DvsHealthCheckConfigTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DvsHealthCheckConfigVisitor)
            }
        }

struct DvsHealthCheckConfigVisitor;

impl<'de> de::Visitor<'de> for DvsHealthCheckConfigVisitor {
    type Value = Box<dyn DvsHealthCheckConfigTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DvsHealthCheckConfigTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DvsHealthCheckConfigTrait for DvsHealthCheckConfig {
    fn get_enable(&self) -> Option<bool> { self.enable }
    fn get_interval(&self) -> Option<i32> { self.interval }
}
impl DvsHealthCheckConfigTrait for VMwareDvsHealthCheckConfig {
    fn get_enable(&self) -> Option<bool> { self.enable }
    fn get_interval(&self) -> Option<i32> { self.interval }
}
impl DvsHealthCheckConfigTrait for VMwareDvsTeamingHealthCheckConfig {
    fn get_enable(&self) -> Option<bool> { self.enable }
    fn get_interval(&self) -> Option<i32> { self.interval }
}
impl DvsHealthCheckConfigTrait for VMwareDvsVlanMtuHealthCheckConfig {
    fn get_enable(&self) -> Option<bool> { self.enable }
    fn get_interval(&self) -> Option<i32> { self.interval }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DvsHealthCheckConfigTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsHealthCheckConfig => Some(from.as_any_ref().downcast_ref::<DvsHealthCheckConfig>()?),
            StructType::VMwareDvsHealthCheckConfig => Some(from.as_any_ref().downcast_ref::<VMwareDvsHealthCheckConfig>()?),
            StructType::VMwareDvsTeamingHealthCheckConfig => Some(from.as_any_ref().downcast_ref::<VMwareDvsTeamingHealthCheckConfig>()?),
            StructType::VMwareDvsVlanMtuHealthCheckConfig => Some(from.as_any_ref().downcast_ref::<VMwareDvsVlanMtuHealthCheckConfig>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsHealthCheckConfig => Ok(from.as_any_box().downcast::<DvsHealthCheckConfig>()?),
            StructType::VMwareDvsHealthCheckConfig => Ok(from.as_any_box().downcast::<VMwareDvsHealthCheckConfig>()?),
            StructType::VMwareDvsTeamingHealthCheckConfig => Ok(from.as_any_box().downcast::<VMwareDvsTeamingHealthCheckConfig>()?),
            StructType::VMwareDvsVlanMtuHealthCheckConfig => Ok(from.as_any_box().downcast::<VMwareDvsVlanMtuHealthCheckConfig>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This class defines health check configuration for
/// VMware vSphere Distributed Switch.
pub trait VMwareDvsHealthCheckConfigTrait : super::traits::DvsHealthCheckConfigTrait {
}
impl<'s> serde::Serialize for dyn VMwareDvsHealthCheckConfigTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VMwareDvsHealthCheckConfigTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VMwareDvsHealthCheckConfigVisitor)
            }
        }

struct VMwareDvsHealthCheckConfigVisitor;

impl<'de> de::Visitor<'de> for VMwareDvsHealthCheckConfigVisitor {
    type Value = Box<dyn VMwareDvsHealthCheckConfigTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VMwareDvsHealthCheckConfigTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VMwareDvsHealthCheckConfigTrait for VMwareDvsHealthCheckConfig {
}
impl VMwareDvsHealthCheckConfigTrait for VMwareDvsTeamingHealthCheckConfig {
}
impl VMwareDvsHealthCheckConfigTrait for VMwareDvsVlanMtuHealthCheckConfig {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VMwareDvsHealthCheckConfigTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VMwareDvsHealthCheckConfig => Some(from.as_any_ref().downcast_ref::<VMwareDvsHealthCheckConfig>()?),
            StructType::VMwareDvsTeamingHealthCheckConfig => Some(from.as_any_ref().downcast_ref::<VMwareDvsTeamingHealthCheckConfig>()?),
            StructType::VMwareDvsVlanMtuHealthCheckConfig => Some(from.as_any_ref().downcast_ref::<VMwareDvsVlanMtuHealthCheckConfig>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VMwareDvsHealthCheckConfig => Ok(from.as_any_box().downcast::<VMwareDvsHealthCheckConfig>()?),
            StructType::VMwareDvsTeamingHealthCheckConfig => Ok(from.as_any_box().downcast::<VMwareDvsTeamingHealthCheckConfig>()?),
            StructType::VMwareDvsVlanMtuHealthCheckConfig => Ok(from.as_any_box().downcast::<VMwareDvsVlanMtuHealthCheckConfig>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Health check capabilities of health check supported by the
/// vSphere Distributed Switch
pub trait DvsHealthCheckCapabilityTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn DvsHealthCheckCapabilityTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DvsHealthCheckCapabilityTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DvsHealthCheckCapabilityVisitor)
            }
        }

struct DvsHealthCheckCapabilityVisitor;

impl<'de> de::Visitor<'de> for DvsHealthCheckCapabilityVisitor {
    type Value = Box<dyn DvsHealthCheckCapabilityTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DvsHealthCheckCapabilityTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DvsHealthCheckCapabilityTrait for DvsHealthCheckCapability {
}
impl DvsHealthCheckCapabilityTrait for VMwareDvsHealthCheckCapability {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DvsHealthCheckCapabilityTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsHealthCheckCapability => Some(from.as_any_ref().downcast_ref::<DvsHealthCheckCapability>()?),
            StructType::VMwareDvsHealthCheckCapability => Some(from.as_any_ref().downcast_ref::<VMwareDvsHealthCheckCapability>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsHealthCheckCapability => Ok(from.as_any_box().downcast::<DvsHealthCheckCapability>()?),
            StructType::VMwareDvsHealthCheckCapability => Ok(from.as_any_box().downcast::<VMwareDvsHealthCheckCapability>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The base class for uplink port policy.
pub trait DvsUplinkPortPolicyTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn DvsUplinkPortPolicyTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DvsUplinkPortPolicyTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DvsUplinkPortPolicyVisitor)
            }
        }

struct DvsUplinkPortPolicyVisitor;

impl<'de> de::Visitor<'de> for DvsUplinkPortPolicyVisitor {
    type Value = Box<dyn DvsUplinkPortPolicyTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DvsUplinkPortPolicyTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DvsUplinkPortPolicyTrait for DvsUplinkPortPolicy {
}
impl DvsUplinkPortPolicyTrait for DvsNameArrayUplinkPortPolicy {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DvsUplinkPortPolicyTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsUplinkPortPolicy => Some(from.as_any_ref().downcast_ref::<DvsUplinkPortPolicy>()?),
            StructType::DvsNameArrayUplinkPortPolicy => Some(from.as_any_ref().downcast_ref::<DvsNameArrayUplinkPortPolicy>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsUplinkPortPolicy => Ok(from.as_any_box().downcast::<DvsUplinkPortPolicy>()?),
            StructType::DvsNameArrayUplinkPortPolicy => Ok(from.as_any_box().downcast::<DvsNameArrayUplinkPortPolicy>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// An ImportSpec is used when importing VMs or vApps.
/// 
/// It can be built from scratch, or it can be generated from an OVF descriptor using the
/// service interface *OvfManager*.
/// 
/// This class is the abstract base for *VirtualMachineImportSpec* and
/// *VirtualAppImportSpec*. These three classes form a composite structure
/// that allows us to contain arbitrarily complex entitites in a single ImportSpec.
pub trait ImportSpecTrait : super::traits::DataObjectTrait {
    /// Configuration of sub-entities (virtual machine or vApp).
    /// 
    /// This is used for
    /// sub-entities of a vApp that could be a virtual machine or a vApp.
    fn get_entity_config(&self) -> &Option<VAppEntityConfigInfo>;
    /// The instantiation OST (see *OvfConsumer* ) to be consumed by OVF
    /// consumers.
    fn get_instantiation_ost(&self) -> &Option<OvfConsumerOstNode>;
}
impl<'s> serde::Serialize for dyn ImportSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ImportSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ImportSpecVisitor)
            }
        }

struct ImportSpecVisitor;

impl<'de> de::Visitor<'de> for ImportSpecVisitor {
    type Value = Box<dyn ImportSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ImportSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ImportSpecTrait for ImportSpec {
    fn get_entity_config(&self) -> &Option<VAppEntityConfigInfo> { &self.entity_config }
    fn get_instantiation_ost(&self) -> &Option<OvfConsumerOstNode> { &self.instantiation_ost }
}
impl ImportSpecTrait for VirtualAppImportSpec {
    fn get_entity_config(&self) -> &Option<VAppEntityConfigInfo> { &self.entity_config }
    fn get_instantiation_ost(&self) -> &Option<OvfConsumerOstNode> { &self.instantiation_ost }
}
impl ImportSpecTrait for VirtualMachineImportSpec {
    fn get_entity_config(&self) -> &Option<VAppEntityConfigInfo> { &self.entity_config }
    fn get_instantiation_ost(&self) -> &Option<OvfConsumerOstNode> { &self.instantiation_ost }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ImportSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ImportSpec => Some(from.as_any_ref().downcast_ref::<ImportSpec>()?),
            StructType::VirtualAppImportSpec => Some(from.as_any_ref().downcast_ref::<VirtualAppImportSpec>()?),
            StructType::VirtualMachineImportSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineImportSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ImportSpec => Ok(from.as_any_box().downcast::<ImportSpec>()?),
            StructType::VirtualAppImportSpec => Ok(from.as_any_box().downcast::<VirtualAppImportSpec>()?),
            StructType::VirtualMachineImportSpec => Ok(from.as_any_box().downcast::<VirtualMachineImportSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The base class for any type of setting or configuration that may get a
/// inherited value.
/// 
/// When used in a reconfigure operation specification, if *InheritablePolicy.inherited* is true,
/// it specifies the intention to change the values of subclass's properties to the
/// inherited values from the level above. In this case, users don't need to specify
/// the values and any set property in the subclass will be ignored.
/// if *InheritablePolicy.inherited* is false, it specifies the intention to explicitly set
/// subclass's properties to user specified values. Users should set the properties in
/// the subclass with the desired values.
/// 
/// When used in a configuration information object, The values of the properties in
/// the subclass are the effective values. if *InheritablePolicy.inherited* is true, the object
/// is getting the effective values from upper level. If false, the values are
/// explicitly set by a user.
pub trait InheritablePolicyTrait : super::traits::DataObjectTrait {
    /// Whether the configuration is set to inherited value.
    fn get_inherited(&self) -> bool;
}
impl<'s> serde::Serialize for dyn InheritablePolicyTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn InheritablePolicyTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(InheritablePolicyVisitor)
            }
        }

struct InheritablePolicyVisitor;

impl<'de> de::Visitor<'de> for InheritablePolicyVisitor {
    type Value = Box<dyn InheritablePolicyTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid InheritablePolicyTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl InheritablePolicyTrait for InheritablePolicy {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for BoolPolicy {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for IntPolicy {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for LongPolicy {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for StringPolicy {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for DvsFilterConfig {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for DvsFilterConfigSpec {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for DvsTrafficFilterConfig {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for DvsTrafficFilterConfigSpec {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for DvsFilterPolicy {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for DvsTrafficShapingPolicy {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for DvsVendorSpecificConfig {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for DvsFailureCriteria {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for DvsMacLearningPolicy {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for DvsMacManagementPolicy {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for DvsSecurityPolicy {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for VMwareUplinkLacpPolicy {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for VMwareUplinkPortOrderPolicy {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for VmwareUplinkPortTeamingPolicy {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for VmwareDistributedVirtualSwitchVlanSpec {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for VmwareDistributedVirtualSwitchPvlanSpec {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for VmwareDistributedVirtualSwitchTrunkVlanSpec {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for VmwareDistributedVirtualSwitchVlanIdSpec {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn InheritablePolicyTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::InheritablePolicy => Some(from.as_any_ref().downcast_ref::<InheritablePolicy>()?),
            StructType::BoolPolicy => Some(from.as_any_ref().downcast_ref::<BoolPolicy>()?),
            StructType::IntPolicy => Some(from.as_any_ref().downcast_ref::<IntPolicy>()?),
            StructType::LongPolicy => Some(from.as_any_ref().downcast_ref::<LongPolicy>()?),
            StructType::StringPolicy => Some(from.as_any_ref().downcast_ref::<StringPolicy>()?),
            StructType::DvsFilterConfig => Some(from.as_any_ref().downcast_ref::<DvsFilterConfig>()?),
            StructType::DvsFilterConfigSpec => Some(from.as_any_ref().downcast_ref::<DvsFilterConfigSpec>()?),
            StructType::DvsTrafficFilterConfig => Some(from.as_any_ref().downcast_ref::<DvsTrafficFilterConfig>()?),
            StructType::DvsTrafficFilterConfigSpec => Some(from.as_any_ref().downcast_ref::<DvsTrafficFilterConfigSpec>()?),
            StructType::DvsFilterPolicy => Some(from.as_any_ref().downcast_ref::<DvsFilterPolicy>()?),
            StructType::DvsTrafficShapingPolicy => Some(from.as_any_ref().downcast_ref::<DvsTrafficShapingPolicy>()?),
            StructType::DvsVendorSpecificConfig => Some(from.as_any_ref().downcast_ref::<DvsVendorSpecificConfig>()?),
            StructType::DvsFailureCriteria => Some(from.as_any_ref().downcast_ref::<DvsFailureCriteria>()?),
            StructType::DvsMacLearningPolicy => Some(from.as_any_ref().downcast_ref::<DvsMacLearningPolicy>()?),
            StructType::DvsMacManagementPolicy => Some(from.as_any_ref().downcast_ref::<DvsMacManagementPolicy>()?),
            StructType::DvsSecurityPolicy => Some(from.as_any_ref().downcast_ref::<DvsSecurityPolicy>()?),
            StructType::VMwareUplinkLacpPolicy => Some(from.as_any_ref().downcast_ref::<VMwareUplinkLacpPolicy>()?),
            StructType::VMwareUplinkPortOrderPolicy => Some(from.as_any_ref().downcast_ref::<VMwareUplinkPortOrderPolicy>()?),
            StructType::VmwareUplinkPortTeamingPolicy => Some(from.as_any_ref().downcast_ref::<VmwareUplinkPortTeamingPolicy>()?),
            StructType::VmwareDistributedVirtualSwitchVlanSpec => Some(from.as_any_ref().downcast_ref::<VmwareDistributedVirtualSwitchVlanSpec>()?),
            StructType::VmwareDistributedVirtualSwitchPvlanSpec => Some(from.as_any_ref().downcast_ref::<VmwareDistributedVirtualSwitchPvlanSpec>()?),
            StructType::VmwareDistributedVirtualSwitchTrunkVlanSpec => Some(from.as_any_ref().downcast_ref::<VmwareDistributedVirtualSwitchTrunkVlanSpec>()?),
            StructType::VmwareDistributedVirtualSwitchVlanIdSpec => Some(from.as_any_ref().downcast_ref::<VmwareDistributedVirtualSwitchVlanIdSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::InheritablePolicy => Ok(from.as_any_box().downcast::<InheritablePolicy>()?),
            StructType::BoolPolicy => Ok(from.as_any_box().downcast::<BoolPolicy>()?),
            StructType::IntPolicy => Ok(from.as_any_box().downcast::<IntPolicy>()?),
            StructType::LongPolicy => Ok(from.as_any_box().downcast::<LongPolicy>()?),
            StructType::StringPolicy => Ok(from.as_any_box().downcast::<StringPolicy>()?),
            StructType::DvsFilterConfig => Ok(from.as_any_box().downcast::<DvsFilterConfig>()?),
            StructType::DvsFilterConfigSpec => Ok(from.as_any_box().downcast::<DvsFilterConfigSpec>()?),
            StructType::DvsTrafficFilterConfig => Ok(from.as_any_box().downcast::<DvsTrafficFilterConfig>()?),
            StructType::DvsTrafficFilterConfigSpec => Ok(from.as_any_box().downcast::<DvsTrafficFilterConfigSpec>()?),
            StructType::DvsFilterPolicy => Ok(from.as_any_box().downcast::<DvsFilterPolicy>()?),
            StructType::DvsTrafficShapingPolicy => Ok(from.as_any_box().downcast::<DvsTrafficShapingPolicy>()?),
            StructType::DvsVendorSpecificConfig => Ok(from.as_any_box().downcast::<DvsVendorSpecificConfig>()?),
            StructType::DvsFailureCriteria => Ok(from.as_any_box().downcast::<DvsFailureCriteria>()?),
            StructType::DvsMacLearningPolicy => Ok(from.as_any_box().downcast::<DvsMacLearningPolicy>()?),
            StructType::DvsMacManagementPolicy => Ok(from.as_any_box().downcast::<DvsMacManagementPolicy>()?),
            StructType::DvsSecurityPolicy => Ok(from.as_any_box().downcast::<DvsSecurityPolicy>()?),
            StructType::VMwareUplinkLacpPolicy => Ok(from.as_any_box().downcast::<VMwareUplinkLacpPolicy>()?),
            StructType::VMwareUplinkPortOrderPolicy => Ok(from.as_any_box().downcast::<VMwareUplinkPortOrderPolicy>()?),
            StructType::VmwareUplinkPortTeamingPolicy => Ok(from.as_any_box().downcast::<VmwareUplinkPortTeamingPolicy>()?),
            StructType::VmwareDistributedVirtualSwitchVlanSpec => Ok(from.as_any_box().downcast::<VmwareDistributedVirtualSwitchVlanSpec>()?),
            StructType::VmwareDistributedVirtualSwitchPvlanSpec => Ok(from.as_any_box().downcast::<VmwareDistributedVirtualSwitchPvlanSpec>()?),
            StructType::VmwareDistributedVirtualSwitchTrunkVlanSpec => Ok(from.as_any_box().downcast::<VmwareDistributedVirtualSwitchTrunkVlanSpec>()?),
            StructType::VmwareDistributedVirtualSwitchVlanIdSpec => Ok(from.as_any_box().downcast::<VmwareDistributedVirtualSwitchVlanIdSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This class defines Network Filter configuration.
/// 
/// ** Supported Qualifier and Actions **
/// <table border="1"width="100%">
/// <tr>
/// <th>Network Filter Config</th>
/// <th>Supported classes</th>
/// </tr>
/// <tr>
/// <td>Qualifiers supported</td>
/// <td>*SingleIp*, *IpRange*,
/// *SingleMac*, *MacRange*,
/// *DvsSingleIpPort*,
/// *DvsSystemTrafficNetworkRuleQualifier*
/// </td>
/// </tr>
/// <tr>
/// <td>Actions Supported</td>
/// <td>*DvsDropNetworkRuleAction*,
/// *DvsAcceptNetworkRuleAction*,
/// *DvsPuntNetworkRuleAction*,
/// *DvsCopyNetworkRuleAction*,
/// *DvsMacRewriteNetworkRuleAction*,
/// *DvsGreEncapNetworkRuleAction*,
/// *DvsLogNetworkRuleAction*,
/// *DvsUpdateTagNetworkRuleAction*,
/// *DvsRateLimitNetworkRuleAction*
/// </td>
/// </tr>
pub trait DvsFilterConfigTrait : super::traits::InheritablePolicyTrait {
    /// The key of Network Filter Config.
    fn get_key(&self) -> &Option<String>;
    /// The name of the network traffic filter agent.
    fn get_agent_name(&self) -> &Option<String>;
    /// The slot number of the network filter agent.
    fn get_slot_number(&self) -> &Option<String>;
    /// Network Filter Parameter
    fn get_parameters(&self) -> &Option<DvsFilterParameter>;
    /// This property specifies whether to allow all traffic or to deny all
    /// traffic when a Network Filter fails to configure.
    /// 
    /// Please see *DvsFilterOnFailure_enum*
    /// for more details.
    fn get_on_failure(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn DvsFilterConfigTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DvsFilterConfigTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DvsFilterConfigVisitor)
            }
        }

struct DvsFilterConfigVisitor;

impl<'de> de::Visitor<'de> for DvsFilterConfigVisitor {
    type Value = Box<dyn DvsFilterConfigTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DvsFilterConfigTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DvsFilterConfigTrait for DvsFilterConfig {
    fn get_key(&self) -> &Option<String> { &self.key }
    fn get_agent_name(&self) -> &Option<String> { &self.agent_name }
    fn get_slot_number(&self) -> &Option<String> { &self.slot_number }
    fn get_parameters(&self) -> &Option<DvsFilterParameter> { &self.parameters }
    fn get_on_failure(&self) -> &Option<String> { &self.on_failure }
}
impl DvsFilterConfigTrait for DvsFilterConfigSpec {
    fn get_key(&self) -> &Option<String> { &self.key }
    fn get_agent_name(&self) -> &Option<String> { &self.agent_name }
    fn get_slot_number(&self) -> &Option<String> { &self.slot_number }
    fn get_parameters(&self) -> &Option<DvsFilterParameter> { &self.parameters }
    fn get_on_failure(&self) -> &Option<String> { &self.on_failure }
}
impl DvsFilterConfigTrait for DvsTrafficFilterConfig {
    fn get_key(&self) -> &Option<String> { &self.key }
    fn get_agent_name(&self) -> &Option<String> { &self.agent_name }
    fn get_slot_number(&self) -> &Option<String> { &self.slot_number }
    fn get_parameters(&self) -> &Option<DvsFilterParameter> { &self.parameters }
    fn get_on_failure(&self) -> &Option<String> { &self.on_failure }
}
impl DvsFilterConfigTrait for DvsTrafficFilterConfigSpec {
    fn get_key(&self) -> &Option<String> { &self.key }
    fn get_agent_name(&self) -> &Option<String> { &self.agent_name }
    fn get_slot_number(&self) -> &Option<String> { &self.slot_number }
    fn get_parameters(&self) -> &Option<DvsFilterParameter> { &self.parameters }
    fn get_on_failure(&self) -> &Option<String> { &self.on_failure }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DvsFilterConfigTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsFilterConfig => Some(from.as_any_ref().downcast_ref::<DvsFilterConfig>()?),
            StructType::DvsFilterConfigSpec => Some(from.as_any_ref().downcast_ref::<DvsFilterConfigSpec>()?),
            StructType::DvsTrafficFilterConfig => Some(from.as_any_ref().downcast_ref::<DvsTrafficFilterConfig>()?),
            StructType::DvsTrafficFilterConfigSpec => Some(from.as_any_ref().downcast_ref::<DvsTrafficFilterConfigSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsFilterConfig => Ok(from.as_any_box().downcast::<DvsFilterConfig>()?),
            StructType::DvsFilterConfigSpec => Ok(from.as_any_box().downcast::<DvsFilterConfigSpec>()?),
            StructType::DvsTrafficFilterConfig => Ok(from.as_any_box().downcast::<DvsTrafficFilterConfig>()?),
            StructType::DvsTrafficFilterConfigSpec => Ok(from.as_any_box().downcast::<DvsTrafficFilterConfigSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This class defines Traffic Filter configuration.
/// 
/// ** Supported Qualifier and Actions **
/// <table border="1"width="100%">
/// <tr>
/// <th>Traffic Filter Config</th>
/// <th>Supported classes</th>
/// </tr>
/// <tr>
/// <td>Qualifiers supported</td>
/// <td>*SingleIp*, *IpRange*,
/// *SingleMac*, *MacRange*,
/// *DvsSingleIpPort*,
/// *DvsSystemTrafficNetworkRuleQualifier*
/// </td>
/// </tr>
/// <tr>
/// <td>Actions Supported</td>
/// <td>*DvsDropNetworkRuleAction*,
/// *DvsAcceptNetworkRuleAction*,
/// *DvsPuntNetworkRuleAction*,
/// *DvsCopyNetworkRuleAction*,
/// *DvsMacRewriteNetworkRuleAction*,
/// *DvsGreEncapNetworkRuleAction*,
/// *DvsLogNetworkRuleAction*,
/// *DvsUpdateTagNetworkRuleAction*,
/// *DvsRateLimitNetworkRuleAction*
/// </td>
/// </tr>
pub trait DvsTrafficFilterConfigTrait : super::traits::DvsFilterConfigTrait {
    /// Network Traffic Ruleset
    fn get_traffic_ruleset(&self) -> &Option<DvsTrafficRuleset>;
}
impl<'s> serde::Serialize for dyn DvsTrafficFilterConfigTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DvsTrafficFilterConfigTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DvsTrafficFilterConfigVisitor)
            }
        }

struct DvsTrafficFilterConfigVisitor;

impl<'de> de::Visitor<'de> for DvsTrafficFilterConfigVisitor {
    type Value = Box<dyn DvsTrafficFilterConfigTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DvsTrafficFilterConfigTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DvsTrafficFilterConfigTrait for DvsTrafficFilterConfig {
    fn get_traffic_ruleset(&self) -> &Option<DvsTrafficRuleset> { &self.traffic_ruleset }
}
impl DvsTrafficFilterConfigTrait for DvsTrafficFilterConfigSpec {
    fn get_traffic_ruleset(&self) -> &Option<DvsTrafficRuleset> { &self.traffic_ruleset }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DvsTrafficFilterConfigTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsTrafficFilterConfig => Some(from.as_any_ref().downcast_ref::<DvsTrafficFilterConfig>()?),
            StructType::DvsTrafficFilterConfigSpec => Some(from.as_any_ref().downcast_ref::<DvsTrafficFilterConfigSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsTrafficFilterConfig => Ok(from.as_any_box().downcast::<DvsTrafficFilterConfig>()?),
            StructType::DvsTrafficFilterConfigSpec => Ok(from.as_any_box().downcast::<DvsTrafficFilterConfigSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class for Vlan Specifiation for ports.
pub trait VmwareDistributedVirtualSwitchVlanSpecTrait : super::traits::InheritablePolicyTrait {
}
impl<'s> serde::Serialize for dyn VmwareDistributedVirtualSwitchVlanSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VmwareDistributedVirtualSwitchVlanSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VmwareDistributedVirtualSwitchVlanSpecVisitor)
            }
        }

struct VmwareDistributedVirtualSwitchVlanSpecVisitor;

impl<'de> de::Visitor<'de> for VmwareDistributedVirtualSwitchVlanSpecVisitor {
    type Value = Box<dyn VmwareDistributedVirtualSwitchVlanSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VmwareDistributedVirtualSwitchVlanSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VmwareDistributedVirtualSwitchVlanSpecTrait for VmwareDistributedVirtualSwitchVlanSpec {
}
impl VmwareDistributedVirtualSwitchVlanSpecTrait for VmwareDistributedVirtualSwitchPvlanSpec {
}
impl VmwareDistributedVirtualSwitchVlanSpecTrait for VmwareDistributedVirtualSwitchTrunkVlanSpec {
}
impl VmwareDistributedVirtualSwitchVlanSpecTrait for VmwareDistributedVirtualSwitchVlanIdSpec {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VmwareDistributedVirtualSwitchVlanSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmwareDistributedVirtualSwitchVlanSpec => Some(from.as_any_ref().downcast_ref::<VmwareDistributedVirtualSwitchVlanSpec>()?),
            StructType::VmwareDistributedVirtualSwitchPvlanSpec => Some(from.as_any_ref().downcast_ref::<VmwareDistributedVirtualSwitchPvlanSpec>()?),
            StructType::VmwareDistributedVirtualSwitchTrunkVlanSpec => Some(from.as_any_ref().downcast_ref::<VmwareDistributedVirtualSwitchTrunkVlanSpec>()?),
            StructType::VmwareDistributedVirtualSwitchVlanIdSpec => Some(from.as_any_ref().downcast_ref::<VmwareDistributedVirtualSwitchVlanIdSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmwareDistributedVirtualSwitchVlanSpec => Ok(from.as_any_box().downcast::<VmwareDistributedVirtualSwitchVlanSpec>()?),
            StructType::VmwareDistributedVirtualSwitchPvlanSpec => Ok(from.as_any_box().downcast::<VmwareDistributedVirtualSwitchPvlanSpec>()?),
            StructType::VmwareDistributedVirtualSwitchTrunkVlanSpec => Ok(from.as_any_box().downcast::<VmwareDistributedVirtualSwitchTrunkVlanSpec>()?),
            StructType::VmwareDistributedVirtualSwitchVlanIdSpec => Ok(from.as_any_box().downcast::<VmwareDistributedVirtualSwitchVlanIdSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Information about an IO Filter.
pub trait IoFilterInfoTrait : super::traits::DataObjectTrait {
    /// IO Filter identifier.
    fn get_id(&self) -> &str;
    /// Name of the IO Filter.
    fn get_name(&self) -> &str;
    /// Vendor of the IO Filter.
    fn get_vendor(&self) -> &str;
    /// Version of the IO Filter.
    fn get_version(&self) -> &str;
    /// Type of the IO Filter.
    /// 
    /// The set of possible values are listed in
    /// *IoFilterType_enum*.
    /// The property is unset if the information is not available.
    fn get_type(&self) -> &Option<String>;
    /// Short description of the IO Filter.
    /// 
    /// The property is unset if the information is not available.
    fn get_summary(&self) -> &Option<String>;
    /// Release date of the IO Filter.
    /// 
    /// The property is unset if the information is not available.
    fn get_release_date(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn IoFilterInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn IoFilterInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(IoFilterInfoVisitor)
            }
        }

struct IoFilterInfoVisitor;

impl<'de> de::Visitor<'de> for IoFilterInfoVisitor {
    type Value = Box<dyn IoFilterInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid IoFilterInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl IoFilterInfoTrait for IoFilterInfo {
    fn get_id(&self) -> &str { &self.id }
    fn get_name(&self) -> &str { &self.name }
    fn get_vendor(&self) -> &str { &self.vendor }
    fn get_version(&self) -> &str { &self.version }
    fn get_type(&self) -> &Option<String> { &self.r#type }
    fn get_summary(&self) -> &Option<String> { &self.summary }
    fn get_release_date(&self) -> &Option<String> { &self.release_date }
}
impl IoFilterInfoTrait for ClusterIoFilterInfo {
    fn get_id(&self) -> &str { &self.id }
    fn get_name(&self) -> &str { &self.name }
    fn get_vendor(&self) -> &str { &self.vendor }
    fn get_version(&self) -> &str { &self.version }
    fn get_type(&self) -> &Option<String> { &self.r#type }
    fn get_summary(&self) -> &Option<String> { &self.summary }
    fn get_release_date(&self) -> &Option<String> { &self.release_date }
}
impl IoFilterInfoTrait for HostIoFilterInfo {
    fn get_id(&self) -> &str { &self.id }
    fn get_name(&self) -> &str { &self.name }
    fn get_vendor(&self) -> &str { &self.vendor }
    fn get_version(&self) -> &str { &self.version }
    fn get_type(&self) -> &Option<String> { &self.r#type }
    fn get_summary(&self) -> &Option<String> { &self.summary }
    fn get_release_date(&self) -> &Option<String> { &self.release_date }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn IoFilterInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::IoFilterInfo => Some(from.as_any_ref().downcast_ref::<IoFilterInfo>()?),
            StructType::ClusterIoFilterInfo => Some(from.as_any_ref().downcast_ref::<ClusterIoFilterInfo>()?),
            StructType::HostIoFilterInfo => Some(from.as_any_ref().downcast_ref::<HostIoFilterInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::IoFilterInfo => Ok(from.as_any_box().downcast::<IoFilterInfo>()?),
            StructType::ClusterIoFilterInfo => Ok(from.as_any_box().downcast::<ClusterIoFilterInfo>()?),
            StructType::HostIoFilterInfo => Ok(from.as_any_box().downcast::<HostIoFilterInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Deprecated as of vSphere API 4.0, this is not used by the system.
/// 
/// This data object type is used to communicate configuration about
/// where to find licenses to use for this system.
pub trait LicenseSourceTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn LicenseSourceTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn LicenseSourceTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(LicenseSourceVisitor)
            }
        }

struct LicenseSourceVisitor;

impl<'de> de::Visitor<'de> for LicenseSourceVisitor {
    type Value = Box<dyn LicenseSourceTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid LicenseSourceTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl LicenseSourceTrait for LicenseSource {
}
impl LicenseSourceTrait for EvaluationLicenseSource {
}
impl LicenseSourceTrait for LicenseServerSource {
}
impl LicenseSourceTrait for LocalLicenseSource {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn LicenseSourceTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::LicenseSource => Some(from.as_any_ref().downcast_ref::<LicenseSource>()?),
            StructType::EvaluationLicenseSource => Some(from.as_any_ref().downcast_ref::<EvaluationLicenseSource>()?),
            StructType::LicenseServerSource => Some(from.as_any_ref().downcast_ref::<LicenseServerSource>()?),
            StructType::LocalLicenseSource => Some(from.as_any_ref().downcast_ref::<LocalLicenseSource>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::LicenseSource => Ok(from.as_any_box().downcast::<LicenseSource>()?),
            StructType::EvaluationLicenseSource => Ok(from.as_any_box().downcast::<EvaluationLicenseSource>()?),
            StructType::LicenseServerSource => Ok(from.as_any_box().downcast::<LicenseServerSource>()?),
            StructType::LocalLicenseSource => Ok(from.as_any_box().downcast::<LocalLicenseSource>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The base class for any type of setting or configuration to which negation
/// can be applied.
/// 
/// When used in a configuration information object:
/// if *NegatableExpression.negate* is true, then ~(objectValue) will be used for the
/// configuration. If false, then objectValue will be used as it is.
pub trait NegatableExpressionTrait : super::traits::DataObjectTrait {
    /// Whether the configuration needs to be negated or not.
    fn get_negate(&self) -> Option<bool>;
}
impl<'s> serde::Serialize for dyn NegatableExpressionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn NegatableExpressionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(NegatableExpressionVisitor)
            }
        }

struct NegatableExpressionVisitor;

impl<'de> de::Visitor<'de> for NegatableExpressionVisitor {
    type Value = Box<dyn NegatableExpressionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid NegatableExpressionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl NegatableExpressionTrait for NegatableExpression {
    fn get_negate(&self) -> Option<bool> { self.negate }
}
impl NegatableExpressionTrait for IntExpression {
    fn get_negate(&self) -> Option<bool> { self.negate }
}
impl NegatableExpressionTrait for IpAddress {
    fn get_negate(&self) -> Option<bool> { self.negate }
}
impl NegatableExpressionTrait for IpRange {
    fn get_negate(&self) -> Option<bool> { self.negate }
}
impl NegatableExpressionTrait for SingleIp {
    fn get_negate(&self) -> Option<bool> { self.negate }
}
impl NegatableExpressionTrait for MacAddress {
    fn get_negate(&self) -> Option<bool> { self.negate }
}
impl NegatableExpressionTrait for MacRange {
    fn get_negate(&self) -> Option<bool> { self.negate }
}
impl NegatableExpressionTrait for SingleMac {
    fn get_negate(&self) -> Option<bool> { self.negate }
}
impl NegatableExpressionTrait for StringExpression {
    fn get_negate(&self) -> Option<bool> { self.negate }
}
impl NegatableExpressionTrait for DvsIpPort {
    fn get_negate(&self) -> Option<bool> { self.negate }
}
impl NegatableExpressionTrait for DvsIpPortRange {
    fn get_negate(&self) -> Option<bool> { self.negate }
}
impl NegatableExpressionTrait for DvsSingleIpPort {
    fn get_negate(&self) -> Option<bool> { self.negate }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn NegatableExpressionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::NegatableExpression => Some(from.as_any_ref().downcast_ref::<NegatableExpression>()?),
            StructType::IntExpression => Some(from.as_any_ref().downcast_ref::<IntExpression>()?),
            StructType::IpAddress => Some(from.as_any_ref().downcast_ref::<IpAddress>()?),
            StructType::IpRange => Some(from.as_any_ref().downcast_ref::<IpRange>()?),
            StructType::SingleIp => Some(from.as_any_ref().downcast_ref::<SingleIp>()?),
            StructType::MacAddress => Some(from.as_any_ref().downcast_ref::<MacAddress>()?),
            StructType::MacRange => Some(from.as_any_ref().downcast_ref::<MacRange>()?),
            StructType::SingleMac => Some(from.as_any_ref().downcast_ref::<SingleMac>()?),
            StructType::StringExpression => Some(from.as_any_ref().downcast_ref::<StringExpression>()?),
            StructType::DvsIpPort => Some(from.as_any_ref().downcast_ref::<DvsIpPort>()?),
            StructType::DvsIpPortRange => Some(from.as_any_ref().downcast_ref::<DvsIpPortRange>()?),
            StructType::DvsSingleIpPort => Some(from.as_any_ref().downcast_ref::<DvsSingleIpPort>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::NegatableExpression => Ok(from.as_any_box().downcast::<NegatableExpression>()?),
            StructType::IntExpression => Ok(from.as_any_box().downcast::<IntExpression>()?),
            StructType::IpAddress => Ok(from.as_any_box().downcast::<IpAddress>()?),
            StructType::IpRange => Ok(from.as_any_box().downcast::<IpRange>()?),
            StructType::SingleIp => Ok(from.as_any_box().downcast::<SingleIp>()?),
            StructType::MacAddress => Ok(from.as_any_box().downcast::<MacAddress>()?),
            StructType::MacRange => Ok(from.as_any_box().downcast::<MacRange>()?),
            StructType::SingleMac => Ok(from.as_any_box().downcast::<SingleMac>()?),
            StructType::StringExpression => Ok(from.as_any_box().downcast::<StringExpression>()?),
            StructType::DvsIpPort => Ok(from.as_any_box().downcast::<DvsIpPort>()?),
            StructType::DvsIpPortRange => Ok(from.as_any_box().downcast::<DvsIpPortRange>()?),
            StructType::DvsSingleIpPort => Ok(from.as_any_box().downcast::<DvsSingleIpPort>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This is the abstract base class for IP address.
pub trait IpAddressTrait : super::traits::NegatableExpressionTrait {
}
impl<'s> serde::Serialize for dyn IpAddressTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn IpAddressTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(IpAddressVisitor)
            }
        }

struct IpAddressVisitor;

impl<'de> de::Visitor<'de> for IpAddressVisitor {
    type Value = Box<dyn IpAddressTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid IpAddressTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl IpAddressTrait for IpAddress {
}
impl IpAddressTrait for IpRange {
}
impl IpAddressTrait for SingleIp {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn IpAddressTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::IpAddress => Some(from.as_any_ref().downcast_ref::<IpAddress>()?),
            StructType::IpRange => Some(from.as_any_ref().downcast_ref::<IpRange>()?),
            StructType::SingleIp => Some(from.as_any_ref().downcast_ref::<SingleIp>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::IpAddress => Ok(from.as_any_box().downcast::<IpAddress>()?),
            StructType::IpRange => Ok(from.as_any_box().downcast::<IpRange>()?),
            StructType::SingleIp => Ok(from.as_any_box().downcast::<SingleIp>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class for specifying MAC addresses.
pub trait MacAddressTrait : super::traits::NegatableExpressionTrait {
}
impl<'s> serde::Serialize for dyn MacAddressTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn MacAddressTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(MacAddressVisitor)
            }
        }

struct MacAddressVisitor;

impl<'de> de::Visitor<'de> for MacAddressVisitor {
    type Value = Box<dyn MacAddressTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid MacAddressTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl MacAddressTrait for MacAddress {
}
impl MacAddressTrait for MacRange {
}
impl MacAddressTrait for SingleMac {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn MacAddressTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::MacAddress => Some(from.as_any_ref().downcast_ref::<MacAddress>()?),
            StructType::MacRange => Some(from.as_any_ref().downcast_ref::<MacRange>()?),
            StructType::SingleMac => Some(from.as_any_ref().downcast_ref::<SingleMac>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::MacAddress => Ok(from.as_any_box().downcast::<MacAddress>()?),
            StructType::MacRange => Ok(from.as_any_box().downcast::<MacRange>()?),
            StructType::SingleMac => Ok(from.as_any_box().downcast::<SingleMac>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class for specifying Ports.
/// 
/// Objects of the base class represent any port (single/range/list).
pub trait DvsIpPortTrait : super::traits::NegatableExpressionTrait {
}
impl<'s> serde::Serialize for dyn DvsIpPortTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DvsIpPortTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DvsIpPortVisitor)
            }
        }

struct DvsIpPortVisitor;

impl<'de> de::Visitor<'de> for DvsIpPortVisitor {
    type Value = Box<dyn DvsIpPortTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DvsIpPortTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DvsIpPortTrait for DvsIpPort {
}
impl DvsIpPortTrait for DvsIpPortRange {
}
impl DvsIpPortTrait for DvsSingleIpPort {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DvsIpPortTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsIpPort => Some(from.as_any_ref().downcast_ref::<DvsIpPort>()?),
            StructType::DvsIpPortRange => Some(from.as_any_ref().downcast_ref::<DvsIpPortRange>()?),
            StructType::DvsSingleIpPort => Some(from.as_any_ref().downcast_ref::<DvsSingleIpPort>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsIpPort => Ok(from.as_any_box().downcast::<DvsIpPort>()?),
            StructType::DvsIpPortRange => Ok(from.as_any_box().downcast::<DvsIpPortRange>()?),
            StructType::DvsSingleIpPort => Ok(from.as_any_box().downcast::<DvsSingleIpPort>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// General information about a network.
pub trait NetworkSummaryTrait : super::traits::DataObjectTrait {
    /// Reference to the associated managed object.
    /// 
    /// Refers instance of *Network*.
    fn get_network(&self) -> &Option<ManagedObjectReference>;
    /// Name of the network.
    fn get_name(&self) -> &str;
    /// At least one host is configured to provide this network.
    fn get_accessible(&self) -> bool;
    /// Name of the associated IP pool.
    /// 
    /// Empty if the network is not associated with an
    /// IP pool.
    fn get_ip_pool_name(&self) -> &str;
    /// Identifier of the associated IP pool.
    /// 
    /// Zero if the network is not associated
    /// with an IP pool.
    fn get_ip_pool_id(&self) -> Option<i32>;
}
impl<'s> serde::Serialize for dyn NetworkSummaryTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn NetworkSummaryTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(NetworkSummaryVisitor)
            }
        }

struct NetworkSummaryVisitor;

impl<'de> de::Visitor<'de> for NetworkSummaryVisitor {
    type Value = Box<dyn NetworkSummaryTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid NetworkSummaryTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl NetworkSummaryTrait for NetworkSummary {
    fn get_network(&self) -> &Option<ManagedObjectReference> { &self.network }
    fn get_name(&self) -> &str { &self.name }
    fn get_accessible(&self) -> bool { self.accessible }
    fn get_ip_pool_name(&self) -> &str { &self.ip_pool_name }
    fn get_ip_pool_id(&self) -> Option<i32> { self.ip_pool_id }
}
impl NetworkSummaryTrait for OpaqueNetworkSummary {
    fn get_network(&self) -> &Option<ManagedObjectReference> { &self.network }
    fn get_name(&self) -> &str { &self.name }
    fn get_accessible(&self) -> bool { self.accessible }
    fn get_ip_pool_name(&self) -> &str { &self.ip_pool_name }
    fn get_ip_pool_id(&self) -> Option<i32> { self.ip_pool_id }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn NetworkSummaryTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::NetworkSummary => Some(from.as_any_ref().downcast_ref::<NetworkSummary>()?),
            StructType::OpaqueNetworkSummary => Some(from.as_any_ref().downcast_ref::<OpaqueNetworkSummary>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::NetworkSummary => Ok(from.as_any_box().downcast::<NetworkSummary>()?),
            StructType::OpaqueNetworkSummary => Ok(from.as_any_box().downcast::<OpaqueNetworkSummary>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// A common super-class for basic OVF descriptor parameters
pub trait OvfManagerCommonParamsTrait : super::traits::DataObjectTrait {
    /// The locale-identifier to choose from the descriptor.
    /// 
    /// If empty, the
    /// default locale on the server is used.
    fn get_locale(&self) -> &str;
    /// The key of the chosen deployment option.
    /// 
    /// If empty, the default option is
    /// chosen. The list of possible deployment options is returned in the result of
    /// parseDescriptor.
    fn get_deployment_option(&self) -> &str;
    /// An optional set of localization strings to be used.
    /// 
    /// The server will use
    /// these message strings to localize information in the result and in
    /// error and warning messages.
    /// 
    /// This argument allows a client to pass messages from external
    /// string bundles. The client is responsible for selecting the right string
    /// bundle (based on locale) and parsing the external string bundle. The
    /// passed in key/value pairs are looked up before any messages
    /// included in the OVF descriptor itself.
    fn get_msg_bundle(&self) -> &Option<Vec<KeyValue>>;
    /// An optional argument for modifing the OVF parsing.
    /// 
    /// When the server parses an OVF
    /// descriptor a set of options can be used to modify the parsing. The argument is a list
    /// of keywords.
    /// 
    /// To get a list of supported keywords see *OvfManager.ovfImportOption*. Unknown
    /// options will be ignored by the server.
    fn get_import_option(&self) -> &Option<Vec<String>>;
}
impl<'s> serde::Serialize for dyn OvfManagerCommonParamsTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn OvfManagerCommonParamsTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(OvfManagerCommonParamsVisitor)
            }
        }

struct OvfManagerCommonParamsVisitor;

impl<'de> de::Visitor<'de> for OvfManagerCommonParamsVisitor {
    type Value = Box<dyn OvfManagerCommonParamsTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid OvfManagerCommonParamsTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl OvfManagerCommonParamsTrait for OvfManagerCommonParams {
    fn get_locale(&self) -> &str { &self.locale }
    fn get_deployment_option(&self) -> &str { &self.deployment_option }
    fn get_msg_bundle(&self) -> &Option<Vec<KeyValue>> { &self.msg_bundle }
    fn get_import_option(&self) -> &Option<Vec<String>> { &self.import_option }
}
impl OvfManagerCommonParamsTrait for OvfCreateImportSpecParams {
    fn get_locale(&self) -> &str { &self.locale }
    fn get_deployment_option(&self) -> &str { &self.deployment_option }
    fn get_msg_bundle(&self) -> &Option<Vec<KeyValue>> { &self.msg_bundle }
    fn get_import_option(&self) -> &Option<Vec<String>> { &self.import_option }
}
impl OvfManagerCommonParamsTrait for OvfParseDescriptorParams {
    fn get_locale(&self) -> &str { &self.locale }
    fn get_deployment_option(&self) -> &str { &self.deployment_option }
    fn get_msg_bundle(&self) -> &Option<Vec<KeyValue>> { &self.msg_bundle }
    fn get_import_option(&self) -> &Option<Vec<String>> { &self.import_option }
}
impl OvfManagerCommonParamsTrait for OvfValidateHostParams {
    fn get_locale(&self) -> &str { &self.locale }
    fn get_deployment_option(&self) -> &str { &self.deployment_option }
    fn get_msg_bundle(&self) -> &Option<Vec<KeyValue>> { &self.msg_bundle }
    fn get_import_option(&self) -> &Option<Vec<String>> { &self.import_option }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn OvfManagerCommonParamsTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfManagerCommonParams => Some(from.as_any_ref().downcast_ref::<OvfManagerCommonParams>()?),
            StructType::OvfCreateImportSpecParams => Some(from.as_any_ref().downcast_ref::<OvfCreateImportSpecParams>()?),
            StructType::OvfParseDescriptorParams => Some(from.as_any_ref().downcast_ref::<OvfParseDescriptorParams>()?),
            StructType::OvfValidateHostParams => Some(from.as_any_ref().downcast_ref::<OvfValidateHostParams>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfManagerCommonParams => Ok(from.as_any_box().downcast::<OvfManagerCommonParams>()?),
            StructType::OvfCreateImportSpecParams => Ok(from.as_any_box().downcast::<OvfCreateImportSpecParams>()?),
            StructType::OvfParseDescriptorParams => Ok(from.as_any_box().downcast::<OvfParseDescriptorParams>()?),
            StructType::OvfValidateHostParams => Ok(from.as_any_box().downcast::<OvfValidateHostParams>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base type for the various *PerfEntityMetric*
/// encodings.
pub trait PerfEntityMetricBaseTrait : super::traits::DataObjectTrait {
    /// Performance provider ID.
    fn get_entity(&self) -> &ManagedObjectReference;
}
impl<'s> serde::Serialize for dyn PerfEntityMetricBaseTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn PerfEntityMetricBaseTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(PerfEntityMetricBaseVisitor)
            }
        }

struct PerfEntityMetricBaseVisitor;

impl<'de> de::Visitor<'de> for PerfEntityMetricBaseVisitor {
    type Value = Box<dyn PerfEntityMetricBaseTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid PerfEntityMetricBaseTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl PerfEntityMetricBaseTrait for PerfEntityMetricBase {
    fn get_entity(&self) -> &ManagedObjectReference { &self.entity }
}
impl PerfEntityMetricBaseTrait for PerfEntityMetric {
    fn get_entity(&self) -> &ManagedObjectReference { &self.entity }
}
impl PerfEntityMetricBaseTrait for PerfEntityMetricCsv {
    fn get_entity(&self) -> &ManagedObjectReference { &self.entity }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn PerfEntityMetricBaseTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::PerfEntityMetricBase => Some(from.as_any_ref().downcast_ref::<PerfEntityMetricBase>()?),
            StructType::PerfEntityMetric => Some(from.as_any_ref().downcast_ref::<PerfEntityMetric>()?),
            StructType::PerfEntityMetricCsv => Some(from.as_any_ref().downcast_ref::<PerfEntityMetricCsv>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::PerfEntityMetricBase => Ok(from.as_any_box().downcast::<PerfEntityMetricBase>()?),
            StructType::PerfEntityMetric => Ok(from.as_any_box().downcast::<PerfEntityMetric>()?),
            StructType::PerfEntityMetricCsv => Ok(from.as_any_box().downcast::<PerfEntityMetricCsv>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This is a generic data object type that stores values for a specific
/// performance metric.
/// 
/// Useful data objects that store actual metric values
/// extend this data object (see *PerfMetricIntSeries*).
pub trait PerfMetricSeriesTrait : super::traits::DataObjectTrait {
    /// An identifier for the performance metric.
    fn get_id(&self) -> &PerfMetricId;
}
impl<'s> serde::Serialize for dyn PerfMetricSeriesTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn PerfMetricSeriesTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(PerfMetricSeriesVisitor)
            }
        }

struct PerfMetricSeriesVisitor;

impl<'de> de::Visitor<'de> for PerfMetricSeriesVisitor {
    type Value = Box<dyn PerfMetricSeriesTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid PerfMetricSeriesTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl PerfMetricSeriesTrait for PerfMetricSeries {
    fn get_id(&self) -> &PerfMetricId { &self.id }
}
impl PerfMetricSeriesTrait for PerfMetricIntSeries {
    fn get_id(&self) -> &PerfMetricId { &self.id }
}
impl PerfMetricSeriesTrait for PerfMetricSeriesCsv {
    fn get_id(&self) -> &PerfMetricId { &self.id }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn PerfMetricSeriesTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::PerfMetricSeries => Some(from.as_any_ref().downcast_ref::<PerfMetricSeries>()?),
            StructType::PerfMetricIntSeries => Some(from.as_any_ref().downcast_ref::<PerfMetricIntSeries>()?),
            StructType::PerfMetricSeriesCsv => Some(from.as_any_ref().downcast_ref::<PerfMetricSeriesCsv>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::PerfMetricSeries => Ok(from.as_any_box().downcast::<PerfMetricSeries>()?),
            StructType::PerfMetricIntSeries => Ok(from.as_any_box().downcast::<PerfMetricIntSeries>()?),
            StructType::PerfMetricSeriesCsv => Ok(from.as_any_box().downcast::<PerfMetricSeriesCsv>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type encapsulates a typical set of resource
/// pool information that is useful for list views and summary pages.
pub trait ResourcePoolSummaryTrait : super::traits::DataObjectTrait {
    /// Name of resource pool.
    fn get_name(&self) -> &str;
    /// Current configuration of the resource pool.
    fn get_config(&self) -> &ResourceConfigSpec;
    /// Current runtime state of the resource pool.
    fn get_runtime(&self) -> &ResourcePoolRuntimeInfo;
    /// A set of statistics that are typically updated with near real-time regularity.
    /// 
    /// This data object type does not support notification, for scalability reasons.
    /// Therefore, changes in QuickStats do not generate property collector updates.
    /// To monitor statistics values, use the statistics and alarms modules instead.
    fn get_quick_stats(&self) -> &Option<ResourcePoolQuickStats>;
    /// Total configured memory of all virtual machines in the resource pool, in MB.
    fn get_configured_memory_mb(&self) -> Option<i32>;
}
impl<'s> serde::Serialize for dyn ResourcePoolSummaryTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ResourcePoolSummaryTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ResourcePoolSummaryVisitor)
            }
        }

struct ResourcePoolSummaryVisitor;

impl<'de> de::Visitor<'de> for ResourcePoolSummaryVisitor {
    type Value = Box<dyn ResourcePoolSummaryTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ResourcePoolSummaryTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ResourcePoolSummaryTrait for ResourcePoolSummary {
    fn get_name(&self) -> &str { &self.name }
    fn get_config(&self) -> &ResourceConfigSpec { &self.config }
    fn get_runtime(&self) -> &ResourcePoolRuntimeInfo { &self.runtime }
    fn get_quick_stats(&self) -> &Option<ResourcePoolQuickStats> { &self.quick_stats }
    fn get_configured_memory_mb(&self) -> Option<i32> { self.configured_memory_mb }
}
impl ResourcePoolSummaryTrait for VirtualAppSummary {
    fn get_name(&self) -> &str { &self.name }
    fn get_config(&self) -> &ResourceConfigSpec { &self.config }
    fn get_runtime(&self) -> &ResourcePoolRuntimeInfo { &self.runtime }
    fn get_quick_stats(&self) -> &Option<ResourcePoolQuickStats> { &self.quick_stats }
    fn get_configured_memory_mb(&self) -> Option<i32> { self.configured_memory_mb }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ResourcePoolSummaryTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ResourcePoolSummary => Some(from.as_any_ref().downcast_ref::<ResourcePoolSummary>()?),
            StructType::VirtualAppSummary => Some(from.as_any_ref().downcast_ref::<VirtualAppSummary>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ResourcePoolSummary => Ok(from.as_any_box().downcast::<ResourcePoolSummary>()?),
            StructType::VirtualAppSummary => Ok(from.as_any_box().downcast::<VirtualAppSummary>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class for selecting entities
pub trait SelectionSetTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn SelectionSetTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn SelectionSetTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(SelectionSetVisitor)
            }
        }

struct SelectionSetVisitor;

impl<'de> de::Visitor<'de> for SelectionSetVisitor {
    type Value = Box<dyn SelectionSetTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid SelectionSetTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl SelectionSetTrait for SelectionSet {
}
impl SelectionSetTrait for DvPortgroupSelection {
}
impl SelectionSetTrait for DvsSelection {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn SelectionSetTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::SelectionSet => Some(from.as_any_ref().downcast_ref::<SelectionSet>()?),
            StructType::DvPortgroupSelection => Some(from.as_any_ref().downcast_ref::<DvPortgroupSelection>()?),
            StructType::DvsSelection => Some(from.as_any_ref().downcast_ref::<DvsSelection>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::SelectionSet => Ok(from.as_any_box().downcast::<SelectionSet>()?),
            StructType::DvPortgroupSelection => Ok(from.as_any_box().downcast::<DvPortgroupSelection>()?),
            StructType::DvsSelection => Ok(from.as_any_box().downcast::<DvsSelection>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The data object type is a base type of credential for authentication such
/// as username/password or SAML token.
pub trait ServiceLocatorCredentialTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn ServiceLocatorCredentialTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ServiceLocatorCredentialTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ServiceLocatorCredentialVisitor)
            }
        }

struct ServiceLocatorCredentialVisitor;

impl<'de> de::Visitor<'de> for ServiceLocatorCredentialVisitor {
    type Value = Box<dyn ServiceLocatorCredentialTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ServiceLocatorCredentialTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ServiceLocatorCredentialTrait for ServiceLocatorCredential {
}
impl ServiceLocatorCredentialTrait for ServiceLocatorNamePassword {
}
impl ServiceLocatorCredentialTrait for ServiceLocatorSamlCredential {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ServiceLocatorCredentialTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ServiceLocatorCredential => Some(from.as_any_ref().downcast_ref::<ServiceLocatorCredential>()?),
            StructType::ServiceLocatorNamePassword => Some(from.as_any_ref().downcast_ref::<ServiceLocatorNamePassword>()?),
            StructType::ServiceLocatorSamlCredential => Some(from.as_any_ref().downcast_ref::<ServiceLocatorSamlCredential>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ServiceLocatorCredential => Ok(from.as_any_box().downcast::<ServiceLocatorCredential>()?),
            StructType::ServiceLocatorNamePassword => Ok(from.as_any_box().downcast::<ServiceLocatorNamePassword>()?),
            StructType::ServiceLocatorSamlCredential => Ok(from.as_any_box().downcast::<ServiceLocatorSamlCredential>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type describes a request to a service.
/// 
/// It is used as argument to
/// *SessionManager.AcquireGenericServiceTicket*.
/// This is the base class for more specific service request specifications.
/// E.g. for HTTP services the derived class will provide a URL property.
pub trait SessionManagerServiceRequestSpecTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn SessionManagerServiceRequestSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn SessionManagerServiceRequestSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(SessionManagerServiceRequestSpecVisitor)
            }
        }

struct SessionManagerServiceRequestSpecVisitor;

impl<'de> de::Visitor<'de> for SessionManagerServiceRequestSpecVisitor {
    type Value = Box<dyn SessionManagerServiceRequestSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid SessionManagerServiceRequestSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl SessionManagerServiceRequestSpecTrait for SessionManagerServiceRequestSpec {
}
impl SessionManagerServiceRequestSpecTrait for SessionManagerHttpServiceRequestSpec {
}
impl SessionManagerServiceRequestSpecTrait for SessionManagerVmomiServiceRequestSpec {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn SessionManagerServiceRequestSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::SessionManagerServiceRequestSpec => Some(from.as_any_ref().downcast_ref::<SessionManagerServiceRequestSpec>()?),
            StructType::SessionManagerHttpServiceRequestSpec => Some(from.as_any_ref().downcast_ref::<SessionManagerHttpServiceRequestSpec>()?),
            StructType::SessionManagerVmomiServiceRequestSpec => Some(from.as_any_ref().downcast_ref::<SessionManagerVmomiServiceRequestSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::SessionManagerServiceRequestSpec => Ok(from.as_any_box().downcast::<SessionManagerServiceRequestSpec>()?),
            StructType::SessionManagerHttpServiceRequestSpec => Ok(from.as_any_box().downcast::<SessionManagerHttpServiceRequestSpec>()?),
            StructType::SessionManagerVmomiServiceRequestSpec => Ok(from.as_any_box().downcast::<SessionManagerVmomiServiceRequestSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base type for all task reasons.
/// 
/// Task reasons represent the kind of entity responsible for a task's creation.
pub trait TaskReasonTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn TaskReasonTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn TaskReasonTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(TaskReasonVisitor)
            }
        }

struct TaskReasonVisitor;

impl<'de> de::Visitor<'de> for TaskReasonVisitor {
    type Value = Box<dyn TaskReasonTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid TaskReasonTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl TaskReasonTrait for TaskReason {
}
impl TaskReasonTrait for TaskReasonAlarm {
}
impl TaskReasonTrait for TaskReasonSchedule {
}
impl TaskReasonTrait for TaskReasonSystem {
}
impl TaskReasonTrait for TaskReasonUser {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn TaskReasonTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::TaskReason => Some(from.as_any_ref().downcast_ref::<TaskReason>()?),
            StructType::TaskReasonAlarm => Some(from.as_any_ref().downcast_ref::<TaskReasonAlarm>()?),
            StructType::TaskReasonSchedule => Some(from.as_any_ref().downcast_ref::<TaskReasonSchedule>()?),
            StructType::TaskReasonSystem => Some(from.as_any_ref().downcast_ref::<TaskReasonSystem>()?),
            StructType::TaskReasonUser => Some(from.as_any_ref().downcast_ref::<TaskReasonUser>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::TaskReason => Ok(from.as_any_box().downcast::<TaskReason>()?),
            StructType::TaskReasonAlarm => Ok(from.as_any_box().downcast::<TaskReasonAlarm>()?),
            StructType::TaskReasonSchedule => Ok(from.as_any_box().downcast::<TaskReasonSchedule>()?),
            StructType::TaskReasonSystem => Ok(from.as_any_box().downcast::<TaskReasonSystem>()?),
            StructType::TaskReasonUser => Ok(from.as_any_box().downcast::<TaskReasonUser>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// When searching for users, the search results in
/// some additional information.
/// 
/// This object describes
/// the additional information.
pub trait UserSearchResultTrait : super::traits::DataObjectTrait {
    /// Login name of a user or the name of a group.
    /// 
    /// This key is
    /// the user within the searched domain.
    fn get_principal(&self) -> &str;
    /// Full name of the user found by the search, or the description
    /// of a group, if available.
    fn get_full_name(&self) -> &Option<String>;
    /// If this is true, then the result is a group.
    /// 
    /// If this is false, then the
    /// result is a user.
    fn get_group(&self) -> bool;
}
impl<'s> serde::Serialize for dyn UserSearchResultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn UserSearchResultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(UserSearchResultVisitor)
            }
        }

struct UserSearchResultVisitor;

impl<'de> de::Visitor<'de> for UserSearchResultVisitor {
    type Value = Box<dyn UserSearchResultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid UserSearchResultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl UserSearchResultTrait for UserSearchResult {
    fn get_principal(&self) -> &str { &self.principal }
    fn get_full_name(&self) -> &Option<String> { &self.full_name }
    fn get_group(&self) -> bool { self.group }
}
impl UserSearchResultTrait for PosixUserSearchResult {
    fn get_principal(&self) -> &str { &self.principal }
    fn get_full_name(&self) -> &Option<String> { &self.full_name }
    fn get_group(&self) -> bool { self.group }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn UserSearchResultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::UserSearchResult => Some(from.as_any_ref().downcast_ref::<UserSearchResult>()?),
            StructType::PosixUserSearchResult => Some(from.as_any_ref().downcast_ref::<PosixUserSearchResult>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::UserSearchResult => Ok(from.as_any_box().downcast::<UserSearchResult>()?),
            StructType::PosixUserSearchResult => Ok(from.as_any_box().downcast::<PosixUserSearchResult>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Specification used to create or clone a virtual disk
pub trait VirtualDiskSpecTrait : super::traits::DataObjectTrait {
    /// The type of the new virtual disk.
    /// 
    /// See also *VirtualDiskType_enum*.
    fn get_disk_type(&self) -> &str;
    /// The type of the virtual disk adapter for the new virtual disk.
    /// 
    /// See also *VirtualDiskAdapterType_enum*.
    fn get_adapter_type(&self) -> &str;
}
impl<'s> serde::Serialize for dyn VirtualDiskSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDiskSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDiskSpecVisitor)
            }
        }

struct VirtualDiskSpecVisitor;

impl<'de> de::Visitor<'de> for VirtualDiskSpecVisitor {
    type Value = Box<dyn VirtualDiskSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDiskSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDiskSpecTrait for VirtualDiskSpec {
    fn get_disk_type(&self) -> &str { &self.disk_type }
    fn get_adapter_type(&self) -> &str { &self.adapter_type }
}
impl VirtualDiskSpecTrait for DeviceBackedVirtualDiskSpec {
    fn get_disk_type(&self) -> &str { &self.disk_type }
    fn get_adapter_type(&self) -> &str { &self.adapter_type }
}
impl VirtualDiskSpecTrait for FileBackedVirtualDiskSpec {
    fn get_disk_type(&self) -> &str { &self.disk_type }
    fn get_adapter_type(&self) -> &str { &self.adapter_type }
}
impl VirtualDiskSpecTrait for SeSparseVirtualDiskSpec {
    fn get_disk_type(&self) -> &str { &self.disk_type }
    fn get_adapter_type(&self) -> &str { &self.adapter_type }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDiskSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDiskSpec => Some(from.as_any_ref().downcast_ref::<VirtualDiskSpec>()?),
            StructType::DeviceBackedVirtualDiskSpec => Some(from.as_any_ref().downcast_ref::<DeviceBackedVirtualDiskSpec>()?),
            StructType::FileBackedVirtualDiskSpec => Some(from.as_any_ref().downcast_ref::<FileBackedVirtualDiskSpec>()?),
            StructType::SeSparseVirtualDiskSpec => Some(from.as_any_ref().downcast_ref::<SeSparseVirtualDiskSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDiskSpec => Ok(from.as_any_box().downcast::<VirtualDiskSpec>()?),
            StructType::DeviceBackedVirtualDiskSpec => Ok(from.as_any_box().downcast::<DeviceBackedVirtualDiskSpec>()?),
            StructType::FileBackedVirtualDiskSpec => Ok(from.as_any_box().downcast::<FileBackedVirtualDiskSpec>()?),
            StructType::SeSparseVirtualDiskSpec => Ok(from.as_any_box().downcast::<SeSparseVirtualDiskSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Specification used to create a file based virtual disk
pub trait FileBackedVirtualDiskSpecTrait : super::traits::VirtualDiskSpecTrait {
    /// Specify the capacity of the virtual disk in Kb.
    fn get_capacity_kb(&self) -> i64;
    /// Virtual Disk Profile requirement.
    /// 
    /// Profiles are solution specifics.
    /// Profile Based Storage Management is a vSphere server extension.
    /// The API users who want to provision VMs using Storage Profiles, need to
    /// interact with it.
    /// This is an optional parameter and if user doesn't specify profile,
    /// the default behavior will apply.
    fn get_profile(&self) -> &Option<Vec<Box<dyn super::traits::VirtualMachineProfileSpecTrait>>>;
    /// Encryption options for the new virtual disk.
    fn get_crypto(&self) -> &Option<Box<dyn super::traits::CryptoSpecTrait>>;
}
impl<'s> serde::Serialize for dyn FileBackedVirtualDiskSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn FileBackedVirtualDiskSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(FileBackedVirtualDiskSpecVisitor)
            }
        }

struct FileBackedVirtualDiskSpecVisitor;

impl<'de> de::Visitor<'de> for FileBackedVirtualDiskSpecVisitor {
    type Value = Box<dyn FileBackedVirtualDiskSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid FileBackedVirtualDiskSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl FileBackedVirtualDiskSpecTrait for FileBackedVirtualDiskSpec {
    fn get_capacity_kb(&self) -> i64 { self.capacity_kb }
    fn get_profile(&self) -> &Option<Vec<Box<dyn super::traits::VirtualMachineProfileSpecTrait>>> { &self.profile }
    fn get_crypto(&self) -> &Option<Box<dyn super::traits::CryptoSpecTrait>> { &self.crypto }
}
impl FileBackedVirtualDiskSpecTrait for SeSparseVirtualDiskSpec {
    fn get_capacity_kb(&self) -> i64 { self.capacity_kb }
    fn get_profile(&self) -> &Option<Vec<Box<dyn super::traits::VirtualMachineProfileSpecTrait>>> { &self.profile }
    fn get_crypto(&self) -> &Option<Box<dyn super::traits::CryptoSpecTrait>> { &self.crypto }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn FileBackedVirtualDiskSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::FileBackedVirtualDiskSpec => Some(from.as_any_ref().downcast_ref::<FileBackedVirtualDiskSpec>()?),
            StructType::SeSparseVirtualDiskSpec => Some(from.as_any_ref().downcast_ref::<SeSparseVirtualDiskSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::FileBackedVirtualDiskSpec => Ok(from.as_any_box().downcast::<FileBackedVirtualDiskSpec>()?),
            StructType::SeSparseVirtualDiskSpec => Ok(from.as_any_box().downcast::<SeSparseVirtualDiskSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *VirtualMachineConnection* object describes a connection to the virtual
/// machine.
/// 
/// ***Since:*** vSphere API Release 7.0.1.0
pub trait VirtualMachineConnectionTrait : super::traits::DataObjectTrait {
    /// The unique identifier associated with the connection.
    /// 
    /// The label is a UTF-8 string which specifies a unique identifier for
    /// a connection.
    fn get_label(&self) -> &str;
    /// The client identifer.
    /// 
    /// This identifier is a UTF-8 string which is semantically meaningful
    /// for the connection. Examples of the client identifier are an IP
    /// address (V4 or V6) with or without a port specification, a machine
    /// name that requires a DNS lookup, or any other network oriented
    /// identification scheme.
    fn get_client(&self) -> &str;
    /// The name of the user authorizing the connection.
    /// 
    /// This is used for auditing.
    fn get_user_name(&self) -> &str;
}
impl<'s> serde::Serialize for dyn VirtualMachineConnectionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualMachineConnectionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualMachineConnectionVisitor)
            }
        }

struct VirtualMachineConnectionVisitor;

impl<'de> de::Visitor<'de> for VirtualMachineConnectionVisitor {
    type Value = Box<dyn VirtualMachineConnectionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualMachineConnectionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualMachineConnectionTrait for VirtualMachineConnection {
    fn get_label(&self) -> &str { &self.label }
    fn get_client(&self) -> &str { &self.client }
    fn get_user_name(&self) -> &str { &self.user_name }
}
impl VirtualMachineConnectionTrait for VirtualMachineMksConnection {
    fn get_label(&self) -> &str { &self.label }
    fn get_client(&self) -> &str { &self.client }
    fn get_user_name(&self) -> &str { &self.user_name }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualMachineConnectionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineConnection => Some(from.as_any_ref().downcast_ref::<VirtualMachineConnection>()?),
            StructType::VirtualMachineMksConnection => Some(from.as_any_ref().downcast_ref::<VirtualMachineMksConnection>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineConnection => Ok(from.as_any_box().downcast::<VirtualMachineConnection>()?),
            StructType::VirtualMachineMksConnection => Ok(from.as_any_box().downcast::<VirtualMachineMksConnection>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class for a pre-flight check issue.
/// 
/// Can be used directly
/// but usually a derived class with a specific issue type is used.
pub trait VsanUpgradeSystemPreflightCheckIssueTrait : super::traits::DataObjectTrait {
    /// Message describing the issue.
    fn get_msg(&self) -> &str;
}
impl<'s> serde::Serialize for dyn VsanUpgradeSystemPreflightCheckIssueTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VsanUpgradeSystemPreflightCheckIssueTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VsanUpgradeSystemPreflightCheckIssueVisitor)
            }
        }

struct VsanUpgradeSystemPreflightCheckIssueVisitor;

impl<'de> de::Visitor<'de> for VsanUpgradeSystemPreflightCheckIssueVisitor {
    type Value = Box<dyn VsanUpgradeSystemPreflightCheckIssueTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VsanUpgradeSystemPreflightCheckIssueTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VsanUpgradeSystemPreflightCheckIssueTrait for VsanUpgradeSystemPreflightCheckIssue {
    fn get_msg(&self) -> &str { &self.msg }
}
impl VsanUpgradeSystemPreflightCheckIssueTrait for VsanUpgradeSystemApiBrokenIssue {
    fn get_msg(&self) -> &str { &self.msg }
}
impl VsanUpgradeSystemPreflightCheckIssueTrait for VsanUpgradeSystemAutoClaimEnabledOnHostsIssue {
    fn get_msg(&self) -> &str { &self.msg }
}
impl VsanUpgradeSystemPreflightCheckIssueTrait for VsanUpgradeSystemHostsDisconnectedIssue {
    fn get_msg(&self) -> &str { &self.msg }
}
impl VsanUpgradeSystemPreflightCheckIssueTrait for VsanUpgradeSystemMissingHostsInClusterIssue {
    fn get_msg(&self) -> &str { &self.msg }
}
impl VsanUpgradeSystemPreflightCheckIssueTrait for VsanUpgradeSystemNetworkPartitionIssue {
    fn get_msg(&self) -> &str { &self.msg }
}
impl VsanUpgradeSystemPreflightCheckIssueTrait for VsanUpgradeSystemNotEnoughFreeCapacityIssue {
    fn get_msg(&self) -> &str { &self.msg }
}
impl VsanUpgradeSystemPreflightCheckIssueTrait for VsanUpgradeSystemRogueHostsInClusterIssue {
    fn get_msg(&self) -> &str { &self.msg }
}
impl VsanUpgradeSystemPreflightCheckIssueTrait for VsanUpgradeSystemV2ObjectsPresentDuringDowngradeIssue {
    fn get_msg(&self) -> &str { &self.msg }
}
impl VsanUpgradeSystemPreflightCheckIssueTrait for VsanUpgradeSystemWrongEsxVersionIssue {
    fn get_msg(&self) -> &str { &self.msg }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VsanUpgradeSystemPreflightCheckIssueTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VsanUpgradeSystemPreflightCheckIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemPreflightCheckIssue>()?),
            StructType::VsanUpgradeSystemApiBrokenIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemApiBrokenIssue>()?),
            StructType::VsanUpgradeSystemAutoClaimEnabledOnHostsIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemAutoClaimEnabledOnHostsIssue>()?),
            StructType::VsanUpgradeSystemHostsDisconnectedIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemHostsDisconnectedIssue>()?),
            StructType::VsanUpgradeSystemMissingHostsInClusterIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemMissingHostsInClusterIssue>()?),
            StructType::VsanUpgradeSystemNetworkPartitionIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemNetworkPartitionIssue>()?),
            StructType::VsanUpgradeSystemNotEnoughFreeCapacityIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemNotEnoughFreeCapacityIssue>()?),
            StructType::VsanUpgradeSystemRogueHostsInClusterIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemRogueHostsInClusterIssue>()?),
            StructType::VsanUpgradeSystemV2ObjectsPresentDuringDowngradeIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemV2ObjectsPresentDuringDowngradeIssue>()?),
            StructType::VsanUpgradeSystemWrongEsxVersionIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemWrongEsxVersionIssue>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VsanUpgradeSystemPreflightCheckIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemPreflightCheckIssue>()?),
            StructType::VsanUpgradeSystemApiBrokenIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemApiBrokenIssue>()?),
            StructType::VsanUpgradeSystemAutoClaimEnabledOnHostsIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemAutoClaimEnabledOnHostsIssue>()?),
            StructType::VsanUpgradeSystemHostsDisconnectedIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemHostsDisconnectedIssue>()?),
            StructType::VsanUpgradeSystemMissingHostsInClusterIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemMissingHostsInClusterIssue>()?),
            StructType::VsanUpgradeSystemNetworkPartitionIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemNetworkPartitionIssue>()?),
            StructType::VsanUpgradeSystemNotEnoughFreeCapacityIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemNotEnoughFreeCapacityIssue>()?),
            StructType::VsanUpgradeSystemRogueHostsInClusterIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemRogueHostsInClusterIssue>()?),
            StructType::VsanUpgradeSystemV2ObjectsPresentDuringDowngradeIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemV2ObjectsPresentDuringDowngradeIssue>()?),
            StructType::VsanUpgradeSystemWrongEsxVersionIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemWrongEsxVersionIssue>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Captures one "log entry" of an upgrade process.
pub trait VsanUpgradeSystemUpgradeHistoryItemTrait : super::traits::DataObjectTrait {
    /// Time stamp when the history is record.
    fn get_timestamp(&self) -> &str;
    /// The host a history item pertains to.
    /// 
    /// May be unset when item related
    /// to no particular host.
    /// 
    /// Refers instance of *HostSystem*.
    fn get_host(&self) -> &Option<ManagedObjectReference>;
    /// Description of the history item.
    fn get_message(&self) -> &str;
    /// A task associated with the history item.
    /// 
    /// May be unset if no task is
    /// associated.
    /// 
    /// Refers instance of *Task*.
    fn get_task(&self) -> &Option<ManagedObjectReference>;
}
impl<'s> serde::Serialize for dyn VsanUpgradeSystemUpgradeHistoryItemTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VsanUpgradeSystemUpgradeHistoryItemTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VsanUpgradeSystemUpgradeHistoryItemVisitor)
            }
        }

struct VsanUpgradeSystemUpgradeHistoryItemVisitor;

impl<'de> de::Visitor<'de> for VsanUpgradeSystemUpgradeHistoryItemVisitor {
    type Value = Box<dyn VsanUpgradeSystemUpgradeHistoryItemTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VsanUpgradeSystemUpgradeHistoryItemTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VsanUpgradeSystemUpgradeHistoryItemTrait for VsanUpgradeSystemUpgradeHistoryItem {
    fn get_timestamp(&self) -> &str { &self.timestamp }
    fn get_host(&self) -> &Option<ManagedObjectReference> { &self.host }
    fn get_message(&self) -> &str { &self.message }
    fn get_task(&self) -> &Option<ManagedObjectReference> { &self.task }
}
impl VsanUpgradeSystemUpgradeHistoryItemTrait for VsanUpgradeSystemUpgradeHistoryDiskGroupOp {
    fn get_timestamp(&self) -> &str { &self.timestamp }
    fn get_host(&self) -> &Option<ManagedObjectReference> { &self.host }
    fn get_message(&self) -> &str { &self.message }
    fn get_task(&self) -> &Option<ManagedObjectReference> { &self.task }
}
impl VsanUpgradeSystemUpgradeHistoryItemTrait for VsanUpgradeSystemUpgradeHistoryPreflightFail {
    fn get_timestamp(&self) -> &str { &self.timestamp }
    fn get_host(&self) -> &Option<ManagedObjectReference> { &self.host }
    fn get_message(&self) -> &str { &self.message }
    fn get_task(&self) -> &Option<ManagedObjectReference> { &self.task }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VsanUpgradeSystemUpgradeHistoryItemTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VsanUpgradeSystemUpgradeHistoryItem => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemUpgradeHistoryItem>()?),
            StructType::VsanUpgradeSystemUpgradeHistoryDiskGroupOp => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemUpgradeHistoryDiskGroupOp>()?),
            StructType::VsanUpgradeSystemUpgradeHistoryPreflightFail => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemUpgradeHistoryPreflightFail>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VsanUpgradeSystemUpgradeHistoryItem => Ok(from.as_any_box().downcast::<VsanUpgradeSystemUpgradeHistoryItem>()?),
            StructType::VsanUpgradeSystemUpgradeHistoryDiskGroupOp => Ok(from.as_any_box().downcast::<VsanUpgradeSystemUpgradeHistoryDiskGroupOp>()?),
            StructType::VsanUpgradeSystemUpgradeHistoryPreflightFail => Ok(from.as_any_box().downcast::<VsanUpgradeSystemUpgradeHistoryPreflightFail>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type defines the action initiated by a scheduled task or alarm.
/// 
/// This is an abstract type.
/// A client creates a scheduled task or an alarm each of which triggers
/// an action, defined by a subclass of this type.
pub trait ActionTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn ActionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ActionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ActionVisitor)
            }
        }

struct ActionVisitor;

impl<'de> de::Visitor<'de> for ActionVisitor {
    type Value = Box<dyn ActionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ActionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ActionTrait for Action {
}
impl ActionTrait for CreateTaskAction {
}
impl ActionTrait for MethodAction {
}
impl ActionTrait for RunScriptAction {
}
impl ActionTrait for SendEmailAction {
}
impl ActionTrait for SendSnmpAction {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ActionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::Action => Some(from.as_any_ref().downcast_ref::<Action>()?),
            StructType::CreateTaskAction => Some(from.as_any_ref().downcast_ref::<CreateTaskAction>()?),
            StructType::MethodAction => Some(from.as_any_ref().downcast_ref::<MethodAction>()?),
            StructType::RunScriptAction => Some(from.as_any_ref().downcast_ref::<RunScriptAction>()?),
            StructType::SendEmailAction => Some(from.as_any_ref().downcast_ref::<SendEmailAction>()?),
            StructType::SendSnmpAction => Some(from.as_any_ref().downcast_ref::<SendSnmpAction>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::Action => Ok(from.as_any_box().downcast::<Action>()?),
            StructType::CreateTaskAction => Ok(from.as_any_box().downcast::<CreateTaskAction>()?),
            StructType::MethodAction => Ok(from.as_any_box().downcast::<MethodAction>()?),
            StructType::RunScriptAction => Ok(from.as_any_box().downcast::<RunScriptAction>()?),
            StructType::SendEmailAction => Ok(from.as_any_box().downcast::<SendEmailAction>()?),
            StructType::SendSnmpAction => Ok(from.as_any_box().downcast::<SendSnmpAction>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Action invoked by triggered alarm.
/// 
/// This is an abstract type.
pub trait AlarmActionTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn AlarmActionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn AlarmActionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(AlarmActionVisitor)
            }
        }

struct AlarmActionVisitor;

impl<'de> de::Visitor<'de> for AlarmActionVisitor {
    type Value = Box<dyn AlarmActionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid AlarmActionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl AlarmActionTrait for AlarmAction {
}
impl AlarmActionTrait for AlarmTriggeringAction {
}
impl AlarmActionTrait for GroupAlarmAction {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn AlarmActionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::AlarmAction => Some(from.as_any_ref().downcast_ref::<AlarmAction>()?),
            StructType::AlarmTriggeringAction => Some(from.as_any_ref().downcast_ref::<AlarmTriggeringAction>()?),
            StructType::GroupAlarmAction => Some(from.as_any_ref().downcast_ref::<GroupAlarmAction>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::AlarmAction => Ok(from.as_any_box().downcast::<AlarmAction>()?),
            StructType::AlarmTriggeringAction => Ok(from.as_any_box().downcast::<AlarmTriggeringAction>()?),
            StructType::GroupAlarmAction => Ok(from.as_any_box().downcast::<GroupAlarmAction>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base type for the expressions specifying the conditions that define
/// the status of an alarm.
pub trait AlarmExpressionTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn AlarmExpressionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn AlarmExpressionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(AlarmExpressionVisitor)
            }
        }

struct AlarmExpressionVisitor;

impl<'de> de::Visitor<'de> for AlarmExpressionVisitor {
    type Value = Box<dyn AlarmExpressionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid AlarmExpressionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl AlarmExpressionTrait for AlarmExpression {
}
impl AlarmExpressionTrait for AndAlarmExpression {
}
impl AlarmExpressionTrait for EventAlarmExpression {
}
impl AlarmExpressionTrait for MetricAlarmExpression {
}
impl AlarmExpressionTrait for OrAlarmExpression {
}
impl AlarmExpressionTrait for StateAlarmExpression {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn AlarmExpressionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::AlarmExpression => Some(from.as_any_ref().downcast_ref::<AlarmExpression>()?),
            StructType::AndAlarmExpression => Some(from.as_any_ref().downcast_ref::<AndAlarmExpression>()?),
            StructType::EventAlarmExpression => Some(from.as_any_ref().downcast_ref::<EventAlarmExpression>()?),
            StructType::MetricAlarmExpression => Some(from.as_any_ref().downcast_ref::<MetricAlarmExpression>()?),
            StructType::OrAlarmExpression => Some(from.as_any_ref().downcast_ref::<OrAlarmExpression>()?),
            StructType::StateAlarmExpression => Some(from.as_any_ref().downcast_ref::<StateAlarmExpression>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::AlarmExpression => Ok(from.as_any_box().downcast::<AlarmExpression>()?),
            StructType::AndAlarmExpression => Ok(from.as_any_box().downcast::<AndAlarmExpression>()?),
            StructType::EventAlarmExpression => Ok(from.as_any_box().downcast::<EventAlarmExpression>()?),
            StructType::MetricAlarmExpression => Ok(from.as_any_box().downcast::<MetricAlarmExpression>()?),
            StructType::OrAlarmExpression => Ok(from.as_any_box().downcast::<OrAlarmExpression>()?),
            StructType::StateAlarmExpression => Ok(from.as_any_box().downcast::<StateAlarmExpression>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Parameters for alarm creation.
pub trait AlarmSpecTrait : super::traits::DataObjectTrait {
    /// Name of the alarm.
    fn get_name(&self) -> &str;
    /// System name of the alarm.
    /// 
    /// This is set only for predefined Alarms - i.e. Alarms created by the
    /// server or extensions automatically. After creation this value cannot be
    /// modified. User-created Alarms do not have a systemName at all.
    /// 
    /// The purpose of this field is to identify system-created Alarms
    /// reliably, even if they are edited by users.
    /// 
    /// When creating Alarms with systemName, the systemName and the name of the
    /// alarm should be equal.
    /// 
    /// When reconfiguring an Alarm with systemName, the same systemName should
    /// be passed in the new AlarmSpec. Renaming Alarms with systemName is not
    /// allowed, i.e. when reconfiguring, the name passed in the new AlarmSpec
    /// should be equal to either the systemName or its localized version (the
    /// current name in the Alarm's info).
    fn get_system_name(&self) -> &Option<String>;
    /// Description of the alarm.
    fn get_description(&self) -> &str;
    /// Flag to indicate whether or not the alarm is enabled or disabled.
    fn get_enabled(&self) -> bool;
    /// Top-level alarm expression that defines trigger conditions.
    fn get_expression(&self) -> &Box<dyn super::traits::AlarmExpressionTrait>;
    /// Action to perform when the alarm is triggered.
    fn get_action(&self) -> &Option<Box<dyn super::traits::AlarmActionTrait>>;
    /// Frequency in seconds, which specifies how often appropriate actions
    /// should repeat when an alarm does not change state.
    fn get_action_frequency(&self) -> Option<i32>;
    /// Tolerance and maximum frequency settings.
    fn get_setting(&self) -> &Option<AlarmSetting>;
}
impl<'s> serde::Serialize for dyn AlarmSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn AlarmSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(AlarmSpecVisitor)
            }
        }

struct AlarmSpecVisitor;

impl<'de> de::Visitor<'de> for AlarmSpecVisitor {
    type Value = Box<dyn AlarmSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid AlarmSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl AlarmSpecTrait for AlarmSpec {
    fn get_name(&self) -> &str { &self.name }
    fn get_system_name(&self) -> &Option<String> { &self.system_name }
    fn get_description(&self) -> &str { &self.description }
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_expression(&self) -> &Box<dyn super::traits::AlarmExpressionTrait> { &self.expression }
    fn get_action(&self) -> &Option<Box<dyn super::traits::AlarmActionTrait>> { &self.action }
    fn get_action_frequency(&self) -> Option<i32> { self.action_frequency }
    fn get_setting(&self) -> &Option<AlarmSetting> { &self.setting }
}
impl AlarmSpecTrait for AlarmInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_system_name(&self) -> &Option<String> { &self.system_name }
    fn get_description(&self) -> &str { &self.description }
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_expression(&self) -> &Box<dyn super::traits::AlarmExpressionTrait> { &self.expression }
    fn get_action(&self) -> &Option<Box<dyn super::traits::AlarmActionTrait>> { &self.action }
    fn get_action_frequency(&self) -> Option<i32> { self.action_frequency }
    fn get_setting(&self) -> &Option<AlarmSetting> { &self.setting }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn AlarmSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::AlarmSpec => Some(from.as_any_ref().downcast_ref::<AlarmSpec>()?),
            StructType::AlarmInfo => Some(from.as_any_ref().downcast_ref::<AlarmInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::AlarmSpec => Ok(from.as_any_box().downcast::<AlarmSpec>()?),
            StructType::AlarmInfo => Ok(from.as_any_box().downcast::<AlarmInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class for all action recommendations in VirtualCenter.
pub trait ClusterActionTrait : super::traits::DataObjectTrait {
    /// Type of the action.
    /// 
    /// This is encoded to differentiate between
    /// different types of actions aimed at achieving different goals.
    fn get_type(&self) -> &str;
    /// The target object on which this action will be applied.
    /// 
    /// For
    /// instance, a migration action will have a virtual machine as its
    /// target object, while a host power action will have a host as its
    /// target action.
    fn get_target(&self) -> &Option<ManagedObjectReference>;
}
impl<'s> serde::Serialize for dyn ClusterActionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ClusterActionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ClusterActionVisitor)
            }
        }

struct ClusterActionVisitor;

impl<'de> de::Visitor<'de> for ClusterActionVisitor {
    type Value = Box<dyn ClusterActionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ClusterActionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ClusterActionTrait for ClusterAction {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_target(&self) -> &Option<ManagedObjectReference> { &self.target }
}
impl ClusterActionTrait for ClusterClusterInitialPlacementAction {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_target(&self) -> &Option<ManagedObjectReference> { &self.target }
}
impl ClusterActionTrait for ClusterHostInfraUpdateHaModeAction {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_target(&self) -> &Option<ManagedObjectReference> { &self.target }
}
impl ClusterActionTrait for ClusterHostPowerAction {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_target(&self) -> &Option<ManagedObjectReference> { &self.target }
}
impl ClusterActionTrait for ClusterInitialPlacementAction {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_target(&self) -> &Option<ManagedObjectReference> { &self.target }
}
impl ClusterActionTrait for ClusterMigrationAction {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_target(&self) -> &Option<ManagedObjectReference> { &self.target }
}
impl ClusterActionTrait for PlacementAction {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_target(&self) -> &Option<ManagedObjectReference> { &self.target }
}
impl ClusterActionTrait for HbrDiskMigrationAction {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_target(&self) -> &Option<ManagedObjectReference> { &self.target }
}
impl ClusterActionTrait for StorageMigrationAction {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_target(&self) -> &Option<ManagedObjectReference> { &self.target }
}
impl ClusterActionTrait for StoragePlacementAction {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_target(&self) -> &Option<ManagedObjectReference> { &self.target }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ClusterActionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterAction => Some(from.as_any_ref().downcast_ref::<ClusterAction>()?),
            StructType::ClusterClusterInitialPlacementAction => Some(from.as_any_ref().downcast_ref::<ClusterClusterInitialPlacementAction>()?),
            StructType::ClusterHostInfraUpdateHaModeAction => Some(from.as_any_ref().downcast_ref::<ClusterHostInfraUpdateHaModeAction>()?),
            StructType::ClusterHostPowerAction => Some(from.as_any_ref().downcast_ref::<ClusterHostPowerAction>()?),
            StructType::ClusterInitialPlacementAction => Some(from.as_any_ref().downcast_ref::<ClusterInitialPlacementAction>()?),
            StructType::ClusterMigrationAction => Some(from.as_any_ref().downcast_ref::<ClusterMigrationAction>()?),
            StructType::PlacementAction => Some(from.as_any_ref().downcast_ref::<PlacementAction>()?),
            StructType::HbrDiskMigrationAction => Some(from.as_any_ref().downcast_ref::<HbrDiskMigrationAction>()?),
            StructType::StorageMigrationAction => Some(from.as_any_ref().downcast_ref::<StorageMigrationAction>()?),
            StructType::StoragePlacementAction => Some(from.as_any_ref().downcast_ref::<StoragePlacementAction>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterAction => Ok(from.as_any_box().downcast::<ClusterAction>()?),
            StructType::ClusterClusterInitialPlacementAction => Ok(from.as_any_box().downcast::<ClusterClusterInitialPlacementAction>()?),
            StructType::ClusterHostInfraUpdateHaModeAction => Ok(from.as_any_box().downcast::<ClusterHostInfraUpdateHaModeAction>()?),
            StructType::ClusterHostPowerAction => Ok(from.as_any_box().downcast::<ClusterHostPowerAction>()?),
            StructType::ClusterInitialPlacementAction => Ok(from.as_any_box().downcast::<ClusterInitialPlacementAction>()?),
            StructType::ClusterMigrationAction => Ok(from.as_any_box().downcast::<ClusterMigrationAction>()?),
            StructType::PlacementAction => Ok(from.as_any_box().downcast::<PlacementAction>()?),
            StructType::HbrDiskMigrationAction => Ok(from.as_any_box().downcast::<HbrDiskMigrationAction>()?),
            StructType::StorageMigrationAction => Ok(from.as_any_box().downcast::<StorageMigrationAction>()?),
            StructType::StoragePlacementAction => Ok(from.as_any_box().downcast::<StoragePlacementAction>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class for admission control related information of a vSphere HA cluster.
pub trait ClusterDasAdmissionControlInfoTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn ClusterDasAdmissionControlInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ClusterDasAdmissionControlInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ClusterDasAdmissionControlInfoVisitor)
            }
        }

struct ClusterDasAdmissionControlInfoVisitor;

impl<'de> de::Visitor<'de> for ClusterDasAdmissionControlInfoVisitor {
    type Value = Box<dyn ClusterDasAdmissionControlInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ClusterDasAdmissionControlInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ClusterDasAdmissionControlInfoTrait for ClusterDasAdmissionControlInfo {
}
impl ClusterDasAdmissionControlInfoTrait for ClusterFailoverHostAdmissionControlInfo {
}
impl ClusterDasAdmissionControlInfoTrait for ClusterFailoverLevelAdmissionControlInfo {
}
impl ClusterDasAdmissionControlInfoTrait for ClusterFailoverResourcesAdmissionControlInfo {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ClusterDasAdmissionControlInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterDasAdmissionControlInfo => Some(from.as_any_ref().downcast_ref::<ClusterDasAdmissionControlInfo>()?),
            StructType::ClusterFailoverHostAdmissionControlInfo => Some(from.as_any_ref().downcast_ref::<ClusterFailoverHostAdmissionControlInfo>()?),
            StructType::ClusterFailoverLevelAdmissionControlInfo => Some(from.as_any_ref().downcast_ref::<ClusterFailoverLevelAdmissionControlInfo>()?),
            StructType::ClusterFailoverResourcesAdmissionControlInfo => Some(from.as_any_ref().downcast_ref::<ClusterFailoverResourcesAdmissionControlInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterDasAdmissionControlInfo => Ok(from.as_any_box().downcast::<ClusterDasAdmissionControlInfo>()?),
            StructType::ClusterFailoverHostAdmissionControlInfo => Ok(from.as_any_box().downcast::<ClusterFailoverHostAdmissionControlInfo>()?),
            StructType::ClusterFailoverLevelAdmissionControlInfo => Ok(from.as_any_box().downcast::<ClusterFailoverLevelAdmissionControlInfo>()?),
            StructType::ClusterFailoverResourcesAdmissionControlInfo => Ok(from.as_any_box().downcast::<ClusterFailoverResourcesAdmissionControlInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class for specifying how admission control should be done for vSphere HA.
pub trait ClusterDasAdmissionControlPolicyTrait : super::traits::DataObjectTrait {
    /// Percentage of resource reduction that a cluster of VMs can tolerate
    /// in case of a failover.
    fn get_resource_reduction_to_tolerate_percent(&self) -> Option<i32>;
    /// Flag that determines whether strict admission control for persistent
    /// memory is enabled.
    /// 
    /// By default, this value is false.
    /// This flag can only be set to true if
    /// *ClusterDasConfigInfo.admissionControlEnabled* is set to true.
    /// When you use persistent memory admission control, the following
    /// operations are prevented, if doing so would violate the
    /// *ClusterDasConfigInfo.admissionControlEnabled*.
    /// - Creating a virtual machine with persistent memory.
    /// - Adding a virtual persistent memory device to a virtual machine.
    /// - Increasing the capacity of a virtual persistent memory device.
    ///   
    /// ***Since:*** vSphere API Release 7.0.2.0
    fn get_p_mem_admission_control_enabled(&self) -> Option<bool>;
}
impl<'s> serde::Serialize for dyn ClusterDasAdmissionControlPolicyTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ClusterDasAdmissionControlPolicyTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ClusterDasAdmissionControlPolicyVisitor)
            }
        }

struct ClusterDasAdmissionControlPolicyVisitor;

impl<'de> de::Visitor<'de> for ClusterDasAdmissionControlPolicyVisitor {
    type Value = Box<dyn ClusterDasAdmissionControlPolicyTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ClusterDasAdmissionControlPolicyTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ClusterDasAdmissionControlPolicyTrait for ClusterDasAdmissionControlPolicy {
    fn get_resource_reduction_to_tolerate_percent(&self) -> Option<i32> { self.resource_reduction_to_tolerate_percent }
    fn get_p_mem_admission_control_enabled(&self) -> Option<bool> { self.p_mem_admission_control_enabled }
}
impl ClusterDasAdmissionControlPolicyTrait for ClusterFailoverHostAdmissionControlPolicy {
    fn get_resource_reduction_to_tolerate_percent(&self) -> Option<i32> { self.resource_reduction_to_tolerate_percent }
    fn get_p_mem_admission_control_enabled(&self) -> Option<bool> { self.p_mem_admission_control_enabled }
}
impl ClusterDasAdmissionControlPolicyTrait for ClusterFailoverLevelAdmissionControlPolicy {
    fn get_resource_reduction_to_tolerate_percent(&self) -> Option<i32> { self.resource_reduction_to_tolerate_percent }
    fn get_p_mem_admission_control_enabled(&self) -> Option<bool> { self.p_mem_admission_control_enabled }
}
impl ClusterDasAdmissionControlPolicyTrait for ClusterFailoverResourcesAdmissionControlPolicy {
    fn get_resource_reduction_to_tolerate_percent(&self) -> Option<i32> { self.resource_reduction_to_tolerate_percent }
    fn get_p_mem_admission_control_enabled(&self) -> Option<bool> { self.p_mem_admission_control_enabled }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ClusterDasAdmissionControlPolicyTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterDasAdmissionControlPolicy => Some(from.as_any_ref().downcast_ref::<ClusterDasAdmissionControlPolicy>()?),
            StructType::ClusterFailoverHostAdmissionControlPolicy => Some(from.as_any_ref().downcast_ref::<ClusterFailoverHostAdmissionControlPolicy>()?),
            StructType::ClusterFailoverLevelAdmissionControlPolicy => Some(from.as_any_ref().downcast_ref::<ClusterFailoverLevelAdmissionControlPolicy>()?),
            StructType::ClusterFailoverResourcesAdmissionControlPolicy => Some(from.as_any_ref().downcast_ref::<ClusterFailoverResourcesAdmissionControlPolicy>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterDasAdmissionControlPolicy => Ok(from.as_any_box().downcast::<ClusterDasAdmissionControlPolicy>()?),
            StructType::ClusterFailoverHostAdmissionControlPolicy => Ok(from.as_any_box().downcast::<ClusterFailoverHostAdmissionControlPolicy>()?),
            StructType::ClusterFailoverLevelAdmissionControlPolicy => Ok(from.as_any_box().downcast::<ClusterFailoverLevelAdmissionControlPolicy>()?),
            StructType::ClusterFailoverResourcesAdmissionControlPolicy => Ok(from.as_any_box().downcast::<ClusterFailoverResourcesAdmissionControlPolicy>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class for advanced runtime information related to the high
/// availability service for a cluster.
pub trait ClusterDasAdvancedRuntimeInfoTrait : super::traits::DataObjectTrait {
    /// The information pertaining to the HA agents on the hosts
    fn get_das_host_info(&self) -> &Option<Box<dyn super::traits::ClusterDasHostInfoTrait>>;
    /// Whether HA VM Component Protection can be enabled for the cluster.
    fn get_vmcp_supported(&self) -> &Option<ClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo>;
    /// The map of a datastore to the set of hosts that are using
    /// the datastore for storage heartbeating.
    fn get_heartbeat_datastore_info(&self) -> &Option<Vec<DasHeartbeatDatastoreInfo>>;
}
impl<'s> serde::Serialize for dyn ClusterDasAdvancedRuntimeInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ClusterDasAdvancedRuntimeInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ClusterDasAdvancedRuntimeInfoVisitor)
            }
        }

struct ClusterDasAdvancedRuntimeInfoVisitor;

impl<'de> de::Visitor<'de> for ClusterDasAdvancedRuntimeInfoVisitor {
    type Value = Box<dyn ClusterDasAdvancedRuntimeInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ClusterDasAdvancedRuntimeInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ClusterDasAdvancedRuntimeInfoTrait for ClusterDasAdvancedRuntimeInfo {
    fn get_das_host_info(&self) -> &Option<Box<dyn super::traits::ClusterDasHostInfoTrait>> { &self.das_host_info }
    fn get_vmcp_supported(&self) -> &Option<ClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo> { &self.vmcp_supported }
    fn get_heartbeat_datastore_info(&self) -> &Option<Vec<DasHeartbeatDatastoreInfo>> { &self.heartbeat_datastore_info }
}
impl ClusterDasAdvancedRuntimeInfoTrait for ClusterDasFailoverLevelAdvancedRuntimeInfo {
    fn get_das_host_info(&self) -> &Option<Box<dyn super::traits::ClusterDasHostInfoTrait>> { &self.das_host_info }
    fn get_vmcp_supported(&self) -> &Option<ClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo> { &self.vmcp_supported }
    fn get_heartbeat_datastore_info(&self) -> &Option<Vec<DasHeartbeatDatastoreInfo>> { &self.heartbeat_datastore_info }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ClusterDasAdvancedRuntimeInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterDasAdvancedRuntimeInfo => Some(from.as_any_ref().downcast_ref::<ClusterDasAdvancedRuntimeInfo>()?),
            StructType::ClusterDasFailoverLevelAdvancedRuntimeInfo => Some(from.as_any_ref().downcast_ref::<ClusterDasFailoverLevelAdvancedRuntimeInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterDasAdvancedRuntimeInfo => Ok(from.as_any_box().downcast::<ClusterDasAdvancedRuntimeInfo>()?),
            StructType::ClusterDasFailoverLevelAdvancedRuntimeInfo => Ok(from.as_any_box().downcast::<ClusterDasFailoverLevelAdvancedRuntimeInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class for DAS data for high availability service for a cluster.
pub trait ClusterDasDataTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn ClusterDasDataTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ClusterDasDataTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ClusterDasDataVisitor)
            }
        }

struct ClusterDasDataVisitor;

impl<'de> de::Visitor<'de> for ClusterDasDataVisitor {
    type Value = Box<dyn ClusterDasDataTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ClusterDasDataTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ClusterDasDataTrait for ClusterDasData {
}
impl ClusterDasDataTrait for ClusterDasDataSummary {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ClusterDasDataTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterDasData => Some(from.as_any_ref().downcast_ref::<ClusterDasData>()?),
            StructType::ClusterDasDataSummary => Some(from.as_any_ref().downcast_ref::<ClusterDasDataSummary>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterDasData => Ok(from.as_any_box().downcast::<ClusterDasData>()?),
            StructType::ClusterDasDataSummary => Ok(from.as_any_box().downcast::<ClusterDasDataSummary>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// HA specific advanced information pertaining to the hosts in the cluster.
pub trait ClusterDasHostInfoTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn ClusterDasHostInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ClusterDasHostInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ClusterDasHostInfoVisitor)
            }
        }

struct ClusterDasHostInfoVisitor;

impl<'de> de::Visitor<'de> for ClusterDasHostInfoVisitor {
    type Value = Box<dyn ClusterDasHostInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ClusterDasHostInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ClusterDasHostInfoTrait for ClusterDasHostInfo {
}
impl ClusterDasHostInfoTrait for ClusterDasAamHostInfo {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ClusterDasHostInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterDasHostInfo => Some(from.as_any_ref().downcast_ref::<ClusterDasHostInfo>()?),
            StructType::ClusterDasAamHostInfo => Some(from.as_any_ref().downcast_ref::<ClusterDasAamHostInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterDasHostInfo => Ok(from.as_any_box().downcast::<ClusterDasHostInfo>()?),
            StructType::ClusterDasAamHostInfo => Ok(from.as_any_box().downcast::<ClusterDasAamHostInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// FaultsByVm is the faults generated by DRS when it tries to
/// move a VM.
pub trait ClusterDrsFaultsFaultsByVmTrait : super::traits::DataObjectTrait {
    /// The VM that DRS was trying to migrate when it generated the faults.
    /// 
    /// If this property is NULL, the fault is not associated with a particular VM.
    /// 
    /// Refers instance of *VirtualMachine*.
    fn get_vm(&self) -> &Option<ManagedObjectReference>;
    /// The faults generated by DRS when it was trying to move the given VM.
    fn get_fault(&self) -> &Vec<MethodFault>;
}
impl<'s> serde::Serialize for dyn ClusterDrsFaultsFaultsByVmTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ClusterDrsFaultsFaultsByVmTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ClusterDrsFaultsFaultsByVmVisitor)
            }
        }

struct ClusterDrsFaultsFaultsByVmVisitor;

impl<'de> de::Visitor<'de> for ClusterDrsFaultsFaultsByVmVisitor {
    type Value = Box<dyn ClusterDrsFaultsFaultsByVmTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ClusterDrsFaultsFaultsByVmTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ClusterDrsFaultsFaultsByVmTrait for ClusterDrsFaultsFaultsByVm {
    fn get_vm(&self) -> &Option<ManagedObjectReference> { &self.vm }
    fn get_fault(&self) -> &Vec<MethodFault> { &self.fault }
}
impl ClusterDrsFaultsFaultsByVmTrait for ClusterDrsFaultsFaultsByVirtualDisk {
    fn get_vm(&self) -> &Option<ManagedObjectReference> { &self.vm }
    fn get_fault(&self) -> &Vec<MethodFault> { &self.fault }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ClusterDrsFaultsFaultsByVmTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterDrsFaultsFaultsByVm => Some(from.as_any_ref().downcast_ref::<ClusterDrsFaultsFaultsByVm>()?),
            StructType::ClusterDrsFaultsFaultsByVirtualDisk => Some(from.as_any_ref().downcast_ref::<ClusterDrsFaultsFaultsByVirtualDisk>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterDrsFaultsFaultsByVm => Ok(from.as_any_box().downcast::<ClusterDrsFaultsFaultsByVm>()?),
            StructType::ClusterDrsFaultsFaultsByVirtualDisk => Ok(from.as_any_box().downcast::<ClusterDrsFaultsFaultsByVirtualDisk>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// *ClusterGroupInfo* is the base type for all virtual machine
/// and host groups.
/// 
/// All virtual machines and hosts that are part of a group
/// must be part of the same cluster.
pub trait ClusterGroupInfoTrait : super::traits::DataObjectTrait {
    /// Unique name of the group.
    fn get_name(&self) -> &str;
    /// Flag to indicate whether the group is created by the user or the system.
    fn get_user_created(&self) -> Option<bool>;
    /// Unique ID for the group.
    /// 
    /// uniqueID is unique within a cluster.
    /// Groups residing in different clusters might share a uniqueID.
    fn get_unique_id(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn ClusterGroupInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ClusterGroupInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ClusterGroupInfoVisitor)
            }
        }

struct ClusterGroupInfoVisitor;

impl<'de> de::Visitor<'de> for ClusterGroupInfoVisitor {
    type Value = Box<dyn ClusterGroupInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ClusterGroupInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ClusterGroupInfoTrait for ClusterGroupInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_user_created(&self) -> Option<bool> { self.user_created }
    fn get_unique_id(&self) -> &Option<String> { &self.unique_id }
}
impl ClusterGroupInfoTrait for ClusterHostGroup {
    fn get_name(&self) -> &str { &self.name }
    fn get_user_created(&self) -> Option<bool> { self.user_created }
    fn get_unique_id(&self) -> &Option<String> { &self.unique_id }
}
impl ClusterGroupInfoTrait for ClusterVmGroup {
    fn get_name(&self) -> &str { &self.name }
    fn get_user_created(&self) -> Option<bool> { self.user_created }
    fn get_unique_id(&self) -> &Option<String> { &self.unique_id }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ClusterGroupInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterGroupInfo => Some(from.as_any_ref().downcast_ref::<ClusterGroupInfo>()?),
            StructType::ClusterHostGroup => Some(from.as_any_ref().downcast_ref::<ClusterHostGroup>()?),
            StructType::ClusterVmGroup => Some(from.as_any_ref().downcast_ref::<ClusterVmGroup>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterGroupInfo => Ok(from.as_any_box().downcast::<ClusterGroupInfo>()?),
            StructType::ClusterHostGroup => Ok(from.as_any_box().downcast::<ClusterHostGroup>()?),
            StructType::ClusterVmGroup => Ok(from.as_any_box().downcast::<ClusterVmGroup>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *ClusterRuleInfo* data object is the base type for affinity
/// and anti-affinity rules.
/// 
/// The affinity and anti-affinity rules
/// are DRS (Distributed Resource Scheduling) rules that affect the placement
/// of virtual machines in a cluster. Hosts and virtual machines referenced
/// in a DRS rule must be in the same cluster.
/// 
/// Note: DRS rules are different than an individual host's CPU affinity rules
/// (*VirtualMachineAffinityInfo*).
/// 
/// The Server uses DRS rule objects to describe the current rule configuration
/// (*ClusterConfigInfoEx*.*ClusterConfigInfoEx.rule*).
/// Your client application uses rule objects to configure the affinity and
/// anti-affinity rules
/// (*ClusterConfigSpecEx*.*ClusterConfigSpecEx.rulesSpec*).
/// 
/// You can create the following types of rules:
/// - An affinity rule defines a set of virtual machines that should run
///   on the same host.
///   The *ClusterAffinityRuleSpec* object describes a rule that
///   identifies virtual machines, but does not identify any specific host.
/// - An anti-affinity rule defines a set of virtual machines that should run
///   on different hosts.
///   The *ClusterAntiAffinityRuleSpec* object describes a rule that
///   identifies virtual machines, but does not identify any specific host.
/// - A VM-Host rule defines affinity and anti-affinity relationships between
///   virtual machines and hosts.
///   The *ClusterVmHostRuleInfo* object describes a rule that identifies
///   a virtual machine group (*ClusterVmGroup*) and affinity and
///   anti-affinity host groups (*ClusterHostGroup*).
///   
/// Rule configuration is a dynamic process. When you create or modify a DRS rule,
/// the Server applies the rule to the cluster. If the existing cluster configuration
/// violates the rule, the Server attempts to correct the situation. If that is not
/// possible, the Server generates a fault and produces a log event.
/// DRS rules do not have precedence; all rules are applied equally.
/// DRS does not validate one rule against another. If you create conflicting
/// rules, the older rule takes precedence and DRS disables the newer rule.
/// 
/// Improperly used, DRS rules can fragment the cluster and inhibit the proper
/// functioning of DRS, HA, and DPM services. vSphere services never
/// take any actions that would result in the violation of mandatory DRS rules.
/// An operation that violates a mandatory rule would produce the following
/// consequences.
/// - DRS does not evacuate virtual machines to place a host in maintenance
///   mode.
/// - DRS does not place virtual machines for power-on or load balance virtual
///   machines.
/// - HA does not perform failovers.
/// - DPM does not optimize power management by placing hosts into standby
///   mode.
///   
/// To avoid these situations, exercise caution when creating more than one
/// mandatory rule, or consider using only optional rules. Make sure that
/// the number of hosts with which a virtual machine is related by affinity rule
/// is large enough that losing a host does not prevent the virtual machine
/// from running.
/// 
/// For manual and partially automated DRS clusters, the Server produces migration
/// recommendations to satisfy the DRS rules. You are not required to act on the
/// recommendations, but the Server maintains the recommendations until the rules
/// are satisfied.
pub trait ClusterRuleInfoTrait : super::traits::DataObjectTrait {
    /// Unique ID for rules.
    /// 
    /// When adding a new rule, do not specify this property.
    /// The Server will assign the key.
    fn get_key(&self) -> Option<i32>;
    /// Flag to indicate whether or not the rule is currently satisfied.
    fn get_status(&self) -> &Option<super::enums::ManagedEntityStatusEnum>;
    /// Flag to indicate whether or not the rule is enabled.
    /// 
    /// Set this property
    /// when you configure the rule. The default value is false (disabled).
    /// If there is a rule conflict, the Server can override the setting to disable
    /// a rule.
    fn get_enabled(&self) -> Option<bool>;
    /// Name of the rule.
    fn get_name(&self) -> &Option<String>;
    /// Flag to indicate whether compliance with this rule is mandatory or optional.
    /// 
    /// The default value is false (optional).
    /// - A mandatory rule will prevent a virtual machine from being powered on
    ///   or migrated to a host that does not satisfy the rule.
    /// - An optional rule specifies a preference. DRS takes an optional rule
    ///   into consideration when it places a virtual machine in the cluster.
    ///   DRS will act on an optional rule as long as it does not impact
    ///   the ability of the host to satisfy current CPU or memory requirements
    ///   for virtual machines on the system. (As long as the operation does not
    ///   cause any host to be more than 100% utilized.)
    fn get_mandatory(&self) -> Option<bool>;
    /// Flag to indicate whether the rule is created by the user or the system.
    fn get_user_created(&self) -> Option<bool>;
    /// Flag to indicate whether or not the placement of Virtual Machines is currently
    /// in compliance with this rule.
    /// 
    /// The Server does not currently use this property.
    fn get_in_compliance(&self) -> Option<bool>;
    /// UUID for the rule.
    /// 
    /// When adding a new rule, do not specify this
    /// property. The Server will assign the key.
    fn get_rule_uuid(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn ClusterRuleInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ClusterRuleInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ClusterRuleInfoVisitor)
            }
        }

struct ClusterRuleInfoVisitor;

impl<'de> de::Visitor<'de> for ClusterRuleInfoVisitor {
    type Value = Box<dyn ClusterRuleInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ClusterRuleInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ClusterRuleInfoTrait for ClusterRuleInfo {
    fn get_key(&self) -> Option<i32> { self.key }
    fn get_status(&self) -> &Option<super::enums::ManagedEntityStatusEnum> { &self.status }
    fn get_enabled(&self) -> Option<bool> { self.enabled }
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_mandatory(&self) -> Option<bool> { self.mandatory }
    fn get_user_created(&self) -> Option<bool> { self.user_created }
    fn get_in_compliance(&self) -> Option<bool> { self.in_compliance }
    fn get_rule_uuid(&self) -> &Option<String> { &self.rule_uuid }
}
impl ClusterRuleInfoTrait for ClusterAffinityRuleSpec {
    fn get_key(&self) -> Option<i32> { self.key }
    fn get_status(&self) -> &Option<super::enums::ManagedEntityStatusEnum> { &self.status }
    fn get_enabled(&self) -> Option<bool> { self.enabled }
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_mandatory(&self) -> Option<bool> { self.mandatory }
    fn get_user_created(&self) -> Option<bool> { self.user_created }
    fn get_in_compliance(&self) -> Option<bool> { self.in_compliance }
    fn get_rule_uuid(&self) -> &Option<String> { &self.rule_uuid }
}
impl ClusterRuleInfoTrait for ClusterAntiAffinityRuleSpec {
    fn get_key(&self) -> Option<i32> { self.key }
    fn get_status(&self) -> &Option<super::enums::ManagedEntityStatusEnum> { &self.status }
    fn get_enabled(&self) -> Option<bool> { self.enabled }
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_mandatory(&self) -> Option<bool> { self.mandatory }
    fn get_user_created(&self) -> Option<bool> { self.user_created }
    fn get_in_compliance(&self) -> Option<bool> { self.in_compliance }
    fn get_rule_uuid(&self) -> &Option<String> { &self.rule_uuid }
}
impl ClusterRuleInfoTrait for ClusterDependencyRuleInfo {
    fn get_key(&self) -> Option<i32> { self.key }
    fn get_status(&self) -> &Option<super::enums::ManagedEntityStatusEnum> { &self.status }
    fn get_enabled(&self) -> Option<bool> { self.enabled }
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_mandatory(&self) -> Option<bool> { self.mandatory }
    fn get_user_created(&self) -> Option<bool> { self.user_created }
    fn get_in_compliance(&self) -> Option<bool> { self.in_compliance }
    fn get_rule_uuid(&self) -> &Option<String> { &self.rule_uuid }
}
impl ClusterRuleInfoTrait for ClusterVmHostRuleInfo {
    fn get_key(&self) -> Option<i32> { self.key }
    fn get_status(&self) -> &Option<super::enums::ManagedEntityStatusEnum> { &self.status }
    fn get_enabled(&self) -> Option<bool> { self.enabled }
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_mandatory(&self) -> Option<bool> { self.mandatory }
    fn get_user_created(&self) -> Option<bool> { self.user_created }
    fn get_in_compliance(&self) -> Option<bool> { self.in_compliance }
    fn get_rule_uuid(&self) -> &Option<String> { &self.rule_uuid }
}
impl ClusterRuleInfoTrait for VirtualDiskAntiAffinityRuleSpec {
    fn get_key(&self) -> Option<i32> { self.key }
    fn get_status(&self) -> &Option<super::enums::ManagedEntityStatusEnum> { &self.status }
    fn get_enabled(&self) -> Option<bool> { self.enabled }
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_mandatory(&self) -> Option<bool> { self.mandatory }
    fn get_user_created(&self) -> Option<bool> { self.user_created }
    fn get_in_compliance(&self) -> Option<bool> { self.in_compliance }
    fn get_rule_uuid(&self) -> &Option<String> { &self.rule_uuid }
}
impl ClusterRuleInfoTrait for VirtualDiskRuleSpec {
    fn get_key(&self) -> Option<i32> { self.key }
    fn get_status(&self) -> &Option<super::enums::ManagedEntityStatusEnum> { &self.status }
    fn get_enabled(&self) -> Option<bool> { self.enabled }
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_mandatory(&self) -> Option<bool> { self.mandatory }
    fn get_user_created(&self) -> Option<bool> { self.user_created }
    fn get_in_compliance(&self) -> Option<bool> { self.in_compliance }
    fn get_rule_uuid(&self) -> &Option<String> { &self.rule_uuid }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ClusterRuleInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterRuleInfo => Some(from.as_any_ref().downcast_ref::<ClusterRuleInfo>()?),
            StructType::ClusterAffinityRuleSpec => Some(from.as_any_ref().downcast_ref::<ClusterAffinityRuleSpec>()?),
            StructType::ClusterAntiAffinityRuleSpec => Some(from.as_any_ref().downcast_ref::<ClusterAntiAffinityRuleSpec>()?),
            StructType::ClusterDependencyRuleInfo => Some(from.as_any_ref().downcast_ref::<ClusterDependencyRuleInfo>()?),
            StructType::ClusterVmHostRuleInfo => Some(from.as_any_ref().downcast_ref::<ClusterVmHostRuleInfo>()?),
            StructType::VirtualDiskAntiAffinityRuleSpec => Some(from.as_any_ref().downcast_ref::<VirtualDiskAntiAffinityRuleSpec>()?),
            StructType::VirtualDiskRuleSpec => Some(from.as_any_ref().downcast_ref::<VirtualDiskRuleSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterRuleInfo => Ok(from.as_any_box().downcast::<ClusterRuleInfo>()?),
            StructType::ClusterAffinityRuleSpec => Ok(from.as_any_box().downcast::<ClusterAffinityRuleSpec>()?),
            StructType::ClusterAntiAffinityRuleSpec => Ok(from.as_any_box().downcast::<ClusterAntiAffinityRuleSpec>()?),
            StructType::ClusterDependencyRuleInfo => Ok(from.as_any_box().downcast::<ClusterDependencyRuleInfo>()?),
            StructType::ClusterVmHostRuleInfo => Ok(from.as_any_box().downcast::<ClusterVmHostRuleInfo>()?),
            StructType::VirtualDiskAntiAffinityRuleSpec => Ok(from.as_any_box().downcast::<VirtualDiskAntiAffinityRuleSpec>()?),
            StructType::VirtualDiskRuleSpec => Ok(from.as_any_box().downcast::<VirtualDiskRuleSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The base class *ClusterSlotPolicy* is used for specifying how
/// the slot size is to be computed for the failover level HA admission control
/// policy.
/// 
/// By default, vSphere HA defines the slot size using the largest memory
/// and cpu reservations of any powered on virtual machine in the cluster.
/// Subclasses of this class define various policies to modify how the slot size
/// is chosen to prevent outlier virtual machines (i.e. those with much larger
/// reservations than the average) from skewing the slot size. If such a policy is chosen,
/// outlier virtual machines will use multiple slots. Using such a policy introduces
/// a risk that vSphere HA will be unable to failover these virtual machines because
/// of resource fragmentation.
pub trait ClusterSlotPolicyTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn ClusterSlotPolicyTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ClusterSlotPolicyTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ClusterSlotPolicyVisitor)
            }
        }

struct ClusterSlotPolicyVisitor;

impl<'de> de::Visitor<'de> for ClusterSlotPolicyVisitor {
    type Value = Box<dyn ClusterSlotPolicyTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ClusterSlotPolicyTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ClusterSlotPolicyTrait for ClusterSlotPolicy {
}
impl ClusterSlotPolicyTrait for ClusterFixedSizeSlotPolicy {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ClusterSlotPolicyTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterSlotPolicy => Some(from.as_any_ref().downcast_ref::<ClusterSlotPolicy>()?),
            StructType::ClusterFixedSizeSlotPolicy => Some(from.as_any_ref().downcast_ref::<ClusterFixedSizeSlotPolicy>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterSlotPolicy => Ok(from.as_any_box().downcast::<ClusterSlotPolicy>()?),
            StructType::ClusterFixedSizeSlotPolicy => Ok(from.as_any_box().downcast::<ClusterFixedSizeSlotPolicy>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *DVPortSetting* data object
/// describes the network configuration of a *DistributedVirtualPort*.
pub trait DvPortSettingTrait : super::traits::DataObjectTrait {
    /// Indicates whether this port is blocked.
    /// 
    /// If a port is blocked,
    /// packet forwarding is stopped.
    fn get_blocked(&self) -> &Option<BoolPolicy>;
    /// Deprecated as of vSphere API 8.0. VMDirectPath Gen 2 is no longer supported and
    /// there is no replacement.
    /// 
    /// Indicates whether this port is allowed to do VMDirectPath Gen2 network passthrough.
    /// 
    /// Direct path capability is defined at host, switch, and device levels.
    /// See the <code>vmDirectPathGen2Supported</code> properties on the
    /// *DVSFeatureCapability*,
    /// *HostCapability*, *PhysicalNic*,
    /// and *VirtualEthernetCardOption* objects.
    fn get_vm_direct_path_gen_2_allowed(&self) -> &Option<BoolPolicy>;
    /// Network shaping policy for controlling throughput of inbound traffic.
    fn get_in_shaping_policy(&self) -> &Option<DvsTrafficShapingPolicy>;
    /// Network shaping policy for controlling throughput of outbound traffic.
    fn get_out_shaping_policy(&self) -> &Option<DvsTrafficShapingPolicy>;
    /// Opaque binary blob that stores vendor specific configuration.
    fn get_vendor_specific_config(&self) -> &Option<DvsVendorSpecificConfig>;
    /// Deprecated as of vSphere API 6.0
    /// Use *DVPortgroupConfigInfo.vmVnicNetworkResourcePoolKey* instead
    /// to reference the virtual NIC network resource pool.
    /// 
    /// The key of user defined network resource pool to be associated with a port.
    /// 
    /// The default value for this property is "-1", indicating that
    /// this port is not associated with any network resource pool.
    fn get_network_resource_pool_key(&self) -> &Option<StringPolicy>;
    /// Configuration for Network Filter Policy.
    fn get_filter_policy(&self) -> &Option<DvsFilterPolicy>;
}
impl<'s> serde::Serialize for dyn DvPortSettingTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DvPortSettingTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DvPortSettingVisitor)
            }
        }

struct DvPortSettingVisitor;

impl<'de> de::Visitor<'de> for DvPortSettingVisitor {
    type Value = Box<dyn DvPortSettingTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DvPortSettingTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DvPortSettingTrait for DvPortSetting {
    fn get_blocked(&self) -> &Option<BoolPolicy> { &self.blocked }
    fn get_vm_direct_path_gen_2_allowed(&self) -> &Option<BoolPolicy> { &self.vm_direct_path_gen_2_allowed }
    fn get_in_shaping_policy(&self) -> &Option<DvsTrafficShapingPolicy> { &self.in_shaping_policy }
    fn get_out_shaping_policy(&self) -> &Option<DvsTrafficShapingPolicy> { &self.out_shaping_policy }
    fn get_vendor_specific_config(&self) -> &Option<DvsVendorSpecificConfig> { &self.vendor_specific_config }
    fn get_network_resource_pool_key(&self) -> &Option<StringPolicy> { &self.network_resource_pool_key }
    fn get_filter_policy(&self) -> &Option<DvsFilterPolicy> { &self.filter_policy }
}
impl DvPortSettingTrait for VMwareDvsPortSetting {
    fn get_blocked(&self) -> &Option<BoolPolicy> { &self.blocked }
    fn get_vm_direct_path_gen_2_allowed(&self) -> &Option<BoolPolicy> { &self.vm_direct_path_gen_2_allowed }
    fn get_in_shaping_policy(&self) -> &Option<DvsTrafficShapingPolicy> { &self.in_shaping_policy }
    fn get_out_shaping_policy(&self) -> &Option<DvsTrafficShapingPolicy> { &self.out_shaping_policy }
    fn get_vendor_specific_config(&self) -> &Option<DvsVendorSpecificConfig> { &self.vendor_specific_config }
    fn get_network_resource_pool_key(&self) -> &Option<StringPolicy> { &self.network_resource_pool_key }
    fn get_filter_policy(&self) -> &Option<DvsFilterPolicy> { &self.filter_policy }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DvPortSettingTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvPortSetting => Some(from.as_any_ref().downcast_ref::<DvPortSetting>()?),
            StructType::VMwareDvsPortSetting => Some(from.as_any_ref().downcast_ref::<VMwareDvsPortSetting>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvPortSetting => Ok(from.as_any_box().downcast::<DvPortSetting>()?),
            StructType::VMwareDvsPortSetting => Ok(from.as_any_box().downcast::<VMwareDvsPortSetting>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The DistributedVirtualPortgroup policies.
/// 
/// This field is not applicable
/// when queried directly against an ESX host.
pub trait DvPortgroupPolicyTrait : super::traits::DataObjectTrait {
    /// Allow the *DVPortSetting.blocked* setting
    /// of an individual port to override the setting in
    /// *DVPortgroupConfigInfo.defaultPortConfig* of
    /// a portgroup.
    fn get_block_override_allowed(&self) -> bool;
    /// Allow the *DVPortSetting.inShapingPolicy* or
    /// *DVPortSetting.outShapingPolicy* settings
    /// of an individual port to override the setting in
    /// *DVPortgroupConfigInfo.defaultPortConfig* of
    /// a portgroup.
    fn get_shaping_override_allowed(&self) -> bool;
    /// Allow the *DVPortSetting.vendorSpecificConfig*
    /// setting of an individual port to override the setting in
    /// *DVPortgroupConfigInfo.defaultPortConfig* of
    /// a portgroup.
    fn get_vendor_config_override_allowed(&self) -> bool;
    /// Allow a live port to be moved in and out of the portgroup.
    fn get_live_port_moving_allowed(&self) -> bool;
    /// If true, reset the port network setting back to the portgroup setting
    /// (thus removing the per-port setting) when the port is disconnected from
    /// the connectee.
    fn get_port_config_reset_at_disconnect(&self) -> bool;
    /// Allow the setting of
    /// *DVPortSetting.networkResourcePoolKey* of an
    /// individual port to override the setting in
    /// *DVPortgroupConfigInfo.defaultPortConfig*
    /// of a portgroup.
    fn get_network_resource_pool_override_allowed(&self) -> Option<bool>;
    /// Allow the setting of
    /// *DVPortSetting.filterPolicy*,
    /// for an individual port to override the setting in
    /// *DVPortgroupConfigInfo.defaultPortConfig* of
    /// a portgroup.
    fn get_traffic_filter_override_allowed(&self) -> Option<bool>;
}
impl<'s> serde::Serialize for dyn DvPortgroupPolicyTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DvPortgroupPolicyTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DvPortgroupPolicyVisitor)
            }
        }

struct DvPortgroupPolicyVisitor;

impl<'de> de::Visitor<'de> for DvPortgroupPolicyVisitor {
    type Value = Box<dyn DvPortgroupPolicyTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DvPortgroupPolicyTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DvPortgroupPolicyTrait for DvPortgroupPolicy {
    fn get_block_override_allowed(&self) -> bool { self.block_override_allowed }
    fn get_shaping_override_allowed(&self) -> bool { self.shaping_override_allowed }
    fn get_vendor_config_override_allowed(&self) -> bool { self.vendor_config_override_allowed }
    fn get_live_port_moving_allowed(&self) -> bool { self.live_port_moving_allowed }
    fn get_port_config_reset_at_disconnect(&self) -> bool { self.port_config_reset_at_disconnect }
    fn get_network_resource_pool_override_allowed(&self) -> Option<bool> { self.network_resource_pool_override_allowed }
    fn get_traffic_filter_override_allowed(&self) -> Option<bool> { self.traffic_filter_override_allowed }
}
impl DvPortgroupPolicyTrait for VMwareDvsPortgroupPolicy {
    fn get_block_override_allowed(&self) -> bool { self.block_override_allowed }
    fn get_shaping_override_allowed(&self) -> bool { self.shaping_override_allowed }
    fn get_vendor_config_override_allowed(&self) -> bool { self.vendor_config_override_allowed }
    fn get_live_port_moving_allowed(&self) -> bool { self.live_port_moving_allowed }
    fn get_port_config_reset_at_disconnect(&self) -> bool { self.port_config_reset_at_disconnect }
    fn get_network_resource_pool_override_allowed(&self) -> Option<bool> { self.network_resource_pool_override_allowed }
    fn get_traffic_filter_override_allowed(&self) -> Option<bool> { self.traffic_filter_override_allowed }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DvPortgroupPolicyTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvPortgroupPolicy => Some(from.as_any_ref().downcast_ref::<DvPortgroupPolicy>()?),
            StructType::VMwareDvsPortgroupPolicy => Some(from.as_any_ref().downcast_ref::<VMwareDvsPortgroupPolicy>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvPortgroupPolicy => Ok(from.as_any_box().downcast::<DvPortgroupPolicy>()?),
            StructType::VMwareDvsPortgroupPolicy => Ok(from.as_any_box().downcast::<VMwareDvsPortgroupPolicy>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class for filters to check host compatibility.
pub trait DistributedVirtualSwitchManagerHostDvsFilterSpecTrait : super::traits::DataObjectTrait {
    /// If this flag is true, then the filter returns the hosts in the
    /// *DistributedVirtualSwitchManagerHostContainer*
    /// that satisfy the criteria specified by this filter, otherwise
    /// it returns hosts that don't meet the criteria.
    fn get_inclusive(&self) -> bool;
}
impl<'s> serde::Serialize for dyn DistributedVirtualSwitchManagerHostDvsFilterSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DistributedVirtualSwitchManagerHostDvsFilterSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DistributedVirtualSwitchManagerHostDvsFilterSpecVisitor)
            }
        }

struct DistributedVirtualSwitchManagerHostDvsFilterSpecVisitor;

impl<'de> de::Visitor<'de> for DistributedVirtualSwitchManagerHostDvsFilterSpecVisitor {
    type Value = Box<dyn DistributedVirtualSwitchManagerHostDvsFilterSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DistributedVirtualSwitchManagerHostDvsFilterSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DistributedVirtualSwitchManagerHostDvsFilterSpecTrait for DistributedVirtualSwitchManagerHostDvsFilterSpec {
    fn get_inclusive(&self) -> bool { self.inclusive }
}
impl DistributedVirtualSwitchManagerHostDvsFilterSpecTrait for DistributedVirtualSwitchManagerHostArrayFilter {
    fn get_inclusive(&self) -> bool { self.inclusive }
}
impl DistributedVirtualSwitchManagerHostDvsFilterSpecTrait for DistributedVirtualSwitchManagerHostContainerFilter {
    fn get_inclusive(&self) -> bool { self.inclusive }
}
impl DistributedVirtualSwitchManagerHostDvsFilterSpecTrait for DistributedVirtualSwitchManagerHostDvsMembershipFilter {
    fn get_inclusive(&self) -> bool { self.inclusive }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DistributedVirtualSwitchManagerHostDvsFilterSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DistributedVirtualSwitchManagerHostDvsFilterSpec => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchManagerHostDvsFilterSpec>()?),
            StructType::DistributedVirtualSwitchManagerHostArrayFilter => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchManagerHostArrayFilter>()?),
            StructType::DistributedVirtualSwitchManagerHostContainerFilter => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchManagerHostContainerFilter>()?),
            StructType::DistributedVirtualSwitchManagerHostDvsMembershipFilter => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchManagerHostDvsMembershipFilter>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DistributedVirtualSwitchManagerHostDvsFilterSpec => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchManagerHostDvsFilterSpec>()?),
            StructType::DistributedVirtualSwitchManagerHostArrayFilter => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchManagerHostArrayFilter>()?),
            StructType::DistributedVirtualSwitchManagerHostContainerFilter => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchManagerHostContainerFilter>()?),
            StructType::DistributedVirtualSwitchManagerHostDvsMembershipFilter => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchManagerHostDvsMembershipFilter>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class.
pub trait DistributedVirtualSwitchHostMemberBackingTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn DistributedVirtualSwitchHostMemberBackingTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DistributedVirtualSwitchHostMemberBackingTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DistributedVirtualSwitchHostMemberBackingVisitor)
            }
        }

struct DistributedVirtualSwitchHostMemberBackingVisitor;

impl<'de> de::Visitor<'de> for DistributedVirtualSwitchHostMemberBackingVisitor {
    type Value = Box<dyn DistributedVirtualSwitchHostMemberBackingTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DistributedVirtualSwitchHostMemberBackingTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DistributedVirtualSwitchHostMemberBackingTrait for DistributedVirtualSwitchHostMemberBacking {
}
impl DistributedVirtualSwitchHostMemberBackingTrait for DistributedVirtualSwitchHostMemberPnicBacking {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DistributedVirtualSwitchHostMemberBackingTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DistributedVirtualSwitchHostMemberBacking => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchHostMemberBacking>()?),
            StructType::DistributedVirtualSwitchHostMemberPnicBacking => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchHostMemberPnicBacking>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DistributedVirtualSwitchHostMemberBacking => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchHostMemberBacking>()?),
            StructType::DistributedVirtualSwitchHostMemberPnicBacking => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchHostMemberPnicBacking>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This class defines healthcheck result of the vSphere Distributed Switch.
pub trait HostMemberHealthCheckResultTrait : super::traits::DataObjectTrait {
    /// The summary of health check result.
    fn get_summary(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn HostMemberHealthCheckResultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostMemberHealthCheckResultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostMemberHealthCheckResultVisitor)
            }
        }

struct HostMemberHealthCheckResultVisitor;

impl<'de> de::Visitor<'de> for HostMemberHealthCheckResultVisitor {
    type Value = Box<dyn HostMemberHealthCheckResultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostMemberHealthCheckResultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostMemberHealthCheckResultTrait for HostMemberHealthCheckResult {
    fn get_summary(&self) -> &Option<String> { &self.summary }
}
impl HostMemberHealthCheckResultTrait for HostMemberUplinkHealthCheckResult {
    fn get_summary(&self) -> &Option<String> { &self.summary }
}
impl HostMemberHealthCheckResultTrait for VMwareDvsMtuHealthCheckResult {
    fn get_summary(&self) -> &Option<String> { &self.summary }
}
impl HostMemberHealthCheckResultTrait for VMwareDvsVlanHealthCheckResult {
    fn get_summary(&self) -> &Option<String> { &self.summary }
}
impl HostMemberHealthCheckResultTrait for VMwareDvsTeamingHealthCheckResult {
    fn get_summary(&self) -> &Option<String> { &self.summary }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostMemberHealthCheckResultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostMemberHealthCheckResult => Some(from.as_any_ref().downcast_ref::<HostMemberHealthCheckResult>()?),
            StructType::HostMemberUplinkHealthCheckResult => Some(from.as_any_ref().downcast_ref::<HostMemberUplinkHealthCheckResult>()?),
            StructType::VMwareDvsMtuHealthCheckResult => Some(from.as_any_ref().downcast_ref::<VMwareDvsMtuHealthCheckResult>()?),
            StructType::VMwareDvsVlanHealthCheckResult => Some(from.as_any_ref().downcast_ref::<VMwareDvsVlanHealthCheckResult>()?),
            StructType::VMwareDvsTeamingHealthCheckResult => Some(from.as_any_ref().downcast_ref::<VMwareDvsTeamingHealthCheckResult>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostMemberHealthCheckResult => Ok(from.as_any_box().downcast::<HostMemberHealthCheckResult>()?),
            StructType::HostMemberUplinkHealthCheckResult => Ok(from.as_any_box().downcast::<HostMemberUplinkHealthCheckResult>()?),
            StructType::VMwareDvsMtuHealthCheckResult => Ok(from.as_any_box().downcast::<VMwareDvsMtuHealthCheckResult>()?),
            StructType::VMwareDvsVlanHealthCheckResult => Ok(from.as_any_box().downcast::<VMwareDvsVlanHealthCheckResult>()?),
            StructType::VMwareDvsTeamingHealthCheckResult => Ok(from.as_any_box().downcast::<VMwareDvsTeamingHealthCheckResult>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This class defines healthcheck result of a specified Uplink port
/// in vSphere Distributed Switch.
pub trait HostMemberUplinkHealthCheckResultTrait : super::traits::HostMemberHealthCheckResultTrait {
    /// The uplink port key.
    fn get_uplink_port_key(&self) -> &str;
}
impl<'s> serde::Serialize for dyn HostMemberUplinkHealthCheckResultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostMemberUplinkHealthCheckResultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostMemberUplinkHealthCheckResultVisitor)
            }
        }

struct HostMemberUplinkHealthCheckResultVisitor;

impl<'de> de::Visitor<'de> for HostMemberUplinkHealthCheckResultVisitor {
    type Value = Box<dyn HostMemberUplinkHealthCheckResultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostMemberUplinkHealthCheckResultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostMemberUplinkHealthCheckResultTrait for HostMemberUplinkHealthCheckResult {
    fn get_uplink_port_key(&self) -> &str { &self.uplink_port_key }
}
impl HostMemberUplinkHealthCheckResultTrait for VMwareDvsMtuHealthCheckResult {
    fn get_uplink_port_key(&self) -> &str { &self.uplink_port_key }
}
impl HostMemberUplinkHealthCheckResultTrait for VMwareDvsVlanHealthCheckResult {
    fn get_uplink_port_key(&self) -> &str { &self.uplink_port_key }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostMemberUplinkHealthCheckResultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostMemberUplinkHealthCheckResult => Some(from.as_any_ref().downcast_ref::<HostMemberUplinkHealthCheckResult>()?),
            StructType::VMwareDvsMtuHealthCheckResult => Some(from.as_any_ref().downcast_ref::<VMwareDvsMtuHealthCheckResult>()?),
            StructType::VMwareDvsVlanHealthCheckResult => Some(from.as_any_ref().downcast_ref::<VMwareDvsVlanHealthCheckResult>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostMemberUplinkHealthCheckResult => Ok(from.as_any_box().downcast::<HostMemberUplinkHealthCheckResult>()?),
            StructType::VMwareDvsMtuHealthCheckResult => Ok(from.as_any_box().downcast::<VMwareDvsMtuHealthCheckResult>()?),
            StructType::VMwareDvsVlanHealthCheckResult => Ok(from.as_any_box().downcast::<VMwareDvsVlanHealthCheckResult>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This class is the base class for network rule action.
pub trait DvsNetworkRuleActionTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn DvsNetworkRuleActionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DvsNetworkRuleActionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DvsNetworkRuleActionVisitor)
            }
        }

struct DvsNetworkRuleActionVisitor;

impl<'de> de::Visitor<'de> for DvsNetworkRuleActionVisitor {
    type Value = Box<dyn DvsNetworkRuleActionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DvsNetworkRuleActionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DvsNetworkRuleActionTrait for DvsNetworkRuleAction {
}
impl DvsNetworkRuleActionTrait for DvsAcceptNetworkRuleAction {
}
impl DvsNetworkRuleActionTrait for DvsCopyNetworkRuleAction {
}
impl DvsNetworkRuleActionTrait for DvsDropNetworkRuleAction {
}
impl DvsNetworkRuleActionTrait for DvsGreEncapNetworkRuleAction {
}
impl DvsNetworkRuleActionTrait for DvsLogNetworkRuleAction {
}
impl DvsNetworkRuleActionTrait for DvsMacRewriteNetworkRuleAction {
}
impl DvsNetworkRuleActionTrait for DvsPuntNetworkRuleAction {
}
impl DvsNetworkRuleActionTrait for DvsRateLimitNetworkRuleAction {
}
impl DvsNetworkRuleActionTrait for DvsUpdateTagNetworkRuleAction {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DvsNetworkRuleActionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsNetworkRuleAction>()?),
            StructType::DvsAcceptNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsAcceptNetworkRuleAction>()?),
            StructType::DvsCopyNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsCopyNetworkRuleAction>()?),
            StructType::DvsDropNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsDropNetworkRuleAction>()?),
            StructType::DvsGreEncapNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsGreEncapNetworkRuleAction>()?),
            StructType::DvsLogNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsLogNetworkRuleAction>()?),
            StructType::DvsMacRewriteNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsMacRewriteNetworkRuleAction>()?),
            StructType::DvsPuntNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsPuntNetworkRuleAction>()?),
            StructType::DvsRateLimitNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsRateLimitNetworkRuleAction>()?),
            StructType::DvsUpdateTagNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsUpdateTagNetworkRuleAction>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsNetworkRuleAction>()?),
            StructType::DvsAcceptNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsAcceptNetworkRuleAction>()?),
            StructType::DvsCopyNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsCopyNetworkRuleAction>()?),
            StructType::DvsDropNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsDropNetworkRuleAction>()?),
            StructType::DvsGreEncapNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsGreEncapNetworkRuleAction>()?),
            StructType::DvsLogNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsLogNetworkRuleAction>()?),
            StructType::DvsMacRewriteNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsMacRewriteNetworkRuleAction>()?),
            StructType::DvsPuntNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsPuntNetworkRuleAction>()?),
            StructType::DvsRateLimitNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsRateLimitNetworkRuleAction>()?),
            StructType::DvsUpdateTagNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsUpdateTagNetworkRuleAction>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This class is the base class for identifying network traffic.
pub trait DvsNetworkRuleQualifierTrait : super::traits::DataObjectTrait {
    /// The key of the Qualifier
    fn get_key(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn DvsNetworkRuleQualifierTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DvsNetworkRuleQualifierTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DvsNetworkRuleQualifierVisitor)
            }
        }

struct DvsNetworkRuleQualifierVisitor;

impl<'de> de::Visitor<'de> for DvsNetworkRuleQualifierVisitor {
    type Value = Box<dyn DvsNetworkRuleQualifierTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DvsNetworkRuleQualifierTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DvsNetworkRuleQualifierTrait for DvsNetworkRuleQualifier {
    fn get_key(&self) -> &Option<String> { &self.key }
}
impl DvsNetworkRuleQualifierTrait for DvsIpNetworkRuleQualifier {
    fn get_key(&self) -> &Option<String> { &self.key }
}
impl DvsNetworkRuleQualifierTrait for DvsMacNetworkRuleQualifier {
    fn get_key(&self) -> &Option<String> { &self.key }
}
impl DvsNetworkRuleQualifierTrait for DvsSystemTrafficNetworkRuleQualifier {
    fn get_key(&self) -> &Option<String> { &self.key }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DvsNetworkRuleQualifierTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsNetworkRuleQualifier => Some(from.as_any_ref().downcast_ref::<DvsNetworkRuleQualifier>()?),
            StructType::DvsIpNetworkRuleQualifier => Some(from.as_any_ref().downcast_ref::<DvsIpNetworkRuleQualifier>()?),
            StructType::DvsMacNetworkRuleQualifier => Some(from.as_any_ref().downcast_ref::<DvsMacNetworkRuleQualifier>()?),
            StructType::DvsSystemTrafficNetworkRuleQualifier => Some(from.as_any_ref().downcast_ref::<DvsSystemTrafficNetworkRuleQualifier>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsNetworkRuleQualifier => Ok(from.as_any_box().downcast::<DvsNetworkRuleQualifier>()?),
            StructType::DvsIpNetworkRuleQualifier => Ok(from.as_any_box().downcast::<DvsIpNetworkRuleQualifier>()?),
            StructType::DvsMacNetworkRuleQualifier => Ok(from.as_any_box().downcast::<DvsMacNetworkRuleQualifier>()?),
            StructType::DvsSystemTrafficNetworkRuleQualifier => Ok(from.as_any_box().downcast::<DvsSystemTrafficNetworkRuleQualifier>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type encapsulates virtual machine or disk encryption
/// settings.
pub trait CryptoSpecTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn CryptoSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn CryptoSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(CryptoSpecVisitor)
            }
        }

struct CryptoSpecVisitor;

impl<'de> de::Visitor<'de> for CryptoSpecVisitor {
    type Value = Box<dyn CryptoSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid CryptoSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl CryptoSpecTrait for CryptoSpec {
}
impl CryptoSpecTrait for CryptoSpecDecrypt {
}
impl CryptoSpecTrait for CryptoSpecDeepRecrypt {
}
impl CryptoSpecTrait for CryptoSpecEncrypt {
}
impl CryptoSpecTrait for CryptoSpecNoOp {
}
impl CryptoSpecTrait for CryptoSpecRegister {
}
impl CryptoSpecTrait for CryptoSpecShallowRecrypt {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn CryptoSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::CryptoSpec => Some(from.as_any_ref().downcast_ref::<CryptoSpec>()?),
            StructType::CryptoSpecDecrypt => Some(from.as_any_ref().downcast_ref::<CryptoSpecDecrypt>()?),
            StructType::CryptoSpecDeepRecrypt => Some(from.as_any_ref().downcast_ref::<CryptoSpecDeepRecrypt>()?),
            StructType::CryptoSpecEncrypt => Some(from.as_any_ref().downcast_ref::<CryptoSpecEncrypt>()?),
            StructType::CryptoSpecNoOp => Some(from.as_any_ref().downcast_ref::<CryptoSpecNoOp>()?),
            StructType::CryptoSpecRegister => Some(from.as_any_ref().downcast_ref::<CryptoSpecRegister>()?),
            StructType::CryptoSpecShallowRecrypt => Some(from.as_any_ref().downcast_ref::<CryptoSpecShallowRecrypt>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::CryptoSpec => Ok(from.as_any_box().downcast::<CryptoSpec>()?),
            StructType::CryptoSpecDecrypt => Ok(from.as_any_box().downcast::<CryptoSpecDecrypt>()?),
            StructType::CryptoSpecDeepRecrypt => Ok(from.as_any_box().downcast::<CryptoSpecDeepRecrypt>()?),
            StructType::CryptoSpecEncrypt => Ok(from.as_any_box().downcast::<CryptoSpecEncrypt>()?),
            StructType::CryptoSpecNoOp => Ok(from.as_any_box().downcast::<CryptoSpecNoOp>()?),
            StructType::CryptoSpecRegister => Ok(from.as_any_box().downcast::<CryptoSpecRegister>()?),
            StructType::CryptoSpecShallowRecrypt => Ok(from.as_any_box().downcast::<CryptoSpecShallowRecrypt>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type indicates that the encryption settings of the
/// virtual machine or disk should not be modified by the operation.
pub trait CryptoSpecNoOpTrait : super::traits::CryptoSpecTrait {
}
impl<'s> serde::Serialize for dyn CryptoSpecNoOpTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn CryptoSpecNoOpTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(CryptoSpecNoOpVisitor)
            }
        }

struct CryptoSpecNoOpVisitor;

impl<'de> de::Visitor<'de> for CryptoSpecNoOpVisitor {
    type Value = Box<dyn CryptoSpecNoOpTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid CryptoSpecNoOpTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl CryptoSpecNoOpTrait for CryptoSpecNoOp {
}
impl CryptoSpecNoOpTrait for CryptoSpecRegister {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn CryptoSpecNoOpTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::CryptoSpecNoOp => Some(from.as_any_ref().downcast_ref::<CryptoSpecNoOp>()?),
            StructType::CryptoSpecRegister => Some(from.as_any_ref().downcast_ref::<CryptoSpecRegister>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::CryptoSpecNoOp => Ok(from.as_any_box().downcast::<CryptoSpecNoOp>()?),
            StructType::CryptoSpecRegister => Ok(from.as_any_box().downcast::<CryptoSpecRegister>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This is the base type for event argument types.
/// 
/// Event argument objects, which inherit from a common subtype,
/// are used to manage supplementary properties of different kinds
/// of event objects.
pub trait EventArgumentTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn EventArgumentTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn EventArgumentTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(EventArgumentVisitor)
            }
        }

struct EventArgumentVisitor;

impl<'de> de::Visitor<'de> for EventArgumentVisitor {
    type Value = Box<dyn EventArgumentTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid EventArgumentTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl EventArgumentTrait for EventArgument {
}
impl EventArgumentTrait for EntityEventArgument {
}
impl EventArgumentTrait for AlarmEventArgument {
}
impl EventArgumentTrait for ComputeResourceEventArgument {
}
impl EventArgumentTrait for DatacenterEventArgument {
}
impl EventArgumentTrait for DatastoreEventArgument {
}
impl EventArgumentTrait for DvsEventArgument {
}
impl EventArgumentTrait for FolderEventArgument {
}
impl EventArgumentTrait for HostEventArgument {
}
impl EventArgumentTrait for ManagedEntityEventArgument {
}
impl EventArgumentTrait for NetworkEventArgument {
}
impl EventArgumentTrait for ResourcePoolEventArgument {
}
impl EventArgumentTrait for ScheduledTaskEventArgument {
}
impl EventArgumentTrait for VmEventArgument {
}
impl EventArgumentTrait for ProfileEventArgument {
}
impl EventArgumentTrait for RoleEventArgument {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn EventArgumentTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::EventArgument => Some(from.as_any_ref().downcast_ref::<EventArgument>()?),
            StructType::EntityEventArgument => Some(from.as_any_ref().downcast_ref::<EntityEventArgument>()?),
            StructType::AlarmEventArgument => Some(from.as_any_ref().downcast_ref::<AlarmEventArgument>()?),
            StructType::ComputeResourceEventArgument => Some(from.as_any_ref().downcast_ref::<ComputeResourceEventArgument>()?),
            StructType::DatacenterEventArgument => Some(from.as_any_ref().downcast_ref::<DatacenterEventArgument>()?),
            StructType::DatastoreEventArgument => Some(from.as_any_ref().downcast_ref::<DatastoreEventArgument>()?),
            StructType::DvsEventArgument => Some(from.as_any_ref().downcast_ref::<DvsEventArgument>()?),
            StructType::FolderEventArgument => Some(from.as_any_ref().downcast_ref::<FolderEventArgument>()?),
            StructType::HostEventArgument => Some(from.as_any_ref().downcast_ref::<HostEventArgument>()?),
            StructType::ManagedEntityEventArgument => Some(from.as_any_ref().downcast_ref::<ManagedEntityEventArgument>()?),
            StructType::NetworkEventArgument => Some(from.as_any_ref().downcast_ref::<NetworkEventArgument>()?),
            StructType::ResourcePoolEventArgument => Some(from.as_any_ref().downcast_ref::<ResourcePoolEventArgument>()?),
            StructType::ScheduledTaskEventArgument => Some(from.as_any_ref().downcast_ref::<ScheduledTaskEventArgument>()?),
            StructType::VmEventArgument => Some(from.as_any_ref().downcast_ref::<VmEventArgument>()?),
            StructType::ProfileEventArgument => Some(from.as_any_ref().downcast_ref::<ProfileEventArgument>()?),
            StructType::RoleEventArgument => Some(from.as_any_ref().downcast_ref::<RoleEventArgument>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::EventArgument => Ok(from.as_any_box().downcast::<EventArgument>()?),
            StructType::EntityEventArgument => Ok(from.as_any_box().downcast::<EntityEventArgument>()?),
            StructType::AlarmEventArgument => Ok(from.as_any_box().downcast::<AlarmEventArgument>()?),
            StructType::ComputeResourceEventArgument => Ok(from.as_any_box().downcast::<ComputeResourceEventArgument>()?),
            StructType::DatacenterEventArgument => Ok(from.as_any_box().downcast::<DatacenterEventArgument>()?),
            StructType::DatastoreEventArgument => Ok(from.as_any_box().downcast::<DatastoreEventArgument>()?),
            StructType::DvsEventArgument => Ok(from.as_any_box().downcast::<DvsEventArgument>()?),
            StructType::FolderEventArgument => Ok(from.as_any_box().downcast::<FolderEventArgument>()?),
            StructType::HostEventArgument => Ok(from.as_any_box().downcast::<HostEventArgument>()?),
            StructType::ManagedEntityEventArgument => Ok(from.as_any_box().downcast::<ManagedEntityEventArgument>()?),
            StructType::NetworkEventArgument => Ok(from.as_any_box().downcast::<NetworkEventArgument>()?),
            StructType::ResourcePoolEventArgument => Ok(from.as_any_box().downcast::<ResourcePoolEventArgument>()?),
            StructType::ScheduledTaskEventArgument => Ok(from.as_any_box().downcast::<ScheduledTaskEventArgument>()?),
            StructType::VmEventArgument => Ok(from.as_any_box().downcast::<VmEventArgument>()?),
            StructType::ProfileEventArgument => Ok(from.as_any_box().downcast::<ProfileEventArgument>()?),
            StructType::RoleEventArgument => Ok(from.as_any_box().downcast::<RoleEventArgument>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The event argument is a managed entity object.
/// 
/// Subclasses of this type distinguish the different managed entities
/// referenced in event objects.
pub trait EntityEventArgumentTrait : super::traits::EventArgumentTrait {
    /// Name of the entity, including its full path from the root of the inventory.
    fn get_name(&self) -> &str;
}
impl<'s> serde::Serialize for dyn EntityEventArgumentTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn EntityEventArgumentTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(EntityEventArgumentVisitor)
            }
        }

struct EntityEventArgumentVisitor;

impl<'de> de::Visitor<'de> for EntityEventArgumentVisitor {
    type Value = Box<dyn EntityEventArgumentTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid EntityEventArgumentTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl EntityEventArgumentTrait for EntityEventArgument {
    fn get_name(&self) -> &str { &self.name }
}
impl EntityEventArgumentTrait for AlarmEventArgument {
    fn get_name(&self) -> &str { &self.name }
}
impl EntityEventArgumentTrait for ComputeResourceEventArgument {
    fn get_name(&self) -> &str { &self.name }
}
impl EntityEventArgumentTrait for DatacenterEventArgument {
    fn get_name(&self) -> &str { &self.name }
}
impl EntityEventArgumentTrait for DatastoreEventArgument {
    fn get_name(&self) -> &str { &self.name }
}
impl EntityEventArgumentTrait for DvsEventArgument {
    fn get_name(&self) -> &str { &self.name }
}
impl EntityEventArgumentTrait for FolderEventArgument {
    fn get_name(&self) -> &str { &self.name }
}
impl EntityEventArgumentTrait for HostEventArgument {
    fn get_name(&self) -> &str { &self.name }
}
impl EntityEventArgumentTrait for ManagedEntityEventArgument {
    fn get_name(&self) -> &str { &self.name }
}
impl EntityEventArgumentTrait for NetworkEventArgument {
    fn get_name(&self) -> &str { &self.name }
}
impl EntityEventArgumentTrait for ResourcePoolEventArgument {
    fn get_name(&self) -> &str { &self.name }
}
impl EntityEventArgumentTrait for ScheduledTaskEventArgument {
    fn get_name(&self) -> &str { &self.name }
}
impl EntityEventArgumentTrait for VmEventArgument {
    fn get_name(&self) -> &str { &self.name }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn EntityEventArgumentTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::EntityEventArgument => Some(from.as_any_ref().downcast_ref::<EntityEventArgument>()?),
            StructType::AlarmEventArgument => Some(from.as_any_ref().downcast_ref::<AlarmEventArgument>()?),
            StructType::ComputeResourceEventArgument => Some(from.as_any_ref().downcast_ref::<ComputeResourceEventArgument>()?),
            StructType::DatacenterEventArgument => Some(from.as_any_ref().downcast_ref::<DatacenterEventArgument>()?),
            StructType::DatastoreEventArgument => Some(from.as_any_ref().downcast_ref::<DatastoreEventArgument>()?),
            StructType::DvsEventArgument => Some(from.as_any_ref().downcast_ref::<DvsEventArgument>()?),
            StructType::FolderEventArgument => Some(from.as_any_ref().downcast_ref::<FolderEventArgument>()?),
            StructType::HostEventArgument => Some(from.as_any_ref().downcast_ref::<HostEventArgument>()?),
            StructType::ManagedEntityEventArgument => Some(from.as_any_ref().downcast_ref::<ManagedEntityEventArgument>()?),
            StructType::NetworkEventArgument => Some(from.as_any_ref().downcast_ref::<NetworkEventArgument>()?),
            StructType::ResourcePoolEventArgument => Some(from.as_any_ref().downcast_ref::<ResourcePoolEventArgument>()?),
            StructType::ScheduledTaskEventArgument => Some(from.as_any_ref().downcast_ref::<ScheduledTaskEventArgument>()?),
            StructType::VmEventArgument => Some(from.as_any_ref().downcast_ref::<VmEventArgument>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::EntityEventArgument => Ok(from.as_any_box().downcast::<EntityEventArgument>()?),
            StructType::AlarmEventArgument => Ok(from.as_any_box().downcast::<AlarmEventArgument>()?),
            StructType::ComputeResourceEventArgument => Ok(from.as_any_box().downcast::<ComputeResourceEventArgument>()?),
            StructType::DatacenterEventArgument => Ok(from.as_any_box().downcast::<DatacenterEventArgument>()?),
            StructType::DatastoreEventArgument => Ok(from.as_any_box().downcast::<DatastoreEventArgument>()?),
            StructType::DvsEventArgument => Ok(from.as_any_box().downcast::<DvsEventArgument>()?),
            StructType::FolderEventArgument => Ok(from.as_any_box().downcast::<FolderEventArgument>()?),
            StructType::HostEventArgument => Ok(from.as_any_box().downcast::<HostEventArgument>()?),
            StructType::ManagedEntityEventArgument => Ok(from.as_any_box().downcast::<ManagedEntityEventArgument>()?),
            StructType::NetworkEventArgument => Ok(from.as_any_box().downcast::<NetworkEventArgument>()?),
            StructType::ResourcePoolEventArgument => Ok(from.as_any_box().downcast::<ResourcePoolEventArgument>()?),
            StructType::ScheduledTaskEventArgument => Ok(from.as_any_box().downcast::<ScheduledTaskEventArgument>()?),
            StructType::VmEventArgument => Ok(from.as_any_box().downcast::<VmEventArgument>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *HostAuthenticationStoreInfo* base class defines status information
/// for local and host Active Directory authentication.
pub trait HostAuthenticationStoreInfoTrait : super::traits::DataObjectTrait {
    /// Indicates whether the authentication store is configured.
    /// - Host Active Directory authentication - <code>enabled</code>
    ///   is <code>True</code> if the host is a member of a domain.
    /// - Local authentication - <code>enabled</code> is always <code>True</code>.
    fn get_enabled(&self) -> bool;
}
impl<'s> serde::Serialize for dyn HostAuthenticationStoreInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostAuthenticationStoreInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostAuthenticationStoreInfoVisitor)
            }
        }

struct HostAuthenticationStoreInfoVisitor;

impl<'de> de::Visitor<'de> for HostAuthenticationStoreInfoVisitor {
    type Value = Box<dyn HostAuthenticationStoreInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostAuthenticationStoreInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostAuthenticationStoreInfoTrait for HostAuthenticationStoreInfo {
    fn get_enabled(&self) -> bool { self.enabled }
}
impl HostAuthenticationStoreInfoTrait for HostDirectoryStoreInfo {
    fn get_enabled(&self) -> bool { self.enabled }
}
impl HostAuthenticationStoreInfoTrait for HostActiveDirectoryInfo {
    fn get_enabled(&self) -> bool { self.enabled }
}
impl HostAuthenticationStoreInfoTrait for HostLocalAuthenticationInfo {
    fn get_enabled(&self) -> bool { self.enabled }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostAuthenticationStoreInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostAuthenticationStoreInfo => Some(from.as_any_ref().downcast_ref::<HostAuthenticationStoreInfo>()?),
            StructType::HostDirectoryStoreInfo => Some(from.as_any_ref().downcast_ref::<HostDirectoryStoreInfo>()?),
            StructType::HostActiveDirectoryInfo => Some(from.as_any_ref().downcast_ref::<HostActiveDirectoryInfo>()?),
            StructType::HostLocalAuthenticationInfo => Some(from.as_any_ref().downcast_ref::<HostLocalAuthenticationInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostAuthenticationStoreInfo => Ok(from.as_any_box().downcast::<HostAuthenticationStoreInfo>()?),
            StructType::HostDirectoryStoreInfo => Ok(from.as_any_box().downcast::<HostDirectoryStoreInfo>()?),
            StructType::HostActiveDirectoryInfo => Ok(from.as_any_box().downcast::<HostActiveDirectoryInfo>()?),
            StructType::HostLocalAuthenticationInfo => Ok(from.as_any_box().downcast::<HostLocalAuthenticationInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// *HostDirectoryStoreInfo* is a base class for objects that
/// provide information about directory-based authentication stores.
pub trait HostDirectoryStoreInfoTrait : super::traits::HostAuthenticationStoreInfoTrait {
}
impl<'s> serde::Serialize for dyn HostDirectoryStoreInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostDirectoryStoreInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostDirectoryStoreInfoVisitor)
            }
        }

struct HostDirectoryStoreInfoVisitor;

impl<'de> de::Visitor<'de> for HostDirectoryStoreInfoVisitor {
    type Value = Box<dyn HostDirectoryStoreInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostDirectoryStoreInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostDirectoryStoreInfoTrait for HostDirectoryStoreInfo {
}
impl HostDirectoryStoreInfoTrait for HostActiveDirectoryInfo {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostDirectoryStoreInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostDirectoryStoreInfo => Some(from.as_any_ref().downcast_ref::<HostDirectoryStoreInfo>()?),
            StructType::HostActiveDirectoryInfo => Some(from.as_any_ref().downcast_ref::<HostActiveDirectoryInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostDirectoryStoreInfo => Ok(from.as_any_box().downcast::<HostDirectoryStoreInfo>()?),
            StructType::HostActiveDirectoryInfo => Ok(from.as_any_box().downcast::<HostActiveDirectoryInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The base data object type for information about datastores on the host.
pub trait HostDatastoreConnectInfoTrait : super::traits::DataObjectTrait {
    /// Basic datastore information.
    /// 
    /// The managed object reference is not set.
    fn get_summary(&self) -> &DatastoreSummary;
}
impl<'s> serde::Serialize for dyn HostDatastoreConnectInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostDatastoreConnectInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostDatastoreConnectInfoVisitor)
            }
        }

struct HostDatastoreConnectInfoVisitor;

impl<'de> de::Visitor<'de> for HostDatastoreConnectInfoVisitor {
    type Value = Box<dyn HostDatastoreConnectInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostDatastoreConnectInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostDatastoreConnectInfoTrait for HostDatastoreConnectInfo {
    fn get_summary(&self) -> &DatastoreSummary { &self.summary }
}
impl HostDatastoreConnectInfoTrait for HostDatastoreExistsConnectInfo {
    fn get_summary(&self) -> &DatastoreSummary { &self.summary }
}
impl HostDatastoreConnectInfoTrait for HostDatastoreNameConflictConnectInfo {
    fn get_summary(&self) -> &DatastoreSummary { &self.summary }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostDatastoreConnectInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostDatastoreConnectInfo => Some(from.as_any_ref().downcast_ref::<HostDatastoreConnectInfo>()?),
            StructType::HostDatastoreExistsConnectInfo => Some(from.as_any_ref().downcast_ref::<HostDatastoreExistsConnectInfo>()?),
            StructType::HostDatastoreNameConflictConnectInfo => Some(from.as_any_ref().downcast_ref::<HostDatastoreNameConflictConnectInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostDatastoreConnectInfo => Ok(from.as_any_box().downcast::<HostDatastoreConnectInfo>()?),
            StructType::HostDatastoreExistsConnectInfo => Ok(from.as_any_box().downcast::<HostDatastoreExistsConnectInfo>()?),
            StructType::HostDatastoreNameConflictConnectInfo => Ok(from.as_any_box().downcast::<HostDatastoreNameConflictConnectInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The base data object type for information about networks on the host.
pub trait HostConnectInfoNetworkInfoTrait : super::traits::DataObjectTrait {
    /// Basic network information, such as network name.
    /// 
    /// The managed object reference
    /// is not set.
    fn get_summary(&self) -> &Box<dyn super::traits::NetworkSummaryTrait>;
}
impl<'s> serde::Serialize for dyn HostConnectInfoNetworkInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostConnectInfoNetworkInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostConnectInfoNetworkInfoVisitor)
            }
        }

struct HostConnectInfoNetworkInfoVisitor;

impl<'de> de::Visitor<'de> for HostConnectInfoNetworkInfoVisitor {
    type Value = Box<dyn HostConnectInfoNetworkInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostConnectInfoNetworkInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostConnectInfoNetworkInfoTrait for HostConnectInfoNetworkInfo {
    fn get_summary(&self) -> &Box<dyn super::traits::NetworkSummaryTrait> { &self.summary }
}
impl HostConnectInfoNetworkInfoTrait for HostNewNetworkConnectInfo {
    fn get_summary(&self) -> &Box<dyn super::traits::NetworkSummaryTrait> { &self.summary }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostConnectInfoNetworkInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostConnectInfoNetworkInfo => Some(from.as_any_ref().downcast_ref::<HostConnectInfoNetworkInfo>()?),
            StructType::HostNewNetworkConnectInfo => Some(from.as_any_ref().downcast_ref::<HostNewNetworkConnectInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostConnectInfoNetworkInfo => Ok(from.as_any_box().downcast::<HostConnectInfoNetworkInfo>()?),
            StructType::HostNewNetworkConnectInfo => Ok(from.as_any_box().downcast::<HostNewNetworkConnectInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// DataTransportConnectionInfo contains common information about data transport
/// connections on a host.
/// 
/// ***Since:*** vSphere API Release 7.0.3.0
pub trait HostDataTransportConnectionInfoTrait : super::traits::DataObjectTrait {
    /// Static memory consumption by a connection in bytes like buffer sizes, heap sizes, etc.
    fn get_static_memory_consumed(&self) -> i64;
}
impl<'s> serde::Serialize for dyn HostDataTransportConnectionInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostDataTransportConnectionInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostDataTransportConnectionInfoVisitor)
            }
        }

struct HostDataTransportConnectionInfoVisitor;

impl<'de> de::Visitor<'de> for HostDataTransportConnectionInfoVisitor {
    type Value = Box<dyn HostDataTransportConnectionInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostDataTransportConnectionInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostDataTransportConnectionInfoTrait for HostDataTransportConnectionInfo {
    fn get_static_memory_consumed(&self) -> i64 { self.static_memory_consumed }
}
impl HostDataTransportConnectionInfoTrait for HostNfcConnectionInfo {
    fn get_static_memory_consumed(&self) -> i64 { self.static_memory_consumed }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostDataTransportConnectionInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostDataTransportConnectionInfo => Some(from.as_any_ref().downcast_ref::<HostDataTransportConnectionInfo>()?),
            StructType::HostNfcConnectionInfo => Some(from.as_any_ref().downcast_ref::<HostNfcConnectionInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostDataTransportConnectionInfo => Ok(from.as_any_box().downcast::<HostDataTransportConnectionInfo>()?),
            StructType::HostNfcConnectionInfo => Ok(from.as_any_box().downcast::<HostNfcConnectionInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type contains rudimentary information about a file in a
/// datastore.
/// 
/// The information here is not meant to cover all information in
/// traditional file systems, but rather to provide sufficient information for files
/// that are associated with virtual machines. Derived types describe the known file
/// types for a datastore.
pub trait FileInfoTrait : super::traits::DataObjectTrait {
    /// The path relative to the folder path in the search results.
    fn get_path(&self) -> &str;
    /// User friendly name.
    fn get_friendly_name(&self) -> &Option<String>;
    /// The size of the file in bytes.
    fn get_file_size(&self) -> Option<i64>;
    /// The last date and time the file was modified.
    fn get_modification(&self) -> &Option<String>;
    /// The user name of the owner of the file.
    fn get_owner(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn FileInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn FileInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(FileInfoVisitor)
            }
        }

struct FileInfoVisitor;

impl<'de> de::Visitor<'de> for FileInfoVisitor {
    type Value = Box<dyn FileInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid FileInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl FileInfoTrait for FileInfo {
    fn get_path(&self) -> &str { &self.path }
    fn get_friendly_name(&self) -> &Option<String> { &self.friendly_name }
    fn get_file_size(&self) -> Option<i64> { self.file_size }
    fn get_modification(&self) -> &Option<String> { &self.modification }
    fn get_owner(&self) -> &Option<String> { &self.owner }
}
impl FileInfoTrait for FloppyImageFileInfo {
    fn get_path(&self) -> &str { &self.path }
    fn get_friendly_name(&self) -> &Option<String> { &self.friendly_name }
    fn get_file_size(&self) -> Option<i64> { self.file_size }
    fn get_modification(&self) -> &Option<String> { &self.modification }
    fn get_owner(&self) -> &Option<String> { &self.owner }
}
impl FileInfoTrait for FolderFileInfo {
    fn get_path(&self) -> &str { &self.path }
    fn get_friendly_name(&self) -> &Option<String> { &self.friendly_name }
    fn get_file_size(&self) -> Option<i64> { self.file_size }
    fn get_modification(&self) -> &Option<String> { &self.modification }
    fn get_owner(&self) -> &Option<String> { &self.owner }
}
impl FileInfoTrait for IsoImageFileInfo {
    fn get_path(&self) -> &str { &self.path }
    fn get_friendly_name(&self) -> &Option<String> { &self.friendly_name }
    fn get_file_size(&self) -> Option<i64> { self.file_size }
    fn get_modification(&self) -> &Option<String> { &self.modification }
    fn get_owner(&self) -> &Option<String> { &self.owner }
}
impl FileInfoTrait for VmConfigFileInfo {
    fn get_path(&self) -> &str { &self.path }
    fn get_friendly_name(&self) -> &Option<String> { &self.friendly_name }
    fn get_file_size(&self) -> Option<i64> { self.file_size }
    fn get_modification(&self) -> &Option<String> { &self.modification }
    fn get_owner(&self) -> &Option<String> { &self.owner }
}
impl FileInfoTrait for TemplateConfigFileInfo {
    fn get_path(&self) -> &str { &self.path }
    fn get_friendly_name(&self) -> &Option<String> { &self.friendly_name }
    fn get_file_size(&self) -> Option<i64> { self.file_size }
    fn get_modification(&self) -> &Option<String> { &self.modification }
    fn get_owner(&self) -> &Option<String> { &self.owner }
}
impl FileInfoTrait for VmDiskFileInfo {
    fn get_path(&self) -> &str { &self.path }
    fn get_friendly_name(&self) -> &Option<String> { &self.friendly_name }
    fn get_file_size(&self) -> Option<i64> { self.file_size }
    fn get_modification(&self) -> &Option<String> { &self.modification }
    fn get_owner(&self) -> &Option<String> { &self.owner }
}
impl FileInfoTrait for VmLogFileInfo {
    fn get_path(&self) -> &str { &self.path }
    fn get_friendly_name(&self) -> &Option<String> { &self.friendly_name }
    fn get_file_size(&self) -> Option<i64> { self.file_size }
    fn get_modification(&self) -> &Option<String> { &self.modification }
    fn get_owner(&self) -> &Option<String> { &self.owner }
}
impl FileInfoTrait for VmNvramFileInfo {
    fn get_path(&self) -> &str { &self.path }
    fn get_friendly_name(&self) -> &Option<String> { &self.friendly_name }
    fn get_file_size(&self) -> Option<i64> { self.file_size }
    fn get_modification(&self) -> &Option<String> { &self.modification }
    fn get_owner(&self) -> &Option<String> { &self.owner }
}
impl FileInfoTrait for VmSnapshotFileInfo {
    fn get_path(&self) -> &str { &self.path }
    fn get_friendly_name(&self) -> &Option<String> { &self.friendly_name }
    fn get_file_size(&self) -> Option<i64> { self.file_size }
    fn get_modification(&self) -> &Option<String> { &self.modification }
    fn get_owner(&self) -> &Option<String> { &self.owner }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn FileInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::FileInfo => Some(from.as_any_ref().downcast_ref::<FileInfo>()?),
            StructType::FloppyImageFileInfo => Some(from.as_any_ref().downcast_ref::<FloppyImageFileInfo>()?),
            StructType::FolderFileInfo => Some(from.as_any_ref().downcast_ref::<FolderFileInfo>()?),
            StructType::IsoImageFileInfo => Some(from.as_any_ref().downcast_ref::<IsoImageFileInfo>()?),
            StructType::VmConfigFileInfo => Some(from.as_any_ref().downcast_ref::<VmConfigFileInfo>()?),
            StructType::TemplateConfigFileInfo => Some(from.as_any_ref().downcast_ref::<TemplateConfigFileInfo>()?),
            StructType::VmDiskFileInfo => Some(from.as_any_ref().downcast_ref::<VmDiskFileInfo>()?),
            StructType::VmLogFileInfo => Some(from.as_any_ref().downcast_ref::<VmLogFileInfo>()?),
            StructType::VmNvramFileInfo => Some(from.as_any_ref().downcast_ref::<VmNvramFileInfo>()?),
            StructType::VmSnapshotFileInfo => Some(from.as_any_ref().downcast_ref::<VmSnapshotFileInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::FileInfo => Ok(from.as_any_box().downcast::<FileInfo>()?),
            StructType::FloppyImageFileInfo => Ok(from.as_any_box().downcast::<FloppyImageFileInfo>()?),
            StructType::FolderFileInfo => Ok(from.as_any_box().downcast::<FolderFileInfo>()?),
            StructType::IsoImageFileInfo => Ok(from.as_any_box().downcast::<IsoImageFileInfo>()?),
            StructType::VmConfigFileInfo => Ok(from.as_any_box().downcast::<VmConfigFileInfo>()?),
            StructType::TemplateConfigFileInfo => Ok(from.as_any_box().downcast::<TemplateConfigFileInfo>()?),
            StructType::VmDiskFileInfo => Ok(from.as_any_box().downcast::<VmDiskFileInfo>()?),
            StructType::VmLogFileInfo => Ok(from.as_any_box().downcast::<VmLogFileInfo>()?),
            StructType::VmNvramFileInfo => Ok(from.as_any_box().downcast::<VmNvramFileInfo>()?),
            StructType::VmSnapshotFileInfo => Ok(from.as_any_box().downcast::<VmSnapshotFileInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type describes a virtual machine configuration file.
pub trait VmConfigFileInfoTrait : super::traits::FileInfoTrait {
    fn get_config_version(&self) -> Option<i32>;
    /// The encryption information of the virtual machine
    /// configuration file.
    /// 
    /// If encryption was selected in VmConfigFileQueryFlags then this
    /// field is always set. Inspect the VmConfigEncryptionInfo to
    /// determine if the virtual machine configuration file is encrypted.
    fn get_encryption(&self) -> &Option<VmConfigFileEncryptionInfo>;
}
impl<'s> serde::Serialize for dyn VmConfigFileInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VmConfigFileInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VmConfigFileInfoVisitor)
            }
        }

struct VmConfigFileInfoVisitor;

impl<'de> de::Visitor<'de> for VmConfigFileInfoVisitor {
    type Value = Box<dyn VmConfigFileInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VmConfigFileInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VmConfigFileInfoTrait for VmConfigFileInfo {
    fn get_config_version(&self) -> Option<i32> { self.config_version }
    fn get_encryption(&self) -> &Option<VmConfigFileEncryptionInfo> { &self.encryption }
}
impl VmConfigFileInfoTrait for TemplateConfigFileInfo {
    fn get_config_version(&self) -> Option<i32> { self.config_version }
    fn get_encryption(&self) -> &Option<VmConfigFileEncryptionInfo> { &self.encryption }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VmConfigFileInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmConfigFileInfo => Some(from.as_any_ref().downcast_ref::<VmConfigFileInfo>()?),
            StructType::TemplateConfigFileInfo => Some(from.as_any_ref().downcast_ref::<TemplateConfigFileInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmConfigFileInfo => Ok(from.as_any_box().downcast::<VmConfigFileInfo>()?),
            StructType::TemplateConfigFileInfo => Ok(from.as_any_box().downcast::<TemplateConfigFileInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The data object type that describes the base query specification.
/// 
/// Contains query
/// filters and details that apply to every file. Querying only file details generally
/// does not require opening files and so is an efficient query. Derived types add
/// query parameters specific to the type of file.
pub trait FileQueryTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn FileQueryTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn FileQueryTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(FileQueryVisitor)
            }
        }

struct FileQueryVisitor;

impl<'de> de::Visitor<'de> for FileQueryVisitor {
    type Value = Box<dyn FileQueryTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid FileQueryTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl FileQueryTrait for FileQuery {
}
impl FileQueryTrait for FloppyImageFileQuery {
}
impl FileQueryTrait for FolderFileQuery {
}
impl FileQueryTrait for IsoImageFileQuery {
}
impl FileQueryTrait for VmConfigFileQuery {
}
impl FileQueryTrait for TemplateConfigFileQuery {
}
impl FileQueryTrait for VmDiskFileQuery {
}
impl FileQueryTrait for VmLogFileQuery {
}
impl FileQueryTrait for VmNvramFileQuery {
}
impl FileQueryTrait for VmSnapshotFileQuery {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn FileQueryTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::FileQuery => Some(from.as_any_ref().downcast_ref::<FileQuery>()?),
            StructType::FloppyImageFileQuery => Some(from.as_any_ref().downcast_ref::<FloppyImageFileQuery>()?),
            StructType::FolderFileQuery => Some(from.as_any_ref().downcast_ref::<FolderFileQuery>()?),
            StructType::IsoImageFileQuery => Some(from.as_any_ref().downcast_ref::<IsoImageFileQuery>()?),
            StructType::VmConfigFileQuery => Some(from.as_any_ref().downcast_ref::<VmConfigFileQuery>()?),
            StructType::TemplateConfigFileQuery => Some(from.as_any_ref().downcast_ref::<TemplateConfigFileQuery>()?),
            StructType::VmDiskFileQuery => Some(from.as_any_ref().downcast_ref::<VmDiskFileQuery>()?),
            StructType::VmLogFileQuery => Some(from.as_any_ref().downcast_ref::<VmLogFileQuery>()?),
            StructType::VmNvramFileQuery => Some(from.as_any_ref().downcast_ref::<VmNvramFileQuery>()?),
            StructType::VmSnapshotFileQuery => Some(from.as_any_ref().downcast_ref::<VmSnapshotFileQuery>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::FileQuery => Ok(from.as_any_box().downcast::<FileQuery>()?),
            StructType::FloppyImageFileQuery => Ok(from.as_any_box().downcast::<FloppyImageFileQuery>()?),
            StructType::FolderFileQuery => Ok(from.as_any_box().downcast::<FolderFileQuery>()?),
            StructType::IsoImageFileQuery => Ok(from.as_any_box().downcast::<IsoImageFileQuery>()?),
            StructType::VmConfigFileQuery => Ok(from.as_any_box().downcast::<VmConfigFileQuery>()?),
            StructType::TemplateConfigFileQuery => Ok(from.as_any_box().downcast::<TemplateConfigFileQuery>()?),
            StructType::VmDiskFileQuery => Ok(from.as_any_box().downcast::<VmDiskFileQuery>()?),
            StructType::VmLogFileQuery => Ok(from.as_any_box().downcast::<VmLogFileQuery>()?),
            StructType::VmNvramFileQuery => Ok(from.as_any_box().downcast::<VmNvramFileQuery>()?),
            StructType::VmSnapshotFileQuery => Ok(from.as_any_box().downcast::<VmSnapshotFileQuery>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type describes query specification for the virtual machine
/// configuration file.
pub trait VmConfigFileQueryTrait : super::traits::FileQueryTrait {
    /// The filter specification for the virtual machine configuration file query.
    fn get_filter(&self) -> &Option<VmConfigFileQueryFilter>;
    /// The details specification for the virtual machine configuration file query.
    fn get_details(&self) -> &Option<VmConfigFileQueryFlags>;
}
impl<'s> serde::Serialize for dyn VmConfigFileQueryTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VmConfigFileQueryTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VmConfigFileQueryVisitor)
            }
        }

struct VmConfigFileQueryVisitor;

impl<'de> de::Visitor<'de> for VmConfigFileQueryVisitor {
    type Value = Box<dyn VmConfigFileQueryTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VmConfigFileQueryTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VmConfigFileQueryTrait for VmConfigFileQuery {
    fn get_filter(&self) -> &Option<VmConfigFileQueryFilter> { &self.filter }
    fn get_details(&self) -> &Option<VmConfigFileQueryFlags> { &self.details }
}
impl VmConfigFileQueryTrait for TemplateConfigFileQuery {
    fn get_filter(&self) -> &Option<VmConfigFileQueryFilter> { &self.filter }
    fn get_details(&self) -> &Option<VmConfigFileQueryFlags> { &self.details }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VmConfigFileQueryTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmConfigFileQuery => Some(from.as_any_ref().downcast_ref::<VmConfigFileQuery>()?),
            StructType::TemplateConfigFileQuery => Some(from.as_any_ref().downcast_ref::<TemplateConfigFileQuery>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmConfigFileQuery => Ok(from.as_any_box().downcast::<VmConfigFileQuery>()?),
            StructType::TemplateConfigFileQuery => Ok(from.as_any_box().downcast::<TemplateConfigFileQuery>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type defines a device on the host.
pub trait HostDeviceTrait : super::traits::DataObjectTrait {
    /// The name of the device on the host.
    /// 
    /// For example,
    /// /dev/cdrom or \\\\serverX\\device\_name.
    fn get_device_name(&self) -> &str;
    /// Device type when available:
    /// floppy, mouse, cdrom, disk, scsi device, or adapter.
    fn get_device_type(&self) -> &str;
}
impl<'s> serde::Serialize for dyn HostDeviceTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostDeviceTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostDeviceVisitor)
            }
        }

struct HostDeviceVisitor;

impl<'de> de::Visitor<'de> for HostDeviceVisitor {
    type Value = Box<dyn HostDeviceTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostDeviceTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostDeviceTrait for HostDevice {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_device_type(&self) -> &str { &self.device_type }
}
impl HostDeviceTrait for ScsiLun {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_device_type(&self) -> &str { &self.device_type }
}
impl HostDeviceTrait for HostScsiDisk {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_device_type(&self) -> &str { &self.device_type }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostDeviceTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostDevice => Some(from.as_any_ref().downcast_ref::<HostDevice>()?),
            StructType::ScsiLun => Some(from.as_any_ref().downcast_ref::<ScsiLun>()?),
            StructType::HostScsiDisk => Some(from.as_any_ref().downcast_ref::<HostScsiDisk>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostDevice => Ok(from.as_any_box().downcast::<HostDevice>()?),
            StructType::ScsiLun => Ok(from.as_any_box().downcast::<ScsiLun>()?),
            StructType::HostScsiDisk => Ok(from.as_any_box().downcast::<HostScsiDisk>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *ScsiLun* data object describes a SCSI logical unit.
/// 
/// A SCSI logical unit is a host device that an ESX Server or virtual machine
/// can use for I/O operations.
/// 
/// An ESX Server creates SCSI logical unit objects to represent
/// devices in the host configuration. (See the definition of
/// *ScsiLunType_enum* for a list of the supported device types.)
/// The vSphere API uses one of two object types to represent a SCSI
/// logical unit, depending on the device type.
/// - Disks containing file system volumes or parts of volumes for hosts
///   or raw disks for virtual machines. To represent disks, the ESX Server
///   creates a *HostScsiDisk* object, which inherits properties from
///   the *ScsiLun* base class.
/// - Other SCSI devices, for example SCSI passthrough devices
///   for virtual machines. To represent one of these devices,
///   the ESX Server creates a *ScsiLun* object.
///   
/// When the Server creates a *HostScsiDisk* or *ScsiLun* object,
/// it specifies a valid device name and type:
/// - *HostDevice.deviceName* - A string representing the name of the device
///   that is meaningful to the host. The following are some examples of
///   device names.  
///   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>/dev/cdrom</code>  
///   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>/vmkdev/vmhba0:0:1:0</code>  
///   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>PhysicalDrive0</code>
/// - *HostDevice.deviceType* - A string describing the type of device.
///   The following are some examples of device types.  
///   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>scsi-cdrom</code>  
///   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>scsi-tape</code>  
///   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>scsi-disk</code>  
///   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>scsi-processor</code>  
///   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>scsi-unknown</code>
pub trait ScsiLunTrait : super::traits::HostDeviceTrait {
    /// Linkable identifier
    fn get_key(&self) -> &Option<String>;
    /// Universally unique identifier for the LUN used to identify ScsiLun across
    /// multiple servers.
    /// 
    /// This identifier can be used to identify analogous objects in other views
    /// such as *HostMultipathInfoLogicalUnit* and *HostScsiTopologyLun*.
    /// 
    /// See also *HostMultipathInfoLogicalUnit*, *HostScsiTopologyLun*.
    fn get_uuid(&self) -> &str;
    /// List of descriptors that can be used to identify the LUN object.
    /// 
    /// The
    /// uuid will also appear as a descriptor.
    /// 
    /// The id field in the descriptor is a string that can be used to correlate
    /// the ScsiLun across multiple servers. A ScsiLun may have multiple
    /// descriptors. The choice and order of these descriptors may be different
    /// on different servers.
    /// 
    /// Not all descriptors are suitable for correlation. Some descriptors are
    /// only sufficient to identify the ScsiLun within a single host. Each
    /// descriptor contains a quality property that indicates whether or not
    /// the descriptor is suitable for correlation.
    fn get_descriptor(&self) -> &Option<Vec<ScsiLunDescriptor>>;
    /// Canonical name of the SCSI logical unit.
    /// 
    /// Disk partition or extent identifiers refer to this name when
    /// referring to a disk. Use this property to correlate a partition
    /// or extent to a specific SCSI disk.
    /// 
    /// See also *HostScsiDiskPartition.diskName*.
    fn get_canonical_name(&self) -> &Option<String>;
    /// User configurable display name of the SCSI logical unit.
    /// 
    /// A default
    /// display name will be used if available. If the display name is not
    /// supported, it will be unset. The display name does not have to be
    /// unique but it is recommended that it be unique.
    fn get_display_name(&self) -> &Option<String>;
    /// The type of SCSI device.
    /// 
    /// Must be one of the values of
    /// *ScsiLunType_enum*.
    fn get_lun_type(&self) -> &str;
    /// The vendor of the SCSI device.
    fn get_vendor(&self) -> &Option<String>;
    /// The model number of the SCSI device.
    fn get_model(&self) -> &Option<String>;
    /// The revision of the SCSI device.
    fn get_revision(&self) -> &Option<String>;
    /// The SCSI level of the SCSI device.
    fn get_scsi_level(&self) -> Option<i32>;
    /// The serial number of the SCSI device.
    /// 
    /// For a device that is SCSI-3 compliant, this property is derived
    /// from page 80h of the Vital Product Data (VPD), as defined by the
    /// SCSI-3 Primary Commands (SPC-3) spec. Not all SCSI-3 compliant
    /// devices provide this information. For devices that are not
    /// SCSI-3 compliant, this property is not defined.
    fn get_serial_number(&self) -> &Option<String>;
    /// The durable name of the SCSI device.
    /// 
    /// For a SCSI-3 compliant device this property is derived from the
    /// payloads of pages 80h and 83h of the Vital Product Data (VPD) as
    /// defined by the T10 and SMI standards. For devices that do not provide
    /// this information, this property is not defined.
    fn get_durable_name(&self) -> &Option<ScsiLunDurableName>;
    /// Alternate durable names.
    /// 
    /// Records all available durable names derived from page 80h of the Vital
    /// Product Data (VPD) and the Identification Vital Product Data (VPD) page
    /// 83h as defined by the SCSI-3 Primary Commands. For devices that are not
    /// SCSI-3 compliant this property is not defined.
    fn get_alternate_name(&self) -> &Option<Vec<ScsiLunDurableName>>;
    /// Standard Inquiry payload.
    /// 
    /// For a SCSI-3 compliant device this property is derived from the
    /// standard inquiry data. For devices that are not SCSI-3 compliant this
    /// property is not defined.
    fn get_standard_inquiry(&self) -> &Option<Vec<i8>>;
    /// The queue depth of SCSI device.
    fn get_queue_depth(&self) -> Option<i32>;
    /// The operational states of the LUN.
    /// 
    /// When more than one item is present in the array, the first state
    /// should be considered the primary state. For example, a LUN may
    /// be "ok" and "degraded" indicating I/O is still possible to the LUN, but
    /// it is operating in a degraded mode.
    /// 
    /// See also *ScsiLunState_enum*.
    fn get_operational_state(&self) -> &Vec<String>;
    /// Capabilities of SCSI device.
    fn get_capabilities(&self) -> &Option<ScsiLunCapabilities>;
    /// vStorage hardware acceleration support status.
    /// 
    /// This property
    /// represents storage acceleration provided by the SCSI logical unit.
    /// See *ScsiLunVStorageSupportStatus_enum* for valid values.
    /// 
    /// If a storage device supports hardware acceleration,
    /// the ESX host can offload specific virtual machine management
    /// operations to the storage device. With hardware assistance,
    /// the host performs storage operations faster and consumes
    /// less CPU, memory, and storage fabric bandwidth.
    /// 
    /// For vSphere 4.0 or earlier hosts, this value will be unset.
    fn get_v_storage_support(&self) -> &Option<String>;
    /// Indicates that this SCSI LUN is protocol endpoint.
    /// 
    /// This
    /// property will be populated if and only if host supports
    /// VirtualVolume based Datastore. Check the host capability
    /// *HostCapability.virtualVolumeDatastoreSupported*.
    /// See *HostProtocolEndpoint*.
    fn get_protocol_endpoint(&self) -> Option<bool>;
    /// Indicates the state of a perennially reserved flag for a LUN.
    /// 
    /// If
    /// set for Raw Device Mapped (RDM) LUNs, the host startup or LUN rescan
    /// take comparatively shorter duration than when it is unset.
    fn get_perennially_reserved(&self) -> Option<bool>;
    /// Indicates if LUN has the prequisite properties to enable Clustered Vmdk
    /// feature once formatted into VMFS Datastore.
    fn get_clustered_vmdk_supported(&self) -> Option<bool>;
    /// Indicates the current device protocol.
    /// 
    /// Application protocol for a device which is set based on input
    /// from vmkctl storage control plane. Must be one of the values of
    /// *DeviceProtocol_enum*.
    /// 
    /// ***Since:*** vSphere API Release 8.0.1.0
    fn get_application_protocol(&self) -> &Option<String>;
    /// Indicates whether namespace is dispersed.
    /// 
    /// Set to true when the namespace of LUN is dispersed.
    /// 
    /// ***Since:*** vSphere API Release 8.0.1.0
    fn get_dispersed_ns(&self) -> Option<bool>;
}
impl<'s> serde::Serialize for dyn ScsiLunTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ScsiLunTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ScsiLunVisitor)
            }
        }

struct ScsiLunVisitor;

impl<'de> de::Visitor<'de> for ScsiLunVisitor {
    type Value = Box<dyn ScsiLunTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ScsiLunTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ScsiLunTrait for ScsiLun {
    fn get_key(&self) -> &Option<String> { &self.key }
    fn get_uuid(&self) -> &str { &self.uuid }
    fn get_descriptor(&self) -> &Option<Vec<ScsiLunDescriptor>> { &self.descriptor }
    fn get_canonical_name(&self) -> &Option<String> { &self.canonical_name }
    fn get_display_name(&self) -> &Option<String> { &self.display_name }
    fn get_lun_type(&self) -> &str { &self.lun_type }
    fn get_vendor(&self) -> &Option<String> { &self.vendor }
    fn get_model(&self) -> &Option<String> { &self.model }
    fn get_revision(&self) -> &Option<String> { &self.revision }
    fn get_scsi_level(&self) -> Option<i32> { self.scsi_level }
    fn get_serial_number(&self) -> &Option<String> { &self.serial_number }
    fn get_durable_name(&self) -> &Option<ScsiLunDurableName> { &self.durable_name }
    fn get_alternate_name(&self) -> &Option<Vec<ScsiLunDurableName>> { &self.alternate_name }
    fn get_standard_inquiry(&self) -> &Option<Vec<i8>> { &self.standard_inquiry }
    fn get_queue_depth(&self) -> Option<i32> { self.queue_depth }
    fn get_operational_state(&self) -> &Vec<String> { &self.operational_state }
    fn get_capabilities(&self) -> &Option<ScsiLunCapabilities> { &self.capabilities }
    fn get_v_storage_support(&self) -> &Option<String> { &self.v_storage_support }
    fn get_protocol_endpoint(&self) -> Option<bool> { self.protocol_endpoint }
    fn get_perennially_reserved(&self) -> Option<bool> { self.perennially_reserved }
    fn get_clustered_vmdk_supported(&self) -> Option<bool> { self.clustered_vmdk_supported }
    fn get_application_protocol(&self) -> &Option<String> { &self.application_protocol }
    fn get_dispersed_ns(&self) -> Option<bool> { self.dispersed_ns }
}
impl ScsiLunTrait for HostScsiDisk {
    fn get_key(&self) -> &Option<String> { &self.key }
    fn get_uuid(&self) -> &str { &self.uuid }
    fn get_descriptor(&self) -> &Option<Vec<ScsiLunDescriptor>> { &self.descriptor }
    fn get_canonical_name(&self) -> &Option<String> { &self.canonical_name }
    fn get_display_name(&self) -> &Option<String> { &self.display_name }
    fn get_lun_type(&self) -> &str { &self.lun_type }
    fn get_vendor(&self) -> &Option<String> { &self.vendor }
    fn get_model(&self) -> &Option<String> { &self.model }
    fn get_revision(&self) -> &Option<String> { &self.revision }
    fn get_scsi_level(&self) -> Option<i32> { self.scsi_level }
    fn get_serial_number(&self) -> &Option<String> { &self.serial_number }
    fn get_durable_name(&self) -> &Option<ScsiLunDurableName> { &self.durable_name }
    fn get_alternate_name(&self) -> &Option<Vec<ScsiLunDurableName>> { &self.alternate_name }
    fn get_standard_inquiry(&self) -> &Option<Vec<i8>> { &self.standard_inquiry }
    fn get_queue_depth(&self) -> Option<i32> { self.queue_depth }
    fn get_operational_state(&self) -> &Vec<String> { &self.operational_state }
    fn get_capabilities(&self) -> &Option<ScsiLunCapabilities> { &self.capabilities }
    fn get_v_storage_support(&self) -> &Option<String> { &self.v_storage_support }
    fn get_protocol_endpoint(&self) -> Option<bool> { self.protocol_endpoint }
    fn get_perennially_reserved(&self) -> Option<bool> { self.perennially_reserved }
    fn get_clustered_vmdk_supported(&self) -> Option<bool> { self.clustered_vmdk_supported }
    fn get_application_protocol(&self) -> &Option<String> { &self.application_protocol }
    fn get_dispersed_ns(&self) -> Option<bool> { self.dispersed_ns }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ScsiLunTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ScsiLun => Some(from.as_any_ref().downcast_ref::<ScsiLun>()?),
            StructType::HostScsiDisk => Some(from.as_any_ref().downcast_ref::<HostScsiDisk>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ScsiLun => Ok(from.as_any_box().downcast::<ScsiLun>()?),
            StructType::HostScsiDisk => Ok(from.as_any_box().downcast::<HostScsiDisk>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type describes the digest information
pub trait HostDigestInfoTrait : super::traits::DataObjectTrait {
    /// Method in which the digest value is calculated.
    /// 
    /// The set of possible
    /// values is described in *HostDigestInfoDigestMethodType_enum*.
    fn get_digest_method(&self) -> &str;
    /// The variable length byte array containing the digest value calculated by
    /// the specified digestMethod.
    fn get_digest_value(&self) -> &Vec<i8>;
    /// The name of the object from which this digest value is calcaulated.
    fn get_object_name(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn HostDigestInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostDigestInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostDigestInfoVisitor)
            }
        }

struct HostDigestInfoVisitor;

impl<'de> de::Visitor<'de> for HostDigestInfoVisitor {
    type Value = Box<dyn HostDigestInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostDigestInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostDigestInfoTrait for HostDigestInfo {
    fn get_digest_method(&self) -> &str { &self.digest_method }
    fn get_digest_value(&self) -> &Vec<i8> { &self.digest_value }
    fn get_object_name(&self) -> &Option<String> { &self.object_name }
}
impl HostDigestInfoTrait for HostTpmDigestInfo {
    fn get_digest_method(&self) -> &str { &self.digest_method }
    fn get_digest_value(&self) -> &Vec<i8> { &self.digest_value }
    fn get_object_name(&self) -> &Option<String> { &self.object_name }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostDigestInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostDigestInfo => Some(from.as_any_ref().downcast_ref::<HostDigestInfo>()?),
            StructType::HostTpmDigestInfo => Some(from.as_any_ref().downcast_ref::<HostTpmDigestInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostDigestInfo => Ok(from.as_any_box().downcast::<HostDigestInfo>()?),
            StructType::HostTpmDigestInfo => Ok(from.as_any_box().downcast::<HostTpmDigestInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type describes the DNS configuration.
/// 
/// All IPv4 addresses, subnet addresses, and netmasks are specified using
/// dotted decimal notation. For example, "192.0.2.1".
/// IPv6 addresses are 128-bit addresses represented as
/// eight fields of up to four hexadecimal digits.
/// A colon separates each field (:). For example,
/// 2001:DB8:101::230:6eff:fe04:d9ff. The address can also consist of the
/// symbol '::' to represent multiple 16-bit groups of
/// contiguous 0's only once in an address as described in RFC 2373.
pub trait HostDnsConfigTrait : super::traits::DataObjectTrait {
    /// The flag to indicate whether or not DHCP (dynamic host control
    /// protocol) is used to determine DNS configuration automatically.
    fn get_dhcp(&self) -> bool;
    /// If DHCP is enabled, the DHCP DNS of the vmkernel nic will override
    /// the system's DNS.
    /// 
    /// This field applies to both IPv4 and IPv6 DNS settings
    /// if *ipv6VirtualNicDevice*
    /// is unset, otherwise it is applicable only for IPv4 setting.
    /// This field is ignored if DHCP is disabled by the
    /// *dhcp* property.
    fn get_virtual_nic_device(&self) -> &Option<String>;
    /// If DHCP is enabled, the IPv6 DHCP DNS of the vmkernel nic will override
    /// the system's IPv6 DNS.
    /// 
    /// This field is ignored if DHCP is disabled by the
    /// *dhcp* property.
    fn get_ipv_6_virtual_nic_device(&self) -> &Option<String>;
    /// The host name portion of DNS name.
    /// 
    /// For example, "esx01".
    /// 
    /// **Note**: When DHCP is not enabled, the property can be set
    /// explicitly. When DHCP is enabled, the property reflects the current
    /// DNS configuration, but cannot be set.
    /// The hostName can't have character '.' in it when set explicitly.
    fn get_host_name(&self) -> &str;
    /// The domain name portion of the DNS name.
    /// 
    /// For example, "vmware.com".
    /// 
    /// **Note**: When DHCP is not enabled, the property can be set
    /// explicitly. When DHCP is enabled, the property reflects the current
    /// DNS configuration, but cannot be set.
    fn get_domain_name(&self) -> &str;
    /// The IP addresses of the DNS servers, placed in order of preference.
    /// 
    /// **Note**: When DHCP is not enabled, the property can be set
    /// explicitly. When DHCP is enabled, the property reflects the current
    /// DNS configuration, but cannot be set.
    fn get_address(&self) -> &Option<Vec<String>>;
    /// The domain in which to search for hosts, placed in order of preference.
    /// 
    /// **Note**: When DHCP is not enabled, the property can be set
    /// explicitly. When DHCP is enabled, the property reflects the current
    /// DNS configuration, but cannot be set.
    fn get_search_domain(&self) -> &Option<Vec<String>>;
}
impl<'s> serde::Serialize for dyn HostDnsConfigTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostDnsConfigTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostDnsConfigVisitor)
            }
        }

struct HostDnsConfigVisitor;

impl<'de> de::Visitor<'de> for HostDnsConfigVisitor {
    type Value = Box<dyn HostDnsConfigTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostDnsConfigTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostDnsConfigTrait for HostDnsConfig {
    fn get_dhcp(&self) -> bool { self.dhcp }
    fn get_virtual_nic_device(&self) -> &Option<String> { &self.virtual_nic_device }
    fn get_ipv_6_virtual_nic_device(&self) -> &Option<String> { &self.ipv_6_virtual_nic_device }
    fn get_host_name(&self) -> &str { &self.host_name }
    fn get_domain_name(&self) -> &str { &self.domain_name }
    fn get_address(&self) -> &Option<Vec<String>> { &self.address }
    fn get_search_domain(&self) -> &Option<Vec<String>> { &self.search_domain }
}
impl HostDnsConfigTrait for HostDnsConfigSpec {
    fn get_dhcp(&self) -> bool { self.dhcp }
    fn get_virtual_nic_device(&self) -> &Option<String> { &self.virtual_nic_device }
    fn get_ipv_6_virtual_nic_device(&self) -> &Option<String> { &self.ipv_6_virtual_nic_device }
    fn get_host_name(&self) -> &str { &self.host_name }
    fn get_domain_name(&self) -> &str { &self.domain_name }
    fn get_address(&self) -> &Option<Vec<String>> { &self.address }
    fn get_search_domain(&self) -> &Option<Vec<String>> { &self.search_domain }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostDnsConfigTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostDnsConfig => Some(from.as_any_ref().downcast_ref::<HostDnsConfig>()?),
            StructType::HostDnsConfigSpec => Some(from.as_any_ref().downcast_ref::<HostDnsConfigSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostDnsConfig => Ok(from.as_any_box().downcast::<HostDnsConfig>()?),
            StructType::HostDnsConfigSpec => Ok(from.as_any_box().downcast::<HostDnsConfigSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Detailed information about a file system.
/// 
/// This is a base type for derived types
/// that have more specific details about specific filesystem types.
/// 
/// Typically a FileSystem is exposed as a datatore
/// 
/// See also *DatastoreInfo*, *HostVmfsVolume*, *HostNasVolume*, *HostVffsVolume*, *HostLocalFileSystemVolume*
/// 
/// However, a FileSystemVolume need not be exposed a datastore., *HostVfatVolume*.
pub trait HostFileSystemVolumeTrait : super::traits::DataObjectTrait {
    /// FileSystemType of this particular file system
    /// See *HostFileSystemVolumeFileSystemType_enum*
    fn get_type(&self) -> &str;
    /// Name of the file system volume.
    fn get_name(&self) -> &str;
    /// The capacity of the file system volume, in bytes.
    fn get_capacity(&self) -> i64;
}
impl<'s> serde::Serialize for dyn HostFileSystemVolumeTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostFileSystemVolumeTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostFileSystemVolumeVisitor)
            }
        }

struct HostFileSystemVolumeVisitor;

impl<'de> de::Visitor<'de> for HostFileSystemVolumeVisitor {
    type Value = Box<dyn HostFileSystemVolumeTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostFileSystemVolumeTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostFileSystemVolumeTrait for HostFileSystemVolume {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_name(&self) -> &str { &self.name }
    fn get_capacity(&self) -> i64 { self.capacity }
}
impl HostFileSystemVolumeTrait for HostLocalFileSystemVolume {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_name(&self) -> &str { &self.name }
    fn get_capacity(&self) -> i64 { self.capacity }
}
impl HostFileSystemVolumeTrait for HostNasVolume {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_name(&self) -> &str { &self.name }
    fn get_capacity(&self) -> i64 { self.capacity }
}
impl HostFileSystemVolumeTrait for HostPMemVolume {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_name(&self) -> &str { &self.name }
    fn get_capacity(&self) -> i64 { self.capacity }
}
impl HostFileSystemVolumeTrait for HostVfatVolume {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_name(&self) -> &str { &self.name }
    fn get_capacity(&self) -> i64 { self.capacity }
}
impl HostFileSystemVolumeTrait for HostVffsVolume {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_name(&self) -> &str { &self.name }
    fn get_capacity(&self) -> i64 { self.capacity }
}
impl HostFileSystemVolumeTrait for HostVmfsVolume {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_name(&self) -> &str { &self.name }
    fn get_capacity(&self) -> i64 { self.capacity }
}
impl HostFileSystemVolumeTrait for HostVvolVolume {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_name(&self) -> &str { &self.name }
    fn get_capacity(&self) -> i64 { self.capacity }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostFileSystemVolumeTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostFileSystemVolume => Some(from.as_any_ref().downcast_ref::<HostFileSystemVolume>()?),
            StructType::HostLocalFileSystemVolume => Some(from.as_any_ref().downcast_ref::<HostLocalFileSystemVolume>()?),
            StructType::HostNasVolume => Some(from.as_any_ref().downcast_ref::<HostNasVolume>()?),
            StructType::HostPMemVolume => Some(from.as_any_ref().downcast_ref::<HostPMemVolume>()?),
            StructType::HostVfatVolume => Some(from.as_any_ref().downcast_ref::<HostVfatVolume>()?),
            StructType::HostVffsVolume => Some(from.as_any_ref().downcast_ref::<HostVffsVolume>()?),
            StructType::HostVmfsVolume => Some(from.as_any_ref().downcast_ref::<HostVmfsVolume>()?),
            StructType::HostVvolVolume => Some(from.as_any_ref().downcast_ref::<HostVvolVolume>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostFileSystemVolume => Ok(from.as_any_box().downcast::<HostFileSystemVolume>()?),
            StructType::HostLocalFileSystemVolume => Ok(from.as_any_box().downcast::<HostLocalFileSystemVolume>()?),
            StructType::HostNasVolume => Ok(from.as_any_box().downcast::<HostNasVolume>()?),
            StructType::HostPMemVolume => Ok(from.as_any_box().downcast::<HostPMemVolume>()?),
            StructType::HostVfatVolume => Ok(from.as_any_box().downcast::<HostVfatVolume>()?),
            StructType::HostVffsVolume => Ok(from.as_any_box().downcast::<HostVffsVolume>()?),
            StructType::HostVmfsVolume => Ok(from.as_any_box().downcast::<HostVmfsVolume>()?),
            StructType::HostVvolVolume => Ok(from.as_any_box().downcast::<HostVvolVolume>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Data object describing the operational status of a physical
/// element.
pub trait HostHardwareElementInfoTrait : super::traits::DataObjectTrait {
    /// The name of the physical element
    fn get_name(&self) -> &str;
    /// The operational status of the physical element.
    /// 
    /// The status is one of
    /// the values specified in HostHardwareElementStatus.
    /// 
    /// See also *HostHardwareElementStatus_enum*.
    fn get_status(&self) -> &Box<dyn super::traits::ElementDescriptionTrait>;
}
impl<'s> serde::Serialize for dyn HostHardwareElementInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostHardwareElementInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostHardwareElementInfoVisitor)
            }
        }

struct HostHardwareElementInfoVisitor;

impl<'de> de::Visitor<'de> for HostHardwareElementInfoVisitor {
    type Value = Box<dyn HostHardwareElementInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostHardwareElementInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostHardwareElementInfoTrait for HostHardwareElementInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_status(&self) -> &Box<dyn super::traits::ElementDescriptionTrait> { &self.status }
}
impl HostHardwareElementInfoTrait for DpuStatusInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_status(&self) -> &Box<dyn super::traits::ElementDescriptionTrait> { &self.status }
}
impl HostHardwareElementInfoTrait for HostStorageElementInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_status(&self) -> &Box<dyn super::traits::ElementDescriptionTrait> { &self.status }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostHardwareElementInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostHardwareElementInfo => Some(from.as_any_ref().downcast_ref::<HostHardwareElementInfo>()?),
            StructType::DpuStatusInfo => Some(from.as_any_ref().downcast_ref::<DpuStatusInfo>()?),
            StructType::HostStorageElementInfo => Some(from.as_any_ref().downcast_ref::<HostStorageElementInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostHardwareElementInfo => Ok(from.as_any_box().downcast::<HostHardwareElementInfo>()?),
            StructType::DpuStatusInfo => Ok(from.as_any_box().downcast::<DpuStatusInfo>()?),
            StructType::HostStorageElementInfo => Ok(from.as_any_box().downcast::<HostStorageElementInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// A data object which specifies the parameters needed
/// to create a software host bus adapter of a specific kind.
/// 
/// ***Since:*** vSphere API Release 7.0.3.0
pub trait HostHbaCreateSpecTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn HostHbaCreateSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostHbaCreateSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostHbaCreateSpecVisitor)
            }
        }

struct HostHbaCreateSpecVisitor;

impl<'de> de::Visitor<'de> for HostHbaCreateSpecVisitor {
    type Value = Box<dyn HostHbaCreateSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostHbaCreateSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostHbaCreateSpecTrait for HostHbaCreateSpec {
}
impl HostHbaCreateSpecTrait for HostTcpHbaCreateSpec {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostHbaCreateSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostHbaCreateSpec => Some(from.as_any_ref().downcast_ref::<HostHbaCreateSpec>()?),
            StructType::HostTcpHbaCreateSpec => Some(from.as_any_ref().downcast_ref::<HostTcpHbaCreateSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostHbaCreateSpec => Ok(from.as_any_box().downcast::<HostHbaCreateSpec>()?),
            StructType::HostTcpHbaCreateSpec => Ok(from.as_any_box().downcast::<HostTcpHbaCreateSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type describes the bus adapter for
/// the host.
/// 
/// A host bus adapter (HBA) is a hardware
/// or software adapter that connects the host to storage devices.
pub trait HostHostBusAdapterTrait : super::traits::DataObjectTrait {
    /// The linkable identifier.
    fn get_key(&self) -> &Option<String>;
    /// The device name of host bus adapter.
    fn get_device(&self) -> &str;
    /// The host bus number.
    fn get_bus(&self) -> i32;
    /// The operational status of the adapter.
    /// 
    /// Valid values include "online",
    /// "offline", "unbound", and "unknown".
    fn get_status(&self) -> &str;
    /// The model name of the host bus adapter.
    fn get_model(&self) -> &str;
    /// The name of the driver.
    fn get_driver(&self) -> &Option<String>;
    /// The Peripheral Connect Interface (PCI) ID of the device
    /// representing the host bus adapter.
    fn get_pci(&self) -> &Option<String>;
    /// The type of protocol supported by the host bus adapter.
    /// 
    /// The list of supported values is described in
    /// *HostStorageProtocol_enum*.
    /// When unset, a default value of "scsi" is assumed.
    fn get_storage_protocol(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn HostHostBusAdapterTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostHostBusAdapterTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostHostBusAdapterVisitor)
            }
        }

struct HostHostBusAdapterVisitor;

impl<'de> de::Visitor<'de> for HostHostBusAdapterVisitor {
    type Value = Box<dyn HostHostBusAdapterTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostHostBusAdapterTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostHostBusAdapterTrait for HostHostBusAdapter {
    fn get_key(&self) -> &Option<String> { &self.key }
    fn get_device(&self) -> &str { &self.device }
    fn get_bus(&self) -> i32 { self.bus }
    fn get_status(&self) -> &str { &self.status }
    fn get_model(&self) -> &str { &self.model }
    fn get_driver(&self) -> &Option<String> { &self.driver }
    fn get_pci(&self) -> &Option<String> { &self.pci }
    fn get_storage_protocol(&self) -> &Option<String> { &self.storage_protocol }
}
impl HostHostBusAdapterTrait for HostBlockHba {
    fn get_key(&self) -> &Option<String> { &self.key }
    fn get_device(&self) -> &str { &self.device }
    fn get_bus(&self) -> i32 { self.bus }
    fn get_status(&self) -> &str { &self.status }
    fn get_model(&self) -> &str { &self.model }
    fn get_driver(&self) -> &Option<String> { &self.driver }
    fn get_pci(&self) -> &Option<String> { &self.pci }
    fn get_storage_protocol(&self) -> &Option<String> { &self.storage_protocol }
}
impl HostHostBusAdapterTrait for HostFibreChannelHba {
    fn get_key(&self) -> &Option<String> { &self.key }
    fn get_device(&self) -> &str { &self.device }
    fn get_bus(&self) -> i32 { self.bus }
    fn get_status(&self) -> &str { &self.status }
    fn get_model(&self) -> &str { &self.model }
    fn get_driver(&self) -> &Option<String> { &self.driver }
    fn get_pci(&self) -> &Option<String> { &self.pci }
    fn get_storage_protocol(&self) -> &Option<String> { &self.storage_protocol }
}
impl HostHostBusAdapterTrait for HostFibreChannelOverEthernetHba {
    fn get_key(&self) -> &Option<String> { &self.key }
    fn get_device(&self) -> &str { &self.device }
    fn get_bus(&self) -> i32 { self.bus }
    fn get_status(&self) -> &str { &self.status }
    fn get_model(&self) -> &str { &self.model }
    fn get_driver(&self) -> &Option<String> { &self.driver }
    fn get_pci(&self) -> &Option<String> { &self.pci }
    fn get_storage_protocol(&self) -> &Option<String> { &self.storage_protocol }
}
impl HostHostBusAdapterTrait for HostInternetScsiHba {
    fn get_key(&self) -> &Option<String> { &self.key }
    fn get_device(&self) -> &str { &self.device }
    fn get_bus(&self) -> i32 { self.bus }
    fn get_status(&self) -> &str { &self.status }
    fn get_model(&self) -> &str { &self.model }
    fn get_driver(&self) -> &Option<String> { &self.driver }
    fn get_pci(&self) -> &Option<String> { &self.pci }
    fn get_storage_protocol(&self) -> &Option<String> { &self.storage_protocol }
}
impl HostHostBusAdapterTrait for HostParallelScsiHba {
    fn get_key(&self) -> &Option<String> { &self.key }
    fn get_device(&self) -> &str { &self.device }
    fn get_bus(&self) -> i32 { self.bus }
    fn get_status(&self) -> &str { &self.status }
    fn get_model(&self) -> &str { &self.model }
    fn get_driver(&self) -> &Option<String> { &self.driver }
    fn get_pci(&self) -> &Option<String> { &self.pci }
    fn get_storage_protocol(&self) -> &Option<String> { &self.storage_protocol }
}
impl HostHostBusAdapterTrait for HostPcieHba {
    fn get_key(&self) -> &Option<String> { &self.key }
    fn get_device(&self) -> &str { &self.device }
    fn get_bus(&self) -> i32 { self.bus }
    fn get_status(&self) -> &str { &self.status }
    fn get_model(&self) -> &str { &self.model }
    fn get_driver(&self) -> &Option<String> { &self.driver }
    fn get_pci(&self) -> &Option<String> { &self.pci }
    fn get_storage_protocol(&self) -> &Option<String> { &self.storage_protocol }
}
impl HostHostBusAdapterTrait for HostRdmaHba {
    fn get_key(&self) -> &Option<String> { &self.key }
    fn get_device(&self) -> &str { &self.device }
    fn get_bus(&self) -> i32 { self.bus }
    fn get_status(&self) -> &str { &self.status }
    fn get_model(&self) -> &str { &self.model }
    fn get_driver(&self) -> &Option<String> { &self.driver }
    fn get_pci(&self) -> &Option<String> { &self.pci }
    fn get_storage_protocol(&self) -> &Option<String> { &self.storage_protocol }
}
impl HostHostBusAdapterTrait for HostSerialAttachedHba {
    fn get_key(&self) -> &Option<String> { &self.key }
    fn get_device(&self) -> &str { &self.device }
    fn get_bus(&self) -> i32 { self.bus }
    fn get_status(&self) -> &str { &self.status }
    fn get_model(&self) -> &str { &self.model }
    fn get_driver(&self) -> &Option<String> { &self.driver }
    fn get_pci(&self) -> &Option<String> { &self.pci }
    fn get_storage_protocol(&self) -> &Option<String> { &self.storage_protocol }
}
impl HostHostBusAdapterTrait for HostTcpHba {
    fn get_key(&self) -> &Option<String> { &self.key }
    fn get_device(&self) -> &str { &self.device }
    fn get_bus(&self) -> i32 { self.bus }
    fn get_status(&self) -> &str { &self.status }
    fn get_model(&self) -> &str { &self.model }
    fn get_driver(&self) -> &Option<String> { &self.driver }
    fn get_pci(&self) -> &Option<String> { &self.pci }
    fn get_storage_protocol(&self) -> &Option<String> { &self.storage_protocol }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostHostBusAdapterTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostHostBusAdapter => Some(from.as_any_ref().downcast_ref::<HostHostBusAdapter>()?),
            StructType::HostBlockHba => Some(from.as_any_ref().downcast_ref::<HostBlockHba>()?),
            StructType::HostFibreChannelHba => Some(from.as_any_ref().downcast_ref::<HostFibreChannelHba>()?),
            StructType::HostFibreChannelOverEthernetHba => Some(from.as_any_ref().downcast_ref::<HostFibreChannelOverEthernetHba>()?),
            StructType::HostInternetScsiHba => Some(from.as_any_ref().downcast_ref::<HostInternetScsiHba>()?),
            StructType::HostParallelScsiHba => Some(from.as_any_ref().downcast_ref::<HostParallelScsiHba>()?),
            StructType::HostPcieHba => Some(from.as_any_ref().downcast_ref::<HostPcieHba>()?),
            StructType::HostRdmaHba => Some(from.as_any_ref().downcast_ref::<HostRdmaHba>()?),
            StructType::HostSerialAttachedHba => Some(from.as_any_ref().downcast_ref::<HostSerialAttachedHba>()?),
            StructType::HostTcpHba => Some(from.as_any_ref().downcast_ref::<HostTcpHba>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostHostBusAdapter => Ok(from.as_any_box().downcast::<HostHostBusAdapter>()?),
            StructType::HostBlockHba => Ok(from.as_any_box().downcast::<HostBlockHba>()?),
            StructType::HostFibreChannelHba => Ok(from.as_any_box().downcast::<HostFibreChannelHba>()?),
            StructType::HostFibreChannelOverEthernetHba => Ok(from.as_any_box().downcast::<HostFibreChannelOverEthernetHba>()?),
            StructType::HostInternetScsiHba => Ok(from.as_any_box().downcast::<HostInternetScsiHba>()?),
            StructType::HostParallelScsiHba => Ok(from.as_any_box().downcast::<HostParallelScsiHba>()?),
            StructType::HostPcieHba => Ok(from.as_any_box().downcast::<HostPcieHba>()?),
            StructType::HostRdmaHba => Ok(from.as_any_box().downcast::<HostRdmaHba>()?),
            StructType::HostSerialAttachedHba => Ok(from.as_any_box().downcast::<HostSerialAttachedHba>()?),
            StructType::HostTcpHba => Ok(from.as_any_box().downcast::<HostTcpHba>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type describes the Fibre Channel host bus adapter.
pub trait HostFibreChannelHbaTrait : super::traits::HostHostBusAdapterTrait {
    /// The world wide port name for the adapter.
    fn get_port_world_wide_name(&self) -> i64;
    /// The world wide node name for the adapter.
    fn get_node_world_wide_name(&self) -> i64;
    /// The type of the fiber channel port.
    fn get_port_type(&self) -> &super::enums::FibreChannelPortTypeEnum;
    /// The current operating speed of the adapter in
    /// bits per second.
    fn get_speed(&self) -> i64;
}
impl<'s> serde::Serialize for dyn HostFibreChannelHbaTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostFibreChannelHbaTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostFibreChannelHbaVisitor)
            }
        }

struct HostFibreChannelHbaVisitor;

impl<'de> de::Visitor<'de> for HostFibreChannelHbaVisitor {
    type Value = Box<dyn HostFibreChannelHbaTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostFibreChannelHbaTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostFibreChannelHbaTrait for HostFibreChannelHba {
    fn get_port_world_wide_name(&self) -> i64 { self.port_world_wide_name }
    fn get_node_world_wide_name(&self) -> i64 { self.node_world_wide_name }
    fn get_port_type(&self) -> &super::enums::FibreChannelPortTypeEnum { &self.port_type }
    fn get_speed(&self) -> i64 { self.speed }
}
impl HostFibreChannelHbaTrait for HostFibreChannelOverEthernetHba {
    fn get_port_world_wide_name(&self) -> i64 { self.port_world_wide_name }
    fn get_node_world_wide_name(&self) -> i64 { self.node_world_wide_name }
    fn get_port_type(&self) -> &super::enums::FibreChannelPortTypeEnum { &self.port_type }
    fn get_speed(&self) -> i64 { self.speed }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostFibreChannelHbaTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostFibreChannelHba => Some(from.as_any_ref().downcast_ref::<HostFibreChannelHba>()?),
            StructType::HostFibreChannelOverEthernetHba => Some(from.as_any_ref().downcast_ref::<HostFibreChannelOverEthernetHba>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostFibreChannelHba => Ok(from.as_any_box().downcast::<HostFibreChannelHba>()?),
            StructType::HostFibreChannelOverEthernetHba => Ok(from.as_any_box().downcast::<HostFibreChannelOverEthernetHba>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// IP Route Configuration.
/// 
/// All IPv4 addresses, subnet addresses, and
/// netmasks are specified as strings using dotted decimal notation.
/// For example, "192.0.2.1".
/// IPv6 addresses are 128-bit addresses represented
/// as eight fields of up to four hexadecimal digits. A colon separates each
/// field (:). For example, 2001:DB8:101::230:6eff:fe04:d9ff. The address can
/// also consist of symbol '::' to represent multiple 16-bit groups of
/// contiguous 0's only once in an address as described in RFC 2373.
pub trait HostIpRouteConfigTrait : super::traits::DataObjectTrait {
    /// The default gateway address.
    fn get_default_gateway(&self) -> &Option<String>;
    /// The gateway device.
    /// 
    /// This applies to service console gateway only, it
    /// is ignored otherwise.
    fn get_gateway_device(&self) -> &Option<String>;
    /// The default ipv6 gateway address
    fn get_ip_v_6_default_gateway(&self) -> &Option<String>;
    /// The ipv6 gateway device.
    /// 
    /// This applies to service console gateway only, it
    fn get_ip_v_6_gateway_device(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn HostIpRouteConfigTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostIpRouteConfigTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostIpRouteConfigVisitor)
            }
        }

struct HostIpRouteConfigVisitor;

impl<'de> de::Visitor<'de> for HostIpRouteConfigVisitor {
    type Value = Box<dyn HostIpRouteConfigTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostIpRouteConfigTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostIpRouteConfigTrait for HostIpRouteConfig {
    fn get_default_gateway(&self) -> &Option<String> { &self.default_gateway }
    fn get_gateway_device(&self) -> &Option<String> { &self.gateway_device }
    fn get_ip_v_6_default_gateway(&self) -> &Option<String> { &self.ip_v_6_default_gateway }
    fn get_ip_v_6_gateway_device(&self) -> &Option<String> { &self.ip_v_6_gateway_device }
}
impl HostIpRouteConfigTrait for HostIpRouteConfigSpec {
    fn get_default_gateway(&self) -> &Option<String> { &self.default_gateway }
    fn get_gateway_device(&self) -> &Option<String> { &self.gateway_device }
    fn get_ip_v_6_default_gateway(&self) -> &Option<String> { &self.ip_v_6_default_gateway }
    fn get_ip_v_6_gateway_device(&self) -> &Option<String> { &self.ip_v_6_gateway_device }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostIpRouteConfigTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostIpRouteConfig => Some(from.as_any_ref().downcast_ref::<HostIpRouteConfig>()?),
            StructType::HostIpRouteConfigSpec => Some(from.as_any_ref().downcast_ref::<HostIpRouteConfigSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostIpRouteConfig => Ok(from.as_any_box().downcast::<HostIpRouteConfig>()?),
            StructType::HostIpRouteConfigSpec => Ok(from.as_any_box().downcast::<HostIpRouteConfigSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type contains common parameters
/// for local account creation.
/// 
/// The password and description properties
/// are not supported for group accounts on POSIX hosts.
pub trait HostAccountSpecTrait : super::traits::DataObjectTrait {
    /// The ID of the specified account.
    fn get_id(&self) -> &str;
    /// The password for a user or group.
    fn get_password(&self) -> &Option<String>;
    /// The description of the specified account.
    fn get_description(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn HostAccountSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostAccountSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostAccountSpecVisitor)
            }
        }

struct HostAccountSpecVisitor;

impl<'de> de::Visitor<'de> for HostAccountSpecVisitor {
    type Value = Box<dyn HostAccountSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostAccountSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostAccountSpecTrait for HostAccountSpec {
    fn get_id(&self) -> &str { &self.id }
    fn get_password(&self) -> &Option<String> { &self.password }
    fn get_description(&self) -> &Option<String> { &self.description }
}
impl HostAccountSpecTrait for HostPosixAccountSpec {
    fn get_id(&self) -> &str { &self.id }
    fn get_password(&self) -> &Option<String> { &self.password }
    fn get_description(&self) -> &Option<String> { &self.description }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostAccountSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostAccountSpec => Some(from.as_any_ref().downcast_ref::<HostAccountSpec>()?),
            StructType::HostPosixAccountSpec => Some(from.as_any_ref().downcast_ref::<HostPosixAccountSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostAccountSpec => Ok(from.as_any_box().downcast::<HostAccountSpec>()?),
            StructType::HostPosixAccountSpec => Ok(from.as_any_box().downcast::<HostPosixAccountSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *HostMultipathInfoLogicalUnitPolicy* data object
/// describes a path selection policy for a device.
/// 
/// This policy determines
/// how paths should be utilized when accessing a device.
pub trait HostMultipathInfoLogicalUnitPolicyTrait : super::traits::DataObjectTrait {
    /// String representing the path selection policy for a device.
    /// 
    /// Use one of the following
    /// strings:
    /// For NMP plugin
    /// - <code>VMW\_PSP\_FIXED</code> - Use a preferred path whenever possible.
    /// - <code>VMW\_PSP\_RR</code> - Load balance.
    /// - <code>VMW\_PSP\_MRU</code> - Use the most recently used path.
    ///   
    /// For HPP plugin
    /// - <code>FIXED</code> - Use a preferred path whenever possible.
    /// - <code>LB-RR</code> - Load Balance - round robin.
    /// - <code>LB-IOPS</code> - Load Balance - iops.
    /// - <code>LB-BYTES</code> - Load Balance - bytes.
    /// - <code>LB--Latency</code> - Load balance - least latency.
    ///   
    /// You can also use the
    /// *HostStorageSystem.QueryPathSelectionPolicyOptions* method
    /// to retrieve the set of valid strings.
    /// Use the key from the resulting structure
    /// *HostPathSelectionPolicyOption*.
    fn get_policy(&self) -> &str;
}
impl<'s> serde::Serialize for dyn HostMultipathInfoLogicalUnitPolicyTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostMultipathInfoLogicalUnitPolicyTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostMultipathInfoLogicalUnitPolicyVisitor)
            }
        }

struct HostMultipathInfoLogicalUnitPolicyVisitor;

impl<'de> de::Visitor<'de> for HostMultipathInfoLogicalUnitPolicyVisitor {
    type Value = Box<dyn HostMultipathInfoLogicalUnitPolicyTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostMultipathInfoLogicalUnitPolicyTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostMultipathInfoLogicalUnitPolicyTrait for HostMultipathInfoLogicalUnitPolicy {
    fn get_policy(&self) -> &str { &self.policy }
}
impl HostMultipathInfoLogicalUnitPolicyTrait for HostMultipathInfoFixedLogicalUnitPolicy {
    fn get_policy(&self) -> &str { &self.policy }
}
impl HostMultipathInfoLogicalUnitPolicyTrait for HostMultipathInfoHppLogicalUnitPolicy {
    fn get_policy(&self) -> &str { &self.policy }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostMultipathInfoLogicalUnitPolicyTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostMultipathInfoLogicalUnitPolicy => Some(from.as_any_ref().downcast_ref::<HostMultipathInfoLogicalUnitPolicy>()?),
            StructType::HostMultipathInfoFixedLogicalUnitPolicy => Some(from.as_any_ref().downcast_ref::<HostMultipathInfoFixedLogicalUnitPolicy>()?),
            StructType::HostMultipathInfoHppLogicalUnitPolicy => Some(from.as_any_ref().downcast_ref::<HostMultipathInfoHppLogicalUnitPolicy>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostMultipathInfoLogicalUnitPolicy => Ok(from.as_any_box().downcast::<HostMultipathInfoLogicalUnitPolicy>()?),
            StructType::HostMultipathInfoFixedLogicalUnitPolicy => Ok(from.as_any_box().downcast::<HostMultipathInfoFixedLogicalUnitPolicy>()?),
            StructType::HostMultipathInfoHppLogicalUnitPolicy => Ok(from.as_any_box().downcast::<HostMultipathInfoHppLogicalUnitPolicy>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Specifies the main parameters needed when connecting to
/// an NVMe over Fabrics controller or Discovery Service.
pub trait HostNvmeSpecTrait : super::traits::DataObjectTrait {
    /// The device name of the NVME over Fabrics host bus adapter.
    fn get_hba_name(&self) -> &str;
    /// Transport specific information necessary to connect to the controller.
    fn get_transport_parameters(&self) -> &Box<dyn super::traits::HostNvmeTransportParametersTrait>;
}
impl<'s> serde::Serialize for dyn HostNvmeSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostNvmeSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostNvmeSpecVisitor)
            }
        }

struct HostNvmeSpecVisitor;

impl<'de> de::Visitor<'de> for HostNvmeSpecVisitor {
    type Value = Box<dyn HostNvmeSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostNvmeSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostNvmeSpecTrait for HostNvmeSpec {
    fn get_hba_name(&self) -> &str { &self.hba_name }
    fn get_transport_parameters(&self) -> &Box<dyn super::traits::HostNvmeTransportParametersTrait> { &self.transport_parameters }
}
impl HostNvmeSpecTrait for HostNvmeConnectSpec {
    fn get_hba_name(&self) -> &str { &self.hba_name }
    fn get_transport_parameters(&self) -> &Box<dyn super::traits::HostNvmeTransportParametersTrait> { &self.transport_parameters }
}
impl HostNvmeSpecTrait for HostNvmeDiscoverSpec {
    fn get_hba_name(&self) -> &str { &self.hba_name }
    fn get_transport_parameters(&self) -> &Box<dyn super::traits::HostNvmeTransportParametersTrait> { &self.transport_parameters }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostNvmeSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostNvmeSpec => Some(from.as_any_ref().downcast_ref::<HostNvmeSpec>()?),
            StructType::HostNvmeConnectSpec => Some(from.as_any_ref().downcast_ref::<HostNvmeConnectSpec>()?),
            StructType::HostNvmeDiscoverSpec => Some(from.as_any_ref().downcast_ref::<HostNvmeDiscoverSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostNvmeSpec => Ok(from.as_any_box().downcast::<HostNvmeSpec>()?),
            StructType::HostNvmeConnectSpec => Ok(from.as_any_box().downcast::<HostNvmeConnectSpec>()?),
            StructType::HostNvmeDiscoverSpec => Ok(from.as_any_box().downcast::<HostNvmeDiscoverSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object represents the transport specific parameters
/// necessary to establish an NVM Express over Fabrics connection.
/// 
/// For some further information, see:
/// - "NVM Express over Fabrics 1.0", Section 1.5.7, "Connection"
pub trait HostNvmeTransportParametersTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn HostNvmeTransportParametersTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostNvmeTransportParametersTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostNvmeTransportParametersVisitor)
            }
        }

struct HostNvmeTransportParametersVisitor;

impl<'de> de::Visitor<'de> for HostNvmeTransportParametersVisitor {
    type Value = Box<dyn HostNvmeTransportParametersTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostNvmeTransportParametersTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostNvmeTransportParametersTrait for HostNvmeTransportParameters {
}
impl HostNvmeTransportParametersTrait for HostNvmeOpaqueTransportParameters {
}
impl HostNvmeTransportParametersTrait for HostNvmeOverFibreChannelParameters {
}
impl HostNvmeTransportParametersTrait for HostNvmeOverRdmaParameters {
}
impl HostNvmeTransportParametersTrait for HostNvmeOverTcpParameters {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostNvmeTransportParametersTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostNvmeTransportParameters => Some(from.as_any_ref().downcast_ref::<HostNvmeTransportParameters>()?),
            StructType::HostNvmeOpaqueTransportParameters => Some(from.as_any_ref().downcast_ref::<HostNvmeOpaqueTransportParameters>()?),
            StructType::HostNvmeOverFibreChannelParameters => Some(from.as_any_ref().downcast_ref::<HostNvmeOverFibreChannelParameters>()?),
            StructType::HostNvmeOverRdmaParameters => Some(from.as_any_ref().downcast_ref::<HostNvmeOverRdmaParameters>()?),
            StructType::HostNvmeOverTcpParameters => Some(from.as_any_ref().downcast_ref::<HostNvmeOverTcpParameters>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostNvmeTransportParameters => Ok(from.as_any_box().downcast::<HostNvmeTransportParameters>()?),
            StructType::HostNvmeOpaqueTransportParameters => Ok(from.as_any_box().downcast::<HostNvmeOpaqueTransportParameters>()?),
            StructType::HostNvmeOverFibreChannelParameters => Ok(from.as_any_box().downcast::<HostNvmeOverFibreChannelParameters>()?),
            StructType::HostNvmeOverRdmaParameters => Ok(from.as_any_box().downcast::<HostNvmeOverRdmaParameters>()?),
            StructType::HostNvmeOverTcpParameters => Ok(from.as_any_box().downcast::<HostNvmeOverTcpParameters>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object provides information about the state of PciPassthru
/// for all pci devices.
pub trait HostPciPassthruConfigTrait : super::traits::DataObjectTrait {
    /// The name ID of this PCI, composed of "bus:slot.function".
    fn get_id(&self) -> &str;
    /// Whether passThru has been configured for this device
    fn get_passthru_enabled(&self) -> bool;
    /// Whether the passThru config should take effect without rebooting ESX.
    /// 
    /// When unset, the behavior will be determined automatically
    /// based on *HostCapability.deviceRebindWithoutRebootSupported*.
    /// If the configuration can be applied immediately, it
    /// will be, otherwise the changes will take effect after reboot.
    fn get_apply_now(&self) -> Option<bool>;
    /// The hardware label of the this PCI device.
    /// 
    /// ***Since:*** vSphere API Release 7.0.2.0
    fn get_hardware_label(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn HostPciPassthruConfigTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostPciPassthruConfigTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostPciPassthruConfigVisitor)
            }
        }

struct HostPciPassthruConfigVisitor;

impl<'de> de::Visitor<'de> for HostPciPassthruConfigVisitor {
    type Value = Box<dyn HostPciPassthruConfigTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostPciPassthruConfigTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostPciPassthruConfigTrait for HostPciPassthruConfig {
    fn get_id(&self) -> &str { &self.id }
    fn get_passthru_enabled(&self) -> bool { self.passthru_enabled }
    fn get_apply_now(&self) -> Option<bool> { self.apply_now }
    fn get_hardware_label(&self) -> &Option<String> { &self.hardware_label }
}
impl HostPciPassthruConfigTrait for HostSriovConfig {
    fn get_id(&self) -> &str { &self.id }
    fn get_passthru_enabled(&self) -> bool { self.passthru_enabled }
    fn get_apply_now(&self) -> Option<bool> { self.apply_now }
    fn get_hardware_label(&self) -> &Option<String> { &self.hardware_label }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostPciPassthruConfigTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostPciPassthruConfig => Some(from.as_any_ref().downcast_ref::<HostPciPassthruConfig>()?),
            StructType::HostSriovConfig => Some(from.as_any_ref().downcast_ref::<HostSriovConfig>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostPciPassthruConfig => Ok(from.as_any_box().downcast::<HostPciPassthruConfig>()?),
            StructType::HostSriovConfig => Ok(from.as_any_box().downcast::<HostSriovConfig>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object provides information about the state of PciPassthru
/// for all pci devices.
pub trait HostPciPassthruInfoTrait : super::traits::DataObjectTrait {
    /// The name ID of this PCI, composed of "bus:slot.function".
    fn get_id(&self) -> &str;
    /// Device which needs to be unclaimed by vmkernel (may be bridge)
    fn get_dependent_device(&self) -> &str;
    /// Whether passThru has been configured by the user
    fn get_passthru_enabled(&self) -> bool;
    /// Whether passThru is even possible for this device (decided by vmkctl)
    fn get_passthru_capable(&self) -> bool;
    /// Whether passThru is active for this device (meaning enabled + rebooted)
    fn get_passthru_active(&self) -> bool;
    /// The hardware label of this PCI device.
    /// 
    /// ***Since:*** vSphere API Release 7.0.2.0
    fn get_hardware_label(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn HostPciPassthruInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostPciPassthruInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostPciPassthruInfoVisitor)
            }
        }

struct HostPciPassthruInfoVisitor;

impl<'de> de::Visitor<'de> for HostPciPassthruInfoVisitor {
    type Value = Box<dyn HostPciPassthruInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostPciPassthruInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostPciPassthruInfoTrait for HostPciPassthruInfo {
    fn get_id(&self) -> &str { &self.id }
    fn get_dependent_device(&self) -> &str { &self.dependent_device }
    fn get_passthru_enabled(&self) -> bool { self.passthru_enabled }
    fn get_passthru_capable(&self) -> bool { self.passthru_capable }
    fn get_passthru_active(&self) -> bool { self.passthru_active }
    fn get_hardware_label(&self) -> &Option<String> { &self.hardware_label }
}
impl HostPciPassthruInfoTrait for HostSriovInfo {
    fn get_id(&self) -> &str { &self.id }
    fn get_dependent_device(&self) -> &str { &self.dependent_device }
    fn get_passthru_enabled(&self) -> bool { self.passthru_enabled }
    fn get_passthru_capable(&self) -> bool { self.passthru_capable }
    fn get_passthru_active(&self) -> bool { self.passthru_active }
    fn get_hardware_label(&self) -> &Option<String> { &self.hardware_label }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostPciPassthruInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostPciPassthruInfo => Some(from.as_any_ref().downcast_ref::<HostPciPassthruInfo>()?),
            StructType::HostSriovInfo => Some(from.as_any_ref().downcast_ref::<HostSriovInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostPciPassthruInfo => Ok(from.as_any_box().downcast::<HostPciPassthruInfo>()?),
            StructType::HostSriovInfo => Ok(from.as_any_box().downcast::<HostSriovInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type describes each network of a physical
/// network adapter's network hint.
pub trait PhysicalNicHintTrait : super::traits::DataObjectTrait {
    /// The optional VLAN Id of the network.
    fn get_vlan_id(&self) -> Option<i32>;
}
impl<'s> serde::Serialize for dyn PhysicalNicHintTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn PhysicalNicHintTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(PhysicalNicHintVisitor)
            }
        }

struct PhysicalNicHintVisitor;

impl<'de> de::Visitor<'de> for PhysicalNicHintVisitor {
    type Value = Box<dyn PhysicalNicHintTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid PhysicalNicHintTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl PhysicalNicHintTrait for PhysicalNicHint {
    fn get_vlan_id(&self) -> Option<i32> { self.vlan_id }
}
impl PhysicalNicHintTrait for PhysicalNicIpHint {
    fn get_vlan_id(&self) -> Option<i32> { self.vlan_id }
}
impl PhysicalNicHintTrait for PhysicalNicNameHint {
    fn get_vlan_id(&self) -> Option<i32> { self.vlan_id }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn PhysicalNicHintTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::PhysicalNicHint => Some(from.as_any_ref().downcast_ref::<PhysicalNicHint>()?),
            StructType::PhysicalNicIpHint => Some(from.as_any_ref().downcast_ref::<PhysicalNicIpHint>()?),
            StructType::PhysicalNicNameHint => Some(from.as_any_ref().downcast_ref::<PhysicalNicNameHint>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::PhysicalNicHint => Ok(from.as_any_box().downcast::<PhysicalNicHint>()?),
            StructType::PhysicalNicIpHint => Ok(from.as_any_box().downcast::<PhysicalNicIpHint>()?),
            StructType::PhysicalNicNameHint => Ok(from.as_any_box().downcast::<PhysicalNicNameHint>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object represents the physical
/// backing of an RDMA device.
pub trait HostRdmaDeviceBackingTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn HostRdmaDeviceBackingTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostRdmaDeviceBackingTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostRdmaDeviceBackingVisitor)
            }
        }

struct HostRdmaDeviceBackingVisitor;

impl<'de> de::Visitor<'de> for HostRdmaDeviceBackingVisitor {
    type Value = Box<dyn HostRdmaDeviceBackingTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostRdmaDeviceBackingTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostRdmaDeviceBackingTrait for HostRdmaDeviceBacking {
}
impl HostRdmaDeviceBackingTrait for HostRdmaDevicePnicBacking {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostRdmaDeviceBackingTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostRdmaDeviceBacking => Some(from.as_any_ref().downcast_ref::<HostRdmaDeviceBacking>()?),
            StructType::HostRdmaDevicePnicBacking => Some(from.as_any_ref().downcast_ref::<HostRdmaDevicePnicBacking>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostRdmaDeviceBacking => Ok(from.as_any_box().downcast::<HostRdmaDeviceBacking>()?),
            StructType::HostRdmaDevicePnicBacking => Ok(from.as_any_box().downcast::<HostRdmaDevicePnicBacking>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
pub trait HostSriovDevicePoolInfoTrait : super::traits::DataObjectTrait {
    fn get_key(&self) -> &str;
}
impl<'s> serde::Serialize for dyn HostSriovDevicePoolInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostSriovDevicePoolInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostSriovDevicePoolInfoVisitor)
            }
        }

struct HostSriovDevicePoolInfoVisitor;

impl<'de> de::Visitor<'de> for HostSriovDevicePoolInfoVisitor {
    type Value = Box<dyn HostSriovDevicePoolInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostSriovDevicePoolInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostSriovDevicePoolInfoTrait for HostSriovDevicePoolInfo {
    fn get_key(&self) -> &str { &self.key }
}
impl HostSriovDevicePoolInfoTrait for HostSriovNetworkDevicePoolInfo {
    fn get_key(&self) -> &str { &self.key }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostSriovDevicePoolInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostSriovDevicePoolInfo => Some(from.as_any_ref().downcast_ref::<HostSriovDevicePoolInfo>()?),
            StructType::HostSriovNetworkDevicePoolInfo => Some(from.as_any_ref().downcast_ref::<HostSriovNetworkDevicePoolInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostSriovDevicePoolInfo => Ok(from.as_any_box().downcast::<HostSriovDevicePoolInfo>()?),
            StructType::HostSriovNetworkDevicePoolInfo => Ok(from.as_any_box().downcast::<HostSriovNetworkDevicePoolInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class for all system swap options.
/// 
/// This class is not supposed to be used directly.  
/// These values are to be used in a *SystemSwapConfiguration.option*
/// array.
pub trait HostSystemSwapConfigurationSystemSwapOptionTrait : super::traits::DataObjectTrait {
    /// Specifies the order the options are preferred among each other.
    /// 
    /// The lower the value the more important.
    fn get_key(&self) -> i32;
}
impl<'s> serde::Serialize for dyn HostSystemSwapConfigurationSystemSwapOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostSystemSwapConfigurationSystemSwapOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostSystemSwapConfigurationSystemSwapOptionVisitor)
            }
        }

struct HostSystemSwapConfigurationSystemSwapOptionVisitor;

impl<'de> de::Visitor<'de> for HostSystemSwapConfigurationSystemSwapOptionVisitor {
    type Value = Box<dyn HostSystemSwapConfigurationSystemSwapOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostSystemSwapConfigurationSystemSwapOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostSystemSwapConfigurationSystemSwapOptionTrait for HostSystemSwapConfigurationSystemSwapOption {
    fn get_key(&self) -> i32 { self.key }
}
impl HostSystemSwapConfigurationSystemSwapOptionTrait for HostSystemSwapConfigurationDatastoreOption {
    fn get_key(&self) -> i32 { self.key }
}
impl HostSystemSwapConfigurationSystemSwapOptionTrait for HostSystemSwapConfigurationDisabledOption {
    fn get_key(&self) -> i32 { self.key }
}
impl HostSystemSwapConfigurationSystemSwapOptionTrait for HostSystemSwapConfigurationHostCacheOption {
    fn get_key(&self) -> i32 { self.key }
}
impl HostSystemSwapConfigurationSystemSwapOptionTrait for HostSystemSwapConfigurationHostLocalSwapOption {
    fn get_key(&self) -> i32 { self.key }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostSystemSwapConfigurationSystemSwapOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostSystemSwapConfigurationSystemSwapOption => Some(from.as_any_ref().downcast_ref::<HostSystemSwapConfigurationSystemSwapOption>()?),
            StructType::HostSystemSwapConfigurationDatastoreOption => Some(from.as_any_ref().downcast_ref::<HostSystemSwapConfigurationDatastoreOption>()?),
            StructType::HostSystemSwapConfigurationDisabledOption => Some(from.as_any_ref().downcast_ref::<HostSystemSwapConfigurationDisabledOption>()?),
            StructType::HostSystemSwapConfigurationHostCacheOption => Some(from.as_any_ref().downcast_ref::<HostSystemSwapConfigurationHostCacheOption>()?),
            StructType::HostSystemSwapConfigurationHostLocalSwapOption => Some(from.as_any_ref().downcast_ref::<HostSystemSwapConfigurationHostLocalSwapOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostSystemSwapConfigurationSystemSwapOption => Ok(from.as_any_box().downcast::<HostSystemSwapConfigurationSystemSwapOption>()?),
            StructType::HostSystemSwapConfigurationDatastoreOption => Ok(from.as_any_box().downcast::<HostSystemSwapConfigurationDatastoreOption>()?),
            StructType::HostSystemSwapConfigurationDisabledOption => Ok(from.as_any_box().downcast::<HostSystemSwapConfigurationDisabledOption>()?),
            StructType::HostSystemSwapConfigurationHostCacheOption => Ok(from.as_any_box().downcast::<HostSystemSwapConfigurationHostCacheOption>()?),
            StructType::HostSystemSwapConfigurationHostLocalSwapOption => Ok(from.as_any_box().downcast::<HostSystemSwapConfigurationHostLocalSwapOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Transport information about a SCSI target.
pub trait HostTargetTransportTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn HostTargetTransportTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostTargetTransportTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostTargetTransportVisitor)
            }
        }

struct HostTargetTransportVisitor;

impl<'de> de::Visitor<'de> for HostTargetTransportVisitor {
    type Value = Box<dyn HostTargetTransportTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostTargetTransportTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostTargetTransportTrait for HostTargetTransport {
}
impl HostTargetTransportTrait for HostBlockAdapterTargetTransport {
}
impl HostTargetTransportTrait for HostFibreChannelTargetTransport {
}
impl HostTargetTransportTrait for HostFibreChannelOverEthernetTargetTransport {
}
impl HostTargetTransportTrait for HostInternetScsiTargetTransport {
}
impl HostTargetTransportTrait for HostParallelScsiTargetTransport {
}
impl HostTargetTransportTrait for HostPcieTargetTransport {
}
impl HostTargetTransportTrait for HostRdmaTargetTransport {
}
impl HostTargetTransportTrait for HostSerialAttachedTargetTransport {
}
impl HostTargetTransportTrait for HostTcpTargetTransport {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostTargetTransportTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostTargetTransport => Some(from.as_any_ref().downcast_ref::<HostTargetTransport>()?),
            StructType::HostBlockAdapterTargetTransport => Some(from.as_any_ref().downcast_ref::<HostBlockAdapterTargetTransport>()?),
            StructType::HostFibreChannelTargetTransport => Some(from.as_any_ref().downcast_ref::<HostFibreChannelTargetTransport>()?),
            StructType::HostFibreChannelOverEthernetTargetTransport => Some(from.as_any_ref().downcast_ref::<HostFibreChannelOverEthernetTargetTransport>()?),
            StructType::HostInternetScsiTargetTransport => Some(from.as_any_ref().downcast_ref::<HostInternetScsiTargetTransport>()?),
            StructType::HostParallelScsiTargetTransport => Some(from.as_any_ref().downcast_ref::<HostParallelScsiTargetTransport>()?),
            StructType::HostPcieTargetTransport => Some(from.as_any_ref().downcast_ref::<HostPcieTargetTransport>()?),
            StructType::HostRdmaTargetTransport => Some(from.as_any_ref().downcast_ref::<HostRdmaTargetTransport>()?),
            StructType::HostSerialAttachedTargetTransport => Some(from.as_any_ref().downcast_ref::<HostSerialAttachedTargetTransport>()?),
            StructType::HostTcpTargetTransport => Some(from.as_any_ref().downcast_ref::<HostTcpTargetTransport>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostTargetTransport => Ok(from.as_any_box().downcast::<HostTargetTransport>()?),
            StructType::HostBlockAdapterTargetTransport => Ok(from.as_any_box().downcast::<HostBlockAdapterTargetTransport>()?),
            StructType::HostFibreChannelTargetTransport => Ok(from.as_any_box().downcast::<HostFibreChannelTargetTransport>()?),
            StructType::HostFibreChannelOverEthernetTargetTransport => Ok(from.as_any_box().downcast::<HostFibreChannelOverEthernetTargetTransport>()?),
            StructType::HostInternetScsiTargetTransport => Ok(from.as_any_box().downcast::<HostInternetScsiTargetTransport>()?),
            StructType::HostParallelScsiTargetTransport => Ok(from.as_any_box().downcast::<HostParallelScsiTargetTransport>()?),
            StructType::HostPcieTargetTransport => Ok(from.as_any_box().downcast::<HostPcieTargetTransport>()?),
            StructType::HostRdmaTargetTransport => Ok(from.as_any_box().downcast::<HostRdmaTargetTransport>()?),
            StructType::HostSerialAttachedTargetTransport => Ok(from.as_any_box().downcast::<HostSerialAttachedTargetTransport>()?),
            StructType::HostTcpTargetTransport => Ok(from.as_any_box().downcast::<HostTcpTargetTransport>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Fibre Channel transport information about a SCSI target.
pub trait HostFibreChannelTargetTransportTrait : super::traits::HostTargetTransportTrait {
    /// The world wide port name of the target.
    fn get_port_world_wide_name(&self) -> i64;
    /// The world wide node name of the target.
    fn get_node_world_wide_name(&self) -> i64;
}
impl<'s> serde::Serialize for dyn HostFibreChannelTargetTransportTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostFibreChannelTargetTransportTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostFibreChannelTargetTransportVisitor)
            }
        }

struct HostFibreChannelTargetTransportVisitor;

impl<'de> de::Visitor<'de> for HostFibreChannelTargetTransportVisitor {
    type Value = Box<dyn HostFibreChannelTargetTransportTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostFibreChannelTargetTransportTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostFibreChannelTargetTransportTrait for HostFibreChannelTargetTransport {
    fn get_port_world_wide_name(&self) -> i64 { self.port_world_wide_name }
    fn get_node_world_wide_name(&self) -> i64 { self.node_world_wide_name }
}
impl HostFibreChannelTargetTransportTrait for HostFibreChannelOverEthernetTargetTransport {
    fn get_port_world_wide_name(&self) -> i64 { self.port_world_wide_name }
    fn get_node_world_wide_name(&self) -> i64 { self.node_world_wide_name }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostFibreChannelTargetTransportTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostFibreChannelTargetTransport => Some(from.as_any_ref().downcast_ref::<HostFibreChannelTargetTransport>()?),
            StructType::HostFibreChannelOverEthernetTargetTransport => Some(from.as_any_ref().downcast_ref::<HostFibreChannelOverEthernetTargetTransport>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostFibreChannelTargetTransport => Ok(from.as_any_box().downcast::<HostFibreChannelTargetTransport>()?),
            StructType::HostFibreChannelOverEthernetTargetTransport => Ok(from.as_any_box().downcast::<HostFibreChannelOverEthernetTargetTransport>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This is a base data object for describing an event generated by
/// Trusted Platform Module (TPM).
/// 
/// It contains parameters common to
/// all TPM event types.
pub trait HostTpmEventDetailsTrait : super::traits::DataObjectTrait {
    /// Value of the Platform Configuration Register (PCR) for this event.
    fn get_data_hash(&self) -> &Vec<i8>;
    /// Method in which the digest hash is calculated.
    /// 
    /// The set of possible
    /// values is described in *HostDigestInfoDigestMethodType_enum*.
    fn get_data_hash_method(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn HostTpmEventDetailsTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostTpmEventDetailsTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostTpmEventDetailsVisitor)
            }
        }

struct HostTpmEventDetailsVisitor;

impl<'de> de::Visitor<'de> for HostTpmEventDetailsVisitor {
    type Value = Box<dyn HostTpmEventDetailsTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostTpmEventDetailsTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostTpmEventDetailsTrait for HostTpmEventDetails {
    fn get_data_hash(&self) -> &Vec<i8> { &self.data_hash }
    fn get_data_hash_method(&self) -> &Option<String> { &self.data_hash_method }
}
impl HostTpmEventDetailsTrait for HostTpmBootCompleteEventDetails {
    fn get_data_hash(&self) -> &Vec<i8> { &self.data_hash }
    fn get_data_hash_method(&self) -> &Option<String> { &self.data_hash_method }
}
impl HostTpmEventDetailsTrait for HostTpmBootSecurityOptionEventDetails {
    fn get_data_hash(&self) -> &Vec<i8> { &self.data_hash }
    fn get_data_hash_method(&self) -> &Option<String> { &self.data_hash_method }
}
impl HostTpmEventDetailsTrait for HostTpmNvTagEventDetails {
    fn get_data_hash(&self) -> &Vec<i8> { &self.data_hash }
    fn get_data_hash_method(&self) -> &Option<String> { &self.data_hash_method }
}
impl HostTpmEventDetailsTrait for HostTpmSignerEventDetails {
    fn get_data_hash(&self) -> &Vec<i8> { &self.data_hash }
    fn get_data_hash_method(&self) -> &Option<String> { &self.data_hash_method }
}
impl HostTpmEventDetailsTrait for HostTpmCommandEventDetails {
    fn get_data_hash(&self) -> &Vec<i8> { &self.data_hash }
    fn get_data_hash_method(&self) -> &Option<String> { &self.data_hash_method }
}
impl HostTpmEventDetailsTrait for HostTpmOptionEventDetails {
    fn get_data_hash(&self) -> &Vec<i8> { &self.data_hash }
    fn get_data_hash_method(&self) -> &Option<String> { &self.data_hash_method }
}
impl HostTpmEventDetailsTrait for HostTpmSoftwareComponentEventDetails {
    fn get_data_hash(&self) -> &Vec<i8> { &self.data_hash }
    fn get_data_hash_method(&self) -> &Option<String> { &self.data_hash_method }
}
impl HostTpmEventDetailsTrait for HostTpmVersionEventDetails {
    fn get_data_hash(&self) -> &Vec<i8> { &self.data_hash }
    fn get_data_hash_method(&self) -> &Option<String> { &self.data_hash_method }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostTpmEventDetailsTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostTpmEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmEventDetails>()?),
            StructType::HostTpmBootCompleteEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmBootCompleteEventDetails>()?),
            StructType::HostTpmBootSecurityOptionEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmBootSecurityOptionEventDetails>()?),
            StructType::HostTpmNvTagEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmNvTagEventDetails>()?),
            StructType::HostTpmSignerEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmSignerEventDetails>()?),
            StructType::HostTpmCommandEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmCommandEventDetails>()?),
            StructType::HostTpmOptionEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmOptionEventDetails>()?),
            StructType::HostTpmSoftwareComponentEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmSoftwareComponentEventDetails>()?),
            StructType::HostTpmVersionEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmVersionEventDetails>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostTpmEventDetails => Ok(from.as_any_box().downcast::<HostTpmEventDetails>()?),
            StructType::HostTpmBootCompleteEventDetails => Ok(from.as_any_box().downcast::<HostTpmBootCompleteEventDetails>()?),
            StructType::HostTpmBootSecurityOptionEventDetails => Ok(from.as_any_box().downcast::<HostTpmBootSecurityOptionEventDetails>()?),
            StructType::HostTpmNvTagEventDetails => Ok(from.as_any_box().downcast::<HostTpmNvTagEventDetails>()?),
            StructType::HostTpmSignerEventDetails => Ok(from.as_any_box().downcast::<HostTpmSignerEventDetails>()?),
            StructType::HostTpmCommandEventDetails => Ok(from.as_any_box().downcast::<HostTpmCommandEventDetails>()?),
            StructType::HostTpmOptionEventDetails => Ok(from.as_any_box().downcast::<HostTpmOptionEventDetails>()?),
            StructType::HostTpmSoftwareComponentEventDetails => Ok(from.as_any_box().downcast::<HostTpmSoftwareComponentEventDetails>()?),
            StructType::HostTpmVersionEventDetails => Ok(from.as_any_box().downcast::<HostTpmVersionEventDetails>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Details of a Trusted Platform Module (TPM) event recording kernel security
/// option passed at boot time and currently in effect.
/// 
/// This event type exists to simplify parsing of the security-related information
/// by internal and third-party solutions. Each boot option may be passed to kernel
/// multiple times and/or in different forms. Replicating the parsing logic of the
/// kernel would be neither convinient, nor secure for the client applications.
/// 
/// Each instance of this event reports details of a single security-related
/// boot option, as set in the kernel.
pub trait HostTpmBootSecurityOptionEventDetailsTrait : super::traits::HostTpmEventDetailsTrait {
    /// Security-related options string, reflecting the state of an option set
    /// in the kernel.
    /// 
    /// This string is in the form of a KEY=VALUE pair.
    fn get_boot_security_option(&self) -> &str;
}
impl<'s> serde::Serialize for dyn HostTpmBootSecurityOptionEventDetailsTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostTpmBootSecurityOptionEventDetailsTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostTpmBootSecurityOptionEventDetailsVisitor)
            }
        }

struct HostTpmBootSecurityOptionEventDetailsVisitor;

impl<'de> de::Visitor<'de> for HostTpmBootSecurityOptionEventDetailsVisitor {
    type Value = Box<dyn HostTpmBootSecurityOptionEventDetailsTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostTpmBootSecurityOptionEventDetailsTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostTpmBootSecurityOptionEventDetailsTrait for HostTpmBootSecurityOptionEventDetails {
    fn get_boot_security_option(&self) -> &str { &self.boot_security_option }
}
impl HostTpmBootSecurityOptionEventDetailsTrait for HostTpmNvTagEventDetails {
    fn get_boot_security_option(&self) -> &str { &self.boot_security_option }
}
impl HostTpmBootSecurityOptionEventDetailsTrait for HostTpmSignerEventDetails {
    fn get_boot_security_option(&self) -> &str { &self.boot_security_option }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostTpmBootSecurityOptionEventDetailsTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostTpmBootSecurityOptionEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmBootSecurityOptionEventDetails>()?),
            StructType::HostTpmNvTagEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmNvTagEventDetails>()?),
            StructType::HostTpmSignerEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmSignerEventDetails>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostTpmBootSecurityOptionEventDetails => Ok(from.as_any_box().downcast::<HostTpmBootSecurityOptionEventDetails>()?),
            StructType::HostTpmNvTagEventDetails => Ok(from.as_any_box().downcast::<HostTpmNvTagEventDetails>()?),
            StructType::HostTpmSignerEventDetails => Ok(from.as_any_box().downcast::<HostTpmSignerEventDetails>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// A bridge connects a virtual switch to a physical network adapter.
/// 
/// There are multiple types of bridges.
pub trait HostVirtualSwitchBridgeTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn HostVirtualSwitchBridgeTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostVirtualSwitchBridgeTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostVirtualSwitchBridgeVisitor)
            }
        }

struct HostVirtualSwitchBridgeVisitor;

impl<'de> de::Visitor<'de> for HostVirtualSwitchBridgeVisitor {
    type Value = Box<dyn HostVirtualSwitchBridgeTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostVirtualSwitchBridgeTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostVirtualSwitchBridgeTrait for HostVirtualSwitchBridge {
}
impl HostVirtualSwitchBridgeTrait for HostVirtualSwitchAutoBridge {
}
impl HostVirtualSwitchBridgeTrait for HostVirtualSwitchBondBridge {
}
impl HostVirtualSwitchBridgeTrait for HostVirtualSwitchSimpleBridge {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostVirtualSwitchBridgeTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostVirtualSwitchBridge => Some(from.as_any_ref().downcast_ref::<HostVirtualSwitchBridge>()?),
            StructType::HostVirtualSwitchAutoBridge => Some(from.as_any_ref().downcast_ref::<HostVirtualSwitchAutoBridge>()?),
            StructType::HostVirtualSwitchBondBridge => Some(from.as_any_ref().downcast_ref::<HostVirtualSwitchBondBridge>()?),
            StructType::HostVirtualSwitchSimpleBridge => Some(from.as_any_ref().downcast_ref::<HostVirtualSwitchSimpleBridge>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostVirtualSwitchBridge => Ok(from.as_any_box().downcast::<HostVirtualSwitchBridge>()?),
            StructType::HostVirtualSwitchAutoBridge => Ok(from.as_any_box().downcast::<HostVirtualSwitchAutoBridge>()?),
            StructType::HostVirtualSwitchBondBridge => Ok(from.as_any_box().downcast::<HostVirtualSwitchBondBridge>()?),
            StructType::HostVirtualSwitchSimpleBridge => Ok(from.as_any_box().downcast::<HostVirtualSwitchSimpleBridge>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class that describes a VMFS datastore provisioning option.
pub trait VmfsDatastoreBaseOptionTrait : super::traits::DataObjectTrait {
    /// The partition table layout that the disk will have if this
    /// provisioning option is selected.
    /// 
    /// In releases after vSphere API 5.0, vSphere Servers might not
    /// generate property collector update notifications for this property.
    /// To obtain the latest value of the property, you can use
    /// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
    /// If you use the PropertyCollector.WaitForUpdatesEx method, specify
    /// an empty string for the version parameter.
    /// Since this property is on a DataObject, an update returned by WaitForUpdatesEx may
    /// contain values for this property when some other property on the DataObject changes.
    /// If this update is a result of a call to WaitForUpdatesEx with a non-empty
    /// version parameter, the value for this property may not be current.
    fn get_layout(&self) -> &HostDiskPartitionLayout;
    /// Indicates whether selecting this option will change the partition
    /// format type on the disk.
    /// 
    /// See also *HostDiskPartitionInfoPartitionFormat_enum*.
    fn get_partition_format_change(&self) -> Option<bool>;
}
impl<'s> serde::Serialize for dyn VmfsDatastoreBaseOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VmfsDatastoreBaseOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VmfsDatastoreBaseOptionVisitor)
            }
        }

struct VmfsDatastoreBaseOptionVisitor;

impl<'de> de::Visitor<'de> for VmfsDatastoreBaseOptionVisitor {
    type Value = Box<dyn VmfsDatastoreBaseOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VmfsDatastoreBaseOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VmfsDatastoreBaseOptionTrait for VmfsDatastoreBaseOption {
    fn get_layout(&self) -> &HostDiskPartitionLayout { &self.layout }
    fn get_partition_format_change(&self) -> Option<bool> { self.partition_format_change }
}
impl VmfsDatastoreBaseOptionTrait for VmfsDatastoreMultipleExtentOption {
    fn get_layout(&self) -> &HostDiskPartitionLayout { &self.layout }
    fn get_partition_format_change(&self) -> Option<bool> { self.partition_format_change }
}
impl VmfsDatastoreBaseOptionTrait for VmfsDatastoreSingleExtentOption {
    fn get_layout(&self) -> &HostDiskPartitionLayout { &self.layout }
    fn get_partition_format_change(&self) -> Option<bool> { self.partition_format_change }
}
impl VmfsDatastoreBaseOptionTrait for VmfsDatastoreAllExtentOption {
    fn get_layout(&self) -> &HostDiskPartitionLayout { &self.layout }
    fn get_partition_format_change(&self) -> Option<bool> { self.partition_format_change }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VmfsDatastoreBaseOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmfsDatastoreBaseOption => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreBaseOption>()?),
            StructType::VmfsDatastoreMultipleExtentOption => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreMultipleExtentOption>()?),
            StructType::VmfsDatastoreSingleExtentOption => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreSingleExtentOption>()?),
            StructType::VmfsDatastoreAllExtentOption => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreAllExtentOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmfsDatastoreBaseOption => Ok(from.as_any_box().downcast::<VmfsDatastoreBaseOption>()?),
            StructType::VmfsDatastoreMultipleExtentOption => Ok(from.as_any_box().downcast::<VmfsDatastoreMultipleExtentOption>()?),
            StructType::VmfsDatastoreSingleExtentOption => Ok(from.as_any_box().downcast::<VmfsDatastoreSingleExtentOption>()?),
            StructType::VmfsDatastoreAllExtentOption => Ok(from.as_any_box().downcast::<VmfsDatastoreAllExtentOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Datastore addition policy to use a single extent on the disk for a VMFS
/// datastore.
/// 
/// A single extent implies that one disk partition will be
/// created on the disk for creating or increasing the capacity of a VMFS datastore.
pub trait VmfsDatastoreSingleExtentOptionTrait : super::traits::VmfsDatastoreBaseOptionTrait {
    /// The block range to be used as an extent in a VMFS datastore.
    fn get_vmfs_extent(&self) -> &HostDiskPartitionBlockRange;
}
impl<'s> serde::Serialize for dyn VmfsDatastoreSingleExtentOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VmfsDatastoreSingleExtentOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VmfsDatastoreSingleExtentOptionVisitor)
            }
        }

struct VmfsDatastoreSingleExtentOptionVisitor;

impl<'de> de::Visitor<'de> for VmfsDatastoreSingleExtentOptionVisitor {
    type Value = Box<dyn VmfsDatastoreSingleExtentOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VmfsDatastoreSingleExtentOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VmfsDatastoreSingleExtentOptionTrait for VmfsDatastoreSingleExtentOption {
    fn get_vmfs_extent(&self) -> &HostDiskPartitionBlockRange { &self.vmfs_extent }
}
impl VmfsDatastoreSingleExtentOptionTrait for VmfsDatastoreAllExtentOption {
    fn get_vmfs_extent(&self) -> &HostDiskPartitionBlockRange { &self.vmfs_extent }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VmfsDatastoreSingleExtentOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmfsDatastoreSingleExtentOption => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreSingleExtentOption>()?),
            StructType::VmfsDatastoreAllExtentOption => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreAllExtentOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmfsDatastoreSingleExtentOption => Ok(from.as_any_box().downcast::<VmfsDatastoreSingleExtentOption>()?),
            StructType::VmfsDatastoreAllExtentOption => Ok(from.as_any_box().downcast::<VmfsDatastoreAllExtentOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class for VMFS datastore addition specification.
/// 
/// Used as a generic
/// way to point to one of the creation specifications that can be used to
/// apply a specification to effect the creation or extension of a VMFS
/// datastore.
pub trait VmfsDatastoreSpecTrait : super::traits::DataObjectTrait {
    /// The UUID of the SCSI disk on which the VMFS datastore is located.
    /// 
    /// See also *HostScsiDisk*, *ScsiLun.uuid*.
    fn get_disk_uuid(&self) -> &str;
}
impl<'s> serde::Serialize for dyn VmfsDatastoreSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VmfsDatastoreSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VmfsDatastoreSpecVisitor)
            }
        }

struct VmfsDatastoreSpecVisitor;

impl<'de> de::Visitor<'de> for VmfsDatastoreSpecVisitor {
    type Value = Box<dyn VmfsDatastoreSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VmfsDatastoreSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VmfsDatastoreSpecTrait for VmfsDatastoreSpec {
    fn get_disk_uuid(&self) -> &str { &self.disk_uuid }
}
impl VmfsDatastoreSpecTrait for VmfsDatastoreCreateSpec {
    fn get_disk_uuid(&self) -> &str { &self.disk_uuid }
}
impl VmfsDatastoreSpecTrait for VmfsDatastoreExpandSpec {
    fn get_disk_uuid(&self) -> &str { &self.disk_uuid }
}
impl VmfsDatastoreSpecTrait for VmfsDatastoreExtendSpec {
    fn get_disk_uuid(&self) -> &str { &self.disk_uuid }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VmfsDatastoreSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmfsDatastoreSpec => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreSpec>()?),
            StructType::VmfsDatastoreCreateSpec => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreCreateSpec>()?),
            StructType::VmfsDatastoreExpandSpec => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreExpandSpec>()?),
            StructType::VmfsDatastoreExtendSpec => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreExtendSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmfsDatastoreSpec => Ok(from.as_any_box().downcast::<VmfsDatastoreSpec>()?),
            StructType::VmfsDatastoreCreateSpec => Ok(from.as_any_box().downcast::<VmfsDatastoreCreateSpec>()?),
            StructType::VmfsDatastoreExpandSpec => Ok(from.as_any_box().downcast::<VmfsDatastoreExpandSpec>()?),
            StructType::VmfsDatastoreExtendSpec => Ok(from.as_any_box().downcast::<VmfsDatastoreExtendSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type describes the NetBIOS configuration of
/// an operating system.
pub trait NetBiosConfigInfoTrait : super::traits::DataObjectTrait {
    /// NetBIOS configuration mode.
    /// 
    /// The supported values are described by
    /// *NetBIOSConfigInfoMode_enum*.
    fn get_mode(&self) -> &str;
}
impl<'s> serde::Serialize for dyn NetBiosConfigInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn NetBiosConfigInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(NetBiosConfigInfoVisitor)
            }
        }

struct NetBiosConfigInfoVisitor;

impl<'de> de::Visitor<'de> for NetBiosConfigInfoVisitor {
    type Value = Box<dyn NetBiosConfigInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid NetBiosConfigInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl NetBiosConfigInfoTrait for NetBiosConfigInfo {
    fn get_mode(&self) -> &str { &self.mode }
}
impl NetBiosConfigInfoTrait for WinNetBiosConfigInfo {
    fn get_mode(&self) -> &str { &self.mode }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn NetBiosConfigInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::NetBiosConfigInfo => Some(from.as_any_ref().downcast_ref::<NetBiosConfigInfo>()?),
            StructType::WinNetBiosConfigInfo => Some(from.as_any_ref().downcast_ref::<WinNetBiosConfigInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::NetBiosConfigInfo => Ok(from.as_any_box().downcast::<NetBiosConfigInfo>()?),
            StructType::WinNetBiosConfigInfo => Ok(from.as_any_box().downcast::<WinNetBiosConfigInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// An ArrayUpdateSpec data object type is a common superclass
/// for supporting incremental updates to arrays.
/// 
/// The common code pattern is:
/// 
///          class MyTypeSpec extrends ArrayUpdateSpec {
///                MyTypeInfo info;
///          }
/// The ArrayUpdateSpec contains the following:
/// - **operation**: the type of operation being performed.
/// - **removeKey**: In the case of a remove operation, the
///   key value that identifies the array to be removed.
pub trait ArrayUpdateSpecTrait : super::traits::DataObjectTrait {
    /// The type of operation being performed on the specified virtual device.
    fn get_operation(&self) -> &super::enums::ArrayUpdateOperationEnum;
    /// Key for the element to be removed.
    /// 
    /// Only used if the operation
    /// is "remove".
    fn get_remove_key(&self) -> &Option<VimAny>;
}
impl<'s> serde::Serialize for dyn ArrayUpdateSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ArrayUpdateSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ArrayUpdateSpecVisitor)
            }
        }

struct ArrayUpdateSpecVisitor;

impl<'de> de::Visitor<'de> for ArrayUpdateSpecVisitor {
    type Value = Box<dyn ArrayUpdateSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ArrayUpdateSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ArrayUpdateSpecTrait for ArrayUpdateSpec {
    fn get_operation(&self) -> &super::enums::ArrayUpdateOperationEnum { &self.operation }
    fn get_remove_key(&self) -> &Option<VimAny> { &self.remove_key }
}
impl ArrayUpdateSpecTrait for ClusterDasVmConfigSpec {
    fn get_operation(&self) -> &super::enums::ArrayUpdateOperationEnum { &self.operation }
    fn get_remove_key(&self) -> &Option<VimAny> { &self.remove_key }
}
impl ArrayUpdateSpecTrait for ClusterDatastoreUpdateSpec {
    fn get_operation(&self) -> &super::enums::ArrayUpdateOperationEnum { &self.operation }
    fn get_remove_key(&self) -> &Option<VimAny> { &self.remove_key }
}
impl ArrayUpdateSpecTrait for ClusterDpmHostConfigSpec {
    fn get_operation(&self) -> &super::enums::ArrayUpdateOperationEnum { &self.operation }
    fn get_remove_key(&self) -> &Option<VimAny> { &self.remove_key }
}
impl ArrayUpdateSpecTrait for ClusterDrsVmConfigSpec {
    fn get_operation(&self) -> &super::enums::ArrayUpdateOperationEnum { &self.operation }
    fn get_remove_key(&self) -> &Option<VimAny> { &self.remove_key }
}
impl ArrayUpdateSpecTrait for ClusterGroupSpec {
    fn get_operation(&self) -> &super::enums::ArrayUpdateOperationEnum { &self.operation }
    fn get_remove_key(&self) -> &Option<VimAny> { &self.remove_key }
}
impl ArrayUpdateSpecTrait for ClusterPreemptibleVmPairSpec {
    fn get_operation(&self) -> &super::enums::ArrayUpdateOperationEnum { &self.operation }
    fn get_remove_key(&self) -> &Option<VimAny> { &self.remove_key }
}
impl ArrayUpdateSpecTrait for ClusterRuleSpec {
    fn get_operation(&self) -> &super::enums::ArrayUpdateOperationEnum { &self.operation }
    fn get_remove_key(&self) -> &Option<VimAny> { &self.remove_key }
}
impl ArrayUpdateSpecTrait for ClusterTagCategoryUpdateSpec {
    fn get_operation(&self) -> &super::enums::ArrayUpdateOperationEnum { &self.operation }
    fn get_remove_key(&self) -> &Option<VimAny> { &self.remove_key }
}
impl ArrayUpdateSpecTrait for ClusterVmOrchestrationSpec {
    fn get_operation(&self) -> &super::enums::ArrayUpdateOperationEnum { &self.operation }
    fn get_remove_key(&self) -> &Option<VimAny> { &self.remove_key }
}
impl ArrayUpdateSpecTrait for StorageDrsOptionSpec {
    fn get_operation(&self) -> &super::enums::ArrayUpdateOperationEnum { &self.operation }
    fn get_remove_key(&self) -> &Option<VimAny> { &self.remove_key }
}
impl ArrayUpdateSpecTrait for StorageDrsVmConfigSpec {
    fn get_operation(&self) -> &super::enums::ArrayUpdateOperationEnum { &self.operation }
    fn get_remove_key(&self) -> &Option<VimAny> { &self.remove_key }
}
impl ArrayUpdateSpecTrait for VAppOvfSectionSpec {
    fn get_operation(&self) -> &super::enums::ArrayUpdateOperationEnum { &self.operation }
    fn get_remove_key(&self) -> &Option<VimAny> { &self.remove_key }
}
impl ArrayUpdateSpecTrait for VAppProductSpec {
    fn get_operation(&self) -> &super::enums::ArrayUpdateOperationEnum { &self.operation }
    fn get_remove_key(&self) -> &Option<VimAny> { &self.remove_key }
}
impl ArrayUpdateSpecTrait for VAppPropertySpec {
    fn get_operation(&self) -> &super::enums::ArrayUpdateOperationEnum { &self.operation }
    fn get_remove_key(&self) -> &Option<VimAny> { &self.remove_key }
}
impl ArrayUpdateSpecTrait for VirtualMachineCpuIdInfoSpec {
    fn get_operation(&self) -> &super::enums::ArrayUpdateOperationEnum { &self.operation }
    fn get_remove_key(&self) -> &Option<VimAny> { &self.remove_key }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ArrayUpdateSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ArrayUpdateSpec => Some(from.as_any_ref().downcast_ref::<ArrayUpdateSpec>()?),
            StructType::ClusterDasVmConfigSpec => Some(from.as_any_ref().downcast_ref::<ClusterDasVmConfigSpec>()?),
            StructType::ClusterDatastoreUpdateSpec => Some(from.as_any_ref().downcast_ref::<ClusterDatastoreUpdateSpec>()?),
            StructType::ClusterDpmHostConfigSpec => Some(from.as_any_ref().downcast_ref::<ClusterDpmHostConfigSpec>()?),
            StructType::ClusterDrsVmConfigSpec => Some(from.as_any_ref().downcast_ref::<ClusterDrsVmConfigSpec>()?),
            StructType::ClusterGroupSpec => Some(from.as_any_ref().downcast_ref::<ClusterGroupSpec>()?),
            StructType::ClusterPreemptibleVmPairSpec => Some(from.as_any_ref().downcast_ref::<ClusterPreemptibleVmPairSpec>()?),
            StructType::ClusterRuleSpec => Some(from.as_any_ref().downcast_ref::<ClusterRuleSpec>()?),
            StructType::ClusterTagCategoryUpdateSpec => Some(from.as_any_ref().downcast_ref::<ClusterTagCategoryUpdateSpec>()?),
            StructType::ClusterVmOrchestrationSpec => Some(from.as_any_ref().downcast_ref::<ClusterVmOrchestrationSpec>()?),
            StructType::StorageDrsOptionSpec => Some(from.as_any_ref().downcast_ref::<StorageDrsOptionSpec>()?),
            StructType::StorageDrsVmConfigSpec => Some(from.as_any_ref().downcast_ref::<StorageDrsVmConfigSpec>()?),
            StructType::VAppOvfSectionSpec => Some(from.as_any_ref().downcast_ref::<VAppOvfSectionSpec>()?),
            StructType::VAppProductSpec => Some(from.as_any_ref().downcast_ref::<VAppProductSpec>()?),
            StructType::VAppPropertySpec => Some(from.as_any_ref().downcast_ref::<VAppPropertySpec>()?),
            StructType::VirtualMachineCpuIdInfoSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineCpuIdInfoSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ArrayUpdateSpec => Ok(from.as_any_box().downcast::<ArrayUpdateSpec>()?),
            StructType::ClusterDasVmConfigSpec => Ok(from.as_any_box().downcast::<ClusterDasVmConfigSpec>()?),
            StructType::ClusterDatastoreUpdateSpec => Ok(from.as_any_box().downcast::<ClusterDatastoreUpdateSpec>()?),
            StructType::ClusterDpmHostConfigSpec => Ok(from.as_any_box().downcast::<ClusterDpmHostConfigSpec>()?),
            StructType::ClusterDrsVmConfigSpec => Ok(from.as_any_box().downcast::<ClusterDrsVmConfigSpec>()?),
            StructType::ClusterGroupSpec => Ok(from.as_any_box().downcast::<ClusterGroupSpec>()?),
            StructType::ClusterPreemptibleVmPairSpec => Ok(from.as_any_box().downcast::<ClusterPreemptibleVmPairSpec>()?),
            StructType::ClusterRuleSpec => Ok(from.as_any_box().downcast::<ClusterRuleSpec>()?),
            StructType::ClusterTagCategoryUpdateSpec => Ok(from.as_any_box().downcast::<ClusterTagCategoryUpdateSpec>()?),
            StructType::ClusterVmOrchestrationSpec => Ok(from.as_any_box().downcast::<ClusterVmOrchestrationSpec>()?),
            StructType::StorageDrsOptionSpec => Ok(from.as_any_box().downcast::<StorageDrsOptionSpec>()?),
            StructType::StorageDrsVmConfigSpec => Ok(from.as_any_box().downcast::<StorageDrsVmConfigSpec>()?),
            StructType::VAppOvfSectionSpec => Ok(from.as_any_box().downcast::<VAppOvfSectionSpec>()?),
            StructType::VAppProductSpec => Ok(from.as_any_box().downcast::<VAppProductSpec>()?),
            StructType::VAppPropertySpec => Ok(from.as_any_box().downcast::<VAppPropertySpec>()?),
            StructType::VirtualMachineCpuIdInfoSpec => Ok(from.as_any_box().downcast::<VirtualMachineCpuIdInfoSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The base data object type for all options.
pub trait OptionTypeTrait : super::traits::DataObjectTrait {
    /// The flag to indicate whether or not a user
    /// can modify a value belonging to this option type.
    /// 
    /// If
    /// the flag is not set, the value can be modified.
    fn get_value_is_readonly(&self) -> Option<bool>;
}
impl<'s> serde::Serialize for dyn OptionTypeTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn OptionTypeTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(OptionTypeVisitor)
            }
        }

struct OptionTypeVisitor;

impl<'de> de::Visitor<'de> for OptionTypeVisitor {
    type Value = Box<dyn OptionTypeTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid OptionTypeTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl OptionTypeTrait for OptionType {
    fn get_value_is_readonly(&self) -> Option<bool> { self.value_is_readonly }
}
impl OptionTypeTrait for BoolOption {
    fn get_value_is_readonly(&self) -> Option<bool> { self.value_is_readonly }
}
impl OptionTypeTrait for ChoiceOption {
    fn get_value_is_readonly(&self) -> Option<bool> { self.value_is_readonly }
}
impl OptionTypeTrait for FloatOption {
    fn get_value_is_readonly(&self) -> Option<bool> { self.value_is_readonly }
}
impl OptionTypeTrait for IntOption {
    fn get_value_is_readonly(&self) -> Option<bool> { self.value_is_readonly }
}
impl OptionTypeTrait for LongOption {
    fn get_value_is_readonly(&self) -> Option<bool> { self.value_is_readonly }
}
impl OptionTypeTrait for StringOption {
    fn get_value_is_readonly(&self) -> Option<bool> { self.value_is_readonly }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn OptionTypeTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::OptionType => Some(from.as_any_ref().downcast_ref::<OptionType>()?),
            StructType::BoolOption => Some(from.as_any_ref().downcast_ref::<BoolOption>()?),
            StructType::ChoiceOption => Some(from.as_any_ref().downcast_ref::<ChoiceOption>()?),
            StructType::FloatOption => Some(from.as_any_ref().downcast_ref::<FloatOption>()?),
            StructType::IntOption => Some(from.as_any_ref().downcast_ref::<IntOption>()?),
            StructType::LongOption => Some(from.as_any_ref().downcast_ref::<LongOption>()?),
            StructType::StringOption => Some(from.as_any_ref().downcast_ref::<StringOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::OptionType => Ok(from.as_any_box().downcast::<OptionType>()?),
            StructType::BoolOption => Ok(from.as_any_box().downcast::<BoolOption>()?),
            StructType::ChoiceOption => Ok(from.as_any_box().downcast::<ChoiceOption>()?),
            StructType::FloatOption => Ok(from.as_any_box().downcast::<FloatOption>()?),
            StructType::IntOption => Ok(from.as_any_box().downcast::<IntOption>()?),
            StructType::LongOption => Ok(from.as_any_box().downcast::<LongOption>()?),
            StructType::StringOption => Ok(from.as_any_box().downcast::<StringOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Describes the key/value pair of a configured option.
pub trait OptionValueTrait : super::traits::DataObjectTrait {
    /// The name of the option using dot notation to reflect the
    /// option's position in a hierarchy.
    /// 
    /// For example, you might
    /// have an option called "Ethernet" and another option that is
    /// a child of that called "Connection". In this case, the key
    /// for the latter could be defined as "Ethernet.Connection"
    fn get_key(&self) -> &str;
    /// The value of the option.
    /// 
    /// The Any data object type enables you to
    /// define any value for the option. Typically, however, the value
    /// of an option is of type String or Integer.
    fn get_value(&self) -> &Option<VimAny>;
}
impl<'s> serde::Serialize for dyn OptionValueTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn OptionValueTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(OptionValueVisitor)
            }
        }

struct OptionValueVisitor;

impl<'de> de::Visitor<'de> for OptionValueVisitor {
    type Value = Box<dyn OptionValueTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid OptionValueTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl OptionValueTrait for OptionValue {
    fn get_key(&self) -> &str { &self.key }
    fn get_value(&self) -> &Option<VimAny> { &self.value }
}
impl OptionValueTrait for HostInternetScsiHbaParamValue {
    fn get_key(&self) -> &str { &self.key }
    fn get_value(&self) -> &Option<VimAny> { &self.value }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn OptionValueTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::OptionValue => Some(from.as_any_ref().downcast_ref::<OptionValue>()?),
            StructType::HostInternetScsiHbaParamValue => Some(from.as_any_ref().downcast_ref::<HostInternetScsiHbaParamValue>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::OptionValue => Ok(from.as_any_box().downcast::<OptionValue>()?),
            StructType::HostInternetScsiHbaParamValue => Ok(from.as_any_box().downcast::<HostInternetScsiHbaParamValue>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *ApplyProfile* data object is the base class for all data objects
/// that define profile configuration data.
/// 
/// <code>ApplyProfile</code> defines ESX configuration data storage and it
/// supports recursive profile definition for the profile plug-in architecture.
pub trait ApplyProfileTrait : super::traits::DataObjectTrait {
    /// Indicates whether the profile is enabled.
    fn get_enabled(&self) -> bool;
    /// The list of policies comprising the profile.
    /// 
    /// A *ProfilePolicy*
    /// stores one or more configuration data values in a *PolicyOption*.
    /// The policy option is one of the configuration options from the
    /// *ProfilePolicyMetadata*.*ProfilePolicyMetadata.possibleOption*
    /// list.
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>>;
    /// Identifies the profile type.
    fn get_profile_type_name(&self) -> &Option<String>;
    /// Profile engine version.
    fn get_profile_version(&self) -> &Option<String>;
    /// List of subprofiles for this profile.
    /// 
    /// This list can change depending on which profile plug-ins are available in the system.
    /// Subprofiles can be nested to arbitrary depths to represent host capabilities.
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>>;
    /// Indicates whether this profile is marked as "favorite".
    fn get_favorite(&self) -> Option<bool>;
    /// Indicates whether this profile is marked as to-be-merged.
    fn get_to_be_merged(&self) -> Option<bool>;
    /// Indicates whether the selected array elements, with the current
    /// as one of them, replace the profile array in the target host
    /// profile.
    fn get_to_replace_with(&self) -> Option<bool>;
    /// Indicates whether this profile is marked as to-be-deleted.
    fn get_to_be_deleted(&self) -> Option<bool>;
    /// Indicates that the member variable <code>enabled</code> of this profile
    /// will be copied from source profile to target profiles at host profile
    /// composition.
    fn get_copy_enable_status(&self) -> Option<bool>;
    /// Indicates whether this profile will be displayed or not.
    fn get_hidden(&self) -> Option<bool>;
}
impl<'s> serde::Serialize for dyn ApplyProfileTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ApplyProfileTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ApplyProfileVisitor)
            }
        }

struct ApplyProfileVisitor;

impl<'de> de::Visitor<'de> for ApplyProfileVisitor {
    type Value = Box<dyn ApplyProfileTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ApplyProfileTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ApplyProfileTrait for ApplyProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for ProfileApplyProfileElement {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for ActiveDirectoryProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for AuthenticationProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for DateTimeProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for DvsProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for DvsVNicProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for DvsHostVNicProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for DvsServiceConsoleVNicProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for FirewallProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for FirewallProfileRulesetProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for HostApplyProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for HostMemoryProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for IpAddressProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for IpRouteProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for NasStorageProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for NetStackInstanceProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for NetworkPolicyProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for NetworkProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for NetworkProfileDnsConfigProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for NsxHostVNicProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for OpaqueSwitchProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for OptionProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for PermissionProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for PhysicalNicProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for PnicUplinkProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for PortGroupProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for HostPortGroupProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for ServiceConsolePortGroupProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for VmPortGroupProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for VirtualSwitchSelectionProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for VlanProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for SecurityProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for ServiceProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for StaticRouteProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for StorageProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for UserGroupProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for UserProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for VirtualSwitchProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for LinkProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for NumPortsProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ApplyProfileTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ApplyProfile => Some(from.as_any_ref().downcast_ref::<ApplyProfile>()?),
            StructType::ProfileApplyProfileElement => Some(from.as_any_ref().downcast_ref::<ProfileApplyProfileElement>()?),
            StructType::ActiveDirectoryProfile => Some(from.as_any_ref().downcast_ref::<ActiveDirectoryProfile>()?),
            StructType::AuthenticationProfile => Some(from.as_any_ref().downcast_ref::<AuthenticationProfile>()?),
            StructType::DateTimeProfile => Some(from.as_any_ref().downcast_ref::<DateTimeProfile>()?),
            StructType::DvsProfile => Some(from.as_any_ref().downcast_ref::<DvsProfile>()?),
            StructType::DvsVNicProfile => Some(from.as_any_ref().downcast_ref::<DvsVNicProfile>()?),
            StructType::DvsHostVNicProfile => Some(from.as_any_ref().downcast_ref::<DvsHostVNicProfile>()?),
            StructType::DvsServiceConsoleVNicProfile => Some(from.as_any_ref().downcast_ref::<DvsServiceConsoleVNicProfile>()?),
            StructType::FirewallProfile => Some(from.as_any_ref().downcast_ref::<FirewallProfile>()?),
            StructType::FirewallProfileRulesetProfile => Some(from.as_any_ref().downcast_ref::<FirewallProfileRulesetProfile>()?),
            StructType::HostApplyProfile => Some(from.as_any_ref().downcast_ref::<HostApplyProfile>()?),
            StructType::HostMemoryProfile => Some(from.as_any_ref().downcast_ref::<HostMemoryProfile>()?),
            StructType::IpAddressProfile => Some(from.as_any_ref().downcast_ref::<IpAddressProfile>()?),
            StructType::IpRouteProfile => Some(from.as_any_ref().downcast_ref::<IpRouteProfile>()?),
            StructType::NasStorageProfile => Some(from.as_any_ref().downcast_ref::<NasStorageProfile>()?),
            StructType::NetStackInstanceProfile => Some(from.as_any_ref().downcast_ref::<NetStackInstanceProfile>()?),
            StructType::NetworkPolicyProfile => Some(from.as_any_ref().downcast_ref::<NetworkPolicyProfile>()?),
            StructType::NetworkProfile => Some(from.as_any_ref().downcast_ref::<NetworkProfile>()?),
            StructType::NetworkProfileDnsConfigProfile => Some(from.as_any_ref().downcast_ref::<NetworkProfileDnsConfigProfile>()?),
            StructType::NsxHostVNicProfile => Some(from.as_any_ref().downcast_ref::<NsxHostVNicProfile>()?),
            StructType::OpaqueSwitchProfile => Some(from.as_any_ref().downcast_ref::<OpaqueSwitchProfile>()?),
            StructType::OptionProfile => Some(from.as_any_ref().downcast_ref::<OptionProfile>()?),
            StructType::PermissionProfile => Some(from.as_any_ref().downcast_ref::<PermissionProfile>()?),
            StructType::PhysicalNicProfile => Some(from.as_any_ref().downcast_ref::<PhysicalNicProfile>()?),
            StructType::PnicUplinkProfile => Some(from.as_any_ref().downcast_ref::<PnicUplinkProfile>()?),
            StructType::PortGroupProfile => Some(from.as_any_ref().downcast_ref::<PortGroupProfile>()?),
            StructType::HostPortGroupProfile => Some(from.as_any_ref().downcast_ref::<HostPortGroupProfile>()?),
            StructType::ServiceConsolePortGroupProfile => Some(from.as_any_ref().downcast_ref::<ServiceConsolePortGroupProfile>()?),
            StructType::VmPortGroupProfile => Some(from.as_any_ref().downcast_ref::<VmPortGroupProfile>()?),
            StructType::VirtualSwitchSelectionProfile => Some(from.as_any_ref().downcast_ref::<VirtualSwitchSelectionProfile>()?),
            StructType::VlanProfile => Some(from.as_any_ref().downcast_ref::<VlanProfile>()?),
            StructType::SecurityProfile => Some(from.as_any_ref().downcast_ref::<SecurityProfile>()?),
            StructType::ServiceProfile => Some(from.as_any_ref().downcast_ref::<ServiceProfile>()?),
            StructType::StaticRouteProfile => Some(from.as_any_ref().downcast_ref::<StaticRouteProfile>()?),
            StructType::StorageProfile => Some(from.as_any_ref().downcast_ref::<StorageProfile>()?),
            StructType::UserGroupProfile => Some(from.as_any_ref().downcast_ref::<UserGroupProfile>()?),
            StructType::UserProfile => Some(from.as_any_ref().downcast_ref::<UserProfile>()?),
            StructType::VirtualSwitchProfile => Some(from.as_any_ref().downcast_ref::<VirtualSwitchProfile>()?),
            StructType::LinkProfile => Some(from.as_any_ref().downcast_ref::<LinkProfile>()?),
            StructType::NumPortsProfile => Some(from.as_any_ref().downcast_ref::<NumPortsProfile>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ApplyProfile => Ok(from.as_any_box().downcast::<ApplyProfile>()?),
            StructType::ProfileApplyProfileElement => Ok(from.as_any_box().downcast::<ProfileApplyProfileElement>()?),
            StructType::ActiveDirectoryProfile => Ok(from.as_any_box().downcast::<ActiveDirectoryProfile>()?),
            StructType::AuthenticationProfile => Ok(from.as_any_box().downcast::<AuthenticationProfile>()?),
            StructType::DateTimeProfile => Ok(from.as_any_box().downcast::<DateTimeProfile>()?),
            StructType::DvsProfile => Ok(from.as_any_box().downcast::<DvsProfile>()?),
            StructType::DvsVNicProfile => Ok(from.as_any_box().downcast::<DvsVNicProfile>()?),
            StructType::DvsHostVNicProfile => Ok(from.as_any_box().downcast::<DvsHostVNicProfile>()?),
            StructType::DvsServiceConsoleVNicProfile => Ok(from.as_any_box().downcast::<DvsServiceConsoleVNicProfile>()?),
            StructType::FirewallProfile => Ok(from.as_any_box().downcast::<FirewallProfile>()?),
            StructType::FirewallProfileRulesetProfile => Ok(from.as_any_box().downcast::<FirewallProfileRulesetProfile>()?),
            StructType::HostApplyProfile => Ok(from.as_any_box().downcast::<HostApplyProfile>()?),
            StructType::HostMemoryProfile => Ok(from.as_any_box().downcast::<HostMemoryProfile>()?),
            StructType::IpAddressProfile => Ok(from.as_any_box().downcast::<IpAddressProfile>()?),
            StructType::IpRouteProfile => Ok(from.as_any_box().downcast::<IpRouteProfile>()?),
            StructType::NasStorageProfile => Ok(from.as_any_box().downcast::<NasStorageProfile>()?),
            StructType::NetStackInstanceProfile => Ok(from.as_any_box().downcast::<NetStackInstanceProfile>()?),
            StructType::NetworkPolicyProfile => Ok(from.as_any_box().downcast::<NetworkPolicyProfile>()?),
            StructType::NetworkProfile => Ok(from.as_any_box().downcast::<NetworkProfile>()?),
            StructType::NetworkProfileDnsConfigProfile => Ok(from.as_any_box().downcast::<NetworkProfileDnsConfigProfile>()?),
            StructType::NsxHostVNicProfile => Ok(from.as_any_box().downcast::<NsxHostVNicProfile>()?),
            StructType::OpaqueSwitchProfile => Ok(from.as_any_box().downcast::<OpaqueSwitchProfile>()?),
            StructType::OptionProfile => Ok(from.as_any_box().downcast::<OptionProfile>()?),
            StructType::PermissionProfile => Ok(from.as_any_box().downcast::<PermissionProfile>()?),
            StructType::PhysicalNicProfile => Ok(from.as_any_box().downcast::<PhysicalNicProfile>()?),
            StructType::PnicUplinkProfile => Ok(from.as_any_box().downcast::<PnicUplinkProfile>()?),
            StructType::PortGroupProfile => Ok(from.as_any_box().downcast::<PortGroupProfile>()?),
            StructType::HostPortGroupProfile => Ok(from.as_any_box().downcast::<HostPortGroupProfile>()?),
            StructType::ServiceConsolePortGroupProfile => Ok(from.as_any_box().downcast::<ServiceConsolePortGroupProfile>()?),
            StructType::VmPortGroupProfile => Ok(from.as_any_box().downcast::<VmPortGroupProfile>()?),
            StructType::VirtualSwitchSelectionProfile => Ok(from.as_any_box().downcast::<VirtualSwitchSelectionProfile>()?),
            StructType::VlanProfile => Ok(from.as_any_box().downcast::<VlanProfile>()?),
            StructType::SecurityProfile => Ok(from.as_any_box().downcast::<SecurityProfile>()?),
            StructType::ServiceProfile => Ok(from.as_any_box().downcast::<ServiceProfile>()?),
            StructType::StaticRouteProfile => Ok(from.as_any_box().downcast::<StaticRouteProfile>()?),
            StructType::StorageProfile => Ok(from.as_any_box().downcast::<StorageProfile>()?),
            StructType::UserGroupProfile => Ok(from.as_any_box().downcast::<UserGroupProfile>()?),
            StructType::UserProfile => Ok(from.as_any_box().downcast::<UserProfile>()?),
            StructType::VirtualSwitchProfile => Ok(from.as_any_box().downcast::<VirtualSwitchProfile>()?),
            StructType::LinkProfile => Ok(from.as_any_box().downcast::<LinkProfile>()?),
            StructType::NumPortsProfile => Ok(from.as_any_box().downcast::<NumPortsProfile>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *DvsVNicProfile* data object is the base object
/// for host and service console Virtual NIC subprofiles.
/// 
/// If a profile plug-in defines additional policies or subprofiles, use the
/// *ApplyProfile.policy* or *ApplyProfile.property*
/// list to access the configuration data.
pub trait DvsVNicProfileTrait : super::traits::ApplyProfileTrait {
    /// Linkable identifier.
    fn get_key(&self) -> &str;
    /// IP address for the Virtual NIC belonging to a distributed virtual switch.
    fn get_ip_config(&self) -> &IpAddressProfile;
}
impl<'s> serde::Serialize for dyn DvsVNicProfileTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DvsVNicProfileTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DvsVNicProfileVisitor)
            }
        }

struct DvsVNicProfileVisitor;

impl<'de> de::Visitor<'de> for DvsVNicProfileVisitor {
    type Value = Box<dyn DvsVNicProfileTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DvsVNicProfileTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DvsVNicProfileTrait for DvsVNicProfile {
    fn get_key(&self) -> &str { &self.key }
    fn get_ip_config(&self) -> &IpAddressProfile { &self.ip_config }
}
impl DvsVNicProfileTrait for DvsHostVNicProfile {
    fn get_key(&self) -> &str { &self.key }
    fn get_ip_config(&self) -> &IpAddressProfile { &self.ip_config }
}
impl DvsVNicProfileTrait for DvsServiceConsoleVNicProfile {
    fn get_key(&self) -> &str { &self.key }
    fn get_ip_config(&self) -> &IpAddressProfile { &self.ip_config }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DvsVNicProfileTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsVNicProfile => Some(from.as_any_ref().downcast_ref::<DvsVNicProfile>()?),
            StructType::DvsHostVNicProfile => Some(from.as_any_ref().downcast_ref::<DvsHostVNicProfile>()?),
            StructType::DvsServiceConsoleVNicProfile => Some(from.as_any_ref().downcast_ref::<DvsServiceConsoleVNicProfile>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsVNicProfile => Ok(from.as_any_box().downcast::<DvsVNicProfile>()?),
            StructType::DvsHostVNicProfile => Ok(from.as_any_box().downcast::<DvsHostVNicProfile>()?),
            StructType::DvsServiceConsoleVNicProfile => Ok(from.as_any_box().downcast::<DvsServiceConsoleVNicProfile>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// *PortGroupProfile* is the base class for the different port group
/// subprofile objects.
pub trait PortGroupProfileTrait : super::traits::ApplyProfileTrait {
    /// Linkable identifier.
    fn get_key(&self) -> &str;
    /// Name of the portgroup.
    fn get_name(&self) -> &str;
    /// VLAN identifier for the port group.
    fn get_vlan(&self) -> &VlanProfile;
    /// Virtual switch to which the port group is connected.
    fn get_vswitch(&self) -> &VirtualSwitchSelectionProfile;
    /// The network policy/policies applicable on the port group.
    fn get_network_policy(&self) -> &NetworkPolicyProfile;
}
impl<'s> serde::Serialize for dyn PortGroupProfileTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn PortGroupProfileTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(PortGroupProfileVisitor)
            }
        }

struct PortGroupProfileVisitor;

impl<'de> de::Visitor<'de> for PortGroupProfileVisitor {
    type Value = Box<dyn PortGroupProfileTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid PortGroupProfileTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl PortGroupProfileTrait for PortGroupProfile {
    fn get_key(&self) -> &str { &self.key }
    fn get_name(&self) -> &str { &self.name }
    fn get_vlan(&self) -> &VlanProfile { &self.vlan }
    fn get_vswitch(&self) -> &VirtualSwitchSelectionProfile { &self.vswitch }
    fn get_network_policy(&self) -> &NetworkPolicyProfile { &self.network_policy }
}
impl PortGroupProfileTrait for HostPortGroupProfile {
    fn get_key(&self) -> &str { &self.key }
    fn get_name(&self) -> &str { &self.name }
    fn get_vlan(&self) -> &VlanProfile { &self.vlan }
    fn get_vswitch(&self) -> &VirtualSwitchSelectionProfile { &self.vswitch }
    fn get_network_policy(&self) -> &NetworkPolicyProfile { &self.network_policy }
}
impl PortGroupProfileTrait for ServiceConsolePortGroupProfile {
    fn get_key(&self) -> &str { &self.key }
    fn get_name(&self) -> &str { &self.name }
    fn get_vlan(&self) -> &VlanProfile { &self.vlan }
    fn get_vswitch(&self) -> &VirtualSwitchSelectionProfile { &self.vswitch }
    fn get_network_policy(&self) -> &NetworkPolicyProfile { &self.network_policy }
}
impl PortGroupProfileTrait for VmPortGroupProfile {
    fn get_key(&self) -> &str { &self.key }
    fn get_name(&self) -> &str { &self.name }
    fn get_vlan(&self) -> &VlanProfile { &self.vlan }
    fn get_vswitch(&self) -> &VirtualSwitchSelectionProfile { &self.vswitch }
    fn get_network_policy(&self) -> &NetworkPolicyProfile { &self.network_policy }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn PortGroupProfileTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::PortGroupProfile => Some(from.as_any_ref().downcast_ref::<PortGroupProfile>()?),
            StructType::HostPortGroupProfile => Some(from.as_any_ref().downcast_ref::<HostPortGroupProfile>()?),
            StructType::ServiceConsolePortGroupProfile => Some(from.as_any_ref().downcast_ref::<ServiceConsolePortGroupProfile>()?),
            StructType::VmPortGroupProfile => Some(from.as_any_ref().downcast_ref::<VmPortGroupProfile>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::PortGroupProfile => Ok(from.as_any_box().downcast::<PortGroupProfile>()?),
            StructType::HostPortGroupProfile => Ok(from.as_any_box().downcast::<HostPortGroupProfile>()?),
            StructType::ServiceConsolePortGroupProfile => Ok(from.as_any_box().downcast::<ServiceConsolePortGroupProfile>()?),
            StructType::VmPortGroupProfile => Ok(from.as_any_box().downcast::<VmPortGroupProfile>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
pub trait ProfileExpressionTrait : super::traits::DataObjectTrait {
    /// Identifier of this expression.
    /// 
    /// The id has to be unique within a Profile.
    /// The id can be used as a key while building composite expressions.
    fn get_id(&self) -> &str;
    /// User visible display name
    fn get_display_name(&self) -> &str;
    /// Flag indicating if the condition of the expression should be negated.
    /// 
    /// e.g: conditions like VSwitch0 has vmnic0 connected to it can be turned into
    /// VSwitch0 doesn't have vmnic0 connected to it.
    fn get_negated(&self) -> bool;
}
impl<'s> serde::Serialize for dyn ProfileExpressionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ProfileExpressionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ProfileExpressionVisitor)
            }
        }

struct ProfileExpressionVisitor;

impl<'de> de::Visitor<'de> for ProfileExpressionVisitor {
    type Value = Box<dyn ProfileExpressionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ProfileExpressionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ProfileExpressionTrait for ProfileExpression {
    fn get_id(&self) -> &str { &self.id }
    fn get_display_name(&self) -> &str { &self.display_name }
    fn get_negated(&self) -> bool { self.negated }
}
impl ProfileExpressionTrait for ProfileCompositeExpression {
    fn get_id(&self) -> &str { &self.id }
    fn get_display_name(&self) -> &str { &self.display_name }
    fn get_negated(&self) -> bool { self.negated }
}
impl ProfileExpressionTrait for ProfileSimpleExpression {
    fn get_id(&self) -> &str { &self.id }
    fn get_display_name(&self) -> &str { &self.display_name }
    fn get_negated(&self) -> bool { self.negated }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ProfileExpressionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ProfileExpression => Some(from.as_any_ref().downcast_ref::<ProfileExpression>()?),
            StructType::ProfileCompositeExpression => Some(from.as_any_ref().downcast_ref::<ProfileCompositeExpression>()?),
            StructType::ProfileSimpleExpression => Some(from.as_any_ref().downcast_ref::<ProfileSimpleExpression>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ProfileExpression => Ok(from.as_any_box().downcast::<ProfileExpression>()?),
            StructType::ProfileCompositeExpression => Ok(from.as_any_box().downcast::<ProfileCompositeExpression>()?),
            StructType::ProfileSimpleExpression => Ok(from.as_any_box().downcast::<ProfileSimpleExpression>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *PolicyOption* data object represents one or more configuration
/// values.
/// 
/// A policy option is one of the configuration options from the
/// *ProfilePolicyMetadata*.*ProfilePolicyMetadata.possibleOption*
/// list.
pub trait PolicyOptionTrait : super::traits::DataObjectTrait {
    /// Identifier for the policy option.
    /// 
    /// This value matches one of the
    /// keys from the list of possible options in the policy metadata
    /// (*ProfilePolicyMetadata*.*ProfilePolicyMetadata.possibleOption*\[\].*ProfilePolicyOptionMetadata.id*.*ElementDescription.key*).
    fn get_id(&self) -> &str;
    /// Parameters for the policy option.
    /// 
    /// This list must include all parameters that are not marked as optional
    /// in the policy option metadata parameter list
    /// (*ProfilePolicyMetadata*.*ProfilePolicyMetadata.possibleOption*\[\].*ProfilePolicyOptionMetadata.parameter*\[\].*ProfileParameterMetadata.optional*).
    fn get_parameter(&self) -> &Option<Vec<KeyAnyValue>>;
}
impl<'s> serde::Serialize for dyn PolicyOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn PolicyOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(PolicyOptionVisitor)
            }
        }

struct PolicyOptionVisitor;

impl<'de> de::Visitor<'de> for PolicyOptionVisitor {
    type Value = Box<dyn PolicyOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid PolicyOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl PolicyOptionTrait for PolicyOption {
    fn get_id(&self) -> &str { &self.id }
    fn get_parameter(&self) -> &Option<Vec<KeyAnyValue>> { &self.parameter }
}
impl PolicyOptionTrait for CompositePolicyOption {
    fn get_id(&self) -> &str { &self.id }
    fn get_parameter(&self) -> &Option<Vec<KeyAnyValue>> { &self.parameter }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn PolicyOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::PolicyOption => Some(from.as_any_ref().downcast_ref::<PolicyOption>()?),
            StructType::CompositePolicyOption => Some(from.as_any_ref().downcast_ref::<CompositePolicyOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::PolicyOption => Ok(from.as_any_box().downcast::<PolicyOption>()?),
            StructType::CompositePolicyOption => Ok(from.as_any_box().downcast::<CompositePolicyOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *ProfilePolicyOptionMetadata* data object contains the metadata information
/// for a *PolicyOption*.
pub trait ProfilePolicyOptionMetadataTrait : super::traits::DataObjectTrait {
    /// Identifier for the policy option.
    /// - The <code>id.key</code> value
    ///   (*ExtendedElementDescription*.*ElementDescription.key*)
    ///   identifies the policy option type.
    /// - The <code>id.label</code> property
    ///   (*ExtendedElementDescription*.*Description.label*)
    ///   contains a brief localizable message describing the policy option.
    /// - The <code>id.summary</code> property
    ///   (*ExtendedElementDescription*.*Description.summary*)
    ///   contains a localizable summary of the policy option.
    ///   Summary information can contain embedded variable names which can
    ///   be replaced with values from the <code>parameter</code> property.
    fn get_id(&self) -> &ExtendedElementDescription;
    /// Metadata about the parameters for the policy option.
    fn get_parameter(&self) -> &Option<Vec<ProfileParameterMetadata>>;
}
impl<'s> serde::Serialize for dyn ProfilePolicyOptionMetadataTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ProfilePolicyOptionMetadataTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ProfilePolicyOptionMetadataVisitor)
            }
        }

struct ProfilePolicyOptionMetadataVisitor;

impl<'de> de::Visitor<'de> for ProfilePolicyOptionMetadataVisitor {
    type Value = Box<dyn ProfilePolicyOptionMetadataTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ProfilePolicyOptionMetadataTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ProfilePolicyOptionMetadataTrait for ProfilePolicyOptionMetadata {
    fn get_id(&self) -> &ExtendedElementDescription { &self.id }
    fn get_parameter(&self) -> &Option<Vec<ProfileParameterMetadata>> { &self.parameter }
}
impl ProfilePolicyOptionMetadataTrait for ProfileCompositePolicyOptionMetadata {
    fn get_id(&self) -> &ExtendedElementDescription { &self.id }
    fn get_parameter(&self) -> &Option<Vec<ProfileParameterMetadata>> { &self.parameter }
}
impl ProfilePolicyOptionMetadataTrait for UserInputRequiredParameterMetadata {
    fn get_id(&self) -> &ExtendedElementDescription { &self.id }
    fn get_parameter(&self) -> &Option<Vec<ProfileParameterMetadata>> { &self.parameter }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ProfilePolicyOptionMetadataTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ProfilePolicyOptionMetadata => Some(from.as_any_ref().downcast_ref::<ProfilePolicyOptionMetadata>()?),
            StructType::ProfileCompositePolicyOptionMetadata => Some(from.as_any_ref().downcast_ref::<ProfileCompositePolicyOptionMetadata>()?),
            StructType::UserInputRequiredParameterMetadata => Some(from.as_any_ref().downcast_ref::<UserInputRequiredParameterMetadata>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ProfilePolicyOptionMetadata => Ok(from.as_any_box().downcast::<ProfilePolicyOptionMetadata>()?),
            StructType::ProfileCompositePolicyOptionMetadata => Ok(from.as_any_box().downcast::<ProfileCompositePolicyOptionMetadata>()?),
            StructType::UserInputRequiredParameterMetadata => Ok(from.as_any_box().downcast::<UserInputRequiredParameterMetadata>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
pub trait ProfileConfigInfoTrait : super::traits::DataObjectTrait {
    /// Name of the profile
    fn get_name(&self) -> &str;
    /// User Provided description of the profile
    fn get_annotation(&self) -> &Option<String>;
    /// Flag indicating if the Profile is enabled
    fn get_enabled(&self) -> bool;
}
impl<'s> serde::Serialize for dyn ProfileConfigInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ProfileConfigInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ProfileConfigInfoVisitor)
            }
        }

struct ProfileConfigInfoVisitor;

impl<'de> de::Visitor<'de> for ProfileConfigInfoVisitor {
    type Value = Box<dyn ProfileConfigInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ProfileConfigInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ProfileConfigInfoTrait for ProfileConfigInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_annotation(&self) -> &Option<String> { &self.annotation }
    fn get_enabled(&self) -> bool { self.enabled }
}
impl ProfileConfigInfoTrait for ClusterProfileConfigInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_annotation(&self) -> &Option<String> { &self.annotation }
    fn get_enabled(&self) -> bool { self.enabled }
}
impl ProfileConfigInfoTrait for HostProfileConfigInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_annotation(&self) -> &Option<String> { &self.annotation }
    fn get_enabled(&self) -> bool { self.enabled }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ProfileConfigInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ProfileConfigInfo => Some(from.as_any_ref().downcast_ref::<ProfileConfigInfo>()?),
            StructType::ClusterProfileConfigInfo => Some(from.as_any_ref().downcast_ref::<ClusterProfileConfigInfo>()?),
            StructType::HostProfileConfigInfo => Some(from.as_any_ref().downcast_ref::<HostProfileConfigInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ProfileConfigInfo => Ok(from.as_any_box().downcast::<ProfileConfigInfo>()?),
            StructType::ClusterProfileConfigInfo => Ok(from.as_any_box().downcast::<ClusterProfileConfigInfo>()?),
            StructType::HostProfileConfigInfo => Ok(from.as_any_box().downcast::<HostProfileConfigInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Specification describing the parameters during Profile creation
pub trait ProfileCreateSpecTrait : super::traits::DataObjectTrait {
    /// Name of the profile
    fn get_name(&self) -> &Option<String>;
    /// User Provided description of the profile
    fn get_annotation(&self) -> &Option<String>;
    /// Flag indicating if the Profile is enabled
    fn get_enabled(&self) -> Option<bool>;
}
impl<'s> serde::Serialize for dyn ProfileCreateSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ProfileCreateSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ProfileCreateSpecVisitor)
            }
        }

struct ProfileCreateSpecVisitor;

impl<'de> de::Visitor<'de> for ProfileCreateSpecVisitor {
    type Value = Box<dyn ProfileCreateSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ProfileCreateSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ProfileCreateSpecTrait for ProfileCreateSpec {
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_annotation(&self) -> &Option<String> { &self.annotation }
    fn get_enabled(&self) -> Option<bool> { self.enabled }
}
impl ProfileCreateSpecTrait for ProfileSerializedCreateSpec {
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_annotation(&self) -> &Option<String> { &self.annotation }
    fn get_enabled(&self) -> Option<bool> { self.enabled }
}
impl ProfileCreateSpecTrait for HostProfileSerializedHostProfileSpec {
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_annotation(&self) -> &Option<String> { &self.annotation }
    fn get_enabled(&self) -> Option<bool> { self.enabled }
}
impl ProfileCreateSpecTrait for ClusterProfileCreateSpec {
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_annotation(&self) -> &Option<String> { &self.annotation }
    fn get_enabled(&self) -> Option<bool> { self.enabled }
}
impl ProfileCreateSpecTrait for ClusterProfileConfigSpec {
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_annotation(&self) -> &Option<String> { &self.annotation }
    fn get_enabled(&self) -> Option<bool> { self.enabled }
}
impl ProfileCreateSpecTrait for ClusterProfileCompleteConfigSpec {
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_annotation(&self) -> &Option<String> { &self.annotation }
    fn get_enabled(&self) -> Option<bool> { self.enabled }
}
impl ProfileCreateSpecTrait for ClusterProfileConfigServiceCreateSpec {
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_annotation(&self) -> &Option<String> { &self.annotation }
    fn get_enabled(&self) -> Option<bool> { self.enabled }
}
impl ProfileCreateSpecTrait for HostProfileConfigSpec {
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_annotation(&self) -> &Option<String> { &self.annotation }
    fn get_enabled(&self) -> Option<bool> { self.enabled }
}
impl ProfileCreateSpecTrait for HostProfileCompleteConfigSpec {
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_annotation(&self) -> &Option<String> { &self.annotation }
    fn get_enabled(&self) -> Option<bool> { self.enabled }
}
impl ProfileCreateSpecTrait for HostProfileHostBasedConfigSpec {
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_annotation(&self) -> &Option<String> { &self.annotation }
    fn get_enabled(&self) -> Option<bool> { self.enabled }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ProfileCreateSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ProfileCreateSpec => Some(from.as_any_ref().downcast_ref::<ProfileCreateSpec>()?),
            StructType::ProfileSerializedCreateSpec => Some(from.as_any_ref().downcast_ref::<ProfileSerializedCreateSpec>()?),
            StructType::HostProfileSerializedHostProfileSpec => Some(from.as_any_ref().downcast_ref::<HostProfileSerializedHostProfileSpec>()?),
            StructType::ClusterProfileCreateSpec => Some(from.as_any_ref().downcast_ref::<ClusterProfileCreateSpec>()?),
            StructType::ClusterProfileConfigSpec => Some(from.as_any_ref().downcast_ref::<ClusterProfileConfigSpec>()?),
            StructType::ClusterProfileCompleteConfigSpec => Some(from.as_any_ref().downcast_ref::<ClusterProfileCompleteConfigSpec>()?),
            StructType::ClusterProfileConfigServiceCreateSpec => Some(from.as_any_ref().downcast_ref::<ClusterProfileConfigServiceCreateSpec>()?),
            StructType::HostProfileConfigSpec => Some(from.as_any_ref().downcast_ref::<HostProfileConfigSpec>()?),
            StructType::HostProfileCompleteConfigSpec => Some(from.as_any_ref().downcast_ref::<HostProfileCompleteConfigSpec>()?),
            StructType::HostProfileHostBasedConfigSpec => Some(from.as_any_ref().downcast_ref::<HostProfileHostBasedConfigSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ProfileCreateSpec => Ok(from.as_any_box().downcast::<ProfileCreateSpec>()?),
            StructType::ProfileSerializedCreateSpec => Ok(from.as_any_box().downcast::<ProfileSerializedCreateSpec>()?),
            StructType::HostProfileSerializedHostProfileSpec => Ok(from.as_any_box().downcast::<HostProfileSerializedHostProfileSpec>()?),
            StructType::ClusterProfileCreateSpec => Ok(from.as_any_box().downcast::<ClusterProfileCreateSpec>()?),
            StructType::ClusterProfileConfigSpec => Ok(from.as_any_box().downcast::<ClusterProfileConfigSpec>()?),
            StructType::ClusterProfileCompleteConfigSpec => Ok(from.as_any_box().downcast::<ClusterProfileCompleteConfigSpec>()?),
            StructType::ClusterProfileConfigServiceCreateSpec => Ok(from.as_any_box().downcast::<ClusterProfileConfigServiceCreateSpec>()?),
            StructType::HostProfileConfigSpec => Ok(from.as_any_box().downcast::<HostProfileConfigSpec>()?),
            StructType::HostProfileCompleteConfigSpec => Ok(from.as_any_box().downcast::<HostProfileCompleteConfigSpec>()?),
            StructType::HostProfileHostBasedConfigSpec => Ok(from.as_any_box().downcast::<HostProfileHostBasedConfigSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *ProfileSerializedCreateSpec* data object
/// defines a string that contains a serialized representation of a host profile.
pub trait ProfileSerializedCreateSpecTrait : super::traits::ProfileCreateSpecTrait {
    /// Representation of the profile in the string form.
    fn get_profile_config_string(&self) -> &str;
}
impl<'s> serde::Serialize for dyn ProfileSerializedCreateSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ProfileSerializedCreateSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ProfileSerializedCreateSpecVisitor)
            }
        }

struct ProfileSerializedCreateSpecVisitor;

impl<'de> de::Visitor<'de> for ProfileSerializedCreateSpecVisitor {
    type Value = Box<dyn ProfileSerializedCreateSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ProfileSerializedCreateSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ProfileSerializedCreateSpecTrait for ProfileSerializedCreateSpec {
    fn get_profile_config_string(&self) -> &str { &self.profile_config_string }
}
impl ProfileSerializedCreateSpecTrait for HostProfileSerializedHostProfileSpec {
    fn get_profile_config_string(&self) -> &str { &self.profile_config_string }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ProfileSerializedCreateSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ProfileSerializedCreateSpec => Some(from.as_any_ref().downcast_ref::<ProfileSerializedCreateSpec>()?),
            StructType::HostProfileSerializedHostProfileSpec => Some(from.as_any_ref().downcast_ref::<HostProfileSerializedHostProfileSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ProfileSerializedCreateSpec => Ok(from.as_any_box().downcast::<ProfileSerializedCreateSpec>()?),
            StructType::HostProfileSerializedHostProfileSpec => Ok(from.as_any_box().downcast::<HostProfileSerializedHostProfileSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class for Cluster CreateSpecs
pub trait ClusterProfileCreateSpecTrait : super::traits::ProfileCreateSpecTrait {
}
impl<'s> serde::Serialize for dyn ClusterProfileCreateSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ClusterProfileCreateSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ClusterProfileCreateSpecVisitor)
            }
        }

struct ClusterProfileCreateSpecVisitor;

impl<'de> de::Visitor<'de> for ClusterProfileCreateSpecVisitor {
    type Value = Box<dyn ClusterProfileCreateSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ClusterProfileCreateSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ClusterProfileCreateSpecTrait for ClusterProfileCreateSpec {
}
impl ClusterProfileCreateSpecTrait for ClusterProfileConfigSpec {
}
impl ClusterProfileCreateSpecTrait for ClusterProfileCompleteConfigSpec {
}
impl ClusterProfileCreateSpecTrait for ClusterProfileConfigServiceCreateSpec {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ClusterProfileCreateSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterProfileCreateSpec => Some(from.as_any_ref().downcast_ref::<ClusterProfileCreateSpec>()?),
            StructType::ClusterProfileConfigSpec => Some(from.as_any_ref().downcast_ref::<ClusterProfileConfigSpec>()?),
            StructType::ClusterProfileCompleteConfigSpec => Some(from.as_any_ref().downcast_ref::<ClusterProfileCompleteConfigSpec>()?),
            StructType::ClusterProfileConfigServiceCreateSpec => Some(from.as_any_ref().downcast_ref::<ClusterProfileConfigServiceCreateSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterProfileCreateSpec => Ok(from.as_any_box().downcast::<ClusterProfileCreateSpec>()?),
            StructType::ClusterProfileConfigSpec => Ok(from.as_any_box().downcast::<ClusterProfileConfigSpec>()?),
            StructType::ClusterProfileCompleteConfigSpec => Ok(from.as_any_box().downcast::<ClusterProfileCompleteConfigSpec>()?),
            StructType::ClusterProfileConfigServiceCreateSpec => Ok(from.as_any_box().downcast::<ClusterProfileConfigServiceCreateSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// DataObject which is a baseclass for other configuration
/// specifications.
pub trait ClusterProfileConfigSpecTrait : super::traits::ClusterProfileCreateSpecTrait {
}
impl<'s> serde::Serialize for dyn ClusterProfileConfigSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ClusterProfileConfigSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ClusterProfileConfigSpecVisitor)
            }
        }

struct ClusterProfileConfigSpecVisitor;

impl<'de> de::Visitor<'de> for ClusterProfileConfigSpecVisitor {
    type Value = Box<dyn ClusterProfileConfigSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ClusterProfileConfigSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ClusterProfileConfigSpecTrait for ClusterProfileConfigSpec {
}
impl ClusterProfileConfigSpecTrait for ClusterProfileCompleteConfigSpec {
}
impl ClusterProfileConfigSpecTrait for ClusterProfileConfigServiceCreateSpec {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ClusterProfileConfigSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterProfileConfigSpec => Some(from.as_any_ref().downcast_ref::<ClusterProfileConfigSpec>()?),
            StructType::ClusterProfileCompleteConfigSpec => Some(from.as_any_ref().downcast_ref::<ClusterProfileCompleteConfigSpec>()?),
            StructType::ClusterProfileConfigServiceCreateSpec => Some(from.as_any_ref().downcast_ref::<ClusterProfileConfigServiceCreateSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterProfileConfigSpec => Ok(from.as_any_box().downcast::<ClusterProfileConfigSpec>()?),
            StructType::ClusterProfileCompleteConfigSpec => Ok(from.as_any_box().downcast::<ClusterProfileCompleteConfigSpec>()?),
            StructType::ClusterProfileConfigServiceCreateSpec => Ok(from.as_any_box().downcast::<ClusterProfileConfigServiceCreateSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// *HostProfileConfigSpec* is the base data object
/// for all *HostProfile* configuration specifications.
pub trait HostProfileConfigSpecTrait : super::traits::ProfileCreateSpecTrait {
}
impl<'s> serde::Serialize for dyn HostProfileConfigSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostProfileConfigSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostProfileConfigSpecVisitor)
            }
        }

struct HostProfileConfigSpecVisitor;

impl<'de> de::Visitor<'de> for HostProfileConfigSpecVisitor {
    type Value = Box<dyn HostProfileConfigSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostProfileConfigSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostProfileConfigSpecTrait for HostProfileConfigSpec {
}
impl HostProfileConfigSpecTrait for HostProfileCompleteConfigSpec {
}
impl HostProfileConfigSpecTrait for HostProfileHostBasedConfigSpec {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostProfileConfigSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostProfileConfigSpec => Some(from.as_any_ref().downcast_ref::<HostProfileConfigSpec>()?),
            StructType::HostProfileCompleteConfigSpec => Some(from.as_any_ref().downcast_ref::<HostProfileCompleteConfigSpec>()?),
            StructType::HostProfileHostBasedConfigSpec => Some(from.as_any_ref().downcast_ref::<HostProfileHostBasedConfigSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostProfileConfigSpec => Ok(from.as_any_box().downcast::<HostProfileConfigSpec>()?),
            StructType::HostProfileCompleteConfigSpec => Ok(from.as_any_box().downcast::<HostProfileCompleteConfigSpec>()?),
            StructType::HostProfileHostBasedConfigSpec => Ok(from.as_any_box().downcast::<HostProfileHostBasedConfigSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *ProfileExecuteResult* data object contains the results from a
/// *HostProfile*.*HostProfile.ExecuteHostProfile*
/// operation.
pub trait ProfileExecuteResultTrait : super::traits::DataObjectTrait {
    /// Status of the profile execution operation.
    /// 
    /// The value is a string that contains
    /// one of the *ProfileExecuteResultStatus_enum* enumerations.
    fn get_status(&self) -> &str;
    /// Host configuration specification.
    /// 
    /// This data is valid only if
    /// the <code>status</code> value is <code>success</code>.
    /// See *ProfileExecuteResultStatus_enum*.
    /// 
    /// Use this data object when you apply the configuration
    /// to a host. See the <code>configSpec</code> parameter to the
    /// *HostProfileManager*.*HostProfileManager.ApplyHostConfig_Task*
    /// method.
    fn get_config_spec(&self) -> &Option<HostConfigSpec>;
    /// List of property paths.
    /// 
    /// Each path identifies a policy that does not apply
    /// to this host. For example, if the precheck policies for a port group are not satisfied,
    /// the port group will not be created when you apply the profile to the host.
    /// Based on this information, the client might not display that part of the profile tree.
    fn get_inapplicable_path(&self) -> &Option<Vec<String>>;
    /// List that describes the required input for host configuration and identifies
    /// any policy options that still require parameter data.
    /// 
    /// Each entry in the list
    /// specifies the path to a policy and a parameter list. If the call to
    /// *HostProfile.ExecuteHostProfile* includes deferred parameters,
    /// the <code>requireInput</code> entries
    /// (<code>requireInput\[\].</code>*ProfileDeferredPolicyOptionParameter.parameter*\[\])
    /// will be populated with the parameter data that was passed to the execute method.
    /// For policies that still require input data, the parameter list in the corresponding
    /// entry will be null.
    /// 
    /// A vSphere client that displays a GUI can use this information to show the host-specific
    /// configuration policy options. The client can highlight required input fields
    /// and ask the user for data in increments instead of collecting all of the input at once.
    /// For example, in the first pass, the client collects a minimum of user input and
    /// sends that to the Server. The Server evaluates the profile and might decide to
    /// invalidate a particular part of the subtree or enable a new
    /// subtree in the profile. This would result in a new set of invalid paths
    /// (*ProfileExecuteResult.inapplicablePath*\[\]) and
    /// required input property paths
    /// (*ProfileDeferredPolicyOptionParameter*.*ProfileDeferredPolicyOptionParameter.inputPath*).
    /// The client can make a series of calls to the method until it achieves a success status.
    /// 
    /// When *HostProfile.ExecuteHostProfile* returns a success status,
    /// the <code>requireInput</code> list contains the complete list of parameters,
    /// consisting of the following data:
    /// - Deferred parameter values resolved through successive calls to
    ///   *HostProfile.ExecuteHostProfile*.
    /// - Default parameter values from the host configuration.
    /// - User-specified values that override the defaults.
    ///   
    /// You can specify the returned <code>requireInput</code> list in the
    /// <code>userInput</code> parameter to the
    /// *HostProfileManager*.*HostProfileManager.ApplyHostConfig_Task*
    /// method. The Server will use the list to update the *AnswerFile*
    /// associated with the host.
    fn get_require_input(&self) -> &Option<Vec<ProfileDeferredPolicyOptionParameter>>;
    /// List of errors that were encountered during execute.
    /// 
    /// This field will be set if status is set to error.
    fn get_error(&self) -> &Option<Vec<ProfileExecuteError>>;
}
impl<'s> serde::Serialize for dyn ProfileExecuteResultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ProfileExecuteResultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ProfileExecuteResultVisitor)
            }
        }

struct ProfileExecuteResultVisitor;

impl<'de> de::Visitor<'de> for ProfileExecuteResultVisitor {
    type Value = Box<dyn ProfileExecuteResultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ProfileExecuteResultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ProfileExecuteResultTrait for ProfileExecuteResult {
    fn get_status(&self) -> &str { &self.status }
    fn get_config_spec(&self) -> &Option<HostConfigSpec> { &self.config_spec }
    fn get_inapplicable_path(&self) -> &Option<Vec<String>> { &self.inapplicable_path }
    fn get_require_input(&self) -> &Option<Vec<ProfileDeferredPolicyOptionParameter>> { &self.require_input }
    fn get_error(&self) -> &Option<Vec<ProfileExecuteError>> { &self.error }
}
impl ProfileExecuteResultTrait for ApplyHostProfileConfigurationSpec {
    fn get_status(&self) -> &str { &self.status }
    fn get_config_spec(&self) -> &Option<HostConfigSpec> { &self.config_spec }
    fn get_inapplicable_path(&self) -> &Option<Vec<String>> { &self.inapplicable_path }
    fn get_require_input(&self) -> &Option<Vec<ProfileDeferredPolicyOptionParameter>> { &self.require_input }
    fn get_error(&self) -> &Option<Vec<ProfileExecuteError>> { &self.error }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ProfileExecuteResultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ProfileExecuteResult => Some(from.as_any_ref().downcast_ref::<ProfileExecuteResult>()?),
            StructType::ApplyHostProfileConfigurationSpec => Some(from.as_any_ref().downcast_ref::<ApplyHostProfileConfigurationSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ProfileExecuteResult => Ok(from.as_any_box().downcast::<ProfileExecuteResult>()?),
            StructType::ApplyHostProfileConfigurationSpec => Ok(from.as_any_box().downcast::<ApplyHostProfileConfigurationSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class for host-specific answer file options.
pub trait AnswerFileCreateSpecTrait : super::traits::DataObjectTrait {
    /// If "false", then the answer file will be saved without being validated.
    /// 
    /// The default if not specified is "true".
    /// This option should be used with caution, since the resulting answer
    /// file will not be checked for errors.
    fn get_validating(&self) -> Option<bool>;
}
impl<'s> serde::Serialize for dyn AnswerFileCreateSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn AnswerFileCreateSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(AnswerFileCreateSpecVisitor)
            }
        }

struct AnswerFileCreateSpecVisitor;

impl<'de> de::Visitor<'de> for AnswerFileCreateSpecVisitor {
    type Value = Box<dyn AnswerFileCreateSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid AnswerFileCreateSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl AnswerFileCreateSpecTrait for AnswerFileCreateSpec {
    fn get_validating(&self) -> Option<bool> { self.validating }
}
impl AnswerFileCreateSpecTrait for AnswerFileOptionsCreateSpec {
    fn get_validating(&self) -> Option<bool> { self.validating }
}
impl AnswerFileCreateSpecTrait for AnswerFileSerializedCreateSpec {
    fn get_validating(&self) -> Option<bool> { self.validating }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn AnswerFileCreateSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::AnswerFileCreateSpec => Some(from.as_any_ref().downcast_ref::<AnswerFileCreateSpec>()?),
            StructType::AnswerFileOptionsCreateSpec => Some(from.as_any_ref().downcast_ref::<AnswerFileOptionsCreateSpec>()?),
            StructType::AnswerFileSerializedCreateSpec => Some(from.as_any_ref().downcast_ref::<AnswerFileSerializedCreateSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::AnswerFileCreateSpec => Ok(from.as_any_box().downcast::<AnswerFileCreateSpec>()?),
            StructType::AnswerFileOptionsCreateSpec => Ok(from.as_any_box().downcast::<AnswerFileOptionsCreateSpec>()?),
            StructType::AnswerFileSerializedCreateSpec => Ok(from.as_any_box().downcast::<AnswerFileSerializedCreateSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Data type used to contain a representation of host or cluster customization
/// data in a *HostProfilesCustomizationData* object.
/// 
/// Subclasses of this must be defined to provide host or cluster customization
/// data in specific formats.
pub trait HostProfilesEntityCustomizationsTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn HostProfilesEntityCustomizationsTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostProfilesEntityCustomizationsTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostProfilesEntityCustomizationsVisitor)
            }
        }

struct HostProfilesEntityCustomizationsVisitor;

impl<'de> de::Visitor<'de> for HostProfilesEntityCustomizationsVisitor {
    type Value = Box<dyn HostProfilesEntityCustomizationsTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostProfilesEntityCustomizationsTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostProfilesEntityCustomizationsTrait for HostProfilesEntityCustomizations {
}
impl HostProfilesEntityCustomizationsTrait for StructuredCustomizations {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostProfilesEntityCustomizationsTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostProfilesEntityCustomizations => Some(from.as_any_ref().downcast_ref::<HostProfilesEntityCustomizations>()?),
            StructType::StructuredCustomizations => Some(from.as_any_ref().downcast_ref::<StructuredCustomizations>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostProfilesEntityCustomizations => Ok(from.as_any_box().downcast::<HostProfilesEntityCustomizations>()?),
            StructType::StructuredCustomizations => Ok(from.as_any_box().downcast::<StructuredCustomizations>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Parameters for scheduled task creation.
pub trait ScheduledTaskSpecTrait : super::traits::DataObjectTrait {
    /// Name of the scheduled task.
    fn get_name(&self) -> &str;
    /// Description of the scheduled task.
    fn get_description(&self) -> &str;
    /// Flag to indicate whether the scheduled task is enabled or disabled.
    fn get_enabled(&self) -> bool;
    /// The time scheduler that determines when the scheduled task runs.
    fn get_scheduler(&self) -> &Box<dyn super::traits::TaskSchedulerTrait>;
    /// The action of the scheduled task, to be done when the scheduled task runs.
    fn get_action(&self) -> &Box<dyn super::traits::ActionTrait>;
    /// The email notification.
    /// 
    /// If not set, this property is set to empty string, indicating no notification.
    fn get_notification(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn ScheduledTaskSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ScheduledTaskSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ScheduledTaskSpecVisitor)
            }
        }

struct ScheduledTaskSpecVisitor;

impl<'de> de::Visitor<'de> for ScheduledTaskSpecVisitor {
    type Value = Box<dyn ScheduledTaskSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ScheduledTaskSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ScheduledTaskSpecTrait for ScheduledTaskSpec {
    fn get_name(&self) -> &str { &self.name }
    fn get_description(&self) -> &str { &self.description }
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_scheduler(&self) -> &Box<dyn super::traits::TaskSchedulerTrait> { &self.scheduler }
    fn get_action(&self) -> &Box<dyn super::traits::ActionTrait> { &self.action }
    fn get_notification(&self) -> &Option<String> { &self.notification }
}
impl ScheduledTaskSpecTrait for ScheduledTaskInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_description(&self) -> &str { &self.description }
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_scheduler(&self) -> &Box<dyn super::traits::TaskSchedulerTrait> { &self.scheduler }
    fn get_action(&self) -> &Box<dyn super::traits::ActionTrait> { &self.action }
    fn get_notification(&self) -> &Option<String> { &self.notification }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ScheduledTaskSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ScheduledTaskSpec => Some(from.as_any_ref().downcast_ref::<ScheduledTaskSpec>()?),
            StructType::ScheduledTaskInfo => Some(from.as_any_ref().downcast_ref::<ScheduledTaskInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ScheduledTaskSpec => Ok(from.as_any_box().downcast::<ScheduledTaskSpec>()?),
            StructType::ScheduledTaskInfo => Ok(from.as_any_box().downcast::<ScheduledTaskInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *TaskScheduler* data object is the base type for the scheduler objects.
/// 
/// The hierarchy of scheduler objects is as follows:
/// 
///         TaskScheduler
///             *AfterStartupTaskScheduler*
///             *OnceTaskScheduler*
///             *RecurrentTaskScheduler*
///                 *HourlyTaskScheduler*
///                     *DailyTaskScheduler*
///                         *WeeklyTaskScheduler*
///                         *MonthlyTaskScheduler*
///                             *MonthlyByDayTaskScheduler*
///                             *MonthlyByWeekdayTaskScheduler*
/// 
/// Use a scheduler object to set the time(s) for task execution.
/// You can use two scheduling modes - single execution or
/// recurring execution:
/// - Use the *AfterStartupTaskScheduler* or the *OnceTaskScheduler*
///   to schedule a single instance of task execution.
/// - Use one of the recurrent task schedulers to schedule
///   hourly, daily, weekly, or monthly task execution.
///   
/// After you have established the task timing, use the scheduler
/// object for the *ScheduledTaskSpec*
/// *ScheduledTaskSpec.scheduler* property value.
pub trait TaskSchedulerTrait : super::traits::DataObjectTrait {
    /// The time that the schedule for the task takes effect.
    /// 
    /// Task activation is distinct from task execution.
    /// When you activate a task, its schedule starts,
    /// and when the next execution time occurs, the task will run.
    /// If you do not set activeTime, the activation time defaults to
    /// the time that you create the scheduled task.
    fn get_active_time(&self) -> &Option<String>;
    /// The time the schedule for the task expires.
    /// 
    /// If you do not set expireTime, the schedule does not expire.
    fn get_expire_time(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn TaskSchedulerTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn TaskSchedulerTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(TaskSchedulerVisitor)
            }
        }

struct TaskSchedulerVisitor;

impl<'de> de::Visitor<'de> for TaskSchedulerVisitor {
    type Value = Box<dyn TaskSchedulerTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid TaskSchedulerTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl TaskSchedulerTrait for TaskScheduler {
    fn get_active_time(&self) -> &Option<String> { &self.active_time }
    fn get_expire_time(&self) -> &Option<String> { &self.expire_time }
}
impl TaskSchedulerTrait for AfterStartupTaskScheduler {
    fn get_active_time(&self) -> &Option<String> { &self.active_time }
    fn get_expire_time(&self) -> &Option<String> { &self.expire_time }
}
impl TaskSchedulerTrait for OnceTaskScheduler {
    fn get_active_time(&self) -> &Option<String> { &self.active_time }
    fn get_expire_time(&self) -> &Option<String> { &self.expire_time }
}
impl TaskSchedulerTrait for RecurrentTaskScheduler {
    fn get_active_time(&self) -> &Option<String> { &self.active_time }
    fn get_expire_time(&self) -> &Option<String> { &self.expire_time }
}
impl TaskSchedulerTrait for HourlyTaskScheduler {
    fn get_active_time(&self) -> &Option<String> { &self.active_time }
    fn get_expire_time(&self) -> &Option<String> { &self.expire_time }
}
impl TaskSchedulerTrait for DailyTaskScheduler {
    fn get_active_time(&self) -> &Option<String> { &self.active_time }
    fn get_expire_time(&self) -> &Option<String> { &self.expire_time }
}
impl TaskSchedulerTrait for MonthlyTaskScheduler {
    fn get_active_time(&self) -> &Option<String> { &self.active_time }
    fn get_expire_time(&self) -> &Option<String> { &self.expire_time }
}
impl TaskSchedulerTrait for MonthlyByDayTaskScheduler {
    fn get_active_time(&self) -> &Option<String> { &self.active_time }
    fn get_expire_time(&self) -> &Option<String> { &self.expire_time }
}
impl TaskSchedulerTrait for MonthlyByWeekdayTaskScheduler {
    fn get_active_time(&self) -> &Option<String> { &self.active_time }
    fn get_expire_time(&self) -> &Option<String> { &self.expire_time }
}
impl TaskSchedulerTrait for WeeklyTaskScheduler {
    fn get_active_time(&self) -> &Option<String> { &self.active_time }
    fn get_expire_time(&self) -> &Option<String> { &self.expire_time }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn TaskSchedulerTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::TaskScheduler => Some(from.as_any_ref().downcast_ref::<TaskScheduler>()?),
            StructType::AfterStartupTaskScheduler => Some(from.as_any_ref().downcast_ref::<AfterStartupTaskScheduler>()?),
            StructType::OnceTaskScheduler => Some(from.as_any_ref().downcast_ref::<OnceTaskScheduler>()?),
            StructType::RecurrentTaskScheduler => Some(from.as_any_ref().downcast_ref::<RecurrentTaskScheduler>()?),
            StructType::HourlyTaskScheduler => Some(from.as_any_ref().downcast_ref::<HourlyTaskScheduler>()?),
            StructType::DailyTaskScheduler => Some(from.as_any_ref().downcast_ref::<DailyTaskScheduler>()?),
            StructType::MonthlyTaskScheduler => Some(from.as_any_ref().downcast_ref::<MonthlyTaskScheduler>()?),
            StructType::MonthlyByDayTaskScheduler => Some(from.as_any_ref().downcast_ref::<MonthlyByDayTaskScheduler>()?),
            StructType::MonthlyByWeekdayTaskScheduler => Some(from.as_any_ref().downcast_ref::<MonthlyByWeekdayTaskScheduler>()?),
            StructType::WeeklyTaskScheduler => Some(from.as_any_ref().downcast_ref::<WeeklyTaskScheduler>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::TaskScheduler => Ok(from.as_any_box().downcast::<TaskScheduler>()?),
            StructType::AfterStartupTaskScheduler => Ok(from.as_any_box().downcast::<AfterStartupTaskScheduler>()?),
            StructType::OnceTaskScheduler => Ok(from.as_any_box().downcast::<OnceTaskScheduler>()?),
            StructType::RecurrentTaskScheduler => Ok(from.as_any_box().downcast::<RecurrentTaskScheduler>()?),
            StructType::HourlyTaskScheduler => Ok(from.as_any_box().downcast::<HourlyTaskScheduler>()?),
            StructType::DailyTaskScheduler => Ok(from.as_any_box().downcast::<DailyTaskScheduler>()?),
            StructType::MonthlyTaskScheduler => Ok(from.as_any_box().downcast::<MonthlyTaskScheduler>()?),
            StructType::MonthlyByDayTaskScheduler => Ok(from.as_any_box().downcast::<MonthlyByDayTaskScheduler>()?),
            StructType::MonthlyByWeekdayTaskScheduler => Ok(from.as_any_box().downcast::<MonthlyByWeekdayTaskScheduler>()?),
            StructType::WeeklyTaskScheduler => Ok(from.as_any_box().downcast::<WeeklyTaskScheduler>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *RecurrentTaskScheduler* data object is the base type for
/// the hierarchy that includes hourly, daily, weekly, and monthly task schedulers.
pub trait RecurrentTaskSchedulerTrait : super::traits::TaskSchedulerTrait {
    /// How often to run the scheduled task.
    /// 
    /// The value must be greater than
    /// or equal to 1 and less than 1000. The default value is 1.
    /// The interval acts as a multiplier for the unit of time associated
    /// with a particular scheduler (hours, days, weeks, or months).
    /// For example, setting the *HourlyTaskScheduler* interval
    /// to 4 causes the task to run every 4 hours.
    fn get_interval(&self) -> i32;
}
impl<'s> serde::Serialize for dyn RecurrentTaskSchedulerTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn RecurrentTaskSchedulerTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(RecurrentTaskSchedulerVisitor)
            }
        }

struct RecurrentTaskSchedulerVisitor;

impl<'de> de::Visitor<'de> for RecurrentTaskSchedulerVisitor {
    type Value = Box<dyn RecurrentTaskSchedulerTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid RecurrentTaskSchedulerTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl RecurrentTaskSchedulerTrait for RecurrentTaskScheduler {
    fn get_interval(&self) -> i32 { self.interval }
}
impl RecurrentTaskSchedulerTrait for HourlyTaskScheduler {
    fn get_interval(&self) -> i32 { self.interval }
}
impl RecurrentTaskSchedulerTrait for DailyTaskScheduler {
    fn get_interval(&self) -> i32 { self.interval }
}
impl RecurrentTaskSchedulerTrait for MonthlyTaskScheduler {
    fn get_interval(&self) -> i32 { self.interval }
}
impl RecurrentTaskSchedulerTrait for MonthlyByDayTaskScheduler {
    fn get_interval(&self) -> i32 { self.interval }
}
impl RecurrentTaskSchedulerTrait for MonthlyByWeekdayTaskScheduler {
    fn get_interval(&self) -> i32 { self.interval }
}
impl RecurrentTaskSchedulerTrait for WeeklyTaskScheduler {
    fn get_interval(&self) -> i32 { self.interval }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn RecurrentTaskSchedulerTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::RecurrentTaskScheduler => Some(from.as_any_ref().downcast_ref::<RecurrentTaskScheduler>()?),
            StructType::HourlyTaskScheduler => Some(from.as_any_ref().downcast_ref::<HourlyTaskScheduler>()?),
            StructType::DailyTaskScheduler => Some(from.as_any_ref().downcast_ref::<DailyTaskScheduler>()?),
            StructType::MonthlyTaskScheduler => Some(from.as_any_ref().downcast_ref::<MonthlyTaskScheduler>()?),
            StructType::MonthlyByDayTaskScheduler => Some(from.as_any_ref().downcast_ref::<MonthlyByDayTaskScheduler>()?),
            StructType::MonthlyByWeekdayTaskScheduler => Some(from.as_any_ref().downcast_ref::<MonthlyByWeekdayTaskScheduler>()?),
            StructType::WeeklyTaskScheduler => Some(from.as_any_ref().downcast_ref::<WeeklyTaskScheduler>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::RecurrentTaskScheduler => Ok(from.as_any_box().downcast::<RecurrentTaskScheduler>()?),
            StructType::HourlyTaskScheduler => Ok(from.as_any_box().downcast::<HourlyTaskScheduler>()?),
            StructType::DailyTaskScheduler => Ok(from.as_any_box().downcast::<DailyTaskScheduler>()?),
            StructType::MonthlyTaskScheduler => Ok(from.as_any_box().downcast::<MonthlyTaskScheduler>()?),
            StructType::MonthlyByDayTaskScheduler => Ok(from.as_any_box().downcast::<MonthlyByDayTaskScheduler>()?),
            StructType::MonthlyByWeekdayTaskScheduler => Ok(from.as_any_box().downcast::<MonthlyByWeekdayTaskScheduler>()?),
            StructType::WeeklyTaskScheduler => Ok(from.as_any_box().downcast::<WeeklyTaskScheduler>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *HourlyTaskScheduler* data object sets the time for hourly
/// task execution.
/// 
/// By default, the scheduled task will run once every hour,
/// at the specified minute.
/// 
/// If you set the interval to a value greater than 1, the task will
/// execute at the specified hourly interval. (For example, an interval
/// of 2 will cause the task to execute at the specified minute every 2 hours.)
pub trait HourlyTaskSchedulerTrait : super::traits::RecurrentTaskSchedulerTrait {
    /// The minute at which the *RecurrentTaskScheduler* runs
    /// the task.
    /// 
    /// Specify the minute value as a UTC (Coordinated Universal Time)
    /// value in the range 0 to 59.
    /// 
    /// For vCenter 2.x and prior releases, use the server's local time.
    /// For example, use Australia Northern Territory (UTC +9:30) or Indian (UTC +5:30)
    /// time values, rather than a UTC value.
    fn get_minute(&self) -> i32;
}
impl<'s> serde::Serialize for dyn HourlyTaskSchedulerTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HourlyTaskSchedulerTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HourlyTaskSchedulerVisitor)
            }
        }

struct HourlyTaskSchedulerVisitor;

impl<'de> de::Visitor<'de> for HourlyTaskSchedulerVisitor {
    type Value = Box<dyn HourlyTaskSchedulerTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HourlyTaskSchedulerTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HourlyTaskSchedulerTrait for HourlyTaskScheduler {
    fn get_minute(&self) -> i32 { self.minute }
}
impl HourlyTaskSchedulerTrait for DailyTaskScheduler {
    fn get_minute(&self) -> i32 { self.minute }
}
impl HourlyTaskSchedulerTrait for MonthlyTaskScheduler {
    fn get_minute(&self) -> i32 { self.minute }
}
impl HourlyTaskSchedulerTrait for MonthlyByDayTaskScheduler {
    fn get_minute(&self) -> i32 { self.minute }
}
impl HourlyTaskSchedulerTrait for MonthlyByWeekdayTaskScheduler {
    fn get_minute(&self) -> i32 { self.minute }
}
impl HourlyTaskSchedulerTrait for WeeklyTaskScheduler {
    fn get_minute(&self) -> i32 { self.minute }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HourlyTaskSchedulerTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HourlyTaskScheduler => Some(from.as_any_ref().downcast_ref::<HourlyTaskScheduler>()?),
            StructType::DailyTaskScheduler => Some(from.as_any_ref().downcast_ref::<DailyTaskScheduler>()?),
            StructType::MonthlyTaskScheduler => Some(from.as_any_ref().downcast_ref::<MonthlyTaskScheduler>()?),
            StructType::MonthlyByDayTaskScheduler => Some(from.as_any_ref().downcast_ref::<MonthlyByDayTaskScheduler>()?),
            StructType::MonthlyByWeekdayTaskScheduler => Some(from.as_any_ref().downcast_ref::<MonthlyByWeekdayTaskScheduler>()?),
            StructType::WeeklyTaskScheduler => Some(from.as_any_ref().downcast_ref::<WeeklyTaskScheduler>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HourlyTaskScheduler => Ok(from.as_any_box().downcast::<HourlyTaskScheduler>()?),
            StructType::DailyTaskScheduler => Ok(from.as_any_box().downcast::<DailyTaskScheduler>()?),
            StructType::MonthlyTaskScheduler => Ok(from.as_any_box().downcast::<MonthlyTaskScheduler>()?),
            StructType::MonthlyByDayTaskScheduler => Ok(from.as_any_box().downcast::<MonthlyByDayTaskScheduler>()?),
            StructType::MonthlyByWeekdayTaskScheduler => Ok(from.as_any_box().downcast::<MonthlyByWeekdayTaskScheduler>()?),
            StructType::WeeklyTaskScheduler => Ok(from.as_any_box().downcast::<WeeklyTaskScheduler>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *DailyTaskScheduler* data object sets the time for daily
/// task execution.
/// 
/// You set the hour and the inherited minute
/// property to complete the schedule. By default, the scheduled task
/// will run once every day at the specified hour and minute.
/// 
/// If you set the interval to a value greater than 1, the task will
/// execute at the specified daily interval. (For example, an interval
/// of 2 will cause the task to execute at the specified hour and minute
/// every 2 days.)
pub trait DailyTaskSchedulerTrait : super::traits::HourlyTaskSchedulerTrait {
    /// The hour at which the *RecurrentTaskScheduler* runs the task.
    /// 
    /// Use UTC (Coordinated Universal Time) values in the range
    /// 0 to 23, where 0 = 12:00 a.m. (UTC) and 12 = 12:00 p.m. (UTC).
    /// 
    /// For vCenter 2.x and prior releases, use the server's local time.
    /// For example, use Eastern Standard Time (EST) or Pacific Daylight Time (PDT),
    /// rather than UTC.
    fn get_hour(&self) -> i32;
}
impl<'s> serde::Serialize for dyn DailyTaskSchedulerTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DailyTaskSchedulerTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DailyTaskSchedulerVisitor)
            }
        }

struct DailyTaskSchedulerVisitor;

impl<'de> de::Visitor<'de> for DailyTaskSchedulerVisitor {
    type Value = Box<dyn DailyTaskSchedulerTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DailyTaskSchedulerTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DailyTaskSchedulerTrait for DailyTaskScheduler {
    fn get_hour(&self) -> i32 { self.hour }
}
impl DailyTaskSchedulerTrait for MonthlyTaskScheduler {
    fn get_hour(&self) -> i32 { self.hour }
}
impl DailyTaskSchedulerTrait for MonthlyByDayTaskScheduler {
    fn get_hour(&self) -> i32 { self.hour }
}
impl DailyTaskSchedulerTrait for MonthlyByWeekdayTaskScheduler {
    fn get_hour(&self) -> i32 { self.hour }
}
impl DailyTaskSchedulerTrait for WeeklyTaskScheduler {
    fn get_hour(&self) -> i32 { self.hour }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DailyTaskSchedulerTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DailyTaskScheduler => Some(from.as_any_ref().downcast_ref::<DailyTaskScheduler>()?),
            StructType::MonthlyTaskScheduler => Some(from.as_any_ref().downcast_ref::<MonthlyTaskScheduler>()?),
            StructType::MonthlyByDayTaskScheduler => Some(from.as_any_ref().downcast_ref::<MonthlyByDayTaskScheduler>()?),
            StructType::MonthlyByWeekdayTaskScheduler => Some(from.as_any_ref().downcast_ref::<MonthlyByWeekdayTaskScheduler>()?),
            StructType::WeeklyTaskScheduler => Some(from.as_any_ref().downcast_ref::<WeeklyTaskScheduler>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DailyTaskScheduler => Ok(from.as_any_box().downcast::<DailyTaskScheduler>()?),
            StructType::MonthlyTaskScheduler => Ok(from.as_any_box().downcast::<MonthlyTaskScheduler>()?),
            StructType::MonthlyByDayTaskScheduler => Ok(from.as_any_box().downcast::<MonthlyByDayTaskScheduler>()?),
            StructType::MonthlyByWeekdayTaskScheduler => Ok(from.as_any_box().downcast::<MonthlyByWeekdayTaskScheduler>()?),
            StructType::WeeklyTaskScheduler => Ok(from.as_any_box().downcast::<WeeklyTaskScheduler>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *MonthlyTaskScheduler* data object is the base type for
/// the monthly schedulers (*MonthlyByDayTaskScheduler* and
/// *MonthlyByWeekdayTaskScheduler*).
pub trait MonthlyTaskSchedulerTrait : super::traits::DailyTaskSchedulerTrait {
}
impl<'s> serde::Serialize for dyn MonthlyTaskSchedulerTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn MonthlyTaskSchedulerTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(MonthlyTaskSchedulerVisitor)
            }
        }

struct MonthlyTaskSchedulerVisitor;

impl<'de> de::Visitor<'de> for MonthlyTaskSchedulerVisitor {
    type Value = Box<dyn MonthlyTaskSchedulerTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid MonthlyTaskSchedulerTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl MonthlyTaskSchedulerTrait for MonthlyTaskScheduler {
}
impl MonthlyTaskSchedulerTrait for MonthlyByDayTaskScheduler {
}
impl MonthlyTaskSchedulerTrait for MonthlyByWeekdayTaskScheduler {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn MonthlyTaskSchedulerTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::MonthlyTaskScheduler => Some(from.as_any_ref().downcast_ref::<MonthlyTaskScheduler>()?),
            StructType::MonthlyByDayTaskScheduler => Some(from.as_any_ref().downcast_ref::<MonthlyByDayTaskScheduler>()?),
            StructType::MonthlyByWeekdayTaskScheduler => Some(from.as_any_ref().downcast_ref::<MonthlyByWeekdayTaskScheduler>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::MonthlyTaskScheduler => Ok(from.as_any_box().downcast::<MonthlyTaskScheduler>()?),
            StructType::MonthlyByDayTaskScheduler => Ok(from.as_any_box().downcast::<MonthlyByDayTaskScheduler>()?),
            StructType::MonthlyByWeekdayTaskScheduler => Ok(from.as_any_box().downcast::<MonthlyByWeekdayTaskScheduler>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// VM Configuration.
pub trait VmConfigInfoTrait : super::traits::DataObjectTrait {
    /// Information about the package content.
    fn get_product(&self) -> &Option<Vec<VAppProductInfo>>;
    /// List of properties
    fn get_property(&self) -> &Option<Vec<VAppPropertyInfo>>;
    /// IP assignment policy and DHCP support configuration.
    fn get_ip_assignment(&self) -> &VAppIpAssignmentInfo;
    /// End User Liceses Agreements.
    fn get_eula(&self) -> &Option<Vec<String>>;
    /// List of uninterpreted OVF meta-data sections.
    fn get_ovf_section(&self) -> &Option<Vec<VAppOvfSectionInfo>>;
    /// List the transports to use for properties.
    /// 
    /// Supported values are: iso and
    /// com.vmware.guestInfo.
    fn get_ovf_environment_transport(&self) -> &Option<Vec<String>>;
    /// Specifies whether the VM needs an initial boot before the deployment is complete.
    /// 
    /// Not relevant for vApps. This means that the value is always false when reading the
    /// configuration and is ignored when setting the configuration.
    /// 
    /// If a vApp requires an install boot (because one of its VMs does), this is visible
    /// on the *VirtualAppSummary.installBootRequired* field of the vApp.
    fn get_install_boot_required(&self) -> bool;
    /// Specifies the delay in seconds to wait for the VM to power off after the initial
    /// boot (used only if installBootRequired is true).
    /// 
    /// A value of 0 means wait forever.
    /// 
    /// Not relevant for vApps. This means that the value is always false when reading the
    /// configuration and is ignored when setting the configuration.
    fn get_install_boot_stop_delay(&self) -> i32;
}
impl<'s> serde::Serialize for dyn VmConfigInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VmConfigInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VmConfigInfoVisitor)
            }
        }

struct VmConfigInfoVisitor;

impl<'de> de::Visitor<'de> for VmConfigInfoVisitor {
    type Value = Box<dyn VmConfigInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VmConfigInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VmConfigInfoTrait for VmConfigInfo {
    fn get_product(&self) -> &Option<Vec<VAppProductInfo>> { &self.product }
    fn get_property(&self) -> &Option<Vec<VAppPropertyInfo>> { &self.property }
    fn get_ip_assignment(&self) -> &VAppIpAssignmentInfo { &self.ip_assignment }
    fn get_eula(&self) -> &Option<Vec<String>> { &self.eula }
    fn get_ovf_section(&self) -> &Option<Vec<VAppOvfSectionInfo>> { &self.ovf_section }
    fn get_ovf_environment_transport(&self) -> &Option<Vec<String>> { &self.ovf_environment_transport }
    fn get_install_boot_required(&self) -> bool { self.install_boot_required }
    fn get_install_boot_stop_delay(&self) -> i32 { self.install_boot_stop_delay }
}
impl VmConfigInfoTrait for VAppConfigInfo {
    fn get_product(&self) -> &Option<Vec<VAppProductInfo>> { &self.product }
    fn get_property(&self) -> &Option<Vec<VAppPropertyInfo>> { &self.property }
    fn get_ip_assignment(&self) -> &VAppIpAssignmentInfo { &self.ip_assignment }
    fn get_eula(&self) -> &Option<Vec<String>> { &self.eula }
    fn get_ovf_section(&self) -> &Option<Vec<VAppOvfSectionInfo>> { &self.ovf_section }
    fn get_ovf_environment_transport(&self) -> &Option<Vec<String>> { &self.ovf_environment_transport }
    fn get_install_boot_required(&self) -> bool { self.install_boot_required }
    fn get_install_boot_stop_delay(&self) -> i32 { self.install_boot_stop_delay }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VmConfigInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmConfigInfo => Some(from.as_any_ref().downcast_ref::<VmConfigInfo>()?),
            StructType::VAppConfigInfo => Some(from.as_any_ref().downcast_ref::<VAppConfigInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmConfigInfo => Ok(from.as_any_box().downcast::<VmConfigInfo>()?),
            StructType::VAppConfigInfo => Ok(from.as_any_box().downcast::<VAppConfigInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// vApp related configuration of a VM.
pub trait VmConfigSpecTrait : super::traits::DataObjectTrait {
    /// Information about the product.
    /// 
    /// Reconfigure privilege: VApp.ApplicationConfig
    fn get_product(&self) -> &Option<Vec<VAppProductSpec>>;
    /// List of properties.
    /// 
    /// Adding and editing properties requires various privileges depending on which fields
    /// are affected. See *VAppPropertyInfo* for details.
    /// 
    /// Deleting properties requires the privilege VApp.ApplicationConfig.
    fn get_property(&self) -> &Option<Vec<VAppPropertySpec>>;
    /// IP assignment policy and DHCP support configuration.
    /// 
    /// Reconfigure privilege: See *VAppIPAssignmentInfo*
    fn get_ip_assignment(&self) -> &Option<VAppIpAssignmentInfo>;
    /// End User Liceses Agreements.
    /// 
    /// If this list is set, it replaces all exiting licenses. An empty list will not
    /// make any changes to installed licenses. A list with a single element {""} will
    /// remove all licenses and leave an empty list.
    /// 
    /// Reconfigure privilege: VApp.ApplicationConfig
    fn get_eula(&self) -> &Option<Vec<String>>;
    /// List of uninterpreted OVF meta-data sections.
    /// 
    /// Reconfigure privilege: VApp.ApplicationConfig
    fn get_ovf_section(&self) -> &Option<Vec<VAppOvfSectionSpec>>;
    /// List the transports to use for properties.
    /// 
    /// Supported values are: iso and
    /// com.vmware.guestInfo.
    /// 
    /// If this list is set, it replaces all exiting entries. An empty list will not make
    /// any changes. A list with a single element {""} will clear the list of transports.
    /// 
    /// Reconfigure privilege: VApp.ApplicationConfig
    fn get_ovf_environment_transport(&self) -> &Option<Vec<String>>;
    /// If this is on a VirtualMachine object, it specifies whether the VM needs an
    /// initial boot before the deployment is complete.
    /// 
    /// If this is on a vApp object,
    /// it indicates than one or more VMs needs an initial reboot. This flag is
    /// automatically reset once the reboot has happened.
    /// 
    /// Reconfigure privilege: VApp.ApplicationConfig
    fn get_install_boot_required(&self) -> Option<bool>;
    /// Specifies the delay in seconds to wait for the VM to power off after the initial
    /// boot (used only if installBootRequired is true).
    /// 
    /// A value of 0 means wait forever.
    /// 
    /// Reconfigure privilege: VApp.ApplicationConfig
    fn get_install_boot_stop_delay(&self) -> Option<i32>;
}
impl<'s> serde::Serialize for dyn VmConfigSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VmConfigSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VmConfigSpecVisitor)
            }
        }

struct VmConfigSpecVisitor;

impl<'de> de::Visitor<'de> for VmConfigSpecVisitor {
    type Value = Box<dyn VmConfigSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VmConfigSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VmConfigSpecTrait for VmConfigSpec {
    fn get_product(&self) -> &Option<Vec<VAppProductSpec>> { &self.product }
    fn get_property(&self) -> &Option<Vec<VAppPropertySpec>> { &self.property }
    fn get_ip_assignment(&self) -> &Option<VAppIpAssignmentInfo> { &self.ip_assignment }
    fn get_eula(&self) -> &Option<Vec<String>> { &self.eula }
    fn get_ovf_section(&self) -> &Option<Vec<VAppOvfSectionSpec>> { &self.ovf_section }
    fn get_ovf_environment_transport(&self) -> &Option<Vec<String>> { &self.ovf_environment_transport }
    fn get_install_boot_required(&self) -> Option<bool> { self.install_boot_required }
    fn get_install_boot_stop_delay(&self) -> Option<i32> { self.install_boot_stop_delay }
}
impl VmConfigSpecTrait for VAppConfigSpec {
    fn get_product(&self) -> &Option<Vec<VAppProductSpec>> { &self.product }
    fn get_property(&self) -> &Option<Vec<VAppPropertySpec>> { &self.property }
    fn get_ip_assignment(&self) -> &Option<VAppIpAssignmentInfo> { &self.ip_assignment }
    fn get_eula(&self) -> &Option<Vec<String>> { &self.eula }
    fn get_ovf_section(&self) -> &Option<Vec<VAppOvfSectionSpec>> { &self.ovf_section }
    fn get_ovf_environment_transport(&self) -> &Option<Vec<String>> { &self.ovf_environment_transport }
    fn get_install_boot_required(&self) -> Option<bool> { self.install_boot_required }
    fn get_install_boot_stop_delay(&self) -> Option<i32> { self.install_boot_stop_delay }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VmConfigSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmConfigSpec => Some(from.as_any_ref().downcast_ref::<VmConfigSpec>()?),
            StructType::VAppConfigSpec => Some(from.as_any_ref().downcast_ref::<VAppConfigSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmConfigSpec => Ok(from.as_any_box().downcast::<VmConfigSpec>()?),
            StructType::VAppConfigSpec => Ok(from.as_any_box().downcast::<VAppConfigSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The NodeDeploymentSpec class defines location
/// specification of the nodes the VCHA Cluster along with Management
/// vCenter Server information that manages node VM.
pub trait NodeDeploymentSpecTrait : super::traits::DataObjectTrait {
    /// ESX host on which the VM is to be deployed.
    /// 
    /// For behavior when an esxHost is not specified,
    /// 
    /// See also *VirtualMachineRelocateSpec.host*.
    /// 
    /// Refers instance of *HostSystem*.
    fn get_esx_host(&self) -> &Option<ManagedObjectReference>;
    /// Datastore used for deploying the VM.
    /// 
    /// For behavior when a datastore is not specified,
    /// 
    /// See also *VirtualMachineRelocateSpec.datastore*.
    /// 
    /// Refers instance of *Datastore*.
    fn get_datastore(&self) -> &Option<ManagedObjectReference>;
    /// Name of the portgroup that is associated with the public IP address
    /// where clients connect to vCenter Server.
    /// 
    /// If a portgroup is not
    /// specified same portgroup present on source is used to deploy the VM
    /// with an assumption that portgroup is present on destination.
    /// 
    /// Refers instance of *Network*.
    fn get_public_network_port_group(&self) -> &Option<ManagedObjectReference>;
    /// Name of the portgroup that is associated with the VCHA Cluster IP
    /// address where clients connect to vCenter Server.
    /// 
    /// If a portgroup is not
    /// specified same portgroup present on source is used to deploy the VM
    /// with an assumption that portgroup is present on destination.
    /// 
    /// Refers instance of *Network*.
    fn get_cluster_network_port_group(&self) -> &Option<ManagedObjectReference>;
    /// Folder in which the VM is to be created.
    /// 
    /// Refers instance of *Folder*.
    fn get_folder(&self) -> &ManagedObjectReference;
    /// ResourcePool that will be used to deploy this node.
    /// 
    /// If the ResourcePool is not specified, the root resource pool for the
    /// host will be used.
    /// 
    /// Refers instance of *ResourcePool*.
    fn get_resource_pool(&self) -> &Option<ManagedObjectReference>;
    /// Management vCenter Server managing this VM.
    /// 
    /// If the managementVc is not specified, managementVc specified as
    /// part of SourceNodeSpec is used.
    fn get_management_vc(&self) -> &Option<ServiceLocator>;
    /// nodeName here refers to a name that will be assigned to the VM to which
    /// this node will be deployed to.
    fn get_node_name(&self) -> &str;
    /// VCHA Cluster network configuration of the node.
    /// 
    /// All cluster communication (state replication, heartbeat,
    /// cluster messages) happens over this network.
    fn get_ip_settings(&self) -> &CustomizationIpSettings;
}
impl<'s> serde::Serialize for dyn NodeDeploymentSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn NodeDeploymentSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(NodeDeploymentSpecVisitor)
            }
        }

struct NodeDeploymentSpecVisitor;

impl<'de> de::Visitor<'de> for NodeDeploymentSpecVisitor {
    type Value = Box<dyn NodeDeploymentSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid NodeDeploymentSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl NodeDeploymentSpecTrait for NodeDeploymentSpec {
    fn get_esx_host(&self) -> &Option<ManagedObjectReference> { &self.esx_host }
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
    fn get_public_network_port_group(&self) -> &Option<ManagedObjectReference> { &self.public_network_port_group }
    fn get_cluster_network_port_group(&self) -> &Option<ManagedObjectReference> { &self.cluster_network_port_group }
    fn get_folder(&self) -> &ManagedObjectReference { &self.folder }
    fn get_resource_pool(&self) -> &Option<ManagedObjectReference> { &self.resource_pool }
    fn get_management_vc(&self) -> &Option<ServiceLocator> { &self.management_vc }
    fn get_node_name(&self) -> &str { &self.node_name }
    fn get_ip_settings(&self) -> &CustomizationIpSettings { &self.ip_settings }
}
impl NodeDeploymentSpecTrait for PassiveNodeDeploymentSpec {
    fn get_esx_host(&self) -> &Option<ManagedObjectReference> { &self.esx_host }
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
    fn get_public_network_port_group(&self) -> &Option<ManagedObjectReference> { &self.public_network_port_group }
    fn get_cluster_network_port_group(&self) -> &Option<ManagedObjectReference> { &self.cluster_network_port_group }
    fn get_folder(&self) -> &ManagedObjectReference { &self.folder }
    fn get_resource_pool(&self) -> &Option<ManagedObjectReference> { &self.resource_pool }
    fn get_management_vc(&self) -> &Option<ServiceLocator> { &self.management_vc }
    fn get_node_name(&self) -> &str { &self.node_name }
    fn get_ip_settings(&self) -> &CustomizationIpSettings { &self.ip_settings }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn NodeDeploymentSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::NodeDeploymentSpec => Some(from.as_any_ref().downcast_ref::<NodeDeploymentSpec>()?),
            StructType::PassiveNodeDeploymentSpec => Some(from.as_any_ref().downcast_ref::<PassiveNodeDeploymentSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::NodeDeploymentSpec => Ok(from.as_any_box().downcast::<NodeDeploymentSpec>()?),
            StructType::PassiveNodeDeploymentSpec => Ok(from.as_any_box().downcast::<PassiveNodeDeploymentSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The NodeNetworkSpec class defines network specification of a node
/// in the VCHA Cluster.
pub trait NodeNetworkSpecTrait : super::traits::DataObjectTrait {
    /// VCHA Cluster network configuration of the node.
    /// 
    /// All cluster communication (state replication, heartbeat,
    /// cluster messages) happens over this network.
    fn get_ip_settings(&self) -> &CustomizationIpSettings;
}
impl<'s> serde::Serialize for dyn NodeNetworkSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn NodeNetworkSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(NodeNetworkSpecVisitor)
            }
        }

struct NodeNetworkSpecVisitor;

impl<'de> de::Visitor<'de> for NodeNetworkSpecVisitor {
    type Value = Box<dyn NodeNetworkSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid NodeNetworkSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl NodeNetworkSpecTrait for NodeNetworkSpec {
    fn get_ip_settings(&self) -> &CustomizationIpSettings { &self.ip_settings }
}
impl NodeNetworkSpecTrait for PassiveNodeNetworkSpec {
    fn get_ip_settings(&self) -> &CustomizationIpSettings { &self.ip_settings }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn NodeNetworkSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::NodeNetworkSpec => Some(from.as_any_ref().downcast_ref::<NodeNetworkSpec>()?),
            StructType::PassiveNodeNetworkSpec => Some(from.as_any_ref().downcast_ref::<PassiveNodeNetworkSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::NodeNetworkSpec => Ok(from.as_any_box().downcast::<NodeNetworkSpec>()?),
            StructType::PassiveNodeNetworkSpec => Ok(from.as_any_box().downcast::<PassiveNodeNetworkSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The BaseIndependentFilterSpec is base class for two different types
/// of independent filter specs *VirtualMachineIndependentFilterSpec*
/// and *VirtualMachineEmptyIndependentFilterSpec* which are used to specify
/// independent filters to be attached/removed on VMs virtual disk.
/// 
/// ***Since:*** vSphere API Release 7.0.2.1
pub trait VirtualMachineBaseIndependentFilterSpecTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn VirtualMachineBaseIndependentFilterSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualMachineBaseIndependentFilterSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualMachineBaseIndependentFilterSpecVisitor)
            }
        }

struct VirtualMachineBaseIndependentFilterSpecVisitor;

impl<'de> de::Visitor<'de> for VirtualMachineBaseIndependentFilterSpecVisitor {
    type Value = Box<dyn VirtualMachineBaseIndependentFilterSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualMachineBaseIndependentFilterSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualMachineBaseIndependentFilterSpecTrait for VirtualMachineBaseIndependentFilterSpec {
}
impl VirtualMachineBaseIndependentFilterSpecTrait for VirtualMachineEmptyIndependentFilterSpec {
}
impl VirtualMachineBaseIndependentFilterSpecTrait for VirtualMachineIndependentFilterSpec {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualMachineBaseIndependentFilterSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineBaseIndependentFilterSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineBaseIndependentFilterSpec>()?),
            StructType::VirtualMachineEmptyIndependentFilterSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineEmptyIndependentFilterSpec>()?),
            StructType::VirtualMachineIndependentFilterSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineIndependentFilterSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineBaseIndependentFilterSpec => Ok(from.as_any_box().downcast::<VirtualMachineBaseIndependentFilterSpec>()?),
            StructType::VirtualMachineEmptyIndependentFilterSpec => Ok(from.as_any_box().downcast::<VirtualMachineEmptyIndependentFilterSpec>()?),
            StructType::VirtualMachineIndependentFilterSpec => Ok(from.as_any_box().downcast::<VirtualMachineIndependentFilterSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Bootable device.
pub trait VirtualMachineBootOptionsBootableDeviceTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn VirtualMachineBootOptionsBootableDeviceTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualMachineBootOptionsBootableDeviceTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualMachineBootOptionsBootableDeviceVisitor)
            }
        }

struct VirtualMachineBootOptionsBootableDeviceVisitor;

impl<'de> de::Visitor<'de> for VirtualMachineBootOptionsBootableDeviceVisitor {
    type Value = Box<dyn VirtualMachineBootOptionsBootableDeviceTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualMachineBootOptionsBootableDeviceTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualMachineBootOptionsBootableDeviceTrait for VirtualMachineBootOptionsBootableDevice {
}
impl VirtualMachineBootOptionsBootableDeviceTrait for VirtualMachineBootOptionsBootableCdromDevice {
}
impl VirtualMachineBootOptionsBootableDeviceTrait for VirtualMachineBootOptionsBootableDiskDevice {
}
impl VirtualMachineBootOptionsBootableDeviceTrait for VirtualMachineBootOptionsBootableEthernetDevice {
}
impl VirtualMachineBootOptionsBootableDeviceTrait for VirtualMachineBootOptionsBootableFloppyDevice {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualMachineBootOptionsBootableDeviceTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineBootOptionsBootableDevice => Some(from.as_any_ref().downcast_ref::<VirtualMachineBootOptionsBootableDevice>()?),
            StructType::VirtualMachineBootOptionsBootableCdromDevice => Some(from.as_any_ref().downcast_ref::<VirtualMachineBootOptionsBootableCdromDevice>()?),
            StructType::VirtualMachineBootOptionsBootableDiskDevice => Some(from.as_any_ref().downcast_ref::<VirtualMachineBootOptionsBootableDiskDevice>()?),
            StructType::VirtualMachineBootOptionsBootableEthernetDevice => Some(from.as_any_ref().downcast_ref::<VirtualMachineBootOptionsBootableEthernetDevice>()?),
            StructType::VirtualMachineBootOptionsBootableFloppyDevice => Some(from.as_any_ref().downcast_ref::<VirtualMachineBootOptionsBootableFloppyDevice>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineBootOptionsBootableDevice => Ok(from.as_any_box().downcast::<VirtualMachineBootOptionsBootableDevice>()?),
            StructType::VirtualMachineBootOptionsBootableCdromDevice => Ok(from.as_any_box().downcast::<VirtualMachineBootOptionsBootableCdromDevice>()?),
            StructType::VirtualMachineBootOptionsBootableDiskDevice => Ok(from.as_any_box().downcast::<VirtualMachineBootOptionsBootableDiskDevice>()?),
            StructType::VirtualMachineBootOptionsBootableEthernetDevice => Ok(from.as_any_box().downcast::<VirtualMachineBootOptionsBootableEthernetDevice>()?),
            StructType::VirtualMachineBootOptionsBootableFloppyDevice => Ok(from.as_any_box().downcast::<VirtualMachineBootOptionsBootableFloppyDevice>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Runtime state of a device.
/// 
/// Subclassed for information that is specific
/// to certain device types.
pub trait VirtualMachineDeviceRuntimeInfoDeviceRuntimeStateTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn VirtualMachineDeviceRuntimeInfoDeviceRuntimeStateTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualMachineDeviceRuntimeInfoDeviceRuntimeStateTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualMachineDeviceRuntimeInfoDeviceRuntimeStateVisitor)
            }
        }

struct VirtualMachineDeviceRuntimeInfoDeviceRuntimeStateVisitor;

impl<'de> de::Visitor<'de> for VirtualMachineDeviceRuntimeInfoDeviceRuntimeStateVisitor {
    type Value = Box<dyn VirtualMachineDeviceRuntimeInfoDeviceRuntimeStateTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualMachineDeviceRuntimeInfoDeviceRuntimeStateTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualMachineDeviceRuntimeInfoDeviceRuntimeStateTrait for VirtualMachineDeviceRuntimeInfoDeviceRuntimeState {
}
impl VirtualMachineDeviceRuntimeInfoDeviceRuntimeStateTrait for VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualMachineDeviceRuntimeInfoDeviceRuntimeStateTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineDeviceRuntimeInfoDeviceRuntimeState => Some(from.as_any_ref().downcast_ref::<VirtualMachineDeviceRuntimeInfoDeviceRuntimeState>()?),
            StructType::VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState => Some(from.as_any_ref().downcast_ref::<VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineDeviceRuntimeInfoDeviceRuntimeState => Ok(from.as_any_box().downcast::<VirtualMachineDeviceRuntimeInfoDeviceRuntimeState>()?),
            StructType::VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState => Ok(from.as_any_box().downcast::<VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// FaultToleranceConfigInfo is a data object type containing Fault Tolerance
/// settings for this virtual machine.
/// 
/// role, instanceUuids and configPaths contain information about the
/// whole fault tolerance group.
pub trait FaultToleranceConfigInfoTrait : super::traits::DataObjectTrait {
    /// The index of the current VM in instanceUuids array starting from 1, so
    /// 1 means that it is the primary VM.
    fn get_role(&self) -> i32;
    /// The instanceUuid of all the VMs in this fault tolerance group.
    /// 
    /// The
    /// first element is the instanceUuid of the primary VM.
    fn get_instance_uuids(&self) -> &Vec<String>;
    /// The configuration file path for all the VMs in this fault tolerance
    /// group.
    fn get_config_paths(&self) -> &Vec<String>;
    /// Indicates whether a secondary VM is orphaned (no longer associated with
    /// the primary VM).
    fn get_orphaned(&self) -> Option<bool>;
}
impl<'s> serde::Serialize for dyn FaultToleranceConfigInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn FaultToleranceConfigInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(FaultToleranceConfigInfoVisitor)
            }
        }

struct FaultToleranceConfigInfoVisitor;

impl<'de> de::Visitor<'de> for FaultToleranceConfigInfoVisitor {
    type Value = Box<dyn FaultToleranceConfigInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid FaultToleranceConfigInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl FaultToleranceConfigInfoTrait for FaultToleranceConfigInfo {
    fn get_role(&self) -> i32 { self.role }
    fn get_instance_uuids(&self) -> &Vec<String> { &self.instance_uuids }
    fn get_config_paths(&self) -> &Vec<String> { &self.config_paths }
    fn get_orphaned(&self) -> Option<bool> { self.orphaned }
}
impl FaultToleranceConfigInfoTrait for FaultTolerancePrimaryConfigInfo {
    fn get_role(&self) -> i32 { self.role }
    fn get_instance_uuids(&self) -> &Vec<String> { &self.instance_uuids }
    fn get_config_paths(&self) -> &Vec<String> { &self.config_paths }
    fn get_orphaned(&self) -> Option<bool> { self.orphaned }
}
impl FaultToleranceConfigInfoTrait for FaultToleranceSecondaryConfigInfo {
    fn get_role(&self) -> i32 { self.role }
    fn get_instance_uuids(&self) -> &Vec<String> { &self.instance_uuids }
    fn get_config_paths(&self) -> &Vec<String> { &self.config_paths }
    fn get_orphaned(&self) -> Option<bool> { self.orphaned }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn FaultToleranceConfigInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::FaultToleranceConfigInfo => Some(from.as_any_ref().downcast_ref::<FaultToleranceConfigInfo>()?),
            StructType::FaultTolerancePrimaryConfigInfo => Some(from.as_any_ref().downcast_ref::<FaultTolerancePrimaryConfigInfo>()?),
            StructType::FaultToleranceSecondaryConfigInfo => Some(from.as_any_ref().downcast_ref::<FaultToleranceSecondaryConfigInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::FaultToleranceConfigInfo => Ok(from.as_any_box().downcast::<FaultToleranceConfigInfo>()?),
            StructType::FaultTolerancePrimaryConfigInfo => Ok(from.as_any_box().downcast::<FaultTolerancePrimaryConfigInfo>()?),
            StructType::FaultToleranceSecondaryConfigInfo => Ok(from.as_any_box().downcast::<FaultToleranceSecondaryConfigInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type encapsulates configuration settings
/// when creating a virtual machine quiesced snapshot.
pub trait VirtualMachineGuestQuiesceSpecTrait : super::traits::DataObjectTrait {
    /// The property to indicate maximum time in minutes for snapshot operation
    /// to be performed on the virtual machine.
    /// 
    /// The timeout can not be less than 5 minutes or more than 240 minutes.
    fn get_timeout(&self) -> Option<i32>;
}
impl<'s> serde::Serialize for dyn VirtualMachineGuestQuiesceSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualMachineGuestQuiesceSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualMachineGuestQuiesceSpecVisitor)
            }
        }

struct VirtualMachineGuestQuiesceSpecVisitor;

impl<'de> de::Visitor<'de> for VirtualMachineGuestQuiesceSpecVisitor {
    type Value = Box<dyn VirtualMachineGuestQuiesceSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualMachineGuestQuiesceSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualMachineGuestQuiesceSpecTrait for VirtualMachineGuestQuiesceSpec {
    fn get_timeout(&self) -> Option<i32> { self.timeout }
}
impl VirtualMachineGuestQuiesceSpecTrait for VirtualMachineWindowsQuiesceSpec {
    fn get_timeout(&self) -> Option<i32> { self.timeout }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualMachineGuestQuiesceSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineGuestQuiesceSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineGuestQuiesceSpec>()?),
            StructType::VirtualMachineWindowsQuiesceSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineWindowsQuiesceSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineGuestQuiesceSpec => Ok(from.as_any_box().downcast::<VirtualMachineGuestQuiesceSpec>()?),
            StructType::VirtualMachineWindowsQuiesceSpec => Ok(from.as_any_box().downcast::<VirtualMachineWindowsQuiesceSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The ProfileSpec data object is used to specify the Storage Policy to be
/// associated with a Virtual Machine Home or a Virtual Disk.
pub trait VirtualMachineProfileSpecTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn VirtualMachineProfileSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualMachineProfileSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualMachineProfileSpecVisitor)
            }
        }

struct VirtualMachineProfileSpecVisitor;

impl<'de> de::Visitor<'de> for VirtualMachineProfileSpecVisitor {
    type Value = Box<dyn VirtualMachineProfileSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualMachineProfileSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualMachineProfileSpecTrait for VirtualMachineProfileSpec {
}
impl VirtualMachineProfileSpecTrait for VirtualMachineDefaultProfileSpec {
}
impl VirtualMachineProfileSpecTrait for VirtualMachineDefinedProfileSpec {
}
impl VirtualMachineProfileSpecTrait for VirtualMachineEmptyProfileSpec {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualMachineProfileSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineProfileSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineProfileSpec>()?),
            StructType::VirtualMachineDefaultProfileSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineDefaultProfileSpec>()?),
            StructType::VirtualMachineDefinedProfileSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineDefinedProfileSpec>()?),
            StructType::VirtualMachineEmptyProfileSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineEmptyProfileSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineProfileSpec => Ok(from.as_any_box().downcast::<VirtualMachineProfileSpec>()?),
            StructType::VirtualMachineDefaultProfileSpec => Ok(from.as_any_box().downcast::<VirtualMachineDefaultProfileSpec>()?),
            StructType::VirtualMachineDefinedProfileSpec => Ok(from.as_any_box().downcast::<VirtualMachineDefinedProfileSpec>()?),
            StructType::VirtualMachineEmptyProfileSpec => Ok(from.as_any_box().downcast::<VirtualMachineEmptyProfileSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
pub trait VirtualMachineSriovDevicePoolInfoTrait : super::traits::DataObjectTrait {
    /// To be used for extending to other device types
    fn get_key(&self) -> &str;
}
impl<'s> serde::Serialize for dyn VirtualMachineSriovDevicePoolInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualMachineSriovDevicePoolInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualMachineSriovDevicePoolInfoVisitor)
            }
        }

struct VirtualMachineSriovDevicePoolInfoVisitor;

impl<'de> de::Visitor<'de> for VirtualMachineSriovDevicePoolInfoVisitor {
    type Value = Box<dyn VirtualMachineSriovDevicePoolInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualMachineSriovDevicePoolInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualMachineSriovDevicePoolInfoTrait for VirtualMachineSriovDevicePoolInfo {
    fn get_key(&self) -> &str { &self.key }
}
impl VirtualMachineSriovDevicePoolInfoTrait for VirtualMachineSriovNetworkDevicePoolInfo {
    fn get_key(&self) -> &str { &self.key }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualMachineSriovDevicePoolInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineSriovDevicePoolInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineSriovDevicePoolInfo>()?),
            StructType::VirtualMachineSriovNetworkDevicePoolInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineSriovNetworkDevicePoolInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineSriovDevicePoolInfo => Ok(from.as_any_box().downcast::<VirtualMachineSriovDevicePoolInfo>()?),
            StructType::VirtualMachineSriovNetworkDevicePoolInfo => Ok(from.as_any_box().downcast::<VirtualMachineSriovNetworkDevicePoolInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The TargetInfo specified a value that can be used in the device backings to
/// connect the virtual machine to a physical (or logical) host device.
pub trait VirtualMachineTargetInfoTrait : super::traits::DataObjectTrait {
    /// The identification of the endpoint on the host.
    /// 
    /// The format of this depends
    /// on the kind of virtual device this endpoints is used for. For example,
    /// for a VirtualEthernetCard this would be a networkname, and for a VirtualCDROM
    /// it would be a device name.
    fn get_name(&self) -> &str;
    /// List of configurations that this device is available for.
    /// 
    /// This is only filled
    /// out if more than one configuration is requested.
    fn get_configuration_tag(&self) -> &Option<Vec<String>>;
}
impl<'s> serde::Serialize for dyn VirtualMachineTargetInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualMachineTargetInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualMachineTargetInfoVisitor)
            }
        }

struct VirtualMachineTargetInfoVisitor;

impl<'de> de::Visitor<'de> for VirtualMachineTargetInfoVisitor {
    type Value = Box<dyn VirtualMachineTargetInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualMachineTargetInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualMachineTargetInfoTrait for VirtualMachineTargetInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineCdromInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineDatastoreInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineDiskDeviceInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineIdeDiskDeviceInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineScsiDiskDeviceInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineDynamicPassthroughInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineFloppyInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineNetworkInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for OpaqueNetworkTargetInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineParallelInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachinePciPassthroughInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineSriovInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachinePciSharedGpuPassthroughInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachinePrecisionClockInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineScsiPassthroughInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineSerialInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineSgxTargetInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineSoundInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineUsbInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineVFlashModuleInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineVMotionStunTimeInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineVendorDeviceGroupInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineVgpuDeviceInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineVgpuProfileInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualMachineTargetInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineTargetInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineTargetInfo>()?),
            StructType::VirtualMachineCdromInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineCdromInfo>()?),
            StructType::VirtualMachineDatastoreInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineDatastoreInfo>()?),
            StructType::VirtualMachineDiskDeviceInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineDiskDeviceInfo>()?),
            StructType::VirtualMachineIdeDiskDeviceInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineIdeDiskDeviceInfo>()?),
            StructType::VirtualMachineScsiDiskDeviceInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineScsiDiskDeviceInfo>()?),
            StructType::VirtualMachineDynamicPassthroughInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineDynamicPassthroughInfo>()?),
            StructType::VirtualMachineFloppyInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineFloppyInfo>()?),
            StructType::VirtualMachineNetworkInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineNetworkInfo>()?),
            StructType::OpaqueNetworkTargetInfo => Some(from.as_any_ref().downcast_ref::<OpaqueNetworkTargetInfo>()?),
            StructType::VirtualMachineParallelInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineParallelInfo>()?),
            StructType::VirtualMachinePciPassthroughInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachinePciPassthroughInfo>()?),
            StructType::VirtualMachineSriovInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineSriovInfo>()?),
            StructType::VirtualMachinePciSharedGpuPassthroughInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachinePciSharedGpuPassthroughInfo>()?),
            StructType::VirtualMachinePrecisionClockInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachinePrecisionClockInfo>()?),
            StructType::VirtualMachineScsiPassthroughInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineScsiPassthroughInfo>()?),
            StructType::VirtualMachineSerialInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineSerialInfo>()?),
            StructType::VirtualMachineSgxTargetInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineSgxTargetInfo>()?),
            StructType::VirtualMachineSoundInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineSoundInfo>()?),
            StructType::VirtualMachineUsbInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineUsbInfo>()?),
            StructType::VirtualMachineVFlashModuleInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineVFlashModuleInfo>()?),
            StructType::VirtualMachineVMotionStunTimeInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineVMotionStunTimeInfo>()?),
            StructType::VirtualMachineVendorDeviceGroupInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineVendorDeviceGroupInfo>()?),
            StructType::VirtualMachineVgpuDeviceInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineVgpuDeviceInfo>()?),
            StructType::VirtualMachineVgpuProfileInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineVgpuProfileInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineTargetInfo => Ok(from.as_any_box().downcast::<VirtualMachineTargetInfo>()?),
            StructType::VirtualMachineCdromInfo => Ok(from.as_any_box().downcast::<VirtualMachineCdromInfo>()?),
            StructType::VirtualMachineDatastoreInfo => Ok(from.as_any_box().downcast::<VirtualMachineDatastoreInfo>()?),
            StructType::VirtualMachineDiskDeviceInfo => Ok(from.as_any_box().downcast::<VirtualMachineDiskDeviceInfo>()?),
            StructType::VirtualMachineIdeDiskDeviceInfo => Ok(from.as_any_box().downcast::<VirtualMachineIdeDiskDeviceInfo>()?),
            StructType::VirtualMachineScsiDiskDeviceInfo => Ok(from.as_any_box().downcast::<VirtualMachineScsiDiskDeviceInfo>()?),
            StructType::VirtualMachineDynamicPassthroughInfo => Ok(from.as_any_box().downcast::<VirtualMachineDynamicPassthroughInfo>()?),
            StructType::VirtualMachineFloppyInfo => Ok(from.as_any_box().downcast::<VirtualMachineFloppyInfo>()?),
            StructType::VirtualMachineNetworkInfo => Ok(from.as_any_box().downcast::<VirtualMachineNetworkInfo>()?),
            StructType::OpaqueNetworkTargetInfo => Ok(from.as_any_box().downcast::<OpaqueNetworkTargetInfo>()?),
            StructType::VirtualMachineParallelInfo => Ok(from.as_any_box().downcast::<VirtualMachineParallelInfo>()?),
            StructType::VirtualMachinePciPassthroughInfo => Ok(from.as_any_box().downcast::<VirtualMachinePciPassthroughInfo>()?),
            StructType::VirtualMachineSriovInfo => Ok(from.as_any_box().downcast::<VirtualMachineSriovInfo>()?),
            StructType::VirtualMachinePciSharedGpuPassthroughInfo => Ok(from.as_any_box().downcast::<VirtualMachinePciSharedGpuPassthroughInfo>()?),
            StructType::VirtualMachinePrecisionClockInfo => Ok(from.as_any_box().downcast::<VirtualMachinePrecisionClockInfo>()?),
            StructType::VirtualMachineScsiPassthroughInfo => Ok(from.as_any_box().downcast::<VirtualMachineScsiPassthroughInfo>()?),
            StructType::VirtualMachineSerialInfo => Ok(from.as_any_box().downcast::<VirtualMachineSerialInfo>()?),
            StructType::VirtualMachineSgxTargetInfo => Ok(from.as_any_box().downcast::<VirtualMachineSgxTargetInfo>()?),
            StructType::VirtualMachineSoundInfo => Ok(from.as_any_box().downcast::<VirtualMachineSoundInfo>()?),
            StructType::VirtualMachineUsbInfo => Ok(from.as_any_box().downcast::<VirtualMachineUsbInfo>()?),
            StructType::VirtualMachineVFlashModuleInfo => Ok(from.as_any_box().downcast::<VirtualMachineVFlashModuleInfo>()?),
            StructType::VirtualMachineVMotionStunTimeInfo => Ok(from.as_any_box().downcast::<VirtualMachineVMotionStunTimeInfo>()?),
            StructType::VirtualMachineVendorDeviceGroupInfo => Ok(from.as_any_box().downcast::<VirtualMachineVendorDeviceGroupInfo>()?),
            StructType::VirtualMachineVgpuDeviceInfo => Ok(from.as_any_box().downcast::<VirtualMachineVgpuDeviceInfo>()?),
            StructType::VirtualMachineVgpuProfileInfo => Ok(from.as_any_box().downcast::<VirtualMachineVgpuProfileInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The DiskDeviceInfo class contains basic information about a specific disk hardware
/// device.
pub trait VirtualMachineDiskDeviceInfoTrait : super::traits::VirtualMachineTargetInfoTrait {
    /// Size of disk
    fn get_capacity(&self) -> Option<i64>;
    /// List of known virtual machines using this physical disk as a backing
    /// 
    /// Refers instances of *VirtualMachine*.
    fn get_vm(&self) -> &Option<Vec<ManagedObjectReference>>;
}
impl<'s> serde::Serialize for dyn VirtualMachineDiskDeviceInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualMachineDiskDeviceInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualMachineDiskDeviceInfoVisitor)
            }
        }

struct VirtualMachineDiskDeviceInfoVisitor;

impl<'de> de::Visitor<'de> for VirtualMachineDiskDeviceInfoVisitor {
    type Value = Box<dyn VirtualMachineDiskDeviceInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualMachineDiskDeviceInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualMachineDiskDeviceInfoTrait for VirtualMachineDiskDeviceInfo {
    fn get_capacity(&self) -> Option<i64> { self.capacity }
    fn get_vm(&self) -> &Option<Vec<ManagedObjectReference>> { &self.vm }
}
impl VirtualMachineDiskDeviceInfoTrait for VirtualMachineIdeDiskDeviceInfo {
    fn get_capacity(&self) -> Option<i64> { self.capacity }
    fn get_vm(&self) -> &Option<Vec<ManagedObjectReference>> { &self.vm }
}
impl VirtualMachineDiskDeviceInfoTrait for VirtualMachineScsiDiskDeviceInfo {
    fn get_capacity(&self) -> Option<i64> { self.capacity }
    fn get_vm(&self) -> &Option<Vec<ManagedObjectReference>> { &self.vm }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualMachineDiskDeviceInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineDiskDeviceInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineDiskDeviceInfo>()?),
            StructType::VirtualMachineIdeDiskDeviceInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineIdeDiskDeviceInfo>()?),
            StructType::VirtualMachineScsiDiskDeviceInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineScsiDiskDeviceInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineDiskDeviceInfo => Ok(from.as_any_box().downcast::<VirtualMachineDiskDeviceInfo>()?),
            StructType::VirtualMachineIdeDiskDeviceInfo => Ok(from.as_any_box().downcast::<VirtualMachineIdeDiskDeviceInfo>()?),
            StructType::VirtualMachineScsiDiskDeviceInfo => Ok(from.as_any_box().downcast::<VirtualMachineScsiDiskDeviceInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Description of a generic PCI device that can be attached to a virtual machine.
pub trait VirtualMachinePciPassthroughInfoTrait : super::traits::VirtualMachineTargetInfoTrait {
    /// Details of the PCI device, including vendor, class and
    /// device identification information.
    fn get_pci_device(&self) -> &HostPciDevice;
    /// The ID of the system the PCI device is attached to.
    fn get_system_id(&self) -> &str;
}
impl<'s> serde::Serialize for dyn VirtualMachinePciPassthroughInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualMachinePciPassthroughInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualMachinePciPassthroughInfoVisitor)
            }
        }

struct VirtualMachinePciPassthroughInfoVisitor;

impl<'de> de::Visitor<'de> for VirtualMachinePciPassthroughInfoVisitor {
    type Value = Box<dyn VirtualMachinePciPassthroughInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualMachinePciPassthroughInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualMachinePciPassthroughInfoTrait for VirtualMachinePciPassthroughInfo {
    fn get_pci_device(&self) -> &HostPciDevice { &self.pci_device }
    fn get_system_id(&self) -> &str { &self.system_id }
}
impl VirtualMachinePciPassthroughInfoTrait for VirtualMachineSriovInfo {
    fn get_pci_device(&self) -> &HostPciDevice { &self.pci_device }
    fn get_system_id(&self) -> &str { &self.system_id }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualMachinePciPassthroughInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachinePciPassthroughInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachinePciPassthroughInfo>()?),
            StructType::VirtualMachineSriovInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineSriovInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachinePciPassthroughInfo => Ok(from.as_any_box().downcast::<VirtualMachinePciPassthroughInfo>()?),
            StructType::VirtualMachineSriovInfo => Ok(from.as_any_box().downcast::<VirtualMachineSriovInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base device group type.
pub trait VirtualMachineVirtualDeviceGroupsDeviceGroupTrait : super::traits::DataObjectTrait {
    /// Group instance key.
    /// 
    /// Unique integer referencing
    /// device group. During group creation client should
    /// use a temporary negative number. Once group is
    /// added to the virtual machine, server generates non-negative
    /// integer that stays constant during group lifetime.
    /// See *VirtualDevice.key* for details.
    fn get_group_instance_key(&self) -> i32;
    /// Provides a label and summary information for the device.
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>>;
}
impl<'s> serde::Serialize for dyn VirtualMachineVirtualDeviceGroupsDeviceGroupTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualMachineVirtualDeviceGroupsDeviceGroupTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualMachineVirtualDeviceGroupsDeviceGroupVisitor)
            }
        }

struct VirtualMachineVirtualDeviceGroupsDeviceGroupVisitor;

impl<'de> de::Visitor<'de> for VirtualMachineVirtualDeviceGroupsDeviceGroupVisitor {
    type Value = Box<dyn VirtualMachineVirtualDeviceGroupsDeviceGroupTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualMachineVirtualDeviceGroupsDeviceGroupTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualMachineVirtualDeviceGroupsDeviceGroupTrait for VirtualMachineVirtualDeviceGroupsDeviceGroup {
    fn get_group_instance_key(&self) -> i32 { self.group_instance_key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
}
impl VirtualMachineVirtualDeviceGroupsDeviceGroupTrait for VirtualMachineVirtualDeviceGroupsVendorDeviceGroup {
    fn get_group_instance_key(&self) -> i32 { self.group_instance_key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualMachineVirtualDeviceGroupsDeviceGroupTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineVirtualDeviceGroupsDeviceGroup => Some(from.as_any_ref().downcast_ref::<VirtualMachineVirtualDeviceGroupsDeviceGroup>()?),
            StructType::VirtualMachineVirtualDeviceGroupsVendorDeviceGroup => Some(from.as_any_ref().downcast_ref::<VirtualMachineVirtualDeviceGroupsVendorDeviceGroup>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineVirtualDeviceGroupsDeviceGroup => Ok(from.as_any_box().downcast::<VirtualMachineVirtualDeviceGroupsDeviceGroup>()?),
            StructType::VirtualMachineVirtualDeviceGroupsVendorDeviceGroup => Ok(from.as_any_box().downcast::<VirtualMachineVirtualDeviceGroupsVendorDeviceGroup>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base type for sysprep, sysprepText, or linuxPrep object type.
pub trait CustomizationIdentitySettingsTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn CustomizationIdentitySettingsTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn CustomizationIdentitySettingsTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(CustomizationIdentitySettingsVisitor)
            }
        }

struct CustomizationIdentitySettingsVisitor;

impl<'de> de::Visitor<'de> for CustomizationIdentitySettingsVisitor {
    type Value = Box<dyn CustomizationIdentitySettingsTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid CustomizationIdentitySettingsTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl CustomizationIdentitySettingsTrait for CustomizationIdentitySettings {
}
impl CustomizationIdentitySettingsTrait for CustomizationCloudinitPrep {
}
impl CustomizationIdentitySettingsTrait for CustomizationLinuxPrep {
}
impl CustomizationIdentitySettingsTrait for CustomizationSysprep {
}
impl CustomizationIdentitySettingsTrait for CustomizationSysprepText {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn CustomizationIdentitySettingsTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::CustomizationIdentitySettings => Some(from.as_any_ref().downcast_ref::<CustomizationIdentitySettings>()?),
            StructType::CustomizationCloudinitPrep => Some(from.as_any_ref().downcast_ref::<CustomizationCloudinitPrep>()?),
            StructType::CustomizationLinuxPrep => Some(from.as_any_ref().downcast_ref::<CustomizationLinuxPrep>()?),
            StructType::CustomizationSysprep => Some(from.as_any_ref().downcast_ref::<CustomizationSysprep>()?),
            StructType::CustomizationSysprepText => Some(from.as_any_ref().downcast_ref::<CustomizationSysprepText>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::CustomizationIdentitySettings => Ok(from.as_any_box().downcast::<CustomizationIdentitySettings>()?),
            StructType::CustomizationCloudinitPrep => Ok(from.as_any_box().downcast::<CustomizationCloudinitPrep>()?),
            StructType::CustomizationLinuxPrep => Ok(from.as_any_box().downcast::<CustomizationLinuxPrep>()?),
            StructType::CustomizationSysprep => Ok(from.as_any_box().downcast::<CustomizationSysprep>()?),
            StructType::CustomizationSysprepText => Ok(from.as_any_box().downcast::<CustomizationSysprepText>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base type for the various IP specification possibilities.
pub trait CustomizationIpGeneratorTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn CustomizationIpGeneratorTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn CustomizationIpGeneratorTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(CustomizationIpGeneratorVisitor)
            }
        }

struct CustomizationIpGeneratorVisitor;

impl<'de> de::Visitor<'de> for CustomizationIpGeneratorVisitor {
    type Value = Box<dyn CustomizationIpGeneratorTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid CustomizationIpGeneratorTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl CustomizationIpGeneratorTrait for CustomizationIpGenerator {
}
impl CustomizationIpGeneratorTrait for CustomizationCustomIpGenerator {
}
impl CustomizationIpGeneratorTrait for CustomizationDhcpIpGenerator {
}
impl CustomizationIpGeneratorTrait for CustomizationFixedIp {
}
impl CustomizationIpGeneratorTrait for CustomizationUnknownIpGenerator {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn CustomizationIpGeneratorTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::CustomizationIpGenerator => Some(from.as_any_ref().downcast_ref::<CustomizationIpGenerator>()?),
            StructType::CustomizationCustomIpGenerator => Some(from.as_any_ref().downcast_ref::<CustomizationCustomIpGenerator>()?),
            StructType::CustomizationDhcpIpGenerator => Some(from.as_any_ref().downcast_ref::<CustomizationDhcpIpGenerator>()?),
            StructType::CustomizationFixedIp => Some(from.as_any_ref().downcast_ref::<CustomizationFixedIp>()?),
            StructType::CustomizationUnknownIpGenerator => Some(from.as_any_ref().downcast_ref::<CustomizationUnknownIpGenerator>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::CustomizationIpGenerator => Ok(from.as_any_box().downcast::<CustomizationIpGenerator>()?),
            StructType::CustomizationCustomIpGenerator => Ok(from.as_any_box().downcast::<CustomizationCustomIpGenerator>()?),
            StructType::CustomizationDhcpIpGenerator => Ok(from.as_any_box().downcast::<CustomizationDhcpIpGenerator>()?),
            StructType::CustomizationFixedIp => Ok(from.as_any_box().downcast::<CustomizationFixedIp>()?),
            StructType::CustomizationUnknownIpGenerator => Ok(from.as_any_box().downcast::<CustomizationUnknownIpGenerator>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base type for the various IpV6 specification possibilities
pub trait CustomizationIpV6GeneratorTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn CustomizationIpV6GeneratorTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn CustomizationIpV6GeneratorTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(CustomizationIpV6GeneratorVisitor)
            }
        }

struct CustomizationIpV6GeneratorVisitor;

impl<'de> de::Visitor<'de> for CustomizationIpV6GeneratorVisitor {
    type Value = Box<dyn CustomizationIpV6GeneratorTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid CustomizationIpV6GeneratorTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl CustomizationIpV6GeneratorTrait for CustomizationIpV6Generator {
}
impl CustomizationIpV6GeneratorTrait for CustomizationAutoIpV6Generator {
}
impl CustomizationIpV6GeneratorTrait for CustomizationCustomIpV6Generator {
}
impl CustomizationIpV6GeneratorTrait for CustomizationDhcpIpV6Generator {
}
impl CustomizationIpV6GeneratorTrait for CustomizationFixedIpV6 {
}
impl CustomizationIpV6GeneratorTrait for CustomizationStatelessIpV6Generator {
}
impl CustomizationIpV6GeneratorTrait for CustomizationUnknownIpV6Generator {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn CustomizationIpV6GeneratorTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::CustomizationIpV6Generator => Some(from.as_any_ref().downcast_ref::<CustomizationIpV6Generator>()?),
            StructType::CustomizationAutoIpV6Generator => Some(from.as_any_ref().downcast_ref::<CustomizationAutoIpV6Generator>()?),
            StructType::CustomizationCustomIpV6Generator => Some(from.as_any_ref().downcast_ref::<CustomizationCustomIpV6Generator>()?),
            StructType::CustomizationDhcpIpV6Generator => Some(from.as_any_ref().downcast_ref::<CustomizationDhcpIpV6Generator>()?),
            StructType::CustomizationFixedIpV6 => Some(from.as_any_ref().downcast_ref::<CustomizationFixedIpV6>()?),
            StructType::CustomizationStatelessIpV6Generator => Some(from.as_any_ref().downcast_ref::<CustomizationStatelessIpV6Generator>()?),
            StructType::CustomizationUnknownIpV6Generator => Some(from.as_any_ref().downcast_ref::<CustomizationUnknownIpV6Generator>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::CustomizationIpV6Generator => Ok(from.as_any_box().downcast::<CustomizationIpV6Generator>()?),
            StructType::CustomizationAutoIpV6Generator => Ok(from.as_any_box().downcast::<CustomizationAutoIpV6Generator>()?),
            StructType::CustomizationCustomIpV6Generator => Ok(from.as_any_box().downcast::<CustomizationCustomIpV6Generator>()?),
            StructType::CustomizationDhcpIpV6Generator => Ok(from.as_any_box().downcast::<CustomizationDhcpIpV6Generator>()?),
            StructType::CustomizationFixedIpV6 => Ok(from.as_any_box().downcast::<CustomizationFixedIpV6>()?),
            StructType::CustomizationStatelessIpV6Generator => Ok(from.as_any_box().downcast::<CustomizationStatelessIpV6Generator>()?),
            StructType::CustomizationUnknownIpV6Generator => Ok(from.as_any_box().downcast::<CustomizationUnknownIpV6Generator>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// A base object type for a virtual machine name that can be either fixed or
/// auto-generated.
pub trait CustomizationNameTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn CustomizationNameTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn CustomizationNameTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(CustomizationNameVisitor)
            }
        }

struct CustomizationNameVisitor;

impl<'de> de::Visitor<'de> for CustomizationNameVisitor {
    type Value = Box<dyn CustomizationNameTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid CustomizationNameTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl CustomizationNameTrait for CustomizationName {
}
impl CustomizationNameTrait for CustomizationCustomName {
}
impl CustomizationNameTrait for CustomizationFixedName {
}
impl CustomizationNameTrait for CustomizationPrefixName {
}
impl CustomizationNameTrait for CustomizationUnknownName {
}
impl CustomizationNameTrait for CustomizationVirtualMachineName {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn CustomizationNameTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::CustomizationName => Some(from.as_any_ref().downcast_ref::<CustomizationName>()?),
            StructType::CustomizationCustomName => Some(from.as_any_ref().downcast_ref::<CustomizationCustomName>()?),
            StructType::CustomizationFixedName => Some(from.as_any_ref().downcast_ref::<CustomizationFixedName>()?),
            StructType::CustomizationPrefixName => Some(from.as_any_ref().downcast_ref::<CustomizationPrefixName>()?),
            StructType::CustomizationUnknownName => Some(from.as_any_ref().downcast_ref::<CustomizationUnknownName>()?),
            StructType::CustomizationVirtualMachineName => Some(from.as_any_ref().downcast_ref::<CustomizationVirtualMachineName>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::CustomizationName => Ok(from.as_any_box().downcast::<CustomizationName>()?),
            StructType::CustomizationCustomName => Ok(from.as_any_box().downcast::<CustomizationCustomName>()?),
            StructType::CustomizationFixedName => Ok(from.as_any_box().downcast::<CustomizationFixedName>()?),
            StructType::CustomizationPrefixName => Ok(from.as_any_box().downcast::<CustomizationPrefixName>()?),
            StructType::CustomizationUnknownName => Ok(from.as_any_box().downcast::<CustomizationUnknownName>()?),
            StructType::CustomizationVirtualMachineName => Ok(from.as_any_box().downcast::<CustomizationVirtualMachineName>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base object type for optional operations supported by the customization process.
pub trait CustomizationOptionsTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn CustomizationOptionsTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn CustomizationOptionsTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(CustomizationOptionsVisitor)
            }
        }

struct CustomizationOptionsVisitor;

impl<'de> de::Visitor<'de> for CustomizationOptionsVisitor {
    type Value = Box<dyn CustomizationOptionsTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid CustomizationOptionsTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl CustomizationOptionsTrait for CustomizationOptions {
}
impl CustomizationOptionsTrait for CustomizationLinuxOptions {
}
impl CustomizationOptionsTrait for CustomizationWinOptions {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn CustomizationOptionsTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::CustomizationOptions => Some(from.as_any_ref().downcast_ref::<CustomizationOptions>()?),
            StructType::CustomizationLinuxOptions => Some(from.as_any_ref().downcast_ref::<CustomizationLinuxOptions>()?),
            StructType::CustomizationWinOptions => Some(from.as_any_ref().downcast_ref::<CustomizationWinOptions>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::CustomizationOptions => Ok(from.as_any_box().downcast::<CustomizationOptions>()?),
            StructType::CustomizationLinuxOptions => Ok(from.as_any_box().downcast::<CustomizationLinuxOptions>()?),
            StructType::CustomizationWinOptions => Ok(from.as_any_box().downcast::<CustomizationWinOptions>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// VirtualDevice is the base data object type for devices in a virtual machine.
/// 
/// This type contains enough information about a virtual device to allow clients
/// to display devices they do not recognize. For example, a client with an
/// older version than the server to which it connects may see a device
/// without knowing what it is.
pub trait VirtualDeviceTrait : super::traits::DataObjectTrait {
    /// A unique key that distinguishes this device from other
    /// devices in the same virtual machine.
    /// 
    /// Keys are immutable but may be
    /// recycled; that is, a key does not change as long as the device is
    /// associated with a particular virtual machine. However, once a device is
    /// removed, its key may be used when another device is added.
    /// 
    /// This property is not read-only, but the client cannot control its value.
    /// Persistent device keys are always assigned and managed by the server, which
    /// guarantees that all devices will have non-negative key values.
    /// 
    /// When adding new devices, it may be necessary for a client to assign keys
    /// temporarily in order to associate controllers with devices in
    /// configuring a virtual machine. However, the server does not allow a
    /// client to reassign a device key, and the server may assign a different
    /// value from the one passed during configuration. Clients should ensure
    /// that existing device keys are not reused as temporary key values for the
    /// new device to be added (for example, by using unique negative integers as
    /// temporary keys).
    /// 
    /// When editing or deleting a device, clients must use the server-provided key
    /// to refer to an existing device.
    fn get_key(&self) -> i32;
    /// Provides a label and summary information for the device.
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>>;
    /// Information about the backing of this virtual device presented
    /// in the context of the virtual machine's environment.
    /// 
    /// Not all devices are required to have backing information.
    /// 
    /// See also *VirtualMachineConfigOption*.
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>>;
    /// Provides information about restrictions on removing this device while
    /// a virtual machine is running.
    /// 
    /// If the device is not removable, then
    /// this property is null.
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo>;
    /// Information about the bus slot of a device in a virtual machine.
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>>;
    /// Object key for the controller object for this device.
    /// 
    /// This property contains the key property value of the controller device
    /// object.
    fn get_controller_key(&self) -> Option<i32>;
    /// The unit number of this device on its controller.
    /// 
    /// This property is null if
    /// the controller property is null (for example, when the device is not
    /// attached to a specific controller object).
    /// 
    /// Normally, two devices on the same controller
    /// may not be assigned the same unit number. If
    /// multiple devices could exist on a controller,
    /// then unit number has to be specified to
    /// configure respective devices.
    fn get_unit_number(&self) -> Option<i32>;
    /// The virtual NUMA node.
    /// 
    /// A negative number means there is no
    /// affinity for the device. A positive number is a vNUMA node.
    /// An unset value of numaNode is status-quo during Reconfigure time.
    /// If numaNode is unset during ConfigInfo, then it means there is no
    /// affinity for the device.
    /// 
    /// ***Since:*** vSphere API Release 8.0.0.1
    fn get_numa_node(&self) -> Option<i32>;
    /// Information about device group device is part of.
    /// 
    /// Devices in the device group cannot be added/removed individually,
    /// whole group has to be added/removed at once. Value can be set
    /// during device add, it cannot be modified later.
    /// 
    /// ***Since:*** vSphere API Release 8.0.0.1
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo>;
}
impl<'s> serde::Serialize for dyn VirtualDeviceTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDeviceTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDeviceVisitor)
            }
        }

struct VirtualDeviceVisitor;

impl<'de> de::Visitor<'de> for VirtualDeviceVisitor {
    type Value = Box<dyn VirtualDeviceTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDeviceTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDeviceTrait for VirtualDevice {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualCdrom {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualController {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualIdeController {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualNvdimmController {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualNvmeController {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualPciController {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualPs2Controller {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualSataController {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualAhciController {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualScsiController {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for ParaVirtualScsiController {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualBusLogicController {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualLsiLogicController {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualLsiLogicSasController {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualSioController {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualUsbController {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualUsbxhciController {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualDisk {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualEthernetCard {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualE1000 {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualE1000E {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualPcNet32 {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualSriovEthernetCard {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualVmxnet {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualVmxnet2 {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualVmxnet3 {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualVmxnet3Vrdma {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualFloppy {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualKeyboard {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualNvdimm {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualPciPassthrough {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualParallelPort {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualPointingDevice {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualPrecisionClock {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualScsiPassthrough {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualSerialPort {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualSoundCard {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualEnsoniq1371 {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualHdAudioCard {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualSoundBlaster16 {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualTpm {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualUsb {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualMachineVmciDevice {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualMachineVmirom {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualMachineVideoCard {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualWdt {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDeviceTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDevice => Some(from.as_any_ref().downcast_ref::<VirtualDevice>()?),
            StructType::VirtualCdrom => Some(from.as_any_ref().downcast_ref::<VirtualCdrom>()?),
            StructType::VirtualController => Some(from.as_any_ref().downcast_ref::<VirtualController>()?),
            StructType::VirtualIdeController => Some(from.as_any_ref().downcast_ref::<VirtualIdeController>()?),
            StructType::VirtualNvdimmController => Some(from.as_any_ref().downcast_ref::<VirtualNvdimmController>()?),
            StructType::VirtualNvmeController => Some(from.as_any_ref().downcast_ref::<VirtualNvmeController>()?),
            StructType::VirtualPciController => Some(from.as_any_ref().downcast_ref::<VirtualPciController>()?),
            StructType::VirtualPs2Controller => Some(from.as_any_ref().downcast_ref::<VirtualPs2Controller>()?),
            StructType::VirtualSataController => Some(from.as_any_ref().downcast_ref::<VirtualSataController>()?),
            StructType::VirtualAhciController => Some(from.as_any_ref().downcast_ref::<VirtualAhciController>()?),
            StructType::VirtualScsiController => Some(from.as_any_ref().downcast_ref::<VirtualScsiController>()?),
            StructType::ParaVirtualScsiController => Some(from.as_any_ref().downcast_ref::<ParaVirtualScsiController>()?),
            StructType::VirtualBusLogicController => Some(from.as_any_ref().downcast_ref::<VirtualBusLogicController>()?),
            StructType::VirtualLsiLogicController => Some(from.as_any_ref().downcast_ref::<VirtualLsiLogicController>()?),
            StructType::VirtualLsiLogicSasController => Some(from.as_any_ref().downcast_ref::<VirtualLsiLogicSasController>()?),
            StructType::VirtualSioController => Some(from.as_any_ref().downcast_ref::<VirtualSioController>()?),
            StructType::VirtualUsbController => Some(from.as_any_ref().downcast_ref::<VirtualUsbController>()?),
            StructType::VirtualUsbxhciController => Some(from.as_any_ref().downcast_ref::<VirtualUsbxhciController>()?),
            StructType::VirtualDisk => Some(from.as_any_ref().downcast_ref::<VirtualDisk>()?),
            StructType::VirtualEthernetCard => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCard>()?),
            StructType::VirtualE1000 => Some(from.as_any_ref().downcast_ref::<VirtualE1000>()?),
            StructType::VirtualE1000E => Some(from.as_any_ref().downcast_ref::<VirtualE1000E>()?),
            StructType::VirtualPcNet32 => Some(from.as_any_ref().downcast_ref::<VirtualPcNet32>()?),
            StructType::VirtualSriovEthernetCard => Some(from.as_any_ref().downcast_ref::<VirtualSriovEthernetCard>()?),
            StructType::VirtualVmxnet => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet>()?),
            StructType::VirtualVmxnet2 => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet2>()?),
            StructType::VirtualVmxnet3 => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3>()?),
            StructType::VirtualVmxnet3Vrdma => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3Vrdma>()?),
            StructType::VirtualFloppy => Some(from.as_any_ref().downcast_ref::<VirtualFloppy>()?),
            StructType::VirtualKeyboard => Some(from.as_any_ref().downcast_ref::<VirtualKeyboard>()?),
            StructType::VirtualNvdimm => Some(from.as_any_ref().downcast_ref::<VirtualNvdimm>()?),
            StructType::VirtualPciPassthrough => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthrough>()?),
            StructType::VirtualParallelPort => Some(from.as_any_ref().downcast_ref::<VirtualParallelPort>()?),
            StructType::VirtualPointingDevice => Some(from.as_any_ref().downcast_ref::<VirtualPointingDevice>()?),
            StructType::VirtualPrecisionClock => Some(from.as_any_ref().downcast_ref::<VirtualPrecisionClock>()?),
            StructType::VirtualScsiPassthrough => Some(from.as_any_ref().downcast_ref::<VirtualScsiPassthrough>()?),
            StructType::VirtualSerialPort => Some(from.as_any_ref().downcast_ref::<VirtualSerialPort>()?),
            StructType::VirtualSoundCard => Some(from.as_any_ref().downcast_ref::<VirtualSoundCard>()?),
            StructType::VirtualEnsoniq1371 => Some(from.as_any_ref().downcast_ref::<VirtualEnsoniq1371>()?),
            StructType::VirtualHdAudioCard => Some(from.as_any_ref().downcast_ref::<VirtualHdAudioCard>()?),
            StructType::VirtualSoundBlaster16 => Some(from.as_any_ref().downcast_ref::<VirtualSoundBlaster16>()?),
            StructType::VirtualTpm => Some(from.as_any_ref().downcast_ref::<VirtualTpm>()?),
            StructType::VirtualUsb => Some(from.as_any_ref().downcast_ref::<VirtualUsb>()?),
            StructType::VirtualMachineVmciDevice => Some(from.as_any_ref().downcast_ref::<VirtualMachineVmciDevice>()?),
            StructType::VirtualMachineVmirom => Some(from.as_any_ref().downcast_ref::<VirtualMachineVmirom>()?),
            StructType::VirtualMachineVideoCard => Some(from.as_any_ref().downcast_ref::<VirtualMachineVideoCard>()?),
            StructType::VirtualWdt => Some(from.as_any_ref().downcast_ref::<VirtualWdt>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDevice => Ok(from.as_any_box().downcast::<VirtualDevice>()?),
            StructType::VirtualCdrom => Ok(from.as_any_box().downcast::<VirtualCdrom>()?),
            StructType::VirtualController => Ok(from.as_any_box().downcast::<VirtualController>()?),
            StructType::VirtualIdeController => Ok(from.as_any_box().downcast::<VirtualIdeController>()?),
            StructType::VirtualNvdimmController => Ok(from.as_any_box().downcast::<VirtualNvdimmController>()?),
            StructType::VirtualNvmeController => Ok(from.as_any_box().downcast::<VirtualNvmeController>()?),
            StructType::VirtualPciController => Ok(from.as_any_box().downcast::<VirtualPciController>()?),
            StructType::VirtualPs2Controller => Ok(from.as_any_box().downcast::<VirtualPs2Controller>()?),
            StructType::VirtualSataController => Ok(from.as_any_box().downcast::<VirtualSataController>()?),
            StructType::VirtualAhciController => Ok(from.as_any_box().downcast::<VirtualAhciController>()?),
            StructType::VirtualScsiController => Ok(from.as_any_box().downcast::<VirtualScsiController>()?),
            StructType::ParaVirtualScsiController => Ok(from.as_any_box().downcast::<ParaVirtualScsiController>()?),
            StructType::VirtualBusLogicController => Ok(from.as_any_box().downcast::<VirtualBusLogicController>()?),
            StructType::VirtualLsiLogicController => Ok(from.as_any_box().downcast::<VirtualLsiLogicController>()?),
            StructType::VirtualLsiLogicSasController => Ok(from.as_any_box().downcast::<VirtualLsiLogicSasController>()?),
            StructType::VirtualSioController => Ok(from.as_any_box().downcast::<VirtualSioController>()?),
            StructType::VirtualUsbController => Ok(from.as_any_box().downcast::<VirtualUsbController>()?),
            StructType::VirtualUsbxhciController => Ok(from.as_any_box().downcast::<VirtualUsbxhciController>()?),
            StructType::VirtualDisk => Ok(from.as_any_box().downcast::<VirtualDisk>()?),
            StructType::VirtualEthernetCard => Ok(from.as_any_box().downcast::<VirtualEthernetCard>()?),
            StructType::VirtualE1000 => Ok(from.as_any_box().downcast::<VirtualE1000>()?),
            StructType::VirtualE1000E => Ok(from.as_any_box().downcast::<VirtualE1000E>()?),
            StructType::VirtualPcNet32 => Ok(from.as_any_box().downcast::<VirtualPcNet32>()?),
            StructType::VirtualSriovEthernetCard => Ok(from.as_any_box().downcast::<VirtualSriovEthernetCard>()?),
            StructType::VirtualVmxnet => Ok(from.as_any_box().downcast::<VirtualVmxnet>()?),
            StructType::VirtualVmxnet2 => Ok(from.as_any_box().downcast::<VirtualVmxnet2>()?),
            StructType::VirtualVmxnet3 => Ok(from.as_any_box().downcast::<VirtualVmxnet3>()?),
            StructType::VirtualVmxnet3Vrdma => Ok(from.as_any_box().downcast::<VirtualVmxnet3Vrdma>()?),
            StructType::VirtualFloppy => Ok(from.as_any_box().downcast::<VirtualFloppy>()?),
            StructType::VirtualKeyboard => Ok(from.as_any_box().downcast::<VirtualKeyboard>()?),
            StructType::VirtualNvdimm => Ok(from.as_any_box().downcast::<VirtualNvdimm>()?),
            StructType::VirtualPciPassthrough => Ok(from.as_any_box().downcast::<VirtualPciPassthrough>()?),
            StructType::VirtualParallelPort => Ok(from.as_any_box().downcast::<VirtualParallelPort>()?),
            StructType::VirtualPointingDevice => Ok(from.as_any_box().downcast::<VirtualPointingDevice>()?),
            StructType::VirtualPrecisionClock => Ok(from.as_any_box().downcast::<VirtualPrecisionClock>()?),
            StructType::VirtualScsiPassthrough => Ok(from.as_any_box().downcast::<VirtualScsiPassthrough>()?),
            StructType::VirtualSerialPort => Ok(from.as_any_box().downcast::<VirtualSerialPort>()?),
            StructType::VirtualSoundCard => Ok(from.as_any_box().downcast::<VirtualSoundCard>()?),
            StructType::VirtualEnsoniq1371 => Ok(from.as_any_box().downcast::<VirtualEnsoniq1371>()?),
            StructType::VirtualHdAudioCard => Ok(from.as_any_box().downcast::<VirtualHdAudioCard>()?),
            StructType::VirtualSoundBlaster16 => Ok(from.as_any_box().downcast::<VirtualSoundBlaster16>()?),
            StructType::VirtualTpm => Ok(from.as_any_box().downcast::<VirtualTpm>()?),
            StructType::VirtualUsb => Ok(from.as_any_box().downcast::<VirtualUsb>()?),
            StructType::VirtualMachineVmciDevice => Ok(from.as_any_box().downcast::<VirtualMachineVmciDevice>()?),
            StructType::VirtualMachineVmirom => Ok(from.as_any_box().downcast::<VirtualMachineVmirom>()?),
            StructType::VirtualMachineVideoCard => Ok(from.as_any_box().downcast::<VirtualMachineVideoCard>()?),
            StructType::VirtualWdt => Ok(from.as_any_box().downcast::<VirtualWdt>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// VirtualController is the base data object type for a device controller in
/// a virtual machine.
/// 
/// VirtualController extends
/// *VirtualDevice* to inherit
/// general information about a controller (such as name and description), and to allow
/// controllers to appear in a generic list of virtual devices.
pub trait VirtualControllerTrait : super::traits::VirtualDeviceTrait {
    /// Bus number associated with this controller.
    fn get_bus_number(&self) -> i32;
    /// List of devices currently controlled by this controller.
    /// 
    /// Each entry contains the *VirtualDevice.key* property of the
    /// corresponding device object.
    fn get_device(&self) -> &Option<Vec<i32>>;
}
impl<'s> serde::Serialize for dyn VirtualControllerTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualControllerTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualControllerVisitor)
            }
        }

struct VirtualControllerVisitor;

impl<'de> de::Visitor<'de> for VirtualControllerVisitor {
    type Value = Box<dyn VirtualControllerTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualControllerTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualControllerTrait for VirtualController {
    fn get_bus_number(&self) -> i32 { self.bus_number }
    fn get_device(&self) -> &Option<Vec<i32>> { &self.device }
}
impl VirtualControllerTrait for VirtualIdeController {
    fn get_bus_number(&self) -> i32 { self.bus_number }
    fn get_device(&self) -> &Option<Vec<i32>> { &self.device }
}
impl VirtualControllerTrait for VirtualNvdimmController {
    fn get_bus_number(&self) -> i32 { self.bus_number }
    fn get_device(&self) -> &Option<Vec<i32>> { &self.device }
}
impl VirtualControllerTrait for VirtualNvmeController {
    fn get_bus_number(&self) -> i32 { self.bus_number }
    fn get_device(&self) -> &Option<Vec<i32>> { &self.device }
}
impl VirtualControllerTrait for VirtualPciController {
    fn get_bus_number(&self) -> i32 { self.bus_number }
    fn get_device(&self) -> &Option<Vec<i32>> { &self.device }
}
impl VirtualControllerTrait for VirtualPs2Controller {
    fn get_bus_number(&self) -> i32 { self.bus_number }
    fn get_device(&self) -> &Option<Vec<i32>> { &self.device }
}
impl VirtualControllerTrait for VirtualSataController {
    fn get_bus_number(&self) -> i32 { self.bus_number }
    fn get_device(&self) -> &Option<Vec<i32>> { &self.device }
}
impl VirtualControllerTrait for VirtualAhciController {
    fn get_bus_number(&self) -> i32 { self.bus_number }
    fn get_device(&self) -> &Option<Vec<i32>> { &self.device }
}
impl VirtualControllerTrait for VirtualScsiController {
    fn get_bus_number(&self) -> i32 { self.bus_number }
    fn get_device(&self) -> &Option<Vec<i32>> { &self.device }
}
impl VirtualControllerTrait for ParaVirtualScsiController {
    fn get_bus_number(&self) -> i32 { self.bus_number }
    fn get_device(&self) -> &Option<Vec<i32>> { &self.device }
}
impl VirtualControllerTrait for VirtualBusLogicController {
    fn get_bus_number(&self) -> i32 { self.bus_number }
    fn get_device(&self) -> &Option<Vec<i32>> { &self.device }
}
impl VirtualControllerTrait for VirtualLsiLogicController {
    fn get_bus_number(&self) -> i32 { self.bus_number }
    fn get_device(&self) -> &Option<Vec<i32>> { &self.device }
}
impl VirtualControllerTrait for VirtualLsiLogicSasController {
    fn get_bus_number(&self) -> i32 { self.bus_number }
    fn get_device(&self) -> &Option<Vec<i32>> { &self.device }
}
impl VirtualControllerTrait for VirtualSioController {
    fn get_bus_number(&self) -> i32 { self.bus_number }
    fn get_device(&self) -> &Option<Vec<i32>> { &self.device }
}
impl VirtualControllerTrait for VirtualUsbController {
    fn get_bus_number(&self) -> i32 { self.bus_number }
    fn get_device(&self) -> &Option<Vec<i32>> { &self.device }
}
impl VirtualControllerTrait for VirtualUsbxhciController {
    fn get_bus_number(&self) -> i32 { self.bus_number }
    fn get_device(&self) -> &Option<Vec<i32>> { &self.device }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualControllerTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualController => Some(from.as_any_ref().downcast_ref::<VirtualController>()?),
            StructType::VirtualIdeController => Some(from.as_any_ref().downcast_ref::<VirtualIdeController>()?),
            StructType::VirtualNvdimmController => Some(from.as_any_ref().downcast_ref::<VirtualNvdimmController>()?),
            StructType::VirtualNvmeController => Some(from.as_any_ref().downcast_ref::<VirtualNvmeController>()?),
            StructType::VirtualPciController => Some(from.as_any_ref().downcast_ref::<VirtualPciController>()?),
            StructType::VirtualPs2Controller => Some(from.as_any_ref().downcast_ref::<VirtualPs2Controller>()?),
            StructType::VirtualSataController => Some(from.as_any_ref().downcast_ref::<VirtualSataController>()?),
            StructType::VirtualAhciController => Some(from.as_any_ref().downcast_ref::<VirtualAhciController>()?),
            StructType::VirtualScsiController => Some(from.as_any_ref().downcast_ref::<VirtualScsiController>()?),
            StructType::ParaVirtualScsiController => Some(from.as_any_ref().downcast_ref::<ParaVirtualScsiController>()?),
            StructType::VirtualBusLogicController => Some(from.as_any_ref().downcast_ref::<VirtualBusLogicController>()?),
            StructType::VirtualLsiLogicController => Some(from.as_any_ref().downcast_ref::<VirtualLsiLogicController>()?),
            StructType::VirtualLsiLogicSasController => Some(from.as_any_ref().downcast_ref::<VirtualLsiLogicSasController>()?),
            StructType::VirtualSioController => Some(from.as_any_ref().downcast_ref::<VirtualSioController>()?),
            StructType::VirtualUsbController => Some(from.as_any_ref().downcast_ref::<VirtualUsbController>()?),
            StructType::VirtualUsbxhciController => Some(from.as_any_ref().downcast_ref::<VirtualUsbxhciController>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualController => Ok(from.as_any_box().downcast::<VirtualController>()?),
            StructType::VirtualIdeController => Ok(from.as_any_box().downcast::<VirtualIdeController>()?),
            StructType::VirtualNvdimmController => Ok(from.as_any_box().downcast::<VirtualNvdimmController>()?),
            StructType::VirtualNvmeController => Ok(from.as_any_box().downcast::<VirtualNvmeController>()?),
            StructType::VirtualPciController => Ok(from.as_any_box().downcast::<VirtualPciController>()?),
            StructType::VirtualPs2Controller => Ok(from.as_any_box().downcast::<VirtualPs2Controller>()?),
            StructType::VirtualSataController => Ok(from.as_any_box().downcast::<VirtualSataController>()?),
            StructType::VirtualAhciController => Ok(from.as_any_box().downcast::<VirtualAhciController>()?),
            StructType::VirtualScsiController => Ok(from.as_any_box().downcast::<VirtualScsiController>()?),
            StructType::ParaVirtualScsiController => Ok(from.as_any_box().downcast::<ParaVirtualScsiController>()?),
            StructType::VirtualBusLogicController => Ok(from.as_any_box().downcast::<VirtualBusLogicController>()?),
            StructType::VirtualLsiLogicController => Ok(from.as_any_box().downcast::<VirtualLsiLogicController>()?),
            StructType::VirtualLsiLogicSasController => Ok(from.as_any_box().downcast::<VirtualLsiLogicSasController>()?),
            StructType::VirtualSioController => Ok(from.as_any_box().downcast::<VirtualSioController>()?),
            StructType::VirtualUsbController => Ok(from.as_any_box().downcast::<VirtualUsbController>()?),
            StructType::VirtualUsbxhciController => Ok(from.as_any_box().downcast::<VirtualUsbxhciController>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The VirtualSATAController data object type represents
/// a SATA controller in a virtual machine.
pub trait VirtualSataControllerTrait : super::traits::VirtualControllerTrait {
}
impl<'s> serde::Serialize for dyn VirtualSataControllerTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualSataControllerTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualSataControllerVisitor)
            }
        }

struct VirtualSataControllerVisitor;

impl<'de> de::Visitor<'de> for VirtualSataControllerVisitor {
    type Value = Box<dyn VirtualSataControllerTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualSataControllerTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualSataControllerTrait for VirtualSataController {
}
impl VirtualSataControllerTrait for VirtualAhciController {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualSataControllerTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualSataController => Some(from.as_any_ref().downcast_ref::<VirtualSataController>()?),
            StructType::VirtualAhciController => Some(from.as_any_ref().downcast_ref::<VirtualAhciController>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualSataController => Ok(from.as_any_box().downcast::<VirtualSataController>()?),
            StructType::VirtualAhciController => Ok(from.as_any_box().downcast::<VirtualAhciController>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The VirtualSCSIController data object type represents
/// a SCSI controller in a virtual machine.
pub trait VirtualScsiControllerTrait : super::traits::VirtualControllerTrait {
    /// All SCSI controllers support hot adding and removing of devices.
    /// 
    /// This
    /// support can't be toggled in the current implementation. Therefore, this
    /// option is ignored when reconfiguring a SCSI controller and is always set
    /// to "true" when reading an existing configuration.
    fn get_hot_add_remove(&self) -> Option<bool>;
    /// Mode for sharing the SCSI bus.
    /// 
    /// The modes are physicalSharing,
    /// virtualSharing, and noSharing. See the
    /// *Sharing*
    /// data object type for an explanation of these modes.
    fn get_shared_bus(&self) -> &super::enums::VirtualScsiSharingEnum;
    /// The unit number of the SCSI controller.
    /// 
    /// The SCSI controller sits on its
    /// own bus, so this field defines which slot the controller is using.
    fn get_scsi_ctlr_unit_number(&self) -> Option<i32>;
}
impl<'s> serde::Serialize for dyn VirtualScsiControllerTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualScsiControllerTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualScsiControllerVisitor)
            }
        }

struct VirtualScsiControllerVisitor;

impl<'de> de::Visitor<'de> for VirtualScsiControllerVisitor {
    type Value = Box<dyn VirtualScsiControllerTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualScsiControllerTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualScsiControllerTrait for VirtualScsiController {
    fn get_hot_add_remove(&self) -> Option<bool> { self.hot_add_remove }
    fn get_shared_bus(&self) -> &super::enums::VirtualScsiSharingEnum { &self.shared_bus }
    fn get_scsi_ctlr_unit_number(&self) -> Option<i32> { self.scsi_ctlr_unit_number }
}
impl VirtualScsiControllerTrait for ParaVirtualScsiController {
    fn get_hot_add_remove(&self) -> Option<bool> { self.hot_add_remove }
    fn get_shared_bus(&self) -> &super::enums::VirtualScsiSharingEnum { &self.shared_bus }
    fn get_scsi_ctlr_unit_number(&self) -> Option<i32> { self.scsi_ctlr_unit_number }
}
impl VirtualScsiControllerTrait for VirtualBusLogicController {
    fn get_hot_add_remove(&self) -> Option<bool> { self.hot_add_remove }
    fn get_shared_bus(&self) -> &super::enums::VirtualScsiSharingEnum { &self.shared_bus }
    fn get_scsi_ctlr_unit_number(&self) -> Option<i32> { self.scsi_ctlr_unit_number }
}
impl VirtualScsiControllerTrait for VirtualLsiLogicController {
    fn get_hot_add_remove(&self) -> Option<bool> { self.hot_add_remove }
    fn get_shared_bus(&self) -> &super::enums::VirtualScsiSharingEnum { &self.shared_bus }
    fn get_scsi_ctlr_unit_number(&self) -> Option<i32> { self.scsi_ctlr_unit_number }
}
impl VirtualScsiControllerTrait for VirtualLsiLogicSasController {
    fn get_hot_add_remove(&self) -> Option<bool> { self.hot_add_remove }
    fn get_shared_bus(&self) -> &super::enums::VirtualScsiSharingEnum { &self.shared_bus }
    fn get_scsi_ctlr_unit_number(&self) -> Option<i32> { self.scsi_ctlr_unit_number }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualScsiControllerTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualScsiController => Some(from.as_any_ref().downcast_ref::<VirtualScsiController>()?),
            StructType::ParaVirtualScsiController => Some(from.as_any_ref().downcast_ref::<ParaVirtualScsiController>()?),
            StructType::VirtualBusLogicController => Some(from.as_any_ref().downcast_ref::<VirtualBusLogicController>()?),
            StructType::VirtualLsiLogicController => Some(from.as_any_ref().downcast_ref::<VirtualLsiLogicController>()?),
            StructType::VirtualLsiLogicSasController => Some(from.as_any_ref().downcast_ref::<VirtualLsiLogicSasController>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualScsiController => Ok(from.as_any_box().downcast::<VirtualScsiController>()?),
            StructType::ParaVirtualScsiController => Ok(from.as_any_box().downcast::<ParaVirtualScsiController>()?),
            StructType::VirtualBusLogicController => Ok(from.as_any_box().downcast::<VirtualBusLogicController>()?),
            StructType::VirtualLsiLogicController => Ok(from.as_any_box().downcast::<VirtualLsiLogicController>()?),
            StructType::VirtualLsiLogicSasController => Ok(from.as_any_box().downcast::<VirtualLsiLogicSasController>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *VirtualEthernetCard* data object contains the properties
/// of an Ethernet adapter attached to a virtual machine.
pub trait VirtualEthernetCardTrait : super::traits::VirtualDeviceTrait {
    /// Set of dynamic properties.
    /// 
    /// This property is optional because only the
    /// properties of an object that are unknown to a client will be part of this set.
    /// This property is not readonly just in case we want to send such properties
    /// from a client in the future.
    fn get_dynamic_property(&self) -> &Option<Vec<DynamicProperty>>;
    /// MAC address type.
    /// 
    /// Valid values for address type are:
    /// <dl>
    /// <dt>Manual</dt>
    /// <dd>Statically assigned MAC address.</dd>
    /// <dt>Generated</dt>
    /// <dd>Automatically generated MAC address.</dd>
    /// <dt>Assigned</dt>
    /// <dd>MAC address assigned by VirtualCenter.</dd>
    /// </dl>
    fn get_address_type(&self) -> &Option<String>;
    /// MAC address assigned to the virtual network adapter.
    /// 
    /// Clients can
    /// set this property to any of the allowed address types. The server might
    /// override the specified value for "Generated" or "Assigned" if it does not
    /// fall in the right ranges or is determined to be a duplicate.
    fn get_mac_address(&self) -> &Option<String>;
    /// Indicates whether wake-on-LAN is enabled on this virtual network adapter.
    /// 
    /// Clients
    /// can set this property to selectively enable or disable wake-on-LAN.
    fn get_wake_on_lan_enabled(&self) -> Option<bool>;
    /// Resource requirements of the virtual network adapter
    fn get_resource_allocation(&self) -> &Option<VirtualEthernetCardResourceAllocation>;
    /// An ID assigned to the virtual network adapter by external management plane or
    /// controller.
    /// 
    /// The value and format of this property is determined by external
    /// management plane or controller, and vSphere doesn't do any validation. It's
    /// also up to external management plane or controller to set, unset or maintain
    /// this property. Setting this property with an empty string value will unset the
    /// property.
    fn get_external_id(&self) -> &Option<String>;
    /// Deprecated as of vSphere API 8.0. VMDirectPath Gen 2 is no longer supported and
    /// there is no replacement.
    /// 
    /// Indicates whether UPT(Universal Pass-through) compatibility is enabled
    /// on this network adapter.
    /// 
    /// UPT is only compatible for Vmxnet3 adapter.
    /// Clients can set this property enabled or disabled if ethernet
    /// virtual device is Vmxnet3.
    fn get_upt_compatibility_enabled(&self) -> Option<bool>;
}
impl<'s> serde::Serialize for dyn VirtualEthernetCardTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualEthernetCardTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualEthernetCardVisitor)
            }
        }

struct VirtualEthernetCardVisitor;

impl<'de> de::Visitor<'de> for VirtualEthernetCardVisitor {
    type Value = Box<dyn VirtualEthernetCardTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualEthernetCardTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualEthernetCardTrait for VirtualEthernetCard {
    fn get_dynamic_property(&self) -> &Option<Vec<DynamicProperty>> { &self.dynamic_property }
    fn get_address_type(&self) -> &Option<String> { &self.address_type }
    fn get_mac_address(&self) -> &Option<String> { &self.mac_address }
    fn get_wake_on_lan_enabled(&self) -> Option<bool> { self.wake_on_lan_enabled }
    fn get_resource_allocation(&self) -> &Option<VirtualEthernetCardResourceAllocation> { &self.resource_allocation }
    fn get_external_id(&self) -> &Option<String> { &self.external_id }
    fn get_upt_compatibility_enabled(&self) -> Option<bool> { self.upt_compatibility_enabled }
}
impl VirtualEthernetCardTrait for VirtualE1000 {
    fn get_dynamic_property(&self) -> &Option<Vec<DynamicProperty>> { &self.dynamic_property }
    fn get_address_type(&self) -> &Option<String> { &self.address_type }
    fn get_mac_address(&self) -> &Option<String> { &self.mac_address }
    fn get_wake_on_lan_enabled(&self) -> Option<bool> { self.wake_on_lan_enabled }
    fn get_resource_allocation(&self) -> &Option<VirtualEthernetCardResourceAllocation> { &self.resource_allocation }
    fn get_external_id(&self) -> &Option<String> { &self.external_id }
    fn get_upt_compatibility_enabled(&self) -> Option<bool> { self.upt_compatibility_enabled }
}
impl VirtualEthernetCardTrait for VirtualE1000E {
    fn get_dynamic_property(&self) -> &Option<Vec<DynamicProperty>> { &self.dynamic_property }
    fn get_address_type(&self) -> &Option<String> { &self.address_type }
    fn get_mac_address(&self) -> &Option<String> { &self.mac_address }
    fn get_wake_on_lan_enabled(&self) -> Option<bool> { self.wake_on_lan_enabled }
    fn get_resource_allocation(&self) -> &Option<VirtualEthernetCardResourceAllocation> { &self.resource_allocation }
    fn get_external_id(&self) -> &Option<String> { &self.external_id }
    fn get_upt_compatibility_enabled(&self) -> Option<bool> { self.upt_compatibility_enabled }
}
impl VirtualEthernetCardTrait for VirtualPcNet32 {
    fn get_dynamic_property(&self) -> &Option<Vec<DynamicProperty>> { &self.dynamic_property }
    fn get_address_type(&self) -> &Option<String> { &self.address_type }
    fn get_mac_address(&self) -> &Option<String> { &self.mac_address }
    fn get_wake_on_lan_enabled(&self) -> Option<bool> { self.wake_on_lan_enabled }
    fn get_resource_allocation(&self) -> &Option<VirtualEthernetCardResourceAllocation> { &self.resource_allocation }
    fn get_external_id(&self) -> &Option<String> { &self.external_id }
    fn get_upt_compatibility_enabled(&self) -> Option<bool> { self.upt_compatibility_enabled }
}
impl VirtualEthernetCardTrait for VirtualSriovEthernetCard {
    fn get_dynamic_property(&self) -> &Option<Vec<DynamicProperty>> { &self.dynamic_property }
    fn get_address_type(&self) -> &Option<String> { &self.address_type }
    fn get_mac_address(&self) -> &Option<String> { &self.mac_address }
    fn get_wake_on_lan_enabled(&self) -> Option<bool> { self.wake_on_lan_enabled }
    fn get_resource_allocation(&self) -> &Option<VirtualEthernetCardResourceAllocation> { &self.resource_allocation }
    fn get_external_id(&self) -> &Option<String> { &self.external_id }
    fn get_upt_compatibility_enabled(&self) -> Option<bool> { self.upt_compatibility_enabled }
}
impl VirtualEthernetCardTrait for VirtualVmxnet {
    fn get_dynamic_property(&self) -> &Option<Vec<DynamicProperty>> { &self.dynamic_property }
    fn get_address_type(&self) -> &Option<String> { &self.address_type }
    fn get_mac_address(&self) -> &Option<String> { &self.mac_address }
    fn get_wake_on_lan_enabled(&self) -> Option<bool> { self.wake_on_lan_enabled }
    fn get_resource_allocation(&self) -> &Option<VirtualEthernetCardResourceAllocation> { &self.resource_allocation }
    fn get_external_id(&self) -> &Option<String> { &self.external_id }
    fn get_upt_compatibility_enabled(&self) -> Option<bool> { self.upt_compatibility_enabled }
}
impl VirtualEthernetCardTrait for VirtualVmxnet2 {
    fn get_dynamic_property(&self) -> &Option<Vec<DynamicProperty>> { &self.dynamic_property }
    fn get_address_type(&self) -> &Option<String> { &self.address_type }
    fn get_mac_address(&self) -> &Option<String> { &self.mac_address }
    fn get_wake_on_lan_enabled(&self) -> Option<bool> { self.wake_on_lan_enabled }
    fn get_resource_allocation(&self) -> &Option<VirtualEthernetCardResourceAllocation> { &self.resource_allocation }
    fn get_external_id(&self) -> &Option<String> { &self.external_id }
    fn get_upt_compatibility_enabled(&self) -> Option<bool> { self.upt_compatibility_enabled }
}
impl VirtualEthernetCardTrait for VirtualVmxnet3 {
    fn get_dynamic_property(&self) -> &Option<Vec<DynamicProperty>> { &self.dynamic_property }
    fn get_address_type(&self) -> &Option<String> { &self.address_type }
    fn get_mac_address(&self) -> &Option<String> { &self.mac_address }
    fn get_wake_on_lan_enabled(&self) -> Option<bool> { self.wake_on_lan_enabled }
    fn get_resource_allocation(&self) -> &Option<VirtualEthernetCardResourceAllocation> { &self.resource_allocation }
    fn get_external_id(&self) -> &Option<String> { &self.external_id }
    fn get_upt_compatibility_enabled(&self) -> Option<bool> { self.upt_compatibility_enabled }
}
impl VirtualEthernetCardTrait for VirtualVmxnet3Vrdma {
    fn get_dynamic_property(&self) -> &Option<Vec<DynamicProperty>> { &self.dynamic_property }
    fn get_address_type(&self) -> &Option<String> { &self.address_type }
    fn get_mac_address(&self) -> &Option<String> { &self.mac_address }
    fn get_wake_on_lan_enabled(&self) -> Option<bool> { self.wake_on_lan_enabled }
    fn get_resource_allocation(&self) -> &Option<VirtualEthernetCardResourceAllocation> { &self.resource_allocation }
    fn get_external_id(&self) -> &Option<String> { &self.external_id }
    fn get_upt_compatibility_enabled(&self) -> Option<bool> { self.upt_compatibility_enabled }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualEthernetCardTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualEthernetCard => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCard>()?),
            StructType::VirtualE1000 => Some(from.as_any_ref().downcast_ref::<VirtualE1000>()?),
            StructType::VirtualE1000E => Some(from.as_any_ref().downcast_ref::<VirtualE1000E>()?),
            StructType::VirtualPcNet32 => Some(from.as_any_ref().downcast_ref::<VirtualPcNet32>()?),
            StructType::VirtualSriovEthernetCard => Some(from.as_any_ref().downcast_ref::<VirtualSriovEthernetCard>()?),
            StructType::VirtualVmxnet => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet>()?),
            StructType::VirtualVmxnet2 => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet2>()?),
            StructType::VirtualVmxnet3 => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3>()?),
            StructType::VirtualVmxnet3Vrdma => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3Vrdma>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualEthernetCard => Ok(from.as_any_box().downcast::<VirtualEthernetCard>()?),
            StructType::VirtualE1000 => Ok(from.as_any_box().downcast::<VirtualE1000>()?),
            StructType::VirtualE1000E => Ok(from.as_any_box().downcast::<VirtualE1000E>()?),
            StructType::VirtualPcNet32 => Ok(from.as_any_box().downcast::<VirtualPcNet32>()?),
            StructType::VirtualSriovEthernetCard => Ok(from.as_any_box().downcast::<VirtualSriovEthernetCard>()?),
            StructType::VirtualVmxnet => Ok(from.as_any_box().downcast::<VirtualVmxnet>()?),
            StructType::VirtualVmxnet2 => Ok(from.as_any_box().downcast::<VirtualVmxnet2>()?),
            StructType::VirtualVmxnet3 => Ok(from.as_any_box().downcast::<VirtualVmxnet3>()?),
            StructType::VirtualVmxnet3Vrdma => Ok(from.as_any_box().downcast::<VirtualVmxnet3Vrdma>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The VirtualVmxnet data object type represents an instance
/// of the Vmxnet virtual Ethernet adapter attached to a virtual machine.
pub trait VirtualVmxnetTrait : super::traits::VirtualEthernetCardTrait {
}
impl<'s> serde::Serialize for dyn VirtualVmxnetTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualVmxnetTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualVmxnetVisitor)
            }
        }

struct VirtualVmxnetVisitor;

impl<'de> de::Visitor<'de> for VirtualVmxnetVisitor {
    type Value = Box<dyn VirtualVmxnetTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualVmxnetTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualVmxnetTrait for VirtualVmxnet {
}
impl VirtualVmxnetTrait for VirtualVmxnet2 {
}
impl VirtualVmxnetTrait for VirtualVmxnet3 {
}
impl VirtualVmxnetTrait for VirtualVmxnet3Vrdma {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualVmxnetTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualVmxnet => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet>()?),
            StructType::VirtualVmxnet2 => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet2>()?),
            StructType::VirtualVmxnet3 => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3>()?),
            StructType::VirtualVmxnet3Vrdma => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3Vrdma>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualVmxnet => Ok(from.as_any_box().downcast::<VirtualVmxnet>()?),
            StructType::VirtualVmxnet2 => Ok(from.as_any_box().downcast::<VirtualVmxnet2>()?),
            StructType::VirtualVmxnet3 => Ok(from.as_any_box().downcast::<VirtualVmxnet3>()?),
            StructType::VirtualVmxnet3Vrdma => Ok(from.as_any_box().downcast::<VirtualVmxnet3Vrdma>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The VirtualVmxnet3 data object type represents an instance
/// of the Vmxnet3 virtual Ethernet adapter attached to a virtual machine.
pub trait VirtualVmxnet3Trait : super::traits::VirtualVmxnetTrait {
    /// Indicates whether UPTv2(Uniform Pass-through version 2) compatibility is
    /// enabled on this network adapter.
    /// 
    /// UPTv2 is only available on Vmxnet3
    /// adapter. Clients can set this property enabled or disabled if ethernet
    /// virtual device is Vmxnet3. It requires the VM hardware version is
    /// compatible with ESXi version which has enabled smartnic feature.
    /// 
    /// ***Since:*** vSphere API Release 8.0.0.1
    fn get_uptv_2_enabled(&self) -> Option<bool>;
}
impl<'s> serde::Serialize for dyn VirtualVmxnet3Trait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualVmxnet3Trait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualVmxnet3Visitor)
            }
        }

struct VirtualVmxnet3Visitor;

impl<'de> de::Visitor<'de> for VirtualVmxnet3Visitor {
    type Value = Box<dyn VirtualVmxnet3Trait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualVmxnet3Trait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualVmxnet3Trait for VirtualVmxnet3 {
    fn get_uptv_2_enabled(&self) -> Option<bool> { self.uptv_2_enabled }
}
impl VirtualVmxnet3Trait for VirtualVmxnet3Vrdma {
    fn get_uptv_2_enabled(&self) -> Option<bool> { self.uptv_2_enabled }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualVmxnet3Trait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualVmxnet3 => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3>()?),
            StructType::VirtualVmxnet3Vrdma => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3Vrdma>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualVmxnet3 => Ok(from.as_any_box().downcast::<VirtualVmxnet3>()?),
            StructType::VirtualVmxnet3Vrdma => Ok(from.as_any_box().downcast::<VirtualVmxnet3Vrdma>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type represents a sound card in
/// a virtual machine.
pub trait VirtualSoundCardTrait : super::traits::VirtualDeviceTrait {
}
impl<'s> serde::Serialize for dyn VirtualSoundCardTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualSoundCardTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualSoundCardVisitor)
            }
        }

struct VirtualSoundCardVisitor;

impl<'de> de::Visitor<'de> for VirtualSoundCardVisitor {
    type Value = Box<dyn VirtualSoundCardTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualSoundCardTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualSoundCardTrait for VirtualSoundCard {
}
impl VirtualSoundCardTrait for VirtualEnsoniq1371 {
}
impl VirtualSoundCardTrait for VirtualHdAudioCard {
}
impl VirtualSoundCardTrait for VirtualSoundBlaster16 {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualSoundCardTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualSoundCard => Some(from.as_any_ref().downcast_ref::<VirtualSoundCard>()?),
            StructType::VirtualEnsoniq1371 => Some(from.as_any_ref().downcast_ref::<VirtualEnsoniq1371>()?),
            StructType::VirtualHdAudioCard => Some(from.as_any_ref().downcast_ref::<VirtualHdAudioCard>()?),
            StructType::VirtualSoundBlaster16 => Some(from.as_any_ref().downcast_ref::<VirtualSoundBlaster16>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualSoundCard => Ok(from.as_any_box().downcast::<VirtualSoundCard>()?),
            StructType::VirtualEnsoniq1371 => Ok(from.as_any_box().downcast::<VirtualEnsoniq1371>()?),
            StructType::VirtualHdAudioCard => Ok(from.as_any_box().downcast::<VirtualHdAudioCard>()?),
            StructType::VirtualSoundBlaster16 => Ok(from.as_any_box().downcast::<VirtualSoundBlaster16>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// <code>*VirtualDeviceBackingInfo*</code> is a base data object type
/// for information about the backing of a device in a virtual machine.
/// 
/// This base type does not define any properties. It is used as a namespace
/// for general-purpose subtypes. Specific devices are represented by subtypes
/// which define properties for device-specific backing information.
pub trait VirtualDeviceBackingInfoTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn VirtualDeviceBackingInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDeviceBackingInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDeviceBackingInfoVisitor)
            }
        }

struct VirtualDeviceBackingInfoVisitor;

impl<'de> de::Visitor<'de> for VirtualDeviceBackingInfoVisitor {
    type Value = Box<dyn VirtualDeviceBackingInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDeviceBackingInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDeviceBackingInfoTrait for VirtualDeviceBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualDeviceDeviceBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualCdromAtapiBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualCdromPassthroughBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualDiskRawDiskVer2BackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualDiskPartitionedRawDiskVer2BackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualEthernetCardLegacyNetworkBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualEthernetCardNetworkBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualFloppyDeviceBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualPciPassthroughDeviceBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualPciPassthroughDynamicBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualParallelPortDeviceBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualPointingDeviceDeviceBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualScsiPassthroughDeviceBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualSerialPortDeviceBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualSoundCardDeviceBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualUsbRemoteHostBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualUsbusbBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualDeviceFileBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualCdromIsoBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualDiskFlatVer1BackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualDiskFlatVer2BackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualDiskLocalPMemBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualDiskRawDiskMappingVer1BackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualDiskSeSparseBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualDiskSparseVer1BackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualDiskSparseVer2BackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualFloppyImageBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualNvdimmBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualParallelPortFileBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualSerialPortFileBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualDevicePipeBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualSerialPortPipeBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualDeviceRemoteDeviceBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualCdromRemoteAtapiBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualCdromRemotePassthroughBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualFloppyRemoteDeviceBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualUsbRemoteClientBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualDeviceUriBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualSerialPortUriBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualEthernetCardDistributedVirtualPortBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualEthernetCardOpaqueNetworkBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualPciPassthroughDvxBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualPciPassthroughPluginBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualPciPassthroughVmiopBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualPrecisionClockSystemClockBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualSerialPortThinPrintBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualSriovEthernetCardSriovBackingInfo {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDeviceBackingInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDeviceBackingInfo>()?),
            StructType::VirtualDeviceDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDeviceDeviceBackingInfo>()?),
            StructType::VirtualCdromAtapiBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualCdromAtapiBackingInfo>()?),
            StructType::VirtualCdromPassthroughBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualCdromPassthroughBackingInfo>()?),
            StructType::VirtualDiskRawDiskVer2BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskRawDiskVer2BackingInfo>()?),
            StructType::VirtualDiskPartitionedRawDiskVer2BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskPartitionedRawDiskVer2BackingInfo>()?),
            StructType::VirtualEthernetCardLegacyNetworkBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardLegacyNetworkBackingInfo>()?),
            StructType::VirtualEthernetCardNetworkBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardNetworkBackingInfo>()?),
            StructType::VirtualFloppyDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualFloppyDeviceBackingInfo>()?),
            StructType::VirtualPciPassthroughDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughDeviceBackingInfo>()?),
            StructType::VirtualPciPassthroughDynamicBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughDynamicBackingInfo>()?),
            StructType::VirtualParallelPortDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualParallelPortDeviceBackingInfo>()?),
            StructType::VirtualPointingDeviceDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPointingDeviceDeviceBackingInfo>()?),
            StructType::VirtualScsiPassthroughDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualScsiPassthroughDeviceBackingInfo>()?),
            StructType::VirtualSerialPortDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortDeviceBackingInfo>()?),
            StructType::VirtualSoundCardDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSoundCardDeviceBackingInfo>()?),
            StructType::VirtualUsbRemoteHostBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualUsbRemoteHostBackingInfo>()?),
            StructType::VirtualUsbusbBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualUsbusbBackingInfo>()?),
            StructType::VirtualDeviceFileBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDeviceFileBackingInfo>()?),
            StructType::VirtualCdromIsoBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualCdromIsoBackingInfo>()?),
            StructType::VirtualDiskFlatVer1BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskFlatVer1BackingInfo>()?),
            StructType::VirtualDiskFlatVer2BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskFlatVer2BackingInfo>()?),
            StructType::VirtualDiskLocalPMemBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskLocalPMemBackingInfo>()?),
            StructType::VirtualDiskRawDiskMappingVer1BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskRawDiskMappingVer1BackingInfo>()?),
            StructType::VirtualDiskSeSparseBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskSeSparseBackingInfo>()?),
            StructType::VirtualDiskSparseVer1BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskSparseVer1BackingInfo>()?),
            StructType::VirtualDiskSparseVer2BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskSparseVer2BackingInfo>()?),
            StructType::VirtualFloppyImageBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualFloppyImageBackingInfo>()?),
            StructType::VirtualNvdimmBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualNvdimmBackingInfo>()?),
            StructType::VirtualParallelPortFileBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualParallelPortFileBackingInfo>()?),
            StructType::VirtualSerialPortFileBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortFileBackingInfo>()?),
            StructType::VirtualDevicePipeBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDevicePipeBackingInfo>()?),
            StructType::VirtualSerialPortPipeBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortPipeBackingInfo>()?),
            StructType::VirtualDeviceRemoteDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDeviceRemoteDeviceBackingInfo>()?),
            StructType::VirtualCdromRemoteAtapiBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualCdromRemoteAtapiBackingInfo>()?),
            StructType::VirtualCdromRemotePassthroughBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualCdromRemotePassthroughBackingInfo>()?),
            StructType::VirtualFloppyRemoteDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualFloppyRemoteDeviceBackingInfo>()?),
            StructType::VirtualUsbRemoteClientBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualUsbRemoteClientBackingInfo>()?),
            StructType::VirtualDeviceUriBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDeviceUriBackingInfo>()?),
            StructType::VirtualSerialPortUriBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortUriBackingInfo>()?),
            StructType::VirtualEthernetCardDistributedVirtualPortBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardDistributedVirtualPortBackingInfo>()?),
            StructType::VirtualEthernetCardOpaqueNetworkBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardOpaqueNetworkBackingInfo>()?),
            StructType::VirtualPciPassthroughDvxBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughDvxBackingInfo>()?),
            StructType::VirtualPciPassthroughPluginBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughPluginBackingInfo>()?),
            StructType::VirtualPciPassthroughVmiopBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughVmiopBackingInfo>()?),
            StructType::VirtualPrecisionClockSystemClockBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPrecisionClockSystemClockBackingInfo>()?),
            StructType::VirtualSerialPortThinPrintBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortThinPrintBackingInfo>()?),
            StructType::VirtualSriovEthernetCardSriovBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSriovEthernetCardSriovBackingInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualDeviceBackingInfo>()?),
            StructType::VirtualDeviceDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualDeviceDeviceBackingInfo>()?),
            StructType::VirtualCdromAtapiBackingInfo => Ok(from.as_any_box().downcast::<VirtualCdromAtapiBackingInfo>()?),
            StructType::VirtualCdromPassthroughBackingInfo => Ok(from.as_any_box().downcast::<VirtualCdromPassthroughBackingInfo>()?),
            StructType::VirtualDiskRawDiskVer2BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskRawDiskVer2BackingInfo>()?),
            StructType::VirtualDiskPartitionedRawDiskVer2BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskPartitionedRawDiskVer2BackingInfo>()?),
            StructType::VirtualEthernetCardLegacyNetworkBackingInfo => Ok(from.as_any_box().downcast::<VirtualEthernetCardLegacyNetworkBackingInfo>()?),
            StructType::VirtualEthernetCardNetworkBackingInfo => Ok(from.as_any_box().downcast::<VirtualEthernetCardNetworkBackingInfo>()?),
            StructType::VirtualFloppyDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualFloppyDeviceBackingInfo>()?),
            StructType::VirtualPciPassthroughDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualPciPassthroughDeviceBackingInfo>()?),
            StructType::VirtualPciPassthroughDynamicBackingInfo => Ok(from.as_any_box().downcast::<VirtualPciPassthroughDynamicBackingInfo>()?),
            StructType::VirtualParallelPortDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualParallelPortDeviceBackingInfo>()?),
            StructType::VirtualPointingDeviceDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualPointingDeviceDeviceBackingInfo>()?),
            StructType::VirtualScsiPassthroughDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualScsiPassthroughDeviceBackingInfo>()?),
            StructType::VirtualSerialPortDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualSerialPortDeviceBackingInfo>()?),
            StructType::VirtualSoundCardDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualSoundCardDeviceBackingInfo>()?),
            StructType::VirtualUsbRemoteHostBackingInfo => Ok(from.as_any_box().downcast::<VirtualUsbRemoteHostBackingInfo>()?),
            StructType::VirtualUsbusbBackingInfo => Ok(from.as_any_box().downcast::<VirtualUsbusbBackingInfo>()?),
            StructType::VirtualDeviceFileBackingInfo => Ok(from.as_any_box().downcast::<VirtualDeviceFileBackingInfo>()?),
            StructType::VirtualCdromIsoBackingInfo => Ok(from.as_any_box().downcast::<VirtualCdromIsoBackingInfo>()?),
            StructType::VirtualDiskFlatVer1BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskFlatVer1BackingInfo>()?),
            StructType::VirtualDiskFlatVer2BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskFlatVer2BackingInfo>()?),
            StructType::VirtualDiskLocalPMemBackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskLocalPMemBackingInfo>()?),
            StructType::VirtualDiskRawDiskMappingVer1BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskRawDiskMappingVer1BackingInfo>()?),
            StructType::VirtualDiskSeSparseBackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskSeSparseBackingInfo>()?),
            StructType::VirtualDiskSparseVer1BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskSparseVer1BackingInfo>()?),
            StructType::VirtualDiskSparseVer2BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskSparseVer2BackingInfo>()?),
            StructType::VirtualFloppyImageBackingInfo => Ok(from.as_any_box().downcast::<VirtualFloppyImageBackingInfo>()?),
            StructType::VirtualNvdimmBackingInfo => Ok(from.as_any_box().downcast::<VirtualNvdimmBackingInfo>()?),
            StructType::VirtualParallelPortFileBackingInfo => Ok(from.as_any_box().downcast::<VirtualParallelPortFileBackingInfo>()?),
            StructType::VirtualSerialPortFileBackingInfo => Ok(from.as_any_box().downcast::<VirtualSerialPortFileBackingInfo>()?),
            StructType::VirtualDevicePipeBackingInfo => Ok(from.as_any_box().downcast::<VirtualDevicePipeBackingInfo>()?),
            StructType::VirtualSerialPortPipeBackingInfo => Ok(from.as_any_box().downcast::<VirtualSerialPortPipeBackingInfo>()?),
            StructType::VirtualDeviceRemoteDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualDeviceRemoteDeviceBackingInfo>()?),
            StructType::VirtualCdromRemoteAtapiBackingInfo => Ok(from.as_any_box().downcast::<VirtualCdromRemoteAtapiBackingInfo>()?),
            StructType::VirtualCdromRemotePassthroughBackingInfo => Ok(from.as_any_box().downcast::<VirtualCdromRemotePassthroughBackingInfo>()?),
            StructType::VirtualFloppyRemoteDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualFloppyRemoteDeviceBackingInfo>()?),
            StructType::VirtualUsbRemoteClientBackingInfo => Ok(from.as_any_box().downcast::<VirtualUsbRemoteClientBackingInfo>()?),
            StructType::VirtualDeviceUriBackingInfo => Ok(from.as_any_box().downcast::<VirtualDeviceUriBackingInfo>()?),
            StructType::VirtualSerialPortUriBackingInfo => Ok(from.as_any_box().downcast::<VirtualSerialPortUriBackingInfo>()?),
            StructType::VirtualEthernetCardDistributedVirtualPortBackingInfo => Ok(from.as_any_box().downcast::<VirtualEthernetCardDistributedVirtualPortBackingInfo>()?),
            StructType::VirtualEthernetCardOpaqueNetworkBackingInfo => Ok(from.as_any_box().downcast::<VirtualEthernetCardOpaqueNetworkBackingInfo>()?),
            StructType::VirtualPciPassthroughDvxBackingInfo => Ok(from.as_any_box().downcast::<VirtualPciPassthroughDvxBackingInfo>()?),
            StructType::VirtualPciPassthroughPluginBackingInfo => Ok(from.as_any_box().downcast::<VirtualPciPassthroughPluginBackingInfo>()?),
            StructType::VirtualPciPassthroughVmiopBackingInfo => Ok(from.as_any_box().downcast::<VirtualPciPassthroughVmiopBackingInfo>()?),
            StructType::VirtualPrecisionClockSystemClockBackingInfo => Ok(from.as_any_box().downcast::<VirtualPrecisionClockSystemClockBackingInfo>()?),
            StructType::VirtualSerialPortThinPrintBackingInfo => Ok(from.as_any_box().downcast::<VirtualSerialPortThinPrintBackingInfo>()?),
            StructType::VirtualSriovEthernetCardSriovBackingInfo => Ok(from.as_any_box().downcast::<VirtualSriovEthernetCardSriovBackingInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The <code>*VirtualDeviceDeviceBackingInfo*</code> data object type
/// defines information about a host device or resource that backs a device
/// in a virtual machine.
pub trait VirtualDeviceDeviceBackingInfoTrait : super::traits::VirtualDeviceBackingInfoTrait {
    /// The name of the device on the host system.
    fn get_device_name(&self) -> &str;
    /// Indicates whether the device should be auto detected
    /// instead of directly specified.
    /// 
    /// If this value is set to TRUE,
    /// deviceName is ignored.
    fn get_use_auto_detect(&self) -> Option<bool>;
}
impl<'s> serde::Serialize for dyn VirtualDeviceDeviceBackingInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDeviceDeviceBackingInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDeviceDeviceBackingInfoVisitor)
            }
        }

struct VirtualDeviceDeviceBackingInfoVisitor;

impl<'de> de::Visitor<'de> for VirtualDeviceDeviceBackingInfoVisitor {
    type Value = Box<dyn VirtualDeviceDeviceBackingInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDeviceDeviceBackingInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDeviceDeviceBackingInfoTrait for VirtualDeviceDeviceBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceDeviceBackingInfoTrait for VirtualCdromAtapiBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceDeviceBackingInfoTrait for VirtualCdromPassthroughBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceDeviceBackingInfoTrait for VirtualDiskRawDiskVer2BackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceDeviceBackingInfoTrait for VirtualDiskPartitionedRawDiskVer2BackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceDeviceBackingInfoTrait for VirtualEthernetCardLegacyNetworkBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceDeviceBackingInfoTrait for VirtualEthernetCardNetworkBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceDeviceBackingInfoTrait for VirtualFloppyDeviceBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceDeviceBackingInfoTrait for VirtualPciPassthroughDeviceBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceDeviceBackingInfoTrait for VirtualPciPassthroughDynamicBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceDeviceBackingInfoTrait for VirtualParallelPortDeviceBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceDeviceBackingInfoTrait for VirtualPointingDeviceDeviceBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceDeviceBackingInfoTrait for VirtualScsiPassthroughDeviceBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceDeviceBackingInfoTrait for VirtualSerialPortDeviceBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceDeviceBackingInfoTrait for VirtualSoundCardDeviceBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceDeviceBackingInfoTrait for VirtualUsbRemoteHostBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceDeviceBackingInfoTrait for VirtualUsbusbBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDeviceDeviceBackingInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDeviceDeviceBackingInfo>()?),
            StructType::VirtualCdromAtapiBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualCdromAtapiBackingInfo>()?),
            StructType::VirtualCdromPassthroughBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualCdromPassthroughBackingInfo>()?),
            StructType::VirtualDiskRawDiskVer2BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskRawDiskVer2BackingInfo>()?),
            StructType::VirtualDiskPartitionedRawDiskVer2BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskPartitionedRawDiskVer2BackingInfo>()?),
            StructType::VirtualEthernetCardLegacyNetworkBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardLegacyNetworkBackingInfo>()?),
            StructType::VirtualEthernetCardNetworkBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardNetworkBackingInfo>()?),
            StructType::VirtualFloppyDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualFloppyDeviceBackingInfo>()?),
            StructType::VirtualPciPassthroughDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughDeviceBackingInfo>()?),
            StructType::VirtualPciPassthroughDynamicBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughDynamicBackingInfo>()?),
            StructType::VirtualParallelPortDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualParallelPortDeviceBackingInfo>()?),
            StructType::VirtualPointingDeviceDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPointingDeviceDeviceBackingInfo>()?),
            StructType::VirtualScsiPassthroughDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualScsiPassthroughDeviceBackingInfo>()?),
            StructType::VirtualSerialPortDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortDeviceBackingInfo>()?),
            StructType::VirtualSoundCardDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSoundCardDeviceBackingInfo>()?),
            StructType::VirtualUsbRemoteHostBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualUsbRemoteHostBackingInfo>()?),
            StructType::VirtualUsbusbBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualUsbusbBackingInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualDeviceDeviceBackingInfo>()?),
            StructType::VirtualCdromAtapiBackingInfo => Ok(from.as_any_box().downcast::<VirtualCdromAtapiBackingInfo>()?),
            StructType::VirtualCdromPassthroughBackingInfo => Ok(from.as_any_box().downcast::<VirtualCdromPassthroughBackingInfo>()?),
            StructType::VirtualDiskRawDiskVer2BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskRawDiskVer2BackingInfo>()?),
            StructType::VirtualDiskPartitionedRawDiskVer2BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskPartitionedRawDiskVer2BackingInfo>()?),
            StructType::VirtualEthernetCardLegacyNetworkBackingInfo => Ok(from.as_any_box().downcast::<VirtualEthernetCardLegacyNetworkBackingInfo>()?),
            StructType::VirtualEthernetCardNetworkBackingInfo => Ok(from.as_any_box().downcast::<VirtualEthernetCardNetworkBackingInfo>()?),
            StructType::VirtualFloppyDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualFloppyDeviceBackingInfo>()?),
            StructType::VirtualPciPassthroughDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualPciPassthroughDeviceBackingInfo>()?),
            StructType::VirtualPciPassthroughDynamicBackingInfo => Ok(from.as_any_box().downcast::<VirtualPciPassthroughDynamicBackingInfo>()?),
            StructType::VirtualParallelPortDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualParallelPortDeviceBackingInfo>()?),
            StructType::VirtualPointingDeviceDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualPointingDeviceDeviceBackingInfo>()?),
            StructType::VirtualScsiPassthroughDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualScsiPassthroughDeviceBackingInfo>()?),
            StructType::VirtualSerialPortDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualSerialPortDeviceBackingInfo>()?),
            StructType::VirtualSoundCardDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualSoundCardDeviceBackingInfo>()?),
            StructType::VirtualUsbRemoteHostBackingInfo => Ok(from.as_any_box().downcast::<VirtualUsbRemoteHostBackingInfo>()?),
            StructType::VirtualUsbusbBackingInfo => Ok(from.as_any_box().downcast::<VirtualUsbusbBackingInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type contains information about backing a virtual disk by
/// using a host device, as used by VMware Server.
pub trait VirtualDiskRawDiskVer2BackingInfoTrait : super::traits::VirtualDeviceDeviceBackingInfoTrait {
    /// The name of the raw disk descriptor file.
    fn get_descriptor_file_name(&self) -> &str;
    /// Disk UUID for the virtual disk, if available.
    fn get_uuid(&self) -> &Option<String>;
    /// The change ID of the virtual disk for the corresponding
    /// snapshot or virtual machine.
    /// 
    /// This can be used to track
    /// incremental changes to a virtual disk. See
    /// *VirtualMachine.QueryChangedDiskAreas*.
    fn get_change_id(&self) -> &Option<String>;
    /// The sharing mode of the virtual disk.
    /// 
    /// See *VirtualDiskSharing_enum*. The default value is
    /// no sharing.
    fn get_sharing(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn VirtualDiskRawDiskVer2BackingInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDiskRawDiskVer2BackingInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDiskRawDiskVer2BackingInfoVisitor)
            }
        }

struct VirtualDiskRawDiskVer2BackingInfoVisitor;

impl<'de> de::Visitor<'de> for VirtualDiskRawDiskVer2BackingInfoVisitor {
    type Value = Box<dyn VirtualDiskRawDiskVer2BackingInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDiskRawDiskVer2BackingInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDiskRawDiskVer2BackingInfoTrait for VirtualDiskRawDiskVer2BackingInfo {
    fn get_descriptor_file_name(&self) -> &str { &self.descriptor_file_name }
    fn get_uuid(&self) -> &Option<String> { &self.uuid }
    fn get_change_id(&self) -> &Option<String> { &self.change_id }
    fn get_sharing(&self) -> &Option<String> { &self.sharing }
}
impl VirtualDiskRawDiskVer2BackingInfoTrait for VirtualDiskPartitionedRawDiskVer2BackingInfo {
    fn get_descriptor_file_name(&self) -> &str { &self.descriptor_file_name }
    fn get_uuid(&self) -> &Option<String> { &self.uuid }
    fn get_change_id(&self) -> &Option<String> { &self.change_id }
    fn get_sharing(&self) -> &Option<String> { &self.sharing }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDiskRawDiskVer2BackingInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDiskRawDiskVer2BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskRawDiskVer2BackingInfo>()?),
            StructType::VirtualDiskPartitionedRawDiskVer2BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskPartitionedRawDiskVer2BackingInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDiskRawDiskVer2BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskRawDiskVer2BackingInfo>()?),
            StructType::VirtualDiskPartitionedRawDiskVer2BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskPartitionedRawDiskVer2BackingInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// <code>*VirtualDeviceFileBackingInfo*</code> is a data object type
/// for information about file backing for a device in a virtual machine.
pub trait VirtualDeviceFileBackingInfoTrait : super::traits::VirtualDeviceBackingInfoTrait {
    /// Filename for the host file used in this backing.
    fn get_file_name(&self) -> &str;
    /// Reference to the datastore managed object where this file is stored.
    /// 
    /// If the file is not located on a datastore, then this reference is null.
    /// This is not used for configuration.
    /// 
    /// Refers instance of *Datastore*.
    fn get_datastore(&self) -> &Option<ManagedObjectReference>;
    /// Backing object's durable and unmutable identifier.
    /// 
    /// Each backing object has a unique identifier which is not settable.
    fn get_backing_object_id(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn VirtualDeviceFileBackingInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDeviceFileBackingInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDeviceFileBackingInfoVisitor)
            }
        }

struct VirtualDeviceFileBackingInfoVisitor;

impl<'de> de::Visitor<'de> for VirtualDeviceFileBackingInfoVisitor {
    type Value = Box<dyn VirtualDeviceFileBackingInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDeviceFileBackingInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDeviceFileBackingInfoTrait for VirtualDeviceFileBackingInfo {
    fn get_file_name(&self) -> &str { &self.file_name }
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
    fn get_backing_object_id(&self) -> &Option<String> { &self.backing_object_id }
}
impl VirtualDeviceFileBackingInfoTrait for VirtualCdromIsoBackingInfo {
    fn get_file_name(&self) -> &str { &self.file_name }
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
    fn get_backing_object_id(&self) -> &Option<String> { &self.backing_object_id }
}
impl VirtualDeviceFileBackingInfoTrait for VirtualDiskFlatVer1BackingInfo {
    fn get_file_name(&self) -> &str { &self.file_name }
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
    fn get_backing_object_id(&self) -> &Option<String> { &self.backing_object_id }
}
impl VirtualDeviceFileBackingInfoTrait for VirtualDiskFlatVer2BackingInfo {
    fn get_file_name(&self) -> &str { &self.file_name }
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
    fn get_backing_object_id(&self) -> &Option<String> { &self.backing_object_id }
}
impl VirtualDeviceFileBackingInfoTrait for VirtualDiskLocalPMemBackingInfo {
    fn get_file_name(&self) -> &str { &self.file_name }
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
    fn get_backing_object_id(&self) -> &Option<String> { &self.backing_object_id }
}
impl VirtualDeviceFileBackingInfoTrait for VirtualDiskRawDiskMappingVer1BackingInfo {
    fn get_file_name(&self) -> &str { &self.file_name }
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
    fn get_backing_object_id(&self) -> &Option<String> { &self.backing_object_id }
}
impl VirtualDeviceFileBackingInfoTrait for VirtualDiskSeSparseBackingInfo {
    fn get_file_name(&self) -> &str { &self.file_name }
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
    fn get_backing_object_id(&self) -> &Option<String> { &self.backing_object_id }
}
impl VirtualDeviceFileBackingInfoTrait for VirtualDiskSparseVer1BackingInfo {
    fn get_file_name(&self) -> &str { &self.file_name }
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
    fn get_backing_object_id(&self) -> &Option<String> { &self.backing_object_id }
}
impl VirtualDeviceFileBackingInfoTrait for VirtualDiskSparseVer2BackingInfo {
    fn get_file_name(&self) -> &str { &self.file_name }
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
    fn get_backing_object_id(&self) -> &Option<String> { &self.backing_object_id }
}
impl VirtualDeviceFileBackingInfoTrait for VirtualFloppyImageBackingInfo {
    fn get_file_name(&self) -> &str { &self.file_name }
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
    fn get_backing_object_id(&self) -> &Option<String> { &self.backing_object_id }
}
impl VirtualDeviceFileBackingInfoTrait for VirtualNvdimmBackingInfo {
    fn get_file_name(&self) -> &str { &self.file_name }
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
    fn get_backing_object_id(&self) -> &Option<String> { &self.backing_object_id }
}
impl VirtualDeviceFileBackingInfoTrait for VirtualParallelPortFileBackingInfo {
    fn get_file_name(&self) -> &str { &self.file_name }
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
    fn get_backing_object_id(&self) -> &Option<String> { &self.backing_object_id }
}
impl VirtualDeviceFileBackingInfoTrait for VirtualSerialPortFileBackingInfo {
    fn get_file_name(&self) -> &str { &self.file_name }
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
    fn get_backing_object_id(&self) -> &Option<String> { &self.backing_object_id }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDeviceFileBackingInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceFileBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDeviceFileBackingInfo>()?),
            StructType::VirtualCdromIsoBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualCdromIsoBackingInfo>()?),
            StructType::VirtualDiskFlatVer1BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskFlatVer1BackingInfo>()?),
            StructType::VirtualDiskFlatVer2BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskFlatVer2BackingInfo>()?),
            StructType::VirtualDiskLocalPMemBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskLocalPMemBackingInfo>()?),
            StructType::VirtualDiskRawDiskMappingVer1BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskRawDiskMappingVer1BackingInfo>()?),
            StructType::VirtualDiskSeSparseBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskSeSparseBackingInfo>()?),
            StructType::VirtualDiskSparseVer1BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskSparseVer1BackingInfo>()?),
            StructType::VirtualDiskSparseVer2BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskSparseVer2BackingInfo>()?),
            StructType::VirtualFloppyImageBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualFloppyImageBackingInfo>()?),
            StructType::VirtualNvdimmBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualNvdimmBackingInfo>()?),
            StructType::VirtualParallelPortFileBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualParallelPortFileBackingInfo>()?),
            StructType::VirtualSerialPortFileBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortFileBackingInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceFileBackingInfo => Ok(from.as_any_box().downcast::<VirtualDeviceFileBackingInfo>()?),
            StructType::VirtualCdromIsoBackingInfo => Ok(from.as_any_box().downcast::<VirtualCdromIsoBackingInfo>()?),
            StructType::VirtualDiskFlatVer1BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskFlatVer1BackingInfo>()?),
            StructType::VirtualDiskFlatVer2BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskFlatVer2BackingInfo>()?),
            StructType::VirtualDiskLocalPMemBackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskLocalPMemBackingInfo>()?),
            StructType::VirtualDiskRawDiskMappingVer1BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskRawDiskMappingVer1BackingInfo>()?),
            StructType::VirtualDiskSeSparseBackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskSeSparseBackingInfo>()?),
            StructType::VirtualDiskSparseVer1BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskSparseVer1BackingInfo>()?),
            StructType::VirtualDiskSparseVer2BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskSparseVer2BackingInfo>()?),
            StructType::VirtualFloppyImageBackingInfo => Ok(from.as_any_box().downcast::<VirtualFloppyImageBackingInfo>()?),
            StructType::VirtualNvdimmBackingInfo => Ok(from.as_any_box().downcast::<VirtualNvdimmBackingInfo>()?),
            StructType::VirtualParallelPortFileBackingInfo => Ok(from.as_any_box().downcast::<VirtualParallelPortFileBackingInfo>()?),
            StructType::VirtualSerialPortFileBackingInfo => Ok(from.as_any_box().downcast::<VirtualSerialPortFileBackingInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The <code>*VirtualDevicePipeBackingInfo*</code> data object type
/// defines information for using a named pipe as backing for a device
/// in a virtual machine.
pub trait VirtualDevicePipeBackingInfoTrait : super::traits::VirtualDeviceBackingInfoTrait {
    /// Pipe name for the host pipe associated with this backing.
    fn get_pipe_name(&self) -> &str;
}
impl<'s> serde::Serialize for dyn VirtualDevicePipeBackingInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDevicePipeBackingInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDevicePipeBackingInfoVisitor)
            }
        }

struct VirtualDevicePipeBackingInfoVisitor;

impl<'de> de::Visitor<'de> for VirtualDevicePipeBackingInfoVisitor {
    type Value = Box<dyn VirtualDevicePipeBackingInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDevicePipeBackingInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDevicePipeBackingInfoTrait for VirtualDevicePipeBackingInfo {
    fn get_pipe_name(&self) -> &str { &self.pipe_name }
}
impl VirtualDevicePipeBackingInfoTrait for VirtualSerialPortPipeBackingInfo {
    fn get_pipe_name(&self) -> &str { &self.pipe_name }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDevicePipeBackingInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDevicePipeBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDevicePipeBackingInfo>()?),
            StructType::VirtualSerialPortPipeBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortPipeBackingInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDevicePipeBackingInfo => Ok(from.as_any_box().downcast::<VirtualDevicePipeBackingInfo>()?),
            StructType::VirtualSerialPortPipeBackingInfo => Ok(from.as_any_box().downcast::<VirtualSerialPortPipeBackingInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// <code>*VirtualDeviceRemoteDeviceBackingInfo*</code> is a data object type
/// for information
/// about a remote device backing used by a device in a virtual machine.
/// 
/// The primary difference between a remote device backing and a
/// local device backing is that the VirtualCenter server cannot provide a list
/// of remote host devices available for this virtual device backing.
pub trait VirtualDeviceRemoteDeviceBackingInfoTrait : super::traits::VirtualDeviceBackingInfoTrait {
    /// The name of the device on the remote system.
    fn get_device_name(&self) -> &str;
    /// Indicates whether the device should be auto detected
    /// instead of directly specified.
    /// 
    /// If this value is set to TRUE,
    /// <code>deviceName</code> is ignored.
    fn get_use_auto_detect(&self) -> Option<bool>;
}
impl<'s> serde::Serialize for dyn VirtualDeviceRemoteDeviceBackingInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDeviceRemoteDeviceBackingInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDeviceRemoteDeviceBackingInfoVisitor)
            }
        }

struct VirtualDeviceRemoteDeviceBackingInfoVisitor;

impl<'de> de::Visitor<'de> for VirtualDeviceRemoteDeviceBackingInfoVisitor {
    type Value = Box<dyn VirtualDeviceRemoteDeviceBackingInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDeviceRemoteDeviceBackingInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDeviceRemoteDeviceBackingInfoTrait for VirtualDeviceRemoteDeviceBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceRemoteDeviceBackingInfoTrait for VirtualCdromRemoteAtapiBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceRemoteDeviceBackingInfoTrait for VirtualCdromRemotePassthroughBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceRemoteDeviceBackingInfoTrait for VirtualFloppyRemoteDeviceBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceRemoteDeviceBackingInfoTrait for VirtualUsbRemoteClientBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDeviceRemoteDeviceBackingInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceRemoteDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDeviceRemoteDeviceBackingInfo>()?),
            StructType::VirtualCdromRemoteAtapiBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualCdromRemoteAtapiBackingInfo>()?),
            StructType::VirtualCdromRemotePassthroughBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualCdromRemotePassthroughBackingInfo>()?),
            StructType::VirtualFloppyRemoteDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualFloppyRemoteDeviceBackingInfo>()?),
            StructType::VirtualUsbRemoteClientBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualUsbRemoteClientBackingInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceRemoteDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualDeviceRemoteDeviceBackingInfo>()?),
            StructType::VirtualCdromRemoteAtapiBackingInfo => Ok(from.as_any_box().downcast::<VirtualCdromRemoteAtapiBackingInfo>()?),
            StructType::VirtualCdromRemotePassthroughBackingInfo => Ok(from.as_any_box().downcast::<VirtualCdromRemotePassthroughBackingInfo>()?),
            StructType::VirtualFloppyRemoteDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualFloppyRemoteDeviceBackingInfo>()?),
            StructType::VirtualUsbRemoteClientBackingInfo => Ok(from.as_any_box().downcast::<VirtualUsbRemoteClientBackingInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The <code>*VirtualDeviceURIBackingInfo*</code> data object type
/// defines information for using a network socket as backing for a virtual device.
pub trait VirtualDeviceUriBackingInfoTrait : super::traits::VirtualDeviceBackingInfoTrait {
    /// Identifies the local host or a system on the network,
    /// depending on the value of <code>*VirtualDeviceURIBackingInfo.direction*</code>.
    /// - If you use the virtual machine as a server, the URI identifies
    ///   the host on which the virtual machine runs. In this case,
    ///   the host name part of the URI should be empty, or it should
    ///   specify the address of the local host.
    /// - If you use the virtual machine as a client, the URI identifies
    ///   the remote system on the network.
    fn get_service_uri(&self) -> &str;
    /// The direction of the connection.
    /// 
    /// For possible values see
    /// *VirtualDeviceURIBackingOptionDirection_enum*
    fn get_direction(&self) -> &str;
    /// Identifies a proxy service that provides network access to the
    /// <code>*VirtualDeviceURIBackingInfo.serviceURI*</code>.
    /// 
    /// If you specify a proxy URI, the virtual machine initiates
    /// a connection with the proxy service and forwards the
    /// *VirtualDeviceURIBackingInfo.serviceURI* and *VirtualDeviceURIBackingInfo.direction* to the proxy.
    fn get_proxy_uri(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn VirtualDeviceUriBackingInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDeviceUriBackingInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDeviceUriBackingInfoVisitor)
            }
        }

struct VirtualDeviceUriBackingInfoVisitor;

impl<'de> de::Visitor<'de> for VirtualDeviceUriBackingInfoVisitor {
    type Value = Box<dyn VirtualDeviceUriBackingInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDeviceUriBackingInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDeviceUriBackingInfoTrait for VirtualDeviceUriBackingInfo {
    fn get_service_uri(&self) -> &str { &self.service_uri }
    fn get_direction(&self) -> &str { &self.direction }
    fn get_proxy_uri(&self) -> &Option<String> { &self.proxy_uri }
}
impl VirtualDeviceUriBackingInfoTrait for VirtualSerialPortUriBackingInfo {
    fn get_service_uri(&self) -> &str { &self.service_uri }
    fn get_direction(&self) -> &str { &self.direction }
    fn get_proxy_uri(&self) -> &Option<String> { &self.proxy_uri }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDeviceUriBackingInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceUriBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDeviceUriBackingInfo>()?),
            StructType::VirtualSerialPortUriBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortUriBackingInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceUriBackingInfo => Ok(from.as_any_box().downcast::<VirtualDeviceUriBackingInfo>()?),
            StructType::VirtualSerialPortUriBackingInfo => Ok(from.as_any_box().downcast::<VirtualSerialPortUriBackingInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The VirtualPCIPassthrough.PluginBackingInfo is a base data object type
/// for encoding plugin-specific information.
/// 
/// This base type does not define
/// any properties. Specific plugin types are represented by subtypes which
/// define properties for subtype-specific backing information.
pub trait VirtualPciPassthroughPluginBackingInfoTrait : super::traits::VirtualDeviceBackingInfoTrait {
}
impl<'s> serde::Serialize for dyn VirtualPciPassthroughPluginBackingInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualPciPassthroughPluginBackingInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualPciPassthroughPluginBackingInfoVisitor)
            }
        }

struct VirtualPciPassthroughPluginBackingInfoVisitor;

impl<'de> de::Visitor<'de> for VirtualPciPassthroughPluginBackingInfoVisitor {
    type Value = Box<dyn VirtualPciPassthroughPluginBackingInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualPciPassthroughPluginBackingInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualPciPassthroughPluginBackingInfoTrait for VirtualPciPassthroughPluginBackingInfo {
}
impl VirtualPciPassthroughPluginBackingInfoTrait for VirtualPciPassthroughVmiopBackingInfo {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualPciPassthroughPluginBackingInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualPciPassthroughPluginBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughPluginBackingInfo>()?),
            StructType::VirtualPciPassthroughVmiopBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughVmiopBackingInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualPciPassthroughPluginBackingInfo => Ok(from.as_any_box().downcast::<VirtualPciPassthroughPluginBackingInfo>()?),
            StructType::VirtualPciPassthroughVmiopBackingInfo => Ok(from.as_any_box().downcast::<VirtualPciPassthroughVmiopBackingInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// <code>*VirtualDeviceBusSlotInfo*</code> is a base data object type
/// for information about device connection to its bus.
/// 
/// This base type does not
/// define any properties. It is used as a namespace for general-purpose subtypes.
/// Specific devices types are represented by subtypes which define properties for
/// device-specific backing information.
pub trait VirtualDeviceBusSlotInfoTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn VirtualDeviceBusSlotInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDeviceBusSlotInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDeviceBusSlotInfoVisitor)
            }
        }

struct VirtualDeviceBusSlotInfoVisitor;

impl<'de> de::Visitor<'de> for VirtualDeviceBusSlotInfoVisitor {
    type Value = Box<dyn VirtualDeviceBusSlotInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDeviceBusSlotInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDeviceBusSlotInfoTrait for VirtualDeviceBusSlotInfo {
}
impl VirtualDeviceBusSlotInfoTrait for VirtualDevicePciBusSlotInfo {
}
impl VirtualDeviceBusSlotInfoTrait for VirtualUsbControllerPciBusSlotInfo {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDeviceBusSlotInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceBusSlotInfo => Some(from.as_any_ref().downcast_ref::<VirtualDeviceBusSlotInfo>()?),
            StructType::VirtualDevicePciBusSlotInfo => Some(from.as_any_ref().downcast_ref::<VirtualDevicePciBusSlotInfo>()?),
            StructType::VirtualUsbControllerPciBusSlotInfo => Some(from.as_any_ref().downcast_ref::<VirtualUsbControllerPciBusSlotInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceBusSlotInfo => Ok(from.as_any_box().downcast::<VirtualDeviceBusSlotInfo>()?),
            StructType::VirtualDevicePciBusSlotInfo => Ok(from.as_any_box().downcast::<VirtualDevicePciBusSlotInfo>()?),
            StructType::VirtualUsbControllerPciBusSlotInfo => Ok(from.as_any_box().downcast::<VirtualUsbControllerPciBusSlotInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The <code>*VirtualDevicePciBusSlotInfo*</code> data object type
/// defines information about a pci bus slot of pci device in a virtual machine.
pub trait VirtualDevicePciBusSlotInfoTrait : super::traits::VirtualDeviceBusSlotInfoTrait {
    /// The pci slot number of the virtual device.
    /// 
    /// The pci slot number assignment should generally be left to the system.
    /// If assigned a value, and the value is invalid or duplicated, it will
    /// automatically be reassigned. This will not cause an error.
    /// 
    /// Generally, the PCI slot numbers should never be specified in an
    /// Reconfigure operation, and only in a CreateVM operation if i) they
    /// are specified for all devices, and ii) the numbers have been
    /// determined by looking at an existing VM configuration of similar
    /// hardware version. In other words, when the virtual hardware configuration
    /// is duplicated.
    fn get_pci_slot_number(&self) -> i32;
}
impl<'s> serde::Serialize for dyn VirtualDevicePciBusSlotInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDevicePciBusSlotInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDevicePciBusSlotInfoVisitor)
            }
        }

struct VirtualDevicePciBusSlotInfoVisitor;

impl<'de> de::Visitor<'de> for VirtualDevicePciBusSlotInfoVisitor {
    type Value = Box<dyn VirtualDevicePciBusSlotInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDevicePciBusSlotInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDevicePciBusSlotInfoTrait for VirtualDevicePciBusSlotInfo {
    fn get_pci_slot_number(&self) -> i32 { self.pci_slot_number }
}
impl VirtualDevicePciBusSlotInfoTrait for VirtualUsbControllerPciBusSlotInfo {
    fn get_pci_slot_number(&self) -> i32 { self.pci_slot_number }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDevicePciBusSlotInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDevicePciBusSlotInfo => Some(from.as_any_ref().downcast_ref::<VirtualDevicePciBusSlotInfo>()?),
            StructType::VirtualUsbControllerPciBusSlotInfo => Some(from.as_any_ref().downcast_ref::<VirtualUsbControllerPciBusSlotInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDevicePciBusSlotInfo => Ok(from.as_any_box().downcast::<VirtualDevicePciBusSlotInfo>()?),
            StructType::VirtualUsbControllerPciBusSlotInfo => Ok(from.as_any_box().downcast::<VirtualUsbControllerPciBusSlotInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The VirtualDeviceOption data object type contains information about
/// a virtual device type, the options for configuring the virtual device,
/// and the relationship between this virtual device and other devices.
/// 
/// The vSphere API groups device configurations that are mutually exclusive
/// into different configuration objects; each of these configuration objects
/// may define subtypes for virtual device backing options
/// that are independent of the virtual device.
/// Backing-dependent options should appear in a subtype of
/// *VirtualDeviceBackingOption*.
pub trait VirtualDeviceOptionTrait : super::traits::DataObjectTrait {
    /// The name of the run-time class the client should instantiate
    /// to create a run-time instance of this device.
    fn get_type(&self) -> &str;
    /// If the device is connectable, then the connectOption
    /// describes the connect options and defaults.
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption>;
    /// If the device can use a bus slot configuration, then the busSlotOption
    /// describes the bus slot options.
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption>;
    /// Data object type that denotes the controller option object that is
    /// valid for controlling this device.
    fn get_controller_type(&self) -> &Option<String>;
    /// Flag to indicate whether or not this device will be auto-assigned a controller
    /// if one is required.
    /// 
    /// If this is true, then a client need not explicitly create
    /// the controller that this device will plug into.
    fn get_auto_assign_controller(&self) -> &Option<BoolOption>;
    /// A list of backing options that can be used to map the virtual
    /// device to the host.
    /// 
    /// The list is optional, since some devices exist only within
    /// the virtual machine; for example, a VirtualController.
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>>;
    /// Index into the backingOption list, indicating the default backing.
    fn get_default_backing_option_index(&self) -> Option<i32>;
    /// List of property names enforced by a licensing restriction
    /// of the underlying product.
    /// 
    /// For example, a limit that is not
    /// derived based on the product or hardware features; the
    /// property name "numCPU".
    fn get_licensing_limit(&self) -> &Option<Vec<String>>;
    /// Indicates whether this device is deprecated.
    /// 
    /// Hence, if set the device
    /// cannot be used when creating a new virtual machine or be added to an existing
    /// virtual machine. However, the device is still supported by the platform.
    fn get_deprecated(&self) -> bool;
    /// Indicates if this type of device can be hot-added to the virtual machine
    /// via a reconfigure operation when the virtual machine is powered on.
    fn get_plug_and_play(&self) -> bool;
    /// Indicates if this type of device can be hot-removed from the virtual machine
    /// via a reconfigure operation when the virtual machine is powered on.
    fn get_hot_remove_supported(&self) -> bool;
    /// ***Since:*** vSphere API Release 8.0.0.1
    fn get_numa_supported(&self) -> Option<bool>;
}
impl<'s> serde::Serialize for dyn VirtualDeviceOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDeviceOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDeviceOptionVisitor)
            }
        }

struct VirtualDeviceOptionVisitor;

impl<'de> de::Visitor<'de> for VirtualDeviceOptionVisitor {
    type Value = Box<dyn VirtualDeviceOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDeviceOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDeviceOptionTrait for VirtualDeviceOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualCdromOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualControllerOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualIdeControllerOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualNvdimmControllerOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualNvmeControllerOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualPciControllerOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualPs2ControllerOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualSataControllerOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualAhciControllerOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualScsiControllerOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for ParaVirtualScsiControllerOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualBusLogicControllerOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualLsiLogicControllerOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualLsiLogicSasControllerOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualSioControllerOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualUsbControllerOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualUsbxhciControllerOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualDiskOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualEthernetCardOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualE1000Option {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualE1000EOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualPcNet32Option {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualSriovEthernetCardOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualVmxnetOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualVmxnet2Option {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualVmxnet3Option {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualVmxnet3VrdmaOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualFloppyOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualKeyboardOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualNvdimmOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualPciPassthroughOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualParallelPortOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualPointingDeviceOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualPrecisionClockOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualScsiPassthroughOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualSerialPortOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualSoundCardOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualEnsoniq1371Option {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualHdAudioCardOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualSoundBlaster16Option {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualTpmOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualUsbOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualMachineVmciDeviceOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualVmiromOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualVideoCardOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualWdtOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDeviceOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceOption => Some(from.as_any_ref().downcast_ref::<VirtualDeviceOption>()?),
            StructType::VirtualCdromOption => Some(from.as_any_ref().downcast_ref::<VirtualCdromOption>()?),
            StructType::VirtualControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualControllerOption>()?),
            StructType::VirtualIdeControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualIdeControllerOption>()?),
            StructType::VirtualNvdimmControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualNvdimmControllerOption>()?),
            StructType::VirtualNvmeControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualNvmeControllerOption>()?),
            StructType::VirtualPciControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualPciControllerOption>()?),
            StructType::VirtualPs2ControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualPs2ControllerOption>()?),
            StructType::VirtualSataControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualSataControllerOption>()?),
            StructType::VirtualAhciControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualAhciControllerOption>()?),
            StructType::VirtualScsiControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualScsiControllerOption>()?),
            StructType::ParaVirtualScsiControllerOption => Some(from.as_any_ref().downcast_ref::<ParaVirtualScsiControllerOption>()?),
            StructType::VirtualBusLogicControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualBusLogicControllerOption>()?),
            StructType::VirtualLsiLogicControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualLsiLogicControllerOption>()?),
            StructType::VirtualLsiLogicSasControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualLsiLogicSasControllerOption>()?),
            StructType::VirtualSioControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualSioControllerOption>()?),
            StructType::VirtualUsbControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualUsbControllerOption>()?),
            StructType::VirtualUsbxhciControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualUsbxhciControllerOption>()?),
            StructType::VirtualDiskOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskOption>()?),
            StructType::VirtualEthernetCardOption => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardOption>()?),
            StructType::VirtualE1000Option => Some(from.as_any_ref().downcast_ref::<VirtualE1000Option>()?),
            StructType::VirtualE1000EOption => Some(from.as_any_ref().downcast_ref::<VirtualE1000EOption>()?),
            StructType::VirtualPcNet32Option => Some(from.as_any_ref().downcast_ref::<VirtualPcNet32Option>()?),
            StructType::VirtualSriovEthernetCardOption => Some(from.as_any_ref().downcast_ref::<VirtualSriovEthernetCardOption>()?),
            StructType::VirtualVmxnetOption => Some(from.as_any_ref().downcast_ref::<VirtualVmxnetOption>()?),
            StructType::VirtualVmxnet2Option => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet2Option>()?),
            StructType::VirtualVmxnet3Option => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3Option>()?),
            StructType::VirtualVmxnet3VrdmaOption => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3VrdmaOption>()?),
            StructType::VirtualFloppyOption => Some(from.as_any_ref().downcast_ref::<VirtualFloppyOption>()?),
            StructType::VirtualKeyboardOption => Some(from.as_any_ref().downcast_ref::<VirtualKeyboardOption>()?),
            StructType::VirtualNvdimmOption => Some(from.as_any_ref().downcast_ref::<VirtualNvdimmOption>()?),
            StructType::VirtualPciPassthroughOption => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughOption>()?),
            StructType::VirtualParallelPortOption => Some(from.as_any_ref().downcast_ref::<VirtualParallelPortOption>()?),
            StructType::VirtualPointingDeviceOption => Some(from.as_any_ref().downcast_ref::<VirtualPointingDeviceOption>()?),
            StructType::VirtualPrecisionClockOption => Some(from.as_any_ref().downcast_ref::<VirtualPrecisionClockOption>()?),
            StructType::VirtualScsiPassthroughOption => Some(from.as_any_ref().downcast_ref::<VirtualScsiPassthroughOption>()?),
            StructType::VirtualSerialPortOption => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortOption>()?),
            StructType::VirtualSoundCardOption => Some(from.as_any_ref().downcast_ref::<VirtualSoundCardOption>()?),
            StructType::VirtualEnsoniq1371Option => Some(from.as_any_ref().downcast_ref::<VirtualEnsoniq1371Option>()?),
            StructType::VirtualHdAudioCardOption => Some(from.as_any_ref().downcast_ref::<VirtualHdAudioCardOption>()?),
            StructType::VirtualSoundBlaster16Option => Some(from.as_any_ref().downcast_ref::<VirtualSoundBlaster16Option>()?),
            StructType::VirtualTpmOption => Some(from.as_any_ref().downcast_ref::<VirtualTpmOption>()?),
            StructType::VirtualUsbOption => Some(from.as_any_ref().downcast_ref::<VirtualUsbOption>()?),
            StructType::VirtualMachineVmciDeviceOption => Some(from.as_any_ref().downcast_ref::<VirtualMachineVmciDeviceOption>()?),
            StructType::VirtualVmiromOption => Some(from.as_any_ref().downcast_ref::<VirtualVmiromOption>()?),
            StructType::VirtualVideoCardOption => Some(from.as_any_ref().downcast_ref::<VirtualVideoCardOption>()?),
            StructType::VirtualWdtOption => Some(from.as_any_ref().downcast_ref::<VirtualWdtOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceOption => Ok(from.as_any_box().downcast::<VirtualDeviceOption>()?),
            StructType::VirtualCdromOption => Ok(from.as_any_box().downcast::<VirtualCdromOption>()?),
            StructType::VirtualControllerOption => Ok(from.as_any_box().downcast::<VirtualControllerOption>()?),
            StructType::VirtualIdeControllerOption => Ok(from.as_any_box().downcast::<VirtualIdeControllerOption>()?),
            StructType::VirtualNvdimmControllerOption => Ok(from.as_any_box().downcast::<VirtualNvdimmControllerOption>()?),
            StructType::VirtualNvmeControllerOption => Ok(from.as_any_box().downcast::<VirtualNvmeControllerOption>()?),
            StructType::VirtualPciControllerOption => Ok(from.as_any_box().downcast::<VirtualPciControllerOption>()?),
            StructType::VirtualPs2ControllerOption => Ok(from.as_any_box().downcast::<VirtualPs2ControllerOption>()?),
            StructType::VirtualSataControllerOption => Ok(from.as_any_box().downcast::<VirtualSataControllerOption>()?),
            StructType::VirtualAhciControllerOption => Ok(from.as_any_box().downcast::<VirtualAhciControllerOption>()?),
            StructType::VirtualScsiControllerOption => Ok(from.as_any_box().downcast::<VirtualScsiControllerOption>()?),
            StructType::ParaVirtualScsiControllerOption => Ok(from.as_any_box().downcast::<ParaVirtualScsiControllerOption>()?),
            StructType::VirtualBusLogicControllerOption => Ok(from.as_any_box().downcast::<VirtualBusLogicControllerOption>()?),
            StructType::VirtualLsiLogicControllerOption => Ok(from.as_any_box().downcast::<VirtualLsiLogicControllerOption>()?),
            StructType::VirtualLsiLogicSasControllerOption => Ok(from.as_any_box().downcast::<VirtualLsiLogicSasControllerOption>()?),
            StructType::VirtualSioControllerOption => Ok(from.as_any_box().downcast::<VirtualSioControllerOption>()?),
            StructType::VirtualUsbControllerOption => Ok(from.as_any_box().downcast::<VirtualUsbControllerOption>()?),
            StructType::VirtualUsbxhciControllerOption => Ok(from.as_any_box().downcast::<VirtualUsbxhciControllerOption>()?),
            StructType::VirtualDiskOption => Ok(from.as_any_box().downcast::<VirtualDiskOption>()?),
            StructType::VirtualEthernetCardOption => Ok(from.as_any_box().downcast::<VirtualEthernetCardOption>()?),
            StructType::VirtualE1000Option => Ok(from.as_any_box().downcast::<VirtualE1000Option>()?),
            StructType::VirtualE1000EOption => Ok(from.as_any_box().downcast::<VirtualE1000EOption>()?),
            StructType::VirtualPcNet32Option => Ok(from.as_any_box().downcast::<VirtualPcNet32Option>()?),
            StructType::VirtualSriovEthernetCardOption => Ok(from.as_any_box().downcast::<VirtualSriovEthernetCardOption>()?),
            StructType::VirtualVmxnetOption => Ok(from.as_any_box().downcast::<VirtualVmxnetOption>()?),
            StructType::VirtualVmxnet2Option => Ok(from.as_any_box().downcast::<VirtualVmxnet2Option>()?),
            StructType::VirtualVmxnet3Option => Ok(from.as_any_box().downcast::<VirtualVmxnet3Option>()?),
            StructType::VirtualVmxnet3VrdmaOption => Ok(from.as_any_box().downcast::<VirtualVmxnet3VrdmaOption>()?),
            StructType::VirtualFloppyOption => Ok(from.as_any_box().downcast::<VirtualFloppyOption>()?),
            StructType::VirtualKeyboardOption => Ok(from.as_any_box().downcast::<VirtualKeyboardOption>()?),
            StructType::VirtualNvdimmOption => Ok(from.as_any_box().downcast::<VirtualNvdimmOption>()?),
            StructType::VirtualPciPassthroughOption => Ok(from.as_any_box().downcast::<VirtualPciPassthroughOption>()?),
            StructType::VirtualParallelPortOption => Ok(from.as_any_box().downcast::<VirtualParallelPortOption>()?),
            StructType::VirtualPointingDeviceOption => Ok(from.as_any_box().downcast::<VirtualPointingDeviceOption>()?),
            StructType::VirtualPrecisionClockOption => Ok(from.as_any_box().downcast::<VirtualPrecisionClockOption>()?),
            StructType::VirtualScsiPassthroughOption => Ok(from.as_any_box().downcast::<VirtualScsiPassthroughOption>()?),
            StructType::VirtualSerialPortOption => Ok(from.as_any_box().downcast::<VirtualSerialPortOption>()?),
            StructType::VirtualSoundCardOption => Ok(from.as_any_box().downcast::<VirtualSoundCardOption>()?),
            StructType::VirtualEnsoniq1371Option => Ok(from.as_any_box().downcast::<VirtualEnsoniq1371Option>()?),
            StructType::VirtualHdAudioCardOption => Ok(from.as_any_box().downcast::<VirtualHdAudioCardOption>()?),
            StructType::VirtualSoundBlaster16Option => Ok(from.as_any_box().downcast::<VirtualSoundBlaster16Option>()?),
            StructType::VirtualTpmOption => Ok(from.as_any_box().downcast::<VirtualTpmOption>()?),
            StructType::VirtualUsbOption => Ok(from.as_any_box().downcast::<VirtualUsbOption>()?),
            StructType::VirtualMachineVmciDeviceOption => Ok(from.as_any_box().downcast::<VirtualMachineVmciDeviceOption>()?),
            StructType::VirtualVmiromOption => Ok(from.as_any_box().downcast::<VirtualVmiromOption>()?),
            StructType::VirtualVideoCardOption => Ok(from.as_any_box().downcast::<VirtualVideoCardOption>()?),
            StructType::VirtualWdtOption => Ok(from.as_any_box().downcast::<VirtualWdtOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The VirtualControllerOption data object type contains information about
/// a virtual controller type.
pub trait VirtualControllerOptionTrait : super::traits::VirtualDeviceOptionTrait {
    /// The minimum and maximum number of devices this controller can control
    /// at run time.
    fn get_devices(&self) -> &IntOption;
    /// Array of supported device options for this controller.
    fn get_supported_device(&self) -> &Option<Vec<String>>;
}
impl<'s> serde::Serialize for dyn VirtualControllerOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualControllerOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualControllerOptionVisitor)
            }
        }

struct VirtualControllerOptionVisitor;

impl<'de> de::Visitor<'de> for VirtualControllerOptionVisitor {
    type Value = Box<dyn VirtualControllerOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualControllerOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualControllerOptionTrait for VirtualControllerOption {
    fn get_devices(&self) -> &IntOption { &self.devices }
    fn get_supported_device(&self) -> &Option<Vec<String>> { &self.supported_device }
}
impl VirtualControllerOptionTrait for VirtualIdeControllerOption {
    fn get_devices(&self) -> &IntOption { &self.devices }
    fn get_supported_device(&self) -> &Option<Vec<String>> { &self.supported_device }
}
impl VirtualControllerOptionTrait for VirtualNvdimmControllerOption {
    fn get_devices(&self) -> &IntOption { &self.devices }
    fn get_supported_device(&self) -> &Option<Vec<String>> { &self.supported_device }
}
impl VirtualControllerOptionTrait for VirtualNvmeControllerOption {
    fn get_devices(&self) -> &IntOption { &self.devices }
    fn get_supported_device(&self) -> &Option<Vec<String>> { &self.supported_device }
}
impl VirtualControllerOptionTrait for VirtualPciControllerOption {
    fn get_devices(&self) -> &IntOption { &self.devices }
    fn get_supported_device(&self) -> &Option<Vec<String>> { &self.supported_device }
}
impl VirtualControllerOptionTrait for VirtualPs2ControllerOption {
    fn get_devices(&self) -> &IntOption { &self.devices }
    fn get_supported_device(&self) -> &Option<Vec<String>> { &self.supported_device }
}
impl VirtualControllerOptionTrait for VirtualSataControllerOption {
    fn get_devices(&self) -> &IntOption { &self.devices }
    fn get_supported_device(&self) -> &Option<Vec<String>> { &self.supported_device }
}
impl VirtualControllerOptionTrait for VirtualAhciControllerOption {
    fn get_devices(&self) -> &IntOption { &self.devices }
    fn get_supported_device(&self) -> &Option<Vec<String>> { &self.supported_device }
}
impl VirtualControllerOptionTrait for VirtualScsiControllerOption {
    fn get_devices(&self) -> &IntOption { &self.devices }
    fn get_supported_device(&self) -> &Option<Vec<String>> { &self.supported_device }
}
impl VirtualControllerOptionTrait for ParaVirtualScsiControllerOption {
    fn get_devices(&self) -> &IntOption { &self.devices }
    fn get_supported_device(&self) -> &Option<Vec<String>> { &self.supported_device }
}
impl VirtualControllerOptionTrait for VirtualBusLogicControllerOption {
    fn get_devices(&self) -> &IntOption { &self.devices }
    fn get_supported_device(&self) -> &Option<Vec<String>> { &self.supported_device }
}
impl VirtualControllerOptionTrait for VirtualLsiLogicControllerOption {
    fn get_devices(&self) -> &IntOption { &self.devices }
    fn get_supported_device(&self) -> &Option<Vec<String>> { &self.supported_device }
}
impl VirtualControllerOptionTrait for VirtualLsiLogicSasControllerOption {
    fn get_devices(&self) -> &IntOption { &self.devices }
    fn get_supported_device(&self) -> &Option<Vec<String>> { &self.supported_device }
}
impl VirtualControllerOptionTrait for VirtualSioControllerOption {
    fn get_devices(&self) -> &IntOption { &self.devices }
    fn get_supported_device(&self) -> &Option<Vec<String>> { &self.supported_device }
}
impl VirtualControllerOptionTrait for VirtualUsbControllerOption {
    fn get_devices(&self) -> &IntOption { &self.devices }
    fn get_supported_device(&self) -> &Option<Vec<String>> { &self.supported_device }
}
impl VirtualControllerOptionTrait for VirtualUsbxhciControllerOption {
    fn get_devices(&self) -> &IntOption { &self.devices }
    fn get_supported_device(&self) -> &Option<Vec<String>> { &self.supported_device }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualControllerOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualControllerOption>()?),
            StructType::VirtualIdeControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualIdeControllerOption>()?),
            StructType::VirtualNvdimmControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualNvdimmControllerOption>()?),
            StructType::VirtualNvmeControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualNvmeControllerOption>()?),
            StructType::VirtualPciControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualPciControllerOption>()?),
            StructType::VirtualPs2ControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualPs2ControllerOption>()?),
            StructType::VirtualSataControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualSataControllerOption>()?),
            StructType::VirtualAhciControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualAhciControllerOption>()?),
            StructType::VirtualScsiControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualScsiControllerOption>()?),
            StructType::ParaVirtualScsiControllerOption => Some(from.as_any_ref().downcast_ref::<ParaVirtualScsiControllerOption>()?),
            StructType::VirtualBusLogicControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualBusLogicControllerOption>()?),
            StructType::VirtualLsiLogicControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualLsiLogicControllerOption>()?),
            StructType::VirtualLsiLogicSasControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualLsiLogicSasControllerOption>()?),
            StructType::VirtualSioControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualSioControllerOption>()?),
            StructType::VirtualUsbControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualUsbControllerOption>()?),
            StructType::VirtualUsbxhciControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualUsbxhciControllerOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualControllerOption => Ok(from.as_any_box().downcast::<VirtualControllerOption>()?),
            StructType::VirtualIdeControllerOption => Ok(from.as_any_box().downcast::<VirtualIdeControllerOption>()?),
            StructType::VirtualNvdimmControllerOption => Ok(from.as_any_box().downcast::<VirtualNvdimmControllerOption>()?),
            StructType::VirtualNvmeControllerOption => Ok(from.as_any_box().downcast::<VirtualNvmeControllerOption>()?),
            StructType::VirtualPciControllerOption => Ok(from.as_any_box().downcast::<VirtualPciControllerOption>()?),
            StructType::VirtualPs2ControllerOption => Ok(from.as_any_box().downcast::<VirtualPs2ControllerOption>()?),
            StructType::VirtualSataControllerOption => Ok(from.as_any_box().downcast::<VirtualSataControllerOption>()?),
            StructType::VirtualAhciControllerOption => Ok(from.as_any_box().downcast::<VirtualAhciControllerOption>()?),
            StructType::VirtualScsiControllerOption => Ok(from.as_any_box().downcast::<VirtualScsiControllerOption>()?),
            StructType::ParaVirtualScsiControllerOption => Ok(from.as_any_box().downcast::<ParaVirtualScsiControllerOption>()?),
            StructType::VirtualBusLogicControllerOption => Ok(from.as_any_box().downcast::<VirtualBusLogicControllerOption>()?),
            StructType::VirtualLsiLogicControllerOption => Ok(from.as_any_box().downcast::<VirtualLsiLogicControllerOption>()?),
            StructType::VirtualLsiLogicSasControllerOption => Ok(from.as_any_box().downcast::<VirtualLsiLogicSasControllerOption>()?),
            StructType::VirtualSioControllerOption => Ok(from.as_any_box().downcast::<VirtualSioControllerOption>()?),
            StructType::VirtualUsbControllerOption => Ok(from.as_any_box().downcast::<VirtualUsbControllerOption>()?),
            StructType::VirtualUsbxhciControllerOption => Ok(from.as_any_box().downcast::<VirtualUsbxhciControllerOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The VirtualSATAControllerOption data object type contains the options
/// for a virtual SATA controller defined by the
/// *VirtualSATAController*
/// data object type.
pub trait VirtualSataControllerOptionTrait : super::traits::VirtualControllerOptionTrait {
    /// Three properties (numSATADisks.min, numSATADisks.max, and
    /// numSATADisks.defaultValue) define the minimum, maximum, and default
    /// number of SATA VirtualDisk instances available at any given time in the
    /// SATA controller.
    /// 
    /// The number of SATA VirtualDisk instances is
    /// also limited by the number of available slots in the SATA controller.
    fn get_num_sata_disks(&self) -> &IntOption;
    /// Three properties (numSATACdroms.min, numSATACdroms.max, and
    /// numSATACdroms.defaultValue) define the minimum, maximum, and default
    /// number of SATA VirtualCdrom instances available
    /// in the SATA controller.
    /// 
    /// The number of SATA VirtualCdrom instances is
    /// also limited by the number of available slots in the SATA controller.
    fn get_num_sata_cdroms(&self) -> &IntOption;
}
impl<'s> serde::Serialize for dyn VirtualSataControllerOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualSataControllerOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualSataControllerOptionVisitor)
            }
        }

struct VirtualSataControllerOptionVisitor;

impl<'de> de::Visitor<'de> for VirtualSataControllerOptionVisitor {
    type Value = Box<dyn VirtualSataControllerOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualSataControllerOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualSataControllerOptionTrait for VirtualSataControllerOption {
    fn get_num_sata_disks(&self) -> &IntOption { &self.num_sata_disks }
    fn get_num_sata_cdroms(&self) -> &IntOption { &self.num_sata_cdroms }
}
impl VirtualSataControllerOptionTrait for VirtualAhciControllerOption {
    fn get_num_sata_disks(&self) -> &IntOption { &self.num_sata_disks }
    fn get_num_sata_cdroms(&self) -> &IntOption { &self.num_sata_cdroms }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualSataControllerOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualSataControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualSataControllerOption>()?),
            StructType::VirtualAhciControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualAhciControllerOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualSataControllerOption => Ok(from.as_any_box().downcast::<VirtualSataControllerOption>()?),
            StructType::VirtualAhciControllerOption => Ok(from.as_any_box().downcast::<VirtualAhciControllerOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The VirtualSCSIControllerOption data object type contains the options
/// for a virtual SCSI controller defined by the
/// *VirtualSCSIController*
/// data object type.
pub trait VirtualScsiControllerOptionTrait : super::traits::VirtualControllerOptionTrait {
    /// Three properties (numSCSIDisks.min, numSCSIDisks.max, and
    /// numSCSIDisks.defaultValue) define the minimum, maximum, and default
    /// number of SCSI VirtualDisk instances available at any given time in the
    /// SCSI controller.
    /// 
    /// The number of SCSI VirtualDisk instances is
    /// also limited by the number of available slots in the SCSI controller.
    fn get_num_scsi_disks(&self) -> &IntOption;
    /// Three properties (numSCSICdroms.min, numSCSICdroms.max, and
    /// numSCSICdroms.defaultValue) define the minimum, maximum, and default
    /// number of SCSI VirtualCdrom instances available
    /// in the SCSI controller.
    /// 
    /// The number of SCSI VirtualCdrom instances is
    /// also limited by the number of available slots in the SCSI controller.
    fn get_num_scsi_cdroms(&self) -> &IntOption;
    /// Three properties (numSCSIPassthrough.min, numSCSIPassthrough.max, and
    /// numSCSIPassthrough.defaultValue) define the minimum, maximum, and
    /// default number of VirtualSCSIPassthrough instances available
    /// have at any given time in the SCSI controller.
    /// 
    /// The number of
    /// VirtualSCSIPassthrough instances is also limited by the number of
    /// available slots in the SCSI controller.
    fn get_num_scsi_passthrough(&self) -> &IntOption;
    /// Supported shared bus modes.
    fn get_sharing(&self) -> &Vec<super::enums::VirtualScsiSharingEnum>;
    /// Index into sharing array specifying the default value.
    fn get_default_shared_index(&self) -> i32;
    /// All SCSI controllers support hot adding and removing of devices.
    /// 
    /// This
    /// support can't be toggled in the current implementation. Therefore, this
    /// option is ignored when reconfiguring a SCSI controller and is always set
    /// to "true" when reading an existing configuration.
    fn get_hot_add_remove(&self) -> &BoolOption;
    /// The unit number of the SCSI controller.
    /// 
    /// The SCSI controller sits on its
    /// own bus, so that this field defines which slot the controller will use.
    fn get_scsi_ctlr_unit_number(&self) -> i32;
}
impl<'s> serde::Serialize for dyn VirtualScsiControllerOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualScsiControllerOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualScsiControllerOptionVisitor)
            }
        }

struct VirtualScsiControllerOptionVisitor;

impl<'de> de::Visitor<'de> for VirtualScsiControllerOptionVisitor {
    type Value = Box<dyn VirtualScsiControllerOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualScsiControllerOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualScsiControllerOptionTrait for VirtualScsiControllerOption {
    fn get_num_scsi_disks(&self) -> &IntOption { &self.num_scsi_disks }
    fn get_num_scsi_cdroms(&self) -> &IntOption { &self.num_scsi_cdroms }
    fn get_num_scsi_passthrough(&self) -> &IntOption { &self.num_scsi_passthrough }
    fn get_sharing(&self) -> &Vec<super::enums::VirtualScsiSharingEnum> { &self.sharing }
    fn get_default_shared_index(&self) -> i32 { self.default_shared_index }
    fn get_hot_add_remove(&self) -> &BoolOption { &self.hot_add_remove }
    fn get_scsi_ctlr_unit_number(&self) -> i32 { self.scsi_ctlr_unit_number }
}
impl VirtualScsiControllerOptionTrait for ParaVirtualScsiControllerOption {
    fn get_num_scsi_disks(&self) -> &IntOption { &self.num_scsi_disks }
    fn get_num_scsi_cdroms(&self) -> &IntOption { &self.num_scsi_cdroms }
    fn get_num_scsi_passthrough(&self) -> &IntOption { &self.num_scsi_passthrough }
    fn get_sharing(&self) -> &Vec<super::enums::VirtualScsiSharingEnum> { &self.sharing }
    fn get_default_shared_index(&self) -> i32 { self.default_shared_index }
    fn get_hot_add_remove(&self) -> &BoolOption { &self.hot_add_remove }
    fn get_scsi_ctlr_unit_number(&self) -> i32 { self.scsi_ctlr_unit_number }
}
impl VirtualScsiControllerOptionTrait for VirtualBusLogicControllerOption {
    fn get_num_scsi_disks(&self) -> &IntOption { &self.num_scsi_disks }
    fn get_num_scsi_cdroms(&self) -> &IntOption { &self.num_scsi_cdroms }
    fn get_num_scsi_passthrough(&self) -> &IntOption { &self.num_scsi_passthrough }
    fn get_sharing(&self) -> &Vec<super::enums::VirtualScsiSharingEnum> { &self.sharing }
    fn get_default_shared_index(&self) -> i32 { self.default_shared_index }
    fn get_hot_add_remove(&self) -> &BoolOption { &self.hot_add_remove }
    fn get_scsi_ctlr_unit_number(&self) -> i32 { self.scsi_ctlr_unit_number }
}
impl VirtualScsiControllerOptionTrait for VirtualLsiLogicControllerOption {
    fn get_num_scsi_disks(&self) -> &IntOption { &self.num_scsi_disks }
    fn get_num_scsi_cdroms(&self) -> &IntOption { &self.num_scsi_cdroms }
    fn get_num_scsi_passthrough(&self) -> &IntOption { &self.num_scsi_passthrough }
    fn get_sharing(&self) -> &Vec<super::enums::VirtualScsiSharingEnum> { &self.sharing }
    fn get_default_shared_index(&self) -> i32 { self.default_shared_index }
    fn get_hot_add_remove(&self) -> &BoolOption { &self.hot_add_remove }
    fn get_scsi_ctlr_unit_number(&self) -> i32 { self.scsi_ctlr_unit_number }
}
impl VirtualScsiControllerOptionTrait for VirtualLsiLogicSasControllerOption {
    fn get_num_scsi_disks(&self) -> &IntOption { &self.num_scsi_disks }
    fn get_num_scsi_cdroms(&self) -> &IntOption { &self.num_scsi_cdroms }
    fn get_num_scsi_passthrough(&self) -> &IntOption { &self.num_scsi_passthrough }
    fn get_sharing(&self) -> &Vec<super::enums::VirtualScsiSharingEnum> { &self.sharing }
    fn get_default_shared_index(&self) -> i32 { self.default_shared_index }
    fn get_hot_add_remove(&self) -> &BoolOption { &self.hot_add_remove }
    fn get_scsi_ctlr_unit_number(&self) -> i32 { self.scsi_ctlr_unit_number }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualScsiControllerOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualScsiControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualScsiControllerOption>()?),
            StructType::ParaVirtualScsiControllerOption => Some(from.as_any_ref().downcast_ref::<ParaVirtualScsiControllerOption>()?),
            StructType::VirtualBusLogicControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualBusLogicControllerOption>()?),
            StructType::VirtualLsiLogicControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualLsiLogicControllerOption>()?),
            StructType::VirtualLsiLogicSasControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualLsiLogicSasControllerOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualScsiControllerOption => Ok(from.as_any_box().downcast::<VirtualScsiControllerOption>()?),
            StructType::ParaVirtualScsiControllerOption => Ok(from.as_any_box().downcast::<ParaVirtualScsiControllerOption>()?),
            StructType::VirtualBusLogicControllerOption => Ok(from.as_any_box().downcast::<VirtualBusLogicControllerOption>()?),
            StructType::VirtualLsiLogicControllerOption => Ok(from.as_any_box().downcast::<VirtualLsiLogicControllerOption>()?),
            StructType::VirtualLsiLogicSasControllerOption => Ok(from.as_any_box().downcast::<VirtualLsiLogicSasControllerOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type contains the options for the
/// virtual ethernet card data object type.
pub trait VirtualEthernetCardOptionTrait : super::traits::VirtualDeviceOptionTrait {
    /// The valid Organizational Unique Identifiers (OUIs)
    /// supported by this virtual Ethernet card.
    /// 
    /// <dl>
    /// <dt>Supported OUIs for statically assigned MAC addresses:</dt>
    /// <dd>"00:50:56"</dd>
    /// </dl>
    fn get_supported_oui(&self) -> &ChoiceOption;
    /// The supported MAC address types.
    fn get_mac_type(&self) -> &ChoiceOption;
    /// Flag to indicate whether or not wake-on-LAN is settable on this device.
    fn get_wake_on_lan_enabled(&self) -> &BoolOption;
    /// Deprecated as of vSphere API 8.0. VMDirectPath Gen 2 is no longer supported and
    /// there is no replacement.
    /// 
    /// Flag to indicate whether VMDirectPath Gen 2 is available on this device.
    fn get_vm_direct_path_gen_2_supported(&self) -> Option<bool>;
    /// Deprecated as of vSphere API 8.0. VMDirectPath Gen 2 is no longer supported and
    /// there is no replacement.
    /// 
    /// Flag to indicate whether Universal Pass-through(UPT) is settable on this device.
    fn get_upt_compatibility_enabled(&self) -> &Option<BoolOption>;
}
impl<'s> serde::Serialize for dyn VirtualEthernetCardOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualEthernetCardOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualEthernetCardOptionVisitor)
            }
        }

struct VirtualEthernetCardOptionVisitor;

impl<'de> de::Visitor<'de> for VirtualEthernetCardOptionVisitor {
    type Value = Box<dyn VirtualEthernetCardOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualEthernetCardOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualEthernetCardOptionTrait for VirtualEthernetCardOption {
    fn get_supported_oui(&self) -> &ChoiceOption { &self.supported_oui }
    fn get_mac_type(&self) -> &ChoiceOption { &self.mac_type }
    fn get_wake_on_lan_enabled(&self) -> &BoolOption { &self.wake_on_lan_enabled }
    fn get_vm_direct_path_gen_2_supported(&self) -> Option<bool> { self.vm_direct_path_gen_2_supported }
    fn get_upt_compatibility_enabled(&self) -> &Option<BoolOption> { &self.upt_compatibility_enabled }
}
impl VirtualEthernetCardOptionTrait for VirtualE1000Option {
    fn get_supported_oui(&self) -> &ChoiceOption { &self.supported_oui }
    fn get_mac_type(&self) -> &ChoiceOption { &self.mac_type }
    fn get_wake_on_lan_enabled(&self) -> &BoolOption { &self.wake_on_lan_enabled }
    fn get_vm_direct_path_gen_2_supported(&self) -> Option<bool> { self.vm_direct_path_gen_2_supported }
    fn get_upt_compatibility_enabled(&self) -> &Option<BoolOption> { &self.upt_compatibility_enabled }
}
impl VirtualEthernetCardOptionTrait for VirtualE1000EOption {
    fn get_supported_oui(&self) -> &ChoiceOption { &self.supported_oui }
    fn get_mac_type(&self) -> &ChoiceOption { &self.mac_type }
    fn get_wake_on_lan_enabled(&self) -> &BoolOption { &self.wake_on_lan_enabled }
    fn get_vm_direct_path_gen_2_supported(&self) -> Option<bool> { self.vm_direct_path_gen_2_supported }
    fn get_upt_compatibility_enabled(&self) -> &Option<BoolOption> { &self.upt_compatibility_enabled }
}
impl VirtualEthernetCardOptionTrait for VirtualPcNet32Option {
    fn get_supported_oui(&self) -> &ChoiceOption { &self.supported_oui }
    fn get_mac_type(&self) -> &ChoiceOption { &self.mac_type }
    fn get_wake_on_lan_enabled(&self) -> &BoolOption { &self.wake_on_lan_enabled }
    fn get_vm_direct_path_gen_2_supported(&self) -> Option<bool> { self.vm_direct_path_gen_2_supported }
    fn get_upt_compatibility_enabled(&self) -> &Option<BoolOption> { &self.upt_compatibility_enabled }
}
impl VirtualEthernetCardOptionTrait for VirtualSriovEthernetCardOption {
    fn get_supported_oui(&self) -> &ChoiceOption { &self.supported_oui }
    fn get_mac_type(&self) -> &ChoiceOption { &self.mac_type }
    fn get_wake_on_lan_enabled(&self) -> &BoolOption { &self.wake_on_lan_enabled }
    fn get_vm_direct_path_gen_2_supported(&self) -> Option<bool> { self.vm_direct_path_gen_2_supported }
    fn get_upt_compatibility_enabled(&self) -> &Option<BoolOption> { &self.upt_compatibility_enabled }
}
impl VirtualEthernetCardOptionTrait for VirtualVmxnetOption {
    fn get_supported_oui(&self) -> &ChoiceOption { &self.supported_oui }
    fn get_mac_type(&self) -> &ChoiceOption { &self.mac_type }
    fn get_wake_on_lan_enabled(&self) -> &BoolOption { &self.wake_on_lan_enabled }
    fn get_vm_direct_path_gen_2_supported(&self) -> Option<bool> { self.vm_direct_path_gen_2_supported }
    fn get_upt_compatibility_enabled(&self) -> &Option<BoolOption> { &self.upt_compatibility_enabled }
}
impl VirtualEthernetCardOptionTrait for VirtualVmxnet2Option {
    fn get_supported_oui(&self) -> &ChoiceOption { &self.supported_oui }
    fn get_mac_type(&self) -> &ChoiceOption { &self.mac_type }
    fn get_wake_on_lan_enabled(&self) -> &BoolOption { &self.wake_on_lan_enabled }
    fn get_vm_direct_path_gen_2_supported(&self) -> Option<bool> { self.vm_direct_path_gen_2_supported }
    fn get_upt_compatibility_enabled(&self) -> &Option<BoolOption> { &self.upt_compatibility_enabled }
}
impl VirtualEthernetCardOptionTrait for VirtualVmxnet3Option {
    fn get_supported_oui(&self) -> &ChoiceOption { &self.supported_oui }
    fn get_mac_type(&self) -> &ChoiceOption { &self.mac_type }
    fn get_wake_on_lan_enabled(&self) -> &BoolOption { &self.wake_on_lan_enabled }
    fn get_vm_direct_path_gen_2_supported(&self) -> Option<bool> { self.vm_direct_path_gen_2_supported }
    fn get_upt_compatibility_enabled(&self) -> &Option<BoolOption> { &self.upt_compatibility_enabled }
}
impl VirtualEthernetCardOptionTrait for VirtualVmxnet3VrdmaOption {
    fn get_supported_oui(&self) -> &ChoiceOption { &self.supported_oui }
    fn get_mac_type(&self) -> &ChoiceOption { &self.mac_type }
    fn get_wake_on_lan_enabled(&self) -> &BoolOption { &self.wake_on_lan_enabled }
    fn get_vm_direct_path_gen_2_supported(&self) -> Option<bool> { self.vm_direct_path_gen_2_supported }
    fn get_upt_compatibility_enabled(&self) -> &Option<BoolOption> { &self.upt_compatibility_enabled }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualEthernetCardOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualEthernetCardOption => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardOption>()?),
            StructType::VirtualE1000Option => Some(from.as_any_ref().downcast_ref::<VirtualE1000Option>()?),
            StructType::VirtualE1000EOption => Some(from.as_any_ref().downcast_ref::<VirtualE1000EOption>()?),
            StructType::VirtualPcNet32Option => Some(from.as_any_ref().downcast_ref::<VirtualPcNet32Option>()?),
            StructType::VirtualSriovEthernetCardOption => Some(from.as_any_ref().downcast_ref::<VirtualSriovEthernetCardOption>()?),
            StructType::VirtualVmxnetOption => Some(from.as_any_ref().downcast_ref::<VirtualVmxnetOption>()?),
            StructType::VirtualVmxnet2Option => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet2Option>()?),
            StructType::VirtualVmxnet3Option => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3Option>()?),
            StructType::VirtualVmxnet3VrdmaOption => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3VrdmaOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualEthernetCardOption => Ok(from.as_any_box().downcast::<VirtualEthernetCardOption>()?),
            StructType::VirtualE1000Option => Ok(from.as_any_box().downcast::<VirtualE1000Option>()?),
            StructType::VirtualE1000EOption => Ok(from.as_any_box().downcast::<VirtualE1000EOption>()?),
            StructType::VirtualPcNet32Option => Ok(from.as_any_box().downcast::<VirtualPcNet32Option>()?),
            StructType::VirtualSriovEthernetCardOption => Ok(from.as_any_box().downcast::<VirtualSriovEthernetCardOption>()?),
            StructType::VirtualVmxnetOption => Ok(from.as_any_box().downcast::<VirtualVmxnetOption>()?),
            StructType::VirtualVmxnet2Option => Ok(from.as_any_box().downcast::<VirtualVmxnet2Option>()?),
            StructType::VirtualVmxnet3Option => Ok(from.as_any_box().downcast::<VirtualVmxnet3Option>()?),
            StructType::VirtualVmxnet3VrdmaOption => Ok(from.as_any_box().downcast::<VirtualVmxnet3VrdmaOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The VirtualVmxnetOption data object type contains the options for the
/// *VirtualVmxnet* data object type.
pub trait VirtualVmxnetOptionTrait : super::traits::VirtualEthernetCardOptionTrait {
}
impl<'s> serde::Serialize for dyn VirtualVmxnetOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualVmxnetOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualVmxnetOptionVisitor)
            }
        }

struct VirtualVmxnetOptionVisitor;

impl<'de> de::Visitor<'de> for VirtualVmxnetOptionVisitor {
    type Value = Box<dyn VirtualVmxnetOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualVmxnetOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualVmxnetOptionTrait for VirtualVmxnetOption {
}
impl VirtualVmxnetOptionTrait for VirtualVmxnet2Option {
}
impl VirtualVmxnetOptionTrait for VirtualVmxnet3Option {
}
impl VirtualVmxnetOptionTrait for VirtualVmxnet3VrdmaOption {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualVmxnetOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualVmxnetOption => Some(from.as_any_ref().downcast_ref::<VirtualVmxnetOption>()?),
            StructType::VirtualVmxnet2Option => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet2Option>()?),
            StructType::VirtualVmxnet3Option => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3Option>()?),
            StructType::VirtualVmxnet3VrdmaOption => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3VrdmaOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualVmxnetOption => Ok(from.as_any_box().downcast::<VirtualVmxnetOption>()?),
            StructType::VirtualVmxnet2Option => Ok(from.as_any_box().downcast::<VirtualVmxnet2Option>()?),
            StructType::VirtualVmxnet3Option => Ok(from.as_any_box().downcast::<VirtualVmxnet3Option>()?),
            StructType::VirtualVmxnet3VrdmaOption => Ok(from.as_any_box().downcast::<VirtualVmxnet3VrdmaOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The VirtualVmxnet3Option data object type contains the options for the
/// *VirtualVmxnet3* data object type.
pub trait VirtualVmxnet3OptionTrait : super::traits::VirtualVmxnetOptionTrait {
    /// Flag to indicate whether UPTv2(Uniform Pass-through version 2) is
    /// settable on this device.
    /// 
    /// ***Since:*** vSphere API Release 8.0.0.1
    fn get_uptv_2_enabled(&self) -> &Option<BoolOption>;
}
impl<'s> serde::Serialize for dyn VirtualVmxnet3OptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualVmxnet3OptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualVmxnet3OptionVisitor)
            }
        }

struct VirtualVmxnet3OptionVisitor;

impl<'de> de::Visitor<'de> for VirtualVmxnet3OptionVisitor {
    type Value = Box<dyn VirtualVmxnet3OptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualVmxnet3OptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualVmxnet3OptionTrait for VirtualVmxnet3Option {
    fn get_uptv_2_enabled(&self) -> &Option<BoolOption> { &self.uptv_2_enabled }
}
impl VirtualVmxnet3OptionTrait for VirtualVmxnet3VrdmaOption {
    fn get_uptv_2_enabled(&self) -> &Option<BoolOption> { &self.uptv_2_enabled }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualVmxnet3OptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualVmxnet3Option => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3Option>()?),
            StructType::VirtualVmxnet3VrdmaOption => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3VrdmaOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualVmxnet3Option => Ok(from.as_any_box().downcast::<VirtualVmxnet3Option>()?),
            StructType::VirtualVmxnet3VrdmaOption => Ok(from.as_any_box().downcast::<VirtualVmxnet3VrdmaOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The VirtualSoundCardOption data class contains the options for the
/// virtual sound card class.
pub trait VirtualSoundCardOptionTrait : super::traits::VirtualDeviceOptionTrait {
}
impl<'s> serde::Serialize for dyn VirtualSoundCardOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualSoundCardOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualSoundCardOptionVisitor)
            }
        }

struct VirtualSoundCardOptionVisitor;

impl<'de> de::Visitor<'de> for VirtualSoundCardOptionVisitor {
    type Value = Box<dyn VirtualSoundCardOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualSoundCardOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualSoundCardOptionTrait for VirtualSoundCardOption {
}
impl VirtualSoundCardOptionTrait for VirtualEnsoniq1371Option {
}
impl VirtualSoundCardOptionTrait for VirtualHdAudioCardOption {
}
impl VirtualSoundCardOptionTrait for VirtualSoundBlaster16Option {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualSoundCardOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualSoundCardOption => Some(from.as_any_ref().downcast_ref::<VirtualSoundCardOption>()?),
            StructType::VirtualEnsoniq1371Option => Some(from.as_any_ref().downcast_ref::<VirtualEnsoniq1371Option>()?),
            StructType::VirtualHdAudioCardOption => Some(from.as_any_ref().downcast_ref::<VirtualHdAudioCardOption>()?),
            StructType::VirtualSoundBlaster16Option => Some(from.as_any_ref().downcast_ref::<VirtualSoundBlaster16Option>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualSoundCardOption => Ok(from.as_any_box().downcast::<VirtualSoundCardOption>()?),
            StructType::VirtualEnsoniq1371Option => Ok(from.as_any_box().downcast::<VirtualEnsoniq1371Option>()?),
            StructType::VirtualHdAudioCardOption => Ok(from.as_any_box().downcast::<VirtualHdAudioCardOption>()?),
            StructType::VirtualSoundBlaster16Option => Ok(from.as_any_box().downcast::<VirtualSoundBlaster16Option>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *VirtualDeviceBackingOption* data class
/// defines options for device-specific virtual backing objects.
pub trait VirtualDeviceBackingOptionTrait : super::traits::DataObjectTrait {
    /// The name of the class the client should use to instantiate backing
    /// for the virtual device.
    fn get_type(&self) -> &str;
}
impl<'s> serde::Serialize for dyn VirtualDeviceBackingOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDeviceBackingOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDeviceBackingOptionVisitor)
            }
        }

struct VirtualDeviceBackingOptionVisitor;

impl<'de> de::Visitor<'de> for VirtualDeviceBackingOptionVisitor {
    type Value = Box<dyn VirtualDeviceBackingOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDeviceBackingOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDeviceBackingOptionTrait for VirtualDeviceBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualDeviceDeviceBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualCdromAtapiBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualCdromPassthroughBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualCdromRemoteAtapiBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualDiskRawDiskMappingVer1BackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualDiskRawDiskVer2BackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualDiskPartitionedRawDiskVer2BackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualEthernetCardLegacyNetworkBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualEthernetCardNetworkBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualFloppyDeviceBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualPciPassthroughDeviceBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualPciPassthroughDynamicBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualParallelPortDeviceBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualPointingDeviceBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualScsiPassthroughDeviceBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualSerialPortDeviceBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualSoundCardDeviceBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualUsbRemoteHostBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualUsbusbBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualDeviceFileBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualCdromIsoBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualDiskFlatVer1BackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualDiskFlatVer2BackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualDiskLocalPMemBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualDiskSeSparseBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualDiskSparseVer1BackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualDiskSparseVer2BackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualFloppyImageBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualParallelPortFileBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualSerialPortFileBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualDevicePipeBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualSerialPortPipeBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualDeviceRemoteDeviceBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualCdromRemotePassthroughBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualFloppyRemoteDeviceBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualUsbRemoteClientBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualDeviceUriBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualSerialPortUriBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualEthernetCardDvPortBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualEthernetCardOpaqueNetworkBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualPciPassthroughDvxBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualPciPassthroughPluginBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualPciPassthroughVmiopBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualPrecisionClockSystemClockBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualSerialPortThinPrintBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualSriovEthernetCardSriovBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDeviceBackingOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDeviceBackingOption>()?),
            StructType::VirtualDeviceDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDeviceDeviceBackingOption>()?),
            StructType::VirtualCdromAtapiBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualCdromAtapiBackingOption>()?),
            StructType::VirtualCdromPassthroughBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualCdromPassthroughBackingOption>()?),
            StructType::VirtualCdromRemoteAtapiBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualCdromRemoteAtapiBackingOption>()?),
            StructType::VirtualDiskRawDiskMappingVer1BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskRawDiskMappingVer1BackingOption>()?),
            StructType::VirtualDiskRawDiskVer2BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskRawDiskVer2BackingOption>()?),
            StructType::VirtualDiskPartitionedRawDiskVer2BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskPartitionedRawDiskVer2BackingOption>()?),
            StructType::VirtualEthernetCardLegacyNetworkBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardLegacyNetworkBackingOption>()?),
            StructType::VirtualEthernetCardNetworkBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardNetworkBackingOption>()?),
            StructType::VirtualFloppyDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualFloppyDeviceBackingOption>()?),
            StructType::VirtualPciPassthroughDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughDeviceBackingOption>()?),
            StructType::VirtualPciPassthroughDynamicBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughDynamicBackingOption>()?),
            StructType::VirtualParallelPortDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualParallelPortDeviceBackingOption>()?),
            StructType::VirtualPointingDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPointingDeviceBackingOption>()?),
            StructType::VirtualScsiPassthroughDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualScsiPassthroughDeviceBackingOption>()?),
            StructType::VirtualSerialPortDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortDeviceBackingOption>()?),
            StructType::VirtualSoundCardDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSoundCardDeviceBackingOption>()?),
            StructType::VirtualUsbRemoteHostBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualUsbRemoteHostBackingOption>()?),
            StructType::VirtualUsbusbBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualUsbusbBackingOption>()?),
            StructType::VirtualDeviceFileBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDeviceFileBackingOption>()?),
            StructType::VirtualCdromIsoBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualCdromIsoBackingOption>()?),
            StructType::VirtualDiskFlatVer1BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskFlatVer1BackingOption>()?),
            StructType::VirtualDiskFlatVer2BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskFlatVer2BackingOption>()?),
            StructType::VirtualDiskLocalPMemBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskLocalPMemBackingOption>()?),
            StructType::VirtualDiskSeSparseBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskSeSparseBackingOption>()?),
            StructType::VirtualDiskSparseVer1BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskSparseVer1BackingOption>()?),
            StructType::VirtualDiskSparseVer2BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskSparseVer2BackingOption>()?),
            StructType::VirtualFloppyImageBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualFloppyImageBackingOption>()?),
            StructType::VirtualParallelPortFileBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualParallelPortFileBackingOption>()?),
            StructType::VirtualSerialPortFileBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortFileBackingOption>()?),
            StructType::VirtualDevicePipeBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDevicePipeBackingOption>()?),
            StructType::VirtualSerialPortPipeBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortPipeBackingOption>()?),
            StructType::VirtualDeviceRemoteDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDeviceRemoteDeviceBackingOption>()?),
            StructType::VirtualCdromRemotePassthroughBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualCdromRemotePassthroughBackingOption>()?),
            StructType::VirtualFloppyRemoteDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualFloppyRemoteDeviceBackingOption>()?),
            StructType::VirtualUsbRemoteClientBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualUsbRemoteClientBackingOption>()?),
            StructType::VirtualDeviceUriBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDeviceUriBackingOption>()?),
            StructType::VirtualSerialPortUriBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortUriBackingOption>()?),
            StructType::VirtualEthernetCardDvPortBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardDvPortBackingOption>()?),
            StructType::VirtualEthernetCardOpaqueNetworkBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardOpaqueNetworkBackingOption>()?),
            StructType::VirtualPciPassthroughDvxBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughDvxBackingOption>()?),
            StructType::VirtualPciPassthroughPluginBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughPluginBackingOption>()?),
            StructType::VirtualPciPassthroughVmiopBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughVmiopBackingOption>()?),
            StructType::VirtualPrecisionClockSystemClockBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPrecisionClockSystemClockBackingOption>()?),
            StructType::VirtualSerialPortThinPrintBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortThinPrintBackingOption>()?),
            StructType::VirtualSriovEthernetCardSriovBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSriovEthernetCardSriovBackingOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualDeviceBackingOption>()?),
            StructType::VirtualDeviceDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualDeviceDeviceBackingOption>()?),
            StructType::VirtualCdromAtapiBackingOption => Ok(from.as_any_box().downcast::<VirtualCdromAtapiBackingOption>()?),
            StructType::VirtualCdromPassthroughBackingOption => Ok(from.as_any_box().downcast::<VirtualCdromPassthroughBackingOption>()?),
            StructType::VirtualCdromRemoteAtapiBackingOption => Ok(from.as_any_box().downcast::<VirtualCdromRemoteAtapiBackingOption>()?),
            StructType::VirtualDiskRawDiskMappingVer1BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskRawDiskMappingVer1BackingOption>()?),
            StructType::VirtualDiskRawDiskVer2BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskRawDiskVer2BackingOption>()?),
            StructType::VirtualDiskPartitionedRawDiskVer2BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskPartitionedRawDiskVer2BackingOption>()?),
            StructType::VirtualEthernetCardLegacyNetworkBackingOption => Ok(from.as_any_box().downcast::<VirtualEthernetCardLegacyNetworkBackingOption>()?),
            StructType::VirtualEthernetCardNetworkBackingOption => Ok(from.as_any_box().downcast::<VirtualEthernetCardNetworkBackingOption>()?),
            StructType::VirtualFloppyDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualFloppyDeviceBackingOption>()?),
            StructType::VirtualPciPassthroughDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualPciPassthroughDeviceBackingOption>()?),
            StructType::VirtualPciPassthroughDynamicBackingOption => Ok(from.as_any_box().downcast::<VirtualPciPassthroughDynamicBackingOption>()?),
            StructType::VirtualParallelPortDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualParallelPortDeviceBackingOption>()?),
            StructType::VirtualPointingDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualPointingDeviceBackingOption>()?),
            StructType::VirtualScsiPassthroughDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualScsiPassthroughDeviceBackingOption>()?),
            StructType::VirtualSerialPortDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualSerialPortDeviceBackingOption>()?),
            StructType::VirtualSoundCardDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualSoundCardDeviceBackingOption>()?),
            StructType::VirtualUsbRemoteHostBackingOption => Ok(from.as_any_box().downcast::<VirtualUsbRemoteHostBackingOption>()?),
            StructType::VirtualUsbusbBackingOption => Ok(from.as_any_box().downcast::<VirtualUsbusbBackingOption>()?),
            StructType::VirtualDeviceFileBackingOption => Ok(from.as_any_box().downcast::<VirtualDeviceFileBackingOption>()?),
            StructType::VirtualCdromIsoBackingOption => Ok(from.as_any_box().downcast::<VirtualCdromIsoBackingOption>()?),
            StructType::VirtualDiskFlatVer1BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskFlatVer1BackingOption>()?),
            StructType::VirtualDiskFlatVer2BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskFlatVer2BackingOption>()?),
            StructType::VirtualDiskLocalPMemBackingOption => Ok(from.as_any_box().downcast::<VirtualDiskLocalPMemBackingOption>()?),
            StructType::VirtualDiskSeSparseBackingOption => Ok(from.as_any_box().downcast::<VirtualDiskSeSparseBackingOption>()?),
            StructType::VirtualDiskSparseVer1BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskSparseVer1BackingOption>()?),
            StructType::VirtualDiskSparseVer2BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskSparseVer2BackingOption>()?),
            StructType::VirtualFloppyImageBackingOption => Ok(from.as_any_box().downcast::<VirtualFloppyImageBackingOption>()?),
            StructType::VirtualParallelPortFileBackingOption => Ok(from.as_any_box().downcast::<VirtualParallelPortFileBackingOption>()?),
            StructType::VirtualSerialPortFileBackingOption => Ok(from.as_any_box().downcast::<VirtualSerialPortFileBackingOption>()?),
            StructType::VirtualDevicePipeBackingOption => Ok(from.as_any_box().downcast::<VirtualDevicePipeBackingOption>()?),
            StructType::VirtualSerialPortPipeBackingOption => Ok(from.as_any_box().downcast::<VirtualSerialPortPipeBackingOption>()?),
            StructType::VirtualDeviceRemoteDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualDeviceRemoteDeviceBackingOption>()?),
            StructType::VirtualCdromRemotePassthroughBackingOption => Ok(from.as_any_box().downcast::<VirtualCdromRemotePassthroughBackingOption>()?),
            StructType::VirtualFloppyRemoteDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualFloppyRemoteDeviceBackingOption>()?),
            StructType::VirtualUsbRemoteClientBackingOption => Ok(from.as_any_box().downcast::<VirtualUsbRemoteClientBackingOption>()?),
            StructType::VirtualDeviceUriBackingOption => Ok(from.as_any_box().downcast::<VirtualDeviceUriBackingOption>()?),
            StructType::VirtualSerialPortUriBackingOption => Ok(from.as_any_box().downcast::<VirtualSerialPortUriBackingOption>()?),
            StructType::VirtualEthernetCardDvPortBackingOption => Ok(from.as_any_box().downcast::<VirtualEthernetCardDvPortBackingOption>()?),
            StructType::VirtualEthernetCardOpaqueNetworkBackingOption => Ok(from.as_any_box().downcast::<VirtualEthernetCardOpaqueNetworkBackingOption>()?),
            StructType::VirtualPciPassthroughDvxBackingOption => Ok(from.as_any_box().downcast::<VirtualPciPassthroughDvxBackingOption>()?),
            StructType::VirtualPciPassthroughPluginBackingOption => Ok(from.as_any_box().downcast::<VirtualPciPassthroughPluginBackingOption>()?),
            StructType::VirtualPciPassthroughVmiopBackingOption => Ok(from.as_any_box().downcast::<VirtualPciPassthroughVmiopBackingOption>()?),
            StructType::VirtualPrecisionClockSystemClockBackingOption => Ok(from.as_any_box().downcast::<VirtualPrecisionClockSystemClockBackingOption>()?),
            StructType::VirtualSerialPortThinPrintBackingOption => Ok(from.as_any_box().downcast::<VirtualSerialPortThinPrintBackingOption>()?),
            StructType::VirtualSriovEthernetCardSriovBackingOption => Ok(from.as_any_box().downcast::<VirtualSriovEthernetCardSriovBackingOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The DeviceBackingOption data class contains device-specific backing options.
pub trait VirtualDeviceDeviceBackingOptionTrait : super::traits::VirtualDeviceBackingOptionTrait {
    /// Flag to indicate whether the specific instance of this device can
    /// be auto-detected on the host instead of having to specify a
    /// particular physical device.
    fn get_auto_detect_available(&self) -> &BoolOption;
}
impl<'s> serde::Serialize for dyn VirtualDeviceDeviceBackingOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDeviceDeviceBackingOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDeviceDeviceBackingOptionVisitor)
            }
        }

struct VirtualDeviceDeviceBackingOptionVisitor;

impl<'de> de::Visitor<'de> for VirtualDeviceDeviceBackingOptionVisitor {
    type Value = Box<dyn VirtualDeviceDeviceBackingOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDeviceDeviceBackingOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDeviceDeviceBackingOptionTrait for VirtualDeviceDeviceBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceDeviceBackingOptionTrait for VirtualCdromAtapiBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceDeviceBackingOptionTrait for VirtualCdromPassthroughBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceDeviceBackingOptionTrait for VirtualCdromRemoteAtapiBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceDeviceBackingOptionTrait for VirtualDiskRawDiskMappingVer1BackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceDeviceBackingOptionTrait for VirtualDiskRawDiskVer2BackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceDeviceBackingOptionTrait for VirtualDiskPartitionedRawDiskVer2BackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceDeviceBackingOptionTrait for VirtualEthernetCardLegacyNetworkBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceDeviceBackingOptionTrait for VirtualEthernetCardNetworkBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceDeviceBackingOptionTrait for VirtualFloppyDeviceBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceDeviceBackingOptionTrait for VirtualPciPassthroughDeviceBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceDeviceBackingOptionTrait for VirtualPciPassthroughDynamicBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceDeviceBackingOptionTrait for VirtualParallelPortDeviceBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceDeviceBackingOptionTrait for VirtualPointingDeviceBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceDeviceBackingOptionTrait for VirtualScsiPassthroughDeviceBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceDeviceBackingOptionTrait for VirtualSerialPortDeviceBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceDeviceBackingOptionTrait for VirtualSoundCardDeviceBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceDeviceBackingOptionTrait for VirtualUsbRemoteHostBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceDeviceBackingOptionTrait for VirtualUsbusbBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDeviceDeviceBackingOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDeviceDeviceBackingOption>()?),
            StructType::VirtualCdromAtapiBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualCdromAtapiBackingOption>()?),
            StructType::VirtualCdromPassthroughBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualCdromPassthroughBackingOption>()?),
            StructType::VirtualCdromRemoteAtapiBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualCdromRemoteAtapiBackingOption>()?),
            StructType::VirtualDiskRawDiskMappingVer1BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskRawDiskMappingVer1BackingOption>()?),
            StructType::VirtualDiskRawDiskVer2BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskRawDiskVer2BackingOption>()?),
            StructType::VirtualDiskPartitionedRawDiskVer2BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskPartitionedRawDiskVer2BackingOption>()?),
            StructType::VirtualEthernetCardLegacyNetworkBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardLegacyNetworkBackingOption>()?),
            StructType::VirtualEthernetCardNetworkBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardNetworkBackingOption>()?),
            StructType::VirtualFloppyDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualFloppyDeviceBackingOption>()?),
            StructType::VirtualPciPassthroughDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughDeviceBackingOption>()?),
            StructType::VirtualPciPassthroughDynamicBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughDynamicBackingOption>()?),
            StructType::VirtualParallelPortDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualParallelPortDeviceBackingOption>()?),
            StructType::VirtualPointingDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPointingDeviceBackingOption>()?),
            StructType::VirtualScsiPassthroughDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualScsiPassthroughDeviceBackingOption>()?),
            StructType::VirtualSerialPortDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortDeviceBackingOption>()?),
            StructType::VirtualSoundCardDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSoundCardDeviceBackingOption>()?),
            StructType::VirtualUsbRemoteHostBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualUsbRemoteHostBackingOption>()?),
            StructType::VirtualUsbusbBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualUsbusbBackingOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualDeviceDeviceBackingOption>()?),
            StructType::VirtualCdromAtapiBackingOption => Ok(from.as_any_box().downcast::<VirtualCdromAtapiBackingOption>()?),
            StructType::VirtualCdromPassthroughBackingOption => Ok(from.as_any_box().downcast::<VirtualCdromPassthroughBackingOption>()?),
            StructType::VirtualCdromRemoteAtapiBackingOption => Ok(from.as_any_box().downcast::<VirtualCdromRemoteAtapiBackingOption>()?),
            StructType::VirtualDiskRawDiskMappingVer1BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskRawDiskMappingVer1BackingOption>()?),
            StructType::VirtualDiskRawDiskVer2BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskRawDiskVer2BackingOption>()?),
            StructType::VirtualDiskPartitionedRawDiskVer2BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskPartitionedRawDiskVer2BackingOption>()?),
            StructType::VirtualEthernetCardLegacyNetworkBackingOption => Ok(from.as_any_box().downcast::<VirtualEthernetCardLegacyNetworkBackingOption>()?),
            StructType::VirtualEthernetCardNetworkBackingOption => Ok(from.as_any_box().downcast::<VirtualEthernetCardNetworkBackingOption>()?),
            StructType::VirtualFloppyDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualFloppyDeviceBackingOption>()?),
            StructType::VirtualPciPassthroughDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualPciPassthroughDeviceBackingOption>()?),
            StructType::VirtualPciPassthroughDynamicBackingOption => Ok(from.as_any_box().downcast::<VirtualPciPassthroughDynamicBackingOption>()?),
            StructType::VirtualParallelPortDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualParallelPortDeviceBackingOption>()?),
            StructType::VirtualPointingDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualPointingDeviceBackingOption>()?),
            StructType::VirtualScsiPassthroughDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualScsiPassthroughDeviceBackingOption>()?),
            StructType::VirtualSerialPortDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualSerialPortDeviceBackingOption>()?),
            StructType::VirtualSoundCardDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualSoundCardDeviceBackingOption>()?),
            StructType::VirtualUsbRemoteHostBackingOption => Ok(from.as_any_box().downcast::<VirtualUsbRemoteHostBackingOption>()?),
            StructType::VirtualUsbusbBackingOption => Ok(from.as_any_box().downcast::<VirtualUsbusbBackingOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The VirtualDiskOption.RawDiskVer2BackingOption object type
/// contains the available options when backing a virtual disk
/// using a host device on VMware Server.
pub trait VirtualDiskRawDiskVer2BackingOptionTrait : super::traits::VirtualDeviceDeviceBackingOptionTrait {
    /// Valid extensions for the filename of the raw disk descriptor
    /// file.
    fn get_descriptor_file_name_extensions(&self) -> &ChoiceOption;
    /// Flag to indicate whether this backing supports disk UUID property.
    fn get_uuid(&self) -> bool;
}
impl<'s> serde::Serialize for dyn VirtualDiskRawDiskVer2BackingOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDiskRawDiskVer2BackingOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDiskRawDiskVer2BackingOptionVisitor)
            }
        }

struct VirtualDiskRawDiskVer2BackingOptionVisitor;

impl<'de> de::Visitor<'de> for VirtualDiskRawDiskVer2BackingOptionVisitor {
    type Value = Box<dyn VirtualDiskRawDiskVer2BackingOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDiskRawDiskVer2BackingOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDiskRawDiskVer2BackingOptionTrait for VirtualDiskRawDiskVer2BackingOption {
    fn get_descriptor_file_name_extensions(&self) -> &ChoiceOption { &self.descriptor_file_name_extensions }
    fn get_uuid(&self) -> bool { self.uuid }
}
impl VirtualDiskRawDiskVer2BackingOptionTrait for VirtualDiskPartitionedRawDiskVer2BackingOption {
    fn get_descriptor_file_name_extensions(&self) -> &ChoiceOption { &self.descriptor_file_name_extensions }
    fn get_uuid(&self) -> bool { self.uuid }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDiskRawDiskVer2BackingOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDiskRawDiskVer2BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskRawDiskVer2BackingOption>()?),
            StructType::VirtualDiskPartitionedRawDiskVer2BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskPartitionedRawDiskVer2BackingOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDiskRawDiskVer2BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskRawDiskVer2BackingOption>()?),
            StructType::VirtualDiskPartitionedRawDiskVer2BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskPartitionedRawDiskVer2BackingOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The FileBackingOption data class contains file-specific backing options.
pub trait VirtualDeviceFileBackingOptionTrait : super::traits::VirtualDeviceBackingOptionTrait {
    /// Valid filename extension for the filename.
    /// 
    /// If no extensions are present, any file extension is acceptable.
    fn get_file_name_extensions(&self) -> &Option<ChoiceOption>;
}
impl<'s> serde::Serialize for dyn VirtualDeviceFileBackingOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDeviceFileBackingOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDeviceFileBackingOptionVisitor)
            }
        }

struct VirtualDeviceFileBackingOptionVisitor;

impl<'de> de::Visitor<'de> for VirtualDeviceFileBackingOptionVisitor {
    type Value = Box<dyn VirtualDeviceFileBackingOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDeviceFileBackingOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDeviceFileBackingOptionTrait for VirtualDeviceFileBackingOption {
    fn get_file_name_extensions(&self) -> &Option<ChoiceOption> { &self.file_name_extensions }
}
impl VirtualDeviceFileBackingOptionTrait for VirtualCdromIsoBackingOption {
    fn get_file_name_extensions(&self) -> &Option<ChoiceOption> { &self.file_name_extensions }
}
impl VirtualDeviceFileBackingOptionTrait for VirtualDiskFlatVer1BackingOption {
    fn get_file_name_extensions(&self) -> &Option<ChoiceOption> { &self.file_name_extensions }
}
impl VirtualDeviceFileBackingOptionTrait for VirtualDiskFlatVer2BackingOption {
    fn get_file_name_extensions(&self) -> &Option<ChoiceOption> { &self.file_name_extensions }
}
impl VirtualDeviceFileBackingOptionTrait for VirtualDiskLocalPMemBackingOption {
    fn get_file_name_extensions(&self) -> &Option<ChoiceOption> { &self.file_name_extensions }
}
impl VirtualDeviceFileBackingOptionTrait for VirtualDiskSeSparseBackingOption {
    fn get_file_name_extensions(&self) -> &Option<ChoiceOption> { &self.file_name_extensions }
}
impl VirtualDeviceFileBackingOptionTrait for VirtualDiskSparseVer1BackingOption {
    fn get_file_name_extensions(&self) -> &Option<ChoiceOption> { &self.file_name_extensions }
}
impl VirtualDeviceFileBackingOptionTrait for VirtualDiskSparseVer2BackingOption {
    fn get_file_name_extensions(&self) -> &Option<ChoiceOption> { &self.file_name_extensions }
}
impl VirtualDeviceFileBackingOptionTrait for VirtualFloppyImageBackingOption {
    fn get_file_name_extensions(&self) -> &Option<ChoiceOption> { &self.file_name_extensions }
}
impl VirtualDeviceFileBackingOptionTrait for VirtualParallelPortFileBackingOption {
    fn get_file_name_extensions(&self) -> &Option<ChoiceOption> { &self.file_name_extensions }
}
impl VirtualDeviceFileBackingOptionTrait for VirtualSerialPortFileBackingOption {
    fn get_file_name_extensions(&self) -> &Option<ChoiceOption> { &self.file_name_extensions }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDeviceFileBackingOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceFileBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDeviceFileBackingOption>()?),
            StructType::VirtualCdromIsoBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualCdromIsoBackingOption>()?),
            StructType::VirtualDiskFlatVer1BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskFlatVer1BackingOption>()?),
            StructType::VirtualDiskFlatVer2BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskFlatVer2BackingOption>()?),
            StructType::VirtualDiskLocalPMemBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskLocalPMemBackingOption>()?),
            StructType::VirtualDiskSeSparseBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskSeSparseBackingOption>()?),
            StructType::VirtualDiskSparseVer1BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskSparseVer1BackingOption>()?),
            StructType::VirtualDiskSparseVer2BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskSparseVer2BackingOption>()?),
            StructType::VirtualFloppyImageBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualFloppyImageBackingOption>()?),
            StructType::VirtualParallelPortFileBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualParallelPortFileBackingOption>()?),
            StructType::VirtualSerialPortFileBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortFileBackingOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceFileBackingOption => Ok(from.as_any_box().downcast::<VirtualDeviceFileBackingOption>()?),
            StructType::VirtualCdromIsoBackingOption => Ok(from.as_any_box().downcast::<VirtualCdromIsoBackingOption>()?),
            StructType::VirtualDiskFlatVer1BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskFlatVer1BackingOption>()?),
            StructType::VirtualDiskFlatVer2BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskFlatVer2BackingOption>()?),
            StructType::VirtualDiskLocalPMemBackingOption => Ok(from.as_any_box().downcast::<VirtualDiskLocalPMemBackingOption>()?),
            StructType::VirtualDiskSeSparseBackingOption => Ok(from.as_any_box().downcast::<VirtualDiskSeSparseBackingOption>()?),
            StructType::VirtualDiskSparseVer1BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskSparseVer1BackingOption>()?),
            StructType::VirtualDiskSparseVer2BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskSparseVer2BackingOption>()?),
            StructType::VirtualFloppyImageBackingOption => Ok(from.as_any_box().downcast::<VirtualFloppyImageBackingOption>()?),
            StructType::VirtualParallelPortFileBackingOption => Ok(from.as_any_box().downcast::<VirtualParallelPortFileBackingOption>()?),
            StructType::VirtualSerialPortFileBackingOption => Ok(from.as_any_box().downcast::<VirtualSerialPortFileBackingOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The <code>*VirtualDevicePipeBackingOption*</code> data object type contains options
/// specific to pipe backings.
pub trait VirtualDevicePipeBackingOptionTrait : super::traits::VirtualDeviceBackingOptionTrait {
}
impl<'s> serde::Serialize for dyn VirtualDevicePipeBackingOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDevicePipeBackingOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDevicePipeBackingOptionVisitor)
            }
        }

struct VirtualDevicePipeBackingOptionVisitor;

impl<'de> de::Visitor<'de> for VirtualDevicePipeBackingOptionVisitor {
    type Value = Box<dyn VirtualDevicePipeBackingOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDevicePipeBackingOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDevicePipeBackingOptionTrait for VirtualDevicePipeBackingOption {
}
impl VirtualDevicePipeBackingOptionTrait for VirtualSerialPortPipeBackingOption {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDevicePipeBackingOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDevicePipeBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDevicePipeBackingOption>()?),
            StructType::VirtualSerialPortPipeBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortPipeBackingOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDevicePipeBackingOption => Ok(from.as_any_box().downcast::<VirtualDevicePipeBackingOption>()?),
            StructType::VirtualSerialPortPipeBackingOption => Ok(from.as_any_box().downcast::<VirtualSerialPortPipeBackingOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// VirtualDeviceOption.RemoteDeviceBackingOption describes the options
/// for a remote device backing.
/// 
/// The primary difference
/// between a remote device backing and a local device backing is that
/// the VirtualCenter server cannot provide a list of remote host devices
/// available for this virtual device backing.
pub trait VirtualDeviceRemoteDeviceBackingOptionTrait : super::traits::VirtualDeviceBackingOptionTrait {
    /// Flag to indicate whether the specific instance of this device can
    /// be auto-detected on the host instead of having to specify a
    /// particular physical device.
    fn get_auto_detect_available(&self) -> &BoolOption;
}
impl<'s> serde::Serialize for dyn VirtualDeviceRemoteDeviceBackingOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDeviceRemoteDeviceBackingOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDeviceRemoteDeviceBackingOptionVisitor)
            }
        }

struct VirtualDeviceRemoteDeviceBackingOptionVisitor;

impl<'de> de::Visitor<'de> for VirtualDeviceRemoteDeviceBackingOptionVisitor {
    type Value = Box<dyn VirtualDeviceRemoteDeviceBackingOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDeviceRemoteDeviceBackingOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDeviceRemoteDeviceBackingOptionTrait for VirtualDeviceRemoteDeviceBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceRemoteDeviceBackingOptionTrait for VirtualCdromRemotePassthroughBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceRemoteDeviceBackingOptionTrait for VirtualFloppyRemoteDeviceBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceRemoteDeviceBackingOptionTrait for VirtualUsbRemoteClientBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDeviceRemoteDeviceBackingOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceRemoteDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDeviceRemoteDeviceBackingOption>()?),
            StructType::VirtualCdromRemotePassthroughBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualCdromRemotePassthroughBackingOption>()?),
            StructType::VirtualFloppyRemoteDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualFloppyRemoteDeviceBackingOption>()?),
            StructType::VirtualUsbRemoteClientBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualUsbRemoteClientBackingOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceRemoteDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualDeviceRemoteDeviceBackingOption>()?),
            StructType::VirtualCdromRemotePassthroughBackingOption => Ok(from.as_any_box().downcast::<VirtualCdromRemotePassthroughBackingOption>()?),
            StructType::VirtualFloppyRemoteDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualFloppyRemoteDeviceBackingOption>()?),
            StructType::VirtualUsbRemoteClientBackingOption => Ok(from.as_any_box().downcast::<VirtualUsbRemoteClientBackingOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *VirtualDeviceURIBackingOption* data object type describes network communication
/// options for virtual devices.
/// 
/// When establishing a connection with a remote system on the network,
/// the virtual machine can act as a server or a client.
/// When the virtual machine acts as a server, it accepts a connection.
/// When the virtual machine acts as a client, it initiates the connection.
pub trait VirtualDeviceUriBackingOptionTrait : super::traits::VirtualDeviceBackingOptionTrait {
    /// List of possible directions.
    /// 
    /// Valid directions are:
    /// - *server*
    /// - *client*
    fn get_directions(&self) -> &ChoiceOption;
}
impl<'s> serde::Serialize for dyn VirtualDeviceUriBackingOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDeviceUriBackingOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDeviceUriBackingOptionVisitor)
            }
        }

struct VirtualDeviceUriBackingOptionVisitor;

impl<'de> de::Visitor<'de> for VirtualDeviceUriBackingOptionVisitor {
    type Value = Box<dyn VirtualDeviceUriBackingOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDeviceUriBackingOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDeviceUriBackingOptionTrait for VirtualDeviceUriBackingOption {
    fn get_directions(&self) -> &ChoiceOption { &self.directions }
}
impl VirtualDeviceUriBackingOptionTrait for VirtualSerialPortUriBackingOption {
    fn get_directions(&self) -> &ChoiceOption { &self.directions }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDeviceUriBackingOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceUriBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDeviceUriBackingOption>()?),
            StructType::VirtualSerialPortUriBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortUriBackingOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceUriBackingOption => Ok(from.as_any_box().downcast::<VirtualDeviceUriBackingOption>()?),
            StructType::VirtualSerialPortUriBackingOption => Ok(from.as_any_box().downcast::<VirtualSerialPortUriBackingOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type describes the options for the
/// *VirtualPCIPassthroughPluginBackingInfo* data object type.
pub trait VirtualPciPassthroughPluginBackingOptionTrait : super::traits::VirtualDeviceBackingOptionTrait {
}
impl<'s> serde::Serialize for dyn VirtualPciPassthroughPluginBackingOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualPciPassthroughPluginBackingOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualPciPassthroughPluginBackingOptionVisitor)
            }
        }

struct VirtualPciPassthroughPluginBackingOptionVisitor;

impl<'de> de::Visitor<'de> for VirtualPciPassthroughPluginBackingOptionVisitor {
    type Value = Box<dyn VirtualPciPassthroughPluginBackingOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualPciPassthroughPluginBackingOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualPciPassthroughPluginBackingOptionTrait for VirtualPciPassthroughPluginBackingOption {
}
impl VirtualPciPassthroughPluginBackingOptionTrait for VirtualPciPassthroughVmiopBackingOption {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualPciPassthroughPluginBackingOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualPciPassthroughPluginBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughPluginBackingOption>()?),
            StructType::VirtualPciPassthroughVmiopBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughVmiopBackingOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualPciPassthroughPluginBackingOption => Ok(from.as_any_box().downcast::<VirtualPciPassthroughPluginBackingOption>()?),
            StructType::VirtualPciPassthroughVmiopBackingOption => Ok(from.as_any_box().downcast::<VirtualPciPassthroughVmiopBackingOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The VirtualDeviceSpec data object type encapsulates change
/// specifications for an individual virtual device.
/// 
/// The virtual
/// device being added or modified must be fully specified.
pub trait VirtualDeviceConfigSpecTrait : super::traits::DataObjectTrait {
    /// Type of operation being performed on the specified virtual device.
    /// 
    /// If no operation is specified, the spec. is ignored.
    fn get_operation(&self) -> &Option<super::enums::VirtualDeviceConfigSpecOperationEnum>;
    /// Type of operation being performed on the backing
    /// of the specified virtual device.
    /// 
    /// If no file operation is specified in the VirtualDeviceSpec,
    /// then any backing filenames in the
    /// *VirtualDevice*
    /// must refer to files that already exist.
    /// The "replace" and "delete" values for this property are only
    /// applicable to virtual disk backing files.
    fn get_file_operation(&self) -> &Option<super::enums::VirtualDeviceConfigSpecFileOperationEnum>;
    /// Device specification, with all necessary properties set.
    fn get_device(&self) -> &Box<dyn super::traits::VirtualDeviceTrait>;
    /// Virtual Device Profile requirement.
    /// 
    /// Profiles are solution specifics.
    /// Storage Profile Based Management(SPBM) is a vSphere server extension.
    /// The API users who want to provision VMs using Storage Profiles, need to
    /// interact with SPBM service.
    /// This is an optional parameter and if user doesn't specify profile,
    /// the default behavior will apply.
    fn get_profile(&self) -> &Option<Vec<Box<dyn super::traits::VirtualMachineProfileSpecTrait>>>;
    /// BackingInfo configuration options.
    /// 
    /// Each BackingSpec corresponds to a BackingInfo object. The member
    /// *VirtualDeviceConfigSpec.backing* refers to the
    /// *VirtualDeviceConfigSpec.device*.*VirtualDevice.backing*.
    fn get_backing(&self) -> &Option<VirtualDeviceConfigSpecBackingSpec>;
    /// List of independent filters *VirtualMachineIndependentFilterSpec*
    /// to configure on the virtual device.
    /// 
    /// ***Since:*** vSphere API Release 7.0.2.1
    fn get_filter_spec(&self) -> &Option<Vec<Box<dyn super::traits::VirtualMachineBaseIndependentFilterSpecTrait>>>;
    /// The change mode of the device.
    /// 
    /// The values of the mode will be one of *VirtualDeviceConfigSpecChangeMode_enum* enumerations.
    /// On unset, default to 'fail'.
    /// 
    /// ***Since:*** vSphere API Release 8.0.0.1
    fn get_change_mode(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn VirtualDeviceConfigSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDeviceConfigSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDeviceConfigSpecVisitor)
            }
        }

struct VirtualDeviceConfigSpecVisitor;

impl<'de> de::Visitor<'de> for VirtualDeviceConfigSpecVisitor {
    type Value = Box<dyn VirtualDeviceConfigSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDeviceConfigSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDeviceConfigSpecTrait for VirtualDeviceConfigSpec {
    fn get_operation(&self) -> &Option<super::enums::VirtualDeviceConfigSpecOperationEnum> { &self.operation }
    fn get_file_operation(&self) -> &Option<super::enums::VirtualDeviceConfigSpecFileOperationEnum> { &self.file_operation }
    fn get_device(&self) -> &Box<dyn super::traits::VirtualDeviceTrait> { &self.device }
    fn get_profile(&self) -> &Option<Vec<Box<dyn super::traits::VirtualMachineProfileSpecTrait>>> { &self.profile }
    fn get_backing(&self) -> &Option<VirtualDeviceConfigSpecBackingSpec> { &self.backing }
    fn get_filter_spec(&self) -> &Option<Vec<Box<dyn super::traits::VirtualMachineBaseIndependentFilterSpecTrait>>> { &self.filter_spec }
    fn get_change_mode(&self) -> &Option<String> { &self.change_mode }
}
impl VirtualDeviceConfigSpecTrait for VirtualDiskConfigSpec {
    fn get_operation(&self) -> &Option<super::enums::VirtualDeviceConfigSpecOperationEnum> { &self.operation }
    fn get_file_operation(&self) -> &Option<super::enums::VirtualDeviceConfigSpecFileOperationEnum> { &self.file_operation }
    fn get_device(&self) -> &Box<dyn super::traits::VirtualDeviceTrait> { &self.device }
    fn get_profile(&self) -> &Option<Vec<Box<dyn super::traits::VirtualMachineProfileSpecTrait>>> { &self.profile }
    fn get_backing(&self) -> &Option<VirtualDeviceConfigSpecBackingSpec> { &self.backing }
    fn get_filter_spec(&self) -> &Option<Vec<Box<dyn super::traits::VirtualMachineBaseIndependentFilterSpecTrait>>> { &self.filter_spec }
    fn get_change_mode(&self) -> &Option<String> { &self.change_mode }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDeviceConfigSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceConfigSpec => Some(from.as_any_ref().downcast_ref::<VirtualDeviceConfigSpec>()?),
            StructType::VirtualDiskConfigSpec => Some(from.as_any_ref().downcast_ref::<VirtualDiskConfigSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceConfigSpec => Ok(from.as_any_box().downcast::<VirtualDeviceConfigSpec>()?),
            StructType::VirtualDiskConfigSpec => Ok(from.as_any_box().downcast::<VirtualDiskConfigSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// A Subject.
pub trait GuestAuthSubjectTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn GuestAuthSubjectTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn GuestAuthSubjectTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(GuestAuthSubjectVisitor)
            }
        }

struct GuestAuthSubjectVisitor;

impl<'de> de::Visitor<'de> for GuestAuthSubjectVisitor {
    type Value = Box<dyn GuestAuthSubjectTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid GuestAuthSubjectTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl GuestAuthSubjectTrait for GuestAuthSubject {
}
impl GuestAuthSubjectTrait for GuestAuthAnySubject {
}
impl GuestAuthSubjectTrait for GuestAuthNamedSubject {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn GuestAuthSubjectTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::GuestAuthSubject => Some(from.as_any_ref().downcast_ref::<GuestAuthSubject>()?),
            StructType::GuestAuthAnySubject => Some(from.as_any_ref().downcast_ref::<GuestAuthAnySubject>()?),
            StructType::GuestAuthNamedSubject => Some(from.as_any_ref().downcast_ref::<GuestAuthNamedSubject>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::GuestAuthSubject => Ok(from.as_any_box().downcast::<GuestAuthSubject>()?),
            StructType::GuestAuthAnySubject => Ok(from.as_any_box().downcast::<GuestAuthAnySubject>()?),
            StructType::GuestAuthNamedSubject => Ok(from.as_any_box().downcast::<GuestAuthNamedSubject>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Different attributes for a guest file.
/// - Check *GuestPosixFileAttributes*
///   for Posix guest files.
/// - Check *GuestWindowsFileAttributes*
///   for Windows guest files.
pub trait GuestFileAttributesTrait : super::traits::DataObjectTrait {
    /// The date and time the file was last modified.
    /// 
    /// If this property is not specified when passing a
    /// *GuestFileAttributes* object to
    /// *GuestFileManager.InitiateFileTransferToGuest*,
    /// the default value will be the time when the file is created inside the
    /// guest.
    fn get_modification_time(&self) -> &Option<String>;
    /// The date and time the file was last accessed.
    /// 
    /// If this property is not specified when passing a
    /// *GuestFileAttributes* object to
    /// *GuestFileManager.InitiateFileTransferToGuest*,
    /// the default value will be the time when the file is created inside the
    /// guest.
    fn get_access_time(&self) -> &Option<String>;
    /// The target for the file if it's a symbolic link.
    /// 
    /// This is currently only set for Linux guest operating systems,
    /// but may be supported in the
    /// future on Windows guest operating systems that support symbolic links.
    /// This property gives information about files when returned from
    /// *GuestFileManager.ListFilesInGuest* or
    /// *GuestFileManager.InitiateFileTransferFromGuest*
    /// as part of a *GuestFileAttributes* object.
    /// This property will be ignored when passing a
    /// *GuestFileAttributes* object to
    /// *GuestFileManager.InitiateFileTransferToGuest* or
    /// *GuestFileManager.ChangeFileAttributesInGuest*.
    /// If the file is a symbolic link, then the attributes of the target
    /// are returned, not those of the symbolic link.
    fn get_symlink_target(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn GuestFileAttributesTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn GuestFileAttributesTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(GuestFileAttributesVisitor)
            }
        }

struct GuestFileAttributesVisitor;

impl<'de> de::Visitor<'de> for GuestFileAttributesVisitor {
    type Value = Box<dyn GuestFileAttributesTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid GuestFileAttributesTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl GuestFileAttributesTrait for GuestFileAttributes {
    fn get_modification_time(&self) -> &Option<String> { &self.modification_time }
    fn get_access_time(&self) -> &Option<String> { &self.access_time }
    fn get_symlink_target(&self) -> &Option<String> { &self.symlink_target }
}
impl GuestFileAttributesTrait for GuestPosixFileAttributes {
    fn get_modification_time(&self) -> &Option<String> { &self.modification_time }
    fn get_access_time(&self) -> &Option<String> { &self.access_time }
    fn get_symlink_target(&self) -> &Option<String> { &self.symlink_target }
}
impl GuestFileAttributesTrait for GuestWindowsFileAttributes {
    fn get_modification_time(&self) -> &Option<String> { &self.modification_time }
    fn get_access_time(&self) -> &Option<String> { &self.access_time }
    fn get_symlink_target(&self) -> &Option<String> { &self.symlink_target }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn GuestFileAttributesTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::GuestFileAttributes => Some(from.as_any_ref().downcast_ref::<GuestFileAttributes>()?),
            StructType::GuestPosixFileAttributes => Some(from.as_any_ref().downcast_ref::<GuestPosixFileAttributes>()?),
            StructType::GuestWindowsFileAttributes => Some(from.as_any_ref().downcast_ref::<GuestWindowsFileAttributes>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::GuestFileAttributes => Ok(from.as_any_box().downcast::<GuestFileAttributes>()?),
            StructType::GuestPosixFileAttributes => Ok(from.as_any_box().downcast::<GuestPosixFileAttributes>()?),
            StructType::GuestWindowsFileAttributes => Ok(from.as_any_box().downcast::<GuestWindowsFileAttributes>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// GuestAuthentication is an abstract base class for authentication
/// in the guest.
pub trait GuestAuthenticationTrait : super::traits::DataObjectTrait {
    /// This is set to true if the client wants an interactive session
    /// in the guest.
    /// 
    /// Setting this is supported only for *NamePasswordAuthentication*.
    fn get_interactive_session(&self) -> bool;
}
impl<'s> serde::Serialize for dyn GuestAuthenticationTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn GuestAuthenticationTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(GuestAuthenticationVisitor)
            }
        }

struct GuestAuthenticationVisitor;

impl<'de> de::Visitor<'de> for GuestAuthenticationVisitor {
    type Value = Box<dyn GuestAuthenticationTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid GuestAuthenticationTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl GuestAuthenticationTrait for GuestAuthentication {
    fn get_interactive_session(&self) -> bool { self.interactive_session }
}
impl GuestAuthenticationTrait for NamePasswordAuthentication {
    fn get_interactive_session(&self) -> bool { self.interactive_session }
}
impl GuestAuthenticationTrait for SamlTokenAuthentication {
    fn get_interactive_session(&self) -> bool { self.interactive_session }
}
impl GuestAuthenticationTrait for SspiAuthentication {
    fn get_interactive_session(&self) -> bool { self.interactive_session }
}
impl GuestAuthenticationTrait for TicketedSessionAuthentication {
    fn get_interactive_session(&self) -> bool { self.interactive_session }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn GuestAuthenticationTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::GuestAuthentication => Some(from.as_any_ref().downcast_ref::<GuestAuthentication>()?),
            StructType::NamePasswordAuthentication => Some(from.as_any_ref().downcast_ref::<NamePasswordAuthentication>()?),
            StructType::SamlTokenAuthentication => Some(from.as_any_ref().downcast_ref::<SamlTokenAuthentication>()?),
            StructType::SspiAuthentication => Some(from.as_any_ref().downcast_ref::<SspiAuthentication>()?),
            StructType::TicketedSessionAuthentication => Some(from.as_any_ref().downcast_ref::<TicketedSessionAuthentication>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::GuestAuthentication => Ok(from.as_any_box().downcast::<GuestAuthentication>()?),
            StructType::NamePasswordAuthentication => Ok(from.as_any_box().downcast::<NamePasswordAuthentication>()?),
            StructType::SamlTokenAuthentication => Ok(from.as_any_box().downcast::<SamlTokenAuthentication>()?),
            StructType::SspiAuthentication => Ok(from.as_any_box().downcast::<SspiAuthentication>()?),
            StructType::TicketedSessionAuthentication => Ok(from.as_any_box().downcast::<TicketedSessionAuthentication>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This describes the arguments to *GuestProcessManager.StartProgramInGuest*.
pub trait GuestProgramSpecTrait : super::traits::DataObjectTrait {
    /// The absolute path to the program to start.
    /// 
    /// For Linux guest operating systems, /bin/bash is used to start the
    /// program.
    /// 
    /// For Solaris guest operating systems, /bin/bash is used to start
    /// the program if it exists.
    /// Otherwise /bin/sh is used. If /bin/sh is used, then the process ID
    /// returned by *GuestProcessManager.StartProgramInGuest* will be that of the shell used
    /// to start the program, rather than the program itself, due to the
    /// differences in how /bin/sh and /bin/bash work. This PID will
    /// still be usable for watching the process with
    /// *GuestProcessManager.ListProcessesInGuest* to
    /// find its exit code and elapsed time.
    fn get_program_path(&self) -> &str;
    /// The arguments to the program.
    /// 
    /// In Linux and Solaris guest operating
    /// systems, the program will be executed by a guest shell.
    /// This allows stdio redirection, but may also
    /// require that characters which must be escaped to the shell also
    /// be escaped on the command line provided.
    /// 
    /// For Windows guest operating systems, prefixing the command with
    /// "cmd /c" can provide stdio redirection.
    fn get_arguments(&self) -> &str;
    /// The absolute path of the working directory for the program to be
    /// run.
    /// 
    /// VMware recommends explicitly setting the working directory
    /// for the program to be run. If this value is unset or is an empty
    /// string, the behavior depends on the guest operating system.
    /// For Linux guest operating systems, if this value is unset or is
    /// an empty string, the working directory will be the home directory
    /// of the user associated with the guest authentication.
    /// For other guest operating systems, if this value is unset, the
    /// behavior is unspecified.
    fn get_working_directory(&self) -> &Option<String>;
    /// An array of environment variables, specified
    /// in the guest OS notation (eg PATH=c:\\bin;c:\\windows\\system32
    /// or LD\_LIBRARY\_PATH=/usr/lib:/lib), to be set for the program
    /// being run.
    /// 
    /// Note that these are not additions to the default
    /// environment variables; they define the complete set available to
    /// the program. If none are specified the values are guest dependent.
    fn get_env_variables(&self) -> &Option<Vec<String>>;
}
impl<'s> serde::Serialize for dyn GuestProgramSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn GuestProgramSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(GuestProgramSpecVisitor)
            }
        }

struct GuestProgramSpecVisitor;

impl<'de> de::Visitor<'de> for GuestProgramSpecVisitor {
    type Value = Box<dyn GuestProgramSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid GuestProgramSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl GuestProgramSpecTrait for GuestProgramSpec {
    fn get_program_path(&self) -> &str { &self.program_path }
    fn get_arguments(&self) -> &str { &self.arguments }
    fn get_working_directory(&self) -> &Option<String> { &self.working_directory }
    fn get_env_variables(&self) -> &Option<Vec<String>> { &self.env_variables }
}
impl GuestProgramSpecTrait for GuestWindowsProgramSpec {
    fn get_program_path(&self) -> &str { &self.program_path }
    fn get_arguments(&self) -> &str { &self.arguments }
    fn get_working_directory(&self) -> &Option<String> { &self.working_directory }
    fn get_env_variables(&self) -> &Option<Vec<String>> { &self.env_variables }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn GuestProgramSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::GuestProgramSpec => Some(from.as_any_ref().downcast_ref::<GuestProgramSpec>()?),
            StructType::GuestWindowsProgramSpec => Some(from.as_any_ref().downcast_ref::<GuestWindowsProgramSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::GuestProgramSpec => Ok(from.as_any_box().downcast::<GuestProgramSpec>()?),
            StructType::GuestWindowsProgramSpec => Ok(from.as_any_box().downcast::<GuestWindowsProgramSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This describes the registry value data.
pub trait GuestRegValueDataSpecTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn GuestRegValueDataSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn GuestRegValueDataSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(GuestRegValueDataSpecVisitor)
            }
        }

struct GuestRegValueDataSpecVisitor;

impl<'de> de::Visitor<'de> for GuestRegValueDataSpecVisitor {
    type Value = Box<dyn GuestRegValueDataSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid GuestRegValueDataSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl GuestRegValueDataSpecTrait for GuestRegValueDataSpec {
}
impl GuestRegValueDataSpecTrait for GuestRegValueBinarySpec {
}
impl GuestRegValueDataSpecTrait for GuestRegValueDwordSpec {
}
impl GuestRegValueDataSpecTrait for GuestRegValueExpandStringSpec {
}
impl GuestRegValueDataSpecTrait for GuestRegValueMultiStringSpec {
}
impl GuestRegValueDataSpecTrait for GuestRegValueQwordSpec {
}
impl GuestRegValueDataSpecTrait for GuestRegValueStringSpec {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn GuestRegValueDataSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::GuestRegValueDataSpec => Some(from.as_any_ref().downcast_ref::<GuestRegValueDataSpec>()?),
            StructType::GuestRegValueBinarySpec => Some(from.as_any_ref().downcast_ref::<GuestRegValueBinarySpec>()?),
            StructType::GuestRegValueDwordSpec => Some(from.as_any_ref().downcast_ref::<GuestRegValueDwordSpec>()?),
            StructType::GuestRegValueExpandStringSpec => Some(from.as_any_ref().downcast_ref::<GuestRegValueExpandStringSpec>()?),
            StructType::GuestRegValueMultiStringSpec => Some(from.as_any_ref().downcast_ref::<GuestRegValueMultiStringSpec>()?),
            StructType::GuestRegValueQwordSpec => Some(from.as_any_ref().downcast_ref::<GuestRegValueQwordSpec>()?),
            StructType::GuestRegValueStringSpec => Some(from.as_any_ref().downcast_ref::<GuestRegValueStringSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::GuestRegValueDataSpec => Ok(from.as_any_box().downcast::<GuestRegValueDataSpec>()?),
            StructType::GuestRegValueBinarySpec => Ok(from.as_any_box().downcast::<GuestRegValueBinarySpec>()?),
            StructType::GuestRegValueDwordSpec => Ok(from.as_any_box().downcast::<GuestRegValueDwordSpec>()?),
            StructType::GuestRegValueExpandStringSpec => Ok(from.as_any_box().downcast::<GuestRegValueExpandStringSpec>()?),
            StructType::GuestRegValueMultiStringSpec => Ok(from.as_any_box().downcast::<GuestRegValueMultiStringSpec>()?),
            StructType::GuestRegValueQwordSpec => Ok(from.as_any_box().downcast::<GuestRegValueQwordSpec>()?),
            StructType::GuestRegValueStringSpec => Ok(from.as_any_box().downcast::<GuestRegValueStringSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type contains the basic configuration for
/// a virtual storage object or a virtual storage object snapshot.
pub trait BaseConfigInfoTrait : super::traits::DataObjectTrait {
    /// ID of this object.
    fn get_id(&self) -> &Id;
    /// Descriptive name of this object.
    fn get_name(&self) -> &str;
    /// The date and time this object was created.
    fn get_create_time(&self) -> &str;
    /// Choice of the deletion behavior of this virtual storage object.
    /// 
    /// If not set, the default value is false.
    fn get_keep_after_delete_vm(&self) -> Option<bool>;
    /// Is virtual storage object relocation disabled.
    /// 
    /// If not set, the default value is false.
    fn get_relocation_disabled(&self) -> Option<bool>;
    /// Is virtual storage object supports native snapshot.
    /// 
    /// If not set, the default value is false.
    fn get_native_snapshot_supported(&self) -> Option<bool>;
    /// If Virtua storage object has changed block tracking enabled.
    /// 
    /// If not set, the default value is false.
    fn get_changed_block_tracking_enabled(&self) -> Option<bool>;
    /// Backing of this object.
    fn get_backing(&self) -> &Box<dyn super::traits::BaseConfigInfoBackingInfoTrait>;
    /// Metadata associated with the FCD if available.
    /// 
    /// ***Since:*** vSphere API Release 7.0.2.0
    fn get_metadata(&self) -> &Option<Vec<KeyValue>>;
    /// VClock associated with the fcd when the operation completed.
    /// 
    /// The files is unset if the operation is a retrieve.
    /// 
    /// ***Since:*** vSphere API Release 7.0.2.0
    fn get_vclock(&self) -> &Option<VslmVClockInfo>;
    /// IDs of the IO Filters associated with the virtual disk.
    /// 
    /// See *IoFilterInfo.id*.
    /// The client cannot modify this information on a virtual machine.
    fn get_iofilter(&self) -> &Option<Vec<String>>;
}
impl<'s> serde::Serialize for dyn BaseConfigInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn BaseConfigInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(BaseConfigInfoVisitor)
            }
        }

struct BaseConfigInfoVisitor;

impl<'de> de::Visitor<'de> for BaseConfigInfoVisitor {
    type Value = Box<dyn BaseConfigInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid BaseConfigInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl BaseConfigInfoTrait for BaseConfigInfo {
    fn get_id(&self) -> &Id { &self.id }
    fn get_name(&self) -> &str { &self.name }
    fn get_create_time(&self) -> &str { &self.create_time }
    fn get_keep_after_delete_vm(&self) -> Option<bool> { self.keep_after_delete_vm }
    fn get_relocation_disabled(&self) -> Option<bool> { self.relocation_disabled }
    fn get_native_snapshot_supported(&self) -> Option<bool> { self.native_snapshot_supported }
    fn get_changed_block_tracking_enabled(&self) -> Option<bool> { self.changed_block_tracking_enabled }
    fn get_backing(&self) -> &Box<dyn super::traits::BaseConfigInfoBackingInfoTrait> { &self.backing }
    fn get_metadata(&self) -> &Option<Vec<KeyValue>> { &self.metadata }
    fn get_vclock(&self) -> &Option<VslmVClockInfo> { &self.vclock }
    fn get_iofilter(&self) -> &Option<Vec<String>> { &self.iofilter }
}
impl BaseConfigInfoTrait for VStorageObjectConfigInfo {
    fn get_id(&self) -> &Id { &self.id }
    fn get_name(&self) -> &str { &self.name }
    fn get_create_time(&self) -> &str { &self.create_time }
    fn get_keep_after_delete_vm(&self) -> Option<bool> { self.keep_after_delete_vm }
    fn get_relocation_disabled(&self) -> Option<bool> { self.relocation_disabled }
    fn get_native_snapshot_supported(&self) -> Option<bool> { self.native_snapshot_supported }
    fn get_changed_block_tracking_enabled(&self) -> Option<bool> { self.changed_block_tracking_enabled }
    fn get_backing(&self) -> &Box<dyn super::traits::BaseConfigInfoBackingInfoTrait> { &self.backing }
    fn get_metadata(&self) -> &Option<Vec<KeyValue>> { &self.metadata }
    fn get_vclock(&self) -> &Option<VslmVClockInfo> { &self.vclock }
    fn get_iofilter(&self) -> &Option<Vec<String>> { &self.iofilter }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn BaseConfigInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::BaseConfigInfo => Some(from.as_any_ref().downcast_ref::<BaseConfigInfo>()?),
            StructType::VStorageObjectConfigInfo => Some(from.as_any_ref().downcast_ref::<VStorageObjectConfigInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::BaseConfigInfo => Ok(from.as_any_box().downcast::<BaseConfigInfo>()?),
            StructType::VStorageObjectConfigInfo => Ok(from.as_any_box().downcast::<VStorageObjectConfigInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The data object type is a base type of backing of a virtual
/// storage object.
pub trait BaseConfigInfoBackingInfoTrait : super::traits::DataObjectTrait {
    /// The datastore managed object where this backing is located.
    /// 
    /// Refers instance of *Datastore*.
    fn get_datastore(&self) -> &ManagedObjectReference;
}
impl<'s> serde::Serialize for dyn BaseConfigInfoBackingInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn BaseConfigInfoBackingInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(BaseConfigInfoBackingInfoVisitor)
            }
        }

struct BaseConfigInfoBackingInfoVisitor;

impl<'de> de::Visitor<'de> for BaseConfigInfoBackingInfoVisitor {
    type Value = Box<dyn BaseConfigInfoBackingInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid BaseConfigInfoBackingInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl BaseConfigInfoBackingInfoTrait for BaseConfigInfoBackingInfo {
    fn get_datastore(&self) -> &ManagedObjectReference { &self.datastore }
}
impl BaseConfigInfoBackingInfoTrait for BaseConfigInfoFileBackingInfo {
    fn get_datastore(&self) -> &ManagedObjectReference { &self.datastore }
}
impl BaseConfigInfoBackingInfoTrait for BaseConfigInfoDiskFileBackingInfo {
    fn get_datastore(&self) -> &ManagedObjectReference { &self.datastore }
}
impl BaseConfigInfoBackingInfoTrait for BaseConfigInfoRawDiskMappingBackingInfo {
    fn get_datastore(&self) -> &ManagedObjectReference { &self.datastore }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn BaseConfigInfoBackingInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::BaseConfigInfoBackingInfo => Some(from.as_any_ref().downcast_ref::<BaseConfigInfoBackingInfo>()?),
            StructType::BaseConfigInfoFileBackingInfo => Some(from.as_any_ref().downcast_ref::<BaseConfigInfoFileBackingInfo>()?),
            StructType::BaseConfigInfoDiskFileBackingInfo => Some(from.as_any_ref().downcast_ref::<BaseConfigInfoDiskFileBackingInfo>()?),
            StructType::BaseConfigInfoRawDiskMappingBackingInfo => Some(from.as_any_ref().downcast_ref::<BaseConfigInfoRawDiskMappingBackingInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::BaseConfigInfoBackingInfo => Ok(from.as_any_box().downcast::<BaseConfigInfoBackingInfo>()?),
            StructType::BaseConfigInfoFileBackingInfo => Ok(from.as_any_box().downcast::<BaseConfigInfoFileBackingInfo>()?),
            StructType::BaseConfigInfoDiskFileBackingInfo => Ok(from.as_any_box().downcast::<BaseConfigInfoDiskFileBackingInfo>()?),
            StructType::BaseConfigInfoRawDiskMappingBackingInfo => Ok(from.as_any_box().downcast::<BaseConfigInfoRawDiskMappingBackingInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Information for file backing of a virtual storage
/// object.
/// 
/// File backing is mainly used for virtual disks.
pub trait BaseConfigInfoFileBackingInfoTrait : super::traits::BaseConfigInfoBackingInfoTrait {
    /// Full file path for the host file used in this backing.
    fn get_file_path(&self) -> &str;
    /// Id refers to the backed storage object where the virtual storage object
    /// is backed on.
    fn get_backing_object_id(&self) -> &Option<String>;
    /// The parent of this virtual disk file, if this is a delta disk backing.
    /// 
    /// This will be unset if this is the root disk backing.
    /// 
    /// Note that the type of the backing is consistent throughout the chain;
    /// any new delta disk backing which is added is of the same type as the
    /// original disk. Also note that since the parent backing is not being
    /// written to, it is possible that the parent backing may be shared among
    /// multiple disks.
    /// 
    /// Only raw disk mappings in
    /// *virtual compatibility mode* can have parents.
    fn get_parent(&self) -> &Option<Box<dyn super::traits::BaseConfigInfoFileBackingInfoTrait>>;
    /// Size allocated by the FS for this file/chain/link/extent only.
    /// 
    /// This property is used only for a delta disk whose
    /// *BaseConfigInfoFileBackingInfo.parent* is set.
    fn get_delta_size_in_mb(&self) -> Option<i64>;
    /// key id used to encrypt the backing disk.
    fn get_key_id(&self) -> &Option<CryptoKeyId>;
}
impl<'s> serde::Serialize for dyn BaseConfigInfoFileBackingInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn BaseConfigInfoFileBackingInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(BaseConfigInfoFileBackingInfoVisitor)
            }
        }

struct BaseConfigInfoFileBackingInfoVisitor;

impl<'de> de::Visitor<'de> for BaseConfigInfoFileBackingInfoVisitor {
    type Value = Box<dyn BaseConfigInfoFileBackingInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid BaseConfigInfoFileBackingInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl BaseConfigInfoFileBackingInfoTrait for BaseConfigInfoFileBackingInfo {
    fn get_file_path(&self) -> &str { &self.file_path }
    fn get_backing_object_id(&self) -> &Option<String> { &self.backing_object_id }
    fn get_parent(&self) -> &Option<Box<dyn super::traits::BaseConfigInfoFileBackingInfoTrait>> { &self.parent }
    fn get_delta_size_in_mb(&self) -> Option<i64> { self.delta_size_in_mb }
    fn get_key_id(&self) -> &Option<CryptoKeyId> { &self.key_id }
}
impl BaseConfigInfoFileBackingInfoTrait for BaseConfigInfoDiskFileBackingInfo {
    fn get_file_path(&self) -> &str { &self.file_path }
    fn get_backing_object_id(&self) -> &Option<String> { &self.backing_object_id }
    fn get_parent(&self) -> &Option<Box<dyn super::traits::BaseConfigInfoFileBackingInfoTrait>> { &self.parent }
    fn get_delta_size_in_mb(&self) -> Option<i64> { self.delta_size_in_mb }
    fn get_key_id(&self) -> &Option<CryptoKeyId> { &self.key_id }
}
impl BaseConfigInfoFileBackingInfoTrait for BaseConfigInfoRawDiskMappingBackingInfo {
    fn get_file_path(&self) -> &str { &self.file_path }
    fn get_backing_object_id(&self) -> &Option<String> { &self.backing_object_id }
    fn get_parent(&self) -> &Option<Box<dyn super::traits::BaseConfigInfoFileBackingInfoTrait>> { &self.parent }
    fn get_delta_size_in_mb(&self) -> Option<i64> { self.delta_size_in_mb }
    fn get_key_id(&self) -> &Option<CryptoKeyId> { &self.key_id }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn BaseConfigInfoFileBackingInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::BaseConfigInfoFileBackingInfo => Some(from.as_any_ref().downcast_ref::<BaseConfigInfoFileBackingInfo>()?),
            StructType::BaseConfigInfoDiskFileBackingInfo => Some(from.as_any_ref().downcast_ref::<BaseConfigInfoDiskFileBackingInfo>()?),
            StructType::BaseConfigInfoRawDiskMappingBackingInfo => Some(from.as_any_ref().downcast_ref::<BaseConfigInfoRawDiskMappingBackingInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::BaseConfigInfoFileBackingInfo => Ok(from.as_any_box().downcast::<BaseConfigInfoFileBackingInfo>()?),
            StructType::BaseConfigInfoDiskFileBackingInfo => Ok(from.as_any_box().downcast::<BaseConfigInfoDiskFileBackingInfo>()?),
            StructType::BaseConfigInfoRawDiskMappingBackingInfo => Ok(from.as_any_box().downcast::<BaseConfigInfoRawDiskMappingBackingInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Specification of the backing of a virtual
/// storage object.
pub trait VslmCreateSpecBackingSpecTrait : super::traits::DataObjectTrait {
    /// The datastore managed object where this backing is located.
    /// 
    /// Refers instance of *Datastore*.
    fn get_datastore(&self) -> &ManagedObjectReference;
    /// Relative location in the specified datastore where disk needs to be
    /// created.
    /// 
    /// If not specified disk gets created at the defualt
    /// VStorageObject location on the specified datastore.
    fn get_path(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn VslmCreateSpecBackingSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VslmCreateSpecBackingSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VslmCreateSpecBackingSpecVisitor)
            }
        }

struct VslmCreateSpecBackingSpecVisitor;

impl<'de> de::Visitor<'de> for VslmCreateSpecBackingSpecVisitor {
    type Value = Box<dyn VslmCreateSpecBackingSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VslmCreateSpecBackingSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VslmCreateSpecBackingSpecTrait for VslmCreateSpecBackingSpec {
    fn get_datastore(&self) -> &ManagedObjectReference { &self.datastore }
    fn get_path(&self) -> &Option<String> { &self.path }
}
impl VslmCreateSpecBackingSpecTrait for VslmCreateSpecDiskFileBackingSpec {
    fn get_datastore(&self) -> &ManagedObjectReference { &self.datastore }
    fn get_path(&self) -> &Option<String> { &self.path }
}
impl VslmCreateSpecBackingSpecTrait for VslmCreateSpecRawDiskMappingBackingSpec {
    fn get_datastore(&self) -> &ManagedObjectReference { &self.datastore }
    fn get_path(&self) -> &Option<String> { &self.path }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VslmCreateSpecBackingSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VslmCreateSpecBackingSpec => Some(from.as_any_ref().downcast_ref::<VslmCreateSpecBackingSpec>()?),
            StructType::VslmCreateSpecDiskFileBackingSpec => Some(from.as_any_ref().downcast_ref::<VslmCreateSpecDiskFileBackingSpec>()?),
            StructType::VslmCreateSpecRawDiskMappingBackingSpec => Some(from.as_any_ref().downcast_ref::<VslmCreateSpecRawDiskMappingBackingSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VslmCreateSpecBackingSpec => Ok(from.as_any_box().downcast::<VslmCreateSpecBackingSpec>()?),
            StructType::VslmCreateSpecDiskFileBackingSpec => Ok(from.as_any_box().downcast::<VslmCreateSpecDiskFileBackingSpec>()?),
            StructType::VslmCreateSpecRawDiskMappingBackingSpec => Ok(from.as_any_box().downcast::<VslmCreateSpecRawDiskMappingBackingSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base specification of moving or copying a virtual storage object.
pub trait VslmMigrateSpecTrait : super::traits::DataObjectTrait {
    /// Specification of the backings of the target virtual storage object.
    fn get_backing_spec(&self) -> &Box<dyn super::traits::VslmCreateSpecBackingSpecTrait>;
    /// Virtual storage object Profile requirement.
    /// 
    /// If unset,
    /// the default behavior will apply.
    fn get_profile(&self) -> &Option<Vec<Box<dyn super::traits::VirtualMachineProfileSpecTrait>>>;
    /// Flag indicates any delta disk backings will be consolidated
    /// during migration.
    /// 
    /// If unset, delta disk backings will not be
    /// consolidated.
    fn get_consolidate(&self) -> Option<bool>;
    /// Disk chain crypto information.
    /// 
    /// If unset and if *VslmMigrateSpec.profile* contains an encryption iofilter and if
    /// source VStorageObject is unencrypted, then disksCyrpto will be of type
    /// CryptoSpecEncrypt, and filled with keyId that is automatically generated
    /// and keyProviderId that is the default kms cluster. During the migration,
    /// the object will be encrypted.
    /// If unset and if *VslmMigrateSpec.profile* is a default policy and if source
    /// VStorageObject is unenrypted, then disksCrypto is treated as
    /// CryptoSpecNoOp. During migration, no cryptographic change.
    /// If unset and if *VslmMigrateSpec.profile* contains an encryption iofilter and if
    /// source VStorageObject is encrypted, then disksCyrpto is treated as
    /// CryptoSpecNoOp. During migration, no cryptographic change.
    /// If unset and if *VslmMigrateSpec.profile* is a default policy and if
    /// source VStorageObject is encrypted, then disksCyrpto is treated as
    /// CryptoSpecDecrypt, during migration, the object will be decrypted.
    /// To recrypt the disk during migration, disksCrypto has to be present.
    fn get_disks_crypto(&self) -> &Option<DiskCryptoSpec>;
}
impl<'s> serde::Serialize for dyn VslmMigrateSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VslmMigrateSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VslmMigrateSpecVisitor)
            }
        }

struct VslmMigrateSpecVisitor;

impl<'de> de::Visitor<'de> for VslmMigrateSpecVisitor {
    type Value = Box<dyn VslmMigrateSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VslmMigrateSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VslmMigrateSpecTrait for VslmMigrateSpec {
    fn get_backing_spec(&self) -> &Box<dyn super::traits::VslmCreateSpecBackingSpecTrait> { &self.backing_spec }
    fn get_profile(&self) -> &Option<Vec<Box<dyn super::traits::VirtualMachineProfileSpecTrait>>> { &self.profile }
    fn get_consolidate(&self) -> Option<bool> { self.consolidate }
    fn get_disks_crypto(&self) -> &Option<DiskCryptoSpec> { &self.disks_crypto }
}
impl VslmMigrateSpecTrait for VslmCloneSpec {
    fn get_backing_spec(&self) -> &Box<dyn super::traits::VslmCreateSpecBackingSpecTrait> { &self.backing_spec }
    fn get_profile(&self) -> &Option<Vec<Box<dyn super::traits::VirtualMachineProfileSpecTrait>>> { &self.profile }
    fn get_consolidate(&self) -> Option<bool> { self.consolidate }
    fn get_disks_crypto(&self) -> &Option<DiskCryptoSpec> { &self.disks_crypto }
}
impl VslmMigrateSpecTrait for VslmRelocateSpec {
    fn get_backing_spec(&self) -> &Box<dyn super::traits::VslmCreateSpecBackingSpecTrait> { &self.backing_spec }
    fn get_profile(&self) -> &Option<Vec<Box<dyn super::traits::VirtualMachineProfileSpecTrait>>> { &self.profile }
    fn get_consolidate(&self) -> Option<bool> { self.consolidate }
    fn get_disks_crypto(&self) -> &Option<DiskCryptoSpec> { &self.disks_crypto }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VslmMigrateSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VslmMigrateSpec => Some(from.as_any_ref().downcast_ref::<VslmMigrateSpec>()?),
            StructType::VslmCloneSpec => Some(from.as_any_ref().downcast_ref::<VslmCloneSpec>()?),
            StructType::VslmRelocateSpec => Some(from.as_any_ref().downcast_ref::<VslmRelocateSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VslmMigrateSpec => Ok(from.as_any_box().downcast::<VslmMigrateSpec>()?),
            StructType::VslmCloneSpec => Ok(from.as_any_box().downcast::<VslmCloneSpec>()?),
            StructType::VslmRelocateSpec => Ok(from.as_any_box().downcast::<VslmRelocateSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *SelectionSpec* is the base type for data
/// object types that specify what additional objects to filter.
/// 
/// The base
/// type contains only an optional "name" field, which allows a selection to
/// be named for future reference. More information is available in the
/// subtype.
/// 
/// Named selections support recursive specifications on an object
/// hierarchy. When used by a derived object, the "name" field allows other
/// *SelectionSpec* objects to refer to the object by
/// name. When used as the base type only, the "name" field indicates
/// recursion to the derived object by name.
/// 
/// Names are meaningful only within the same FilterSpec.
pub trait SelectionSpecTrait : super::traits::DataObjectTrait {
    /// Name of the selection specification.
    fn get_name(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn SelectionSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn SelectionSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(SelectionSpecVisitor)
            }
        }

struct SelectionSpecVisitor;

impl<'de> de::Visitor<'de> for SelectionSpecVisitor {
    type Value = Box<dyn SelectionSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid SelectionSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl SelectionSpecTrait for SelectionSpec {
    fn get_name(&self) -> &Option<String> { &self.name }
}
impl SelectionSpecTrait for TraversalSpec {
    fn get_name(&self) -> &Option<String> { &self.name }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn SelectionSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::SelectionSpec => Some(from.as_any_ref().downcast_ref::<SelectionSpec>()?),
            StructType::TraversalSpec => Some(from.as_any_ref().downcast_ref::<TraversalSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::SelectionSpec => Ok(from.as_any_box().downcast::<SelectionSpec>()?),
            StructType::TraversalSpec => Ok(from.as_any_box().downcast::<TraversalSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
