use super::vim_object_trait::VimObjectTrait;
use super::dyn_serialize;
use super::convert::CastFrom;
use super::struct_enum::StructType;
use super::structs::*;
use serde::de;
use super::vim_any::VimAny;

/// This is the built-in base interface implemented by all
/// data objects.
pub trait DataObjectTrait : super::traits::VimObjectTrait {
}
impl<'s> serde::Serialize for dyn DataObjectTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DataObjectTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DataObjectVisitor)
            }
        }

struct DataObjectVisitor;

impl<'de> de::Visitor<'de> for DataObjectVisitor {
    type Value = Box<dyn DataObjectTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DataObjectTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DataObjectTrait for DataObject {
}
impl DataObjectTrait for AboutInfo {
}
impl DataObjectTrait for AuthorizationDescription {
}
impl DataObjectTrait for EntityPrivilege {
}
impl DataObjectTrait for Permission {
}
impl DataObjectTrait for AuthorizationPrivilege {
}
impl DataObjectTrait for PrivilegeAvailability {
}
impl DataObjectTrait for AuthorizationRole {
}
impl DataObjectTrait for UserPrivilegeResult {
}
impl DataObjectTrait for BatchResult {
}
impl DataObjectTrait for Capability {
}
impl DataObjectTrait for ClusterComputeResourceClusterConfigResult {
}
impl DataObjectTrait for ClusterComputeResourceDvsSetting {
}
impl DataObjectTrait for ClusterComputeResourceDvsSettingDvPortgroupToServiceMapping {
}
impl DataObjectTrait for ClusterComputeResourceDvsProfile {
}
impl DataObjectTrait for ClusterComputeResourceDvsProfileDvPortgroupSpecToServiceMapping {
}
impl DataObjectTrait for ClusterComputeResourceHciConfigInfo {
}
impl DataObjectTrait for ClusterComputeResourceHciConfigSpec {
}
impl DataObjectTrait for ClusterComputeResourceHostConfigurationInput {
}
impl DataObjectTrait for ClusterComputeResourceHostConfigurationProfile {
}
impl DataObjectTrait for ClusterComputeResourceHostVmkNicInfo {
}
impl DataObjectTrait for ClusterComputeResourceVcProfile {
}
impl DataObjectTrait for ClusterComputeResourceValidationResultBase {
}
impl DataObjectTrait for ClusterComputeResourceDvsConfigurationValidation {
}
impl DataObjectTrait for ClusterComputeResourceHostConfigurationValidation {
}
impl DataObjectTrait for ClusterComputeResourceVcsSlots {
}
impl DataObjectTrait for ComputeResourceConfigInfo {
}
impl DataObjectTrait for ClusterConfigInfoEx {
}
impl DataObjectTrait for ComputeResourceConfigSpec {
}
impl DataObjectTrait for ClusterConfigSpecEx {
}
impl DataObjectTrait for ComputeResourceHostSpbmLicenseInfo {
}
impl DataObjectTrait for ComputeResourceSummary {
}
impl DataObjectTrait for ClusterComputeResourceSummary {
}
impl DataObjectTrait for CustomFieldDef {
}
impl DataObjectTrait for CustomFieldValue {
}
impl DataObjectTrait for CustomFieldStringValue {
}
impl DataObjectTrait for CustomizationSpecInfo {
}
impl DataObjectTrait for CustomizationSpecItem {
}
impl DataObjectTrait for DatacenterBasicConnectInfo {
}
impl DataObjectTrait for DatacenterConfigInfo {
}
impl DataObjectTrait for DatacenterConfigSpec {
}
impl DataObjectTrait for DatastoreCapability {
}
impl DataObjectTrait for DatastoreHostMount {
}
impl DataObjectTrait for DatastoreInfo {
}
impl DataObjectTrait for LocalDatastoreInfo {
}
impl DataObjectTrait for NasDatastoreInfo {
}
impl DataObjectTrait for PMemDatastoreInfo {
}
impl DataObjectTrait for VmfsDatastoreInfo {
}
impl DataObjectTrait for VsanDatastoreInfo {
}
impl DataObjectTrait for VvolDatastoreInfo {
}
impl DataObjectTrait for DatastoreMountPathDatastorePair {
}
impl DataObjectTrait for DatastoreSummary {
}
impl DataObjectTrait for DatastoreVVolContainerFailoverPair {
}
impl DataObjectTrait for DatastoreNamespaceManagerDirectoryInfo {
}
impl DataObjectTrait for Description {
}
impl DataObjectTrait for ElementDescription {
}
impl DataObjectTrait for EvcMode {
}
impl DataObjectTrait for ExtendedElementDescription {
}
impl DataObjectTrait for FeatureEvcMode {
}
impl DataObjectTrait for OptionDef {
}
impl DataObjectTrait for ExtendedDescription {
}
impl DataObjectTrait for MethodDescription {
}
impl DataObjectTrait for TypeDescription {
}
impl DataObjectTrait for ScheduledTaskDetail {
}
impl DataObjectTrait for DesiredSoftwareSpec {
}
impl DataObjectTrait for DesiredSoftwareSpecBaseImageSpec {
}
impl DataObjectTrait for DesiredSoftwareSpecComponentSpec {
}
impl DataObjectTrait for DesiredSoftwareSpecVendorAddOnSpec {
}
impl DataObjectTrait for DiagnosticManagerAuditRecordResult {
}
impl DataObjectTrait for DiagnosticManagerBundleInfo {
}
impl DataObjectTrait for DiagnosticManagerLogDescriptor {
}
impl DataObjectTrait for DiagnosticManagerLogHeader {
}
impl DataObjectTrait for DvsBackupRestoreCapability {
}
impl DataObjectTrait for DvsCapability {
}
impl DataObjectTrait for DvsConfigInfo {
}
impl DataObjectTrait for VMwareDvsConfigInfo {
}
impl DataObjectTrait for DvsConfigSpec {
}
impl DataObjectTrait for VMwareDvsConfigSpec {
}
impl DataObjectTrait for DvsContactInfo {
}
impl DataObjectTrait for DvsCreateSpec {
}
impl DataObjectTrait for DvsFeatureCapability {
}
impl DataObjectTrait for VMwareDvsFeatureCapability {
}
impl DataObjectTrait for DvsHealthCheckConfig {
}
impl DataObjectTrait for VMwareDvsHealthCheckConfig {
}
impl DataObjectTrait for VMwareDvsTeamingHealthCheckConfig {
}
impl DataObjectTrait for VMwareDvsVlanMtuHealthCheckConfig {
}
impl DataObjectTrait for DvsHealthCheckCapability {
}
impl DataObjectTrait for VMwareDvsHealthCheckCapability {
}
impl DataObjectTrait for DvsHostInfrastructureTrafficResource {
}
impl DataObjectTrait for DvsHostInfrastructureTrafficResourceAllocation {
}
impl DataObjectTrait for DvsNetworkResourceManagementCapability {
}
impl DataObjectTrait for DvsResourceRuntimeInfo {
}
impl DataObjectTrait for DvsRollbackCapability {
}
impl DataObjectTrait for DvsRuntimeInfo {
}
impl DataObjectTrait for DvsSummary {
}
impl DataObjectTrait for DvsPolicy {
}
impl DataObjectTrait for DvsUplinkPortPolicy {
}
impl DataObjectTrait for DvsNameArrayUplinkPortPolicy {
}
impl DataObjectTrait for EnumDescription {
}
impl DataObjectTrait for EnvironmentBrowserConfigOptionQuerySpec {
}
impl DataObjectTrait for Extension {
}
impl DataObjectTrait for ExtensionClientInfo {
}
impl DataObjectTrait for ExtensionEventTypeInfo {
}
impl DataObjectTrait for ExtensionFaultTypeInfo {
}
impl DataObjectTrait for ExtensionHealthInfo {
}
impl DataObjectTrait for ExtensionOvfConsumerInfo {
}
impl DataObjectTrait for ExtensionPrivilegeInfo {
}
impl DataObjectTrait for ExtensionResourceInfo {
}
impl DataObjectTrait for ExtensionServerInfo {
}
impl DataObjectTrait for ExtensionTaskTypeInfo {
}
impl DataObjectTrait for ExtensionManagerIpAllocationUsage {
}
impl DataObjectTrait for FaultsByHost {
}
impl DataObjectTrait for FaultsByVm {
}
impl DataObjectTrait for FileLockInfo {
}
impl DataObjectTrait for FileLockInfoResult {
}
impl DataObjectTrait for FolderBatchAddHostsToClusterResult {
}
impl DataObjectTrait for FolderBatchAddStandaloneHostsResult {
}
impl DataObjectTrait for FolderFailedHostResult {
}
impl DataObjectTrait for FolderNewHostSpec {
}
impl DataObjectTrait for HbrManagerReplicationVmInfo {
}
impl DataObjectTrait for ReplicationVmProgressInfo {
}
impl DataObjectTrait for HbrManagerVmReplicationCapability {
}
impl DataObjectTrait for HealthUpdate {
}
impl DataObjectTrait for HealthUpdateInfo {
}
impl DataObjectTrait for PerfInterval {
}
impl DataObjectTrait for HostServiceTicket {
}
impl DataObjectTrait for HostSystemComplianceCheckState {
}
impl DataObjectTrait for HostSystemReconnectSpec {
}
impl DataObjectTrait for HostSystemRemediationState {
}
impl DataObjectTrait for HttpNfcLeaseCapabilities {
}
impl DataObjectTrait for HttpNfcLeaseDatastoreLeaseInfo {
}
impl DataObjectTrait for HttpNfcLeaseDeviceUrl {
}
impl DataObjectTrait for HttpNfcLeaseHostInfo {
}
impl DataObjectTrait for HttpNfcLeaseInfo {
}
impl DataObjectTrait for HttpNfcLeaseManifestEntry {
}
impl DataObjectTrait for HttpNfcLeaseProbeResult {
}
impl DataObjectTrait for HttpNfcLeaseSourceFile {
}
impl DataObjectTrait for ImportSpec {
}
impl DataObjectTrait for VirtualAppImportSpec {
}
impl DataObjectTrait for VirtualMachineImportSpec {
}
impl DataObjectTrait for InheritablePolicy {
}
impl DataObjectTrait for BoolPolicy {
}
impl DataObjectTrait for IntPolicy {
}
impl DataObjectTrait for LongPolicy {
}
impl DataObjectTrait for StringPolicy {
}
impl DataObjectTrait for DvsFilterConfig {
}
impl DataObjectTrait for DvsFilterConfigSpec {
}
impl DataObjectTrait for DvsTrafficFilterConfig {
}
impl DataObjectTrait for DvsTrafficFilterConfigSpec {
}
impl DataObjectTrait for DvsFilterPolicy {
}
impl DataObjectTrait for DvsTrafficShapingPolicy {
}
impl DataObjectTrait for DvsVendorSpecificConfig {
}
impl DataObjectTrait for DvsFailureCriteria {
}
impl DataObjectTrait for DvsMacLearningPolicy {
}
impl DataObjectTrait for DvsMacManagementPolicy {
}
impl DataObjectTrait for DvsSecurityPolicy {
}
impl DataObjectTrait for VMwareUplinkLacpPolicy {
}
impl DataObjectTrait for VMwareUplinkPortOrderPolicy {
}
impl DataObjectTrait for VmwareUplinkPortTeamingPolicy {
}
impl DataObjectTrait for VmwareDistributedVirtualSwitchVlanSpec {
}
impl DataObjectTrait for VmwareDistributedVirtualSwitchPvlanSpec {
}
impl DataObjectTrait for VmwareDistributedVirtualSwitchTrunkVlanSpec {
}
impl DataObjectTrait for VmwareDistributedVirtualSwitchVlanIdSpec {
}
impl DataObjectTrait for IoFilterInfo {
}
impl DataObjectTrait for ClusterIoFilterInfo {
}
impl DataObjectTrait for HostIoFilterInfo {
}
impl DataObjectTrait for IoFilterQueryIssueResult {
}
impl DataObjectTrait for IoFilterHostIssue {
}
impl DataObjectTrait for IpPoolManagerIpAllocation {
}
impl DataObjectTrait for KeyValue {
}
impl DataObjectTrait for LatencySensitivity {
}
impl DataObjectTrait for LicenseAssignmentManagerLicenseAssignment {
}
impl DataObjectTrait for LicenseAvailabilityInfo {
}
impl DataObjectTrait for LicenseDiagnostics {
}
impl DataObjectTrait for LicenseManagerEvaluationInfo {
}
impl DataObjectTrait for LicenseFeatureInfo {
}
impl DataObjectTrait for HostLicensableResourceInfo {
}
impl DataObjectTrait for LicenseManagerLicenseInfo {
}
impl DataObjectTrait for LicenseSource {
}
impl DataObjectTrait for EvaluationLicenseSource {
}
impl DataObjectTrait for LicenseServerSource {
}
impl DataObjectTrait for LocalLicenseSource {
}
impl DataObjectTrait for LicenseUsageInfo {
}
impl DataObjectTrait for LicenseReservationInfo {
}
impl DataObjectTrait for LocalizationManagerMessageCatalog {
}
impl DataObjectTrait for NegatableExpression {
}
impl DataObjectTrait for IntExpression {
}
impl DataObjectTrait for IpAddress {
}
impl DataObjectTrait for IpRange {
}
impl DataObjectTrait for SingleIp {
}
impl DataObjectTrait for MacAddress {
}
impl DataObjectTrait for MacRange {
}
impl DataObjectTrait for SingleMac {
}
impl DataObjectTrait for StringExpression {
}
impl DataObjectTrait for DvsIpPort {
}
impl DataObjectTrait for DvsIpPortRange {
}
impl DataObjectTrait for DvsSingleIpPort {
}
impl DataObjectTrait for NetworkSummary {
}
impl DataObjectTrait for OpaqueNetworkSummary {
}
impl DataObjectTrait for NumericRange {
}
impl DataObjectTrait for OpaqueNetworkCapability {
}
impl DataObjectTrait for OvfConsumerOstNode {
}
impl DataObjectTrait for OvfConsumerOvfSection {
}
impl DataObjectTrait for OvfManagerCommonParams {
}
impl DataObjectTrait for OvfCreateImportSpecParams {
}
impl DataObjectTrait for OvfParseDescriptorParams {
}
impl DataObjectTrait for OvfValidateHostParams {
}
impl DataObjectTrait for OvfCreateDescriptorParams {
}
impl DataObjectTrait for OvfCreateDescriptorResult {
}
impl DataObjectTrait for OvfCreateImportSpecResult {
}
impl DataObjectTrait for OvfDeploymentOption {
}
impl DataObjectTrait for OvfFileItem {
}
impl DataObjectTrait for OvfNetworkInfo {
}
impl DataObjectTrait for OvfNetworkMapping {
}
impl DataObjectTrait for OvfFile {
}
impl DataObjectTrait for OvfOptionInfo {
}
impl DataObjectTrait for OvfParseDescriptorResult {
}
impl DataObjectTrait for OvfResourceMap {
}
impl DataObjectTrait for OvfValidateHostResult {
}
impl DataObjectTrait for PasswordField {
}
impl DataObjectTrait for PerformanceDescription {
}
impl DataObjectTrait for PerfCompositeMetric {
}
impl DataObjectTrait for PerfCounterInfo {
}
impl DataObjectTrait for PerformanceManagerCounterLevelMapping {
}
impl DataObjectTrait for PerfEntityMetricBase {
}
impl DataObjectTrait for PerfEntityMetric {
}
impl DataObjectTrait for PerfEntityMetricCsv {
}
impl DataObjectTrait for PerfMetricId {
}
impl DataObjectTrait for PerfMetricSeries {
}
impl DataObjectTrait for PerfMetricIntSeries {
}
impl DataObjectTrait for PerfMetricSeriesCsv {
}
impl DataObjectTrait for PerfProviderSummary {
}
impl DataObjectTrait for PerfQuerySpec {
}
impl DataObjectTrait for PerfSampleInfo {
}
impl DataObjectTrait for PrivilegePolicyDef {
}
impl DataObjectTrait for ResourceAllocationInfo {
}
impl DataObjectTrait for ResourceAllocationOption {
}
impl DataObjectTrait for ResourceConfigOption {
}
impl DataObjectTrait for ResourceConfigSpec {
}
impl DataObjectTrait for DatabaseSizeEstimate {
}
impl DataObjectTrait for DatabaseSizeParam {
}
impl DataObjectTrait for InventoryDescription {
}
impl DataObjectTrait for PerformanceStatisticsDescription {
}
impl DataObjectTrait for ResourcePoolResourceUsage {
}
impl DataObjectTrait for ResourcePoolRuntimeInfo {
}
impl DataObjectTrait for ResourcePoolSummary {
}
impl DataObjectTrait for VirtualAppSummary {
}
impl DataObjectTrait for ResourcePoolQuickStats {
}
impl DataObjectTrait for SddcBase {
}
impl DataObjectTrait for SelectionSet {
}
impl DataObjectTrait for DvPortgroupSelection {
}
impl DataObjectTrait for DvsSelection {
}
impl DataObjectTrait for HostVMotionCompatibility {
}
impl DataObjectTrait for ProductComponentInfo {
}
impl DataObjectTrait for ServiceContent {
}
impl DataObjectTrait for ServiceLocator {
}
impl DataObjectTrait for ServiceLocatorCredential {
}
impl DataObjectTrait for ServiceLocatorNamePassword {
}
impl DataObjectTrait for ServiceLocatorSamlCredential {
}
impl DataObjectTrait for ServiceManagerServiceInfo {
}
impl DataObjectTrait for SessionManagerGenericServiceTicket {
}
impl DataObjectTrait for SessionManagerLocalTicket {
}
impl DataObjectTrait for SessionManagerServiceRequestSpec {
}
impl DataObjectTrait for SessionManagerHttpServiceRequestSpec {
}
impl DataObjectTrait for SessionManagerVmomiServiceRequestSpec {
}
impl DataObjectTrait for SharesInfo {
}
impl DataObjectTrait for SharesOption {
}
impl DataObjectTrait for SiteInfo {
}
impl DataObjectTrait for StoragePodSummary {
}
impl DataObjectTrait for StorageIoAllocationInfo {
}
impl DataObjectTrait for StorageIoAllocationOption {
}
impl DataObjectTrait for StorageIormInfo {
}
impl DataObjectTrait for StorageIormConfigOption {
}
impl DataObjectTrait for StorageIormConfigSpec {
}
impl DataObjectTrait for PodStorageDrsEntry {
}
impl DataObjectTrait for StoragePerformanceSummary {
}
impl DataObjectTrait for StorageResourceManagerStorageProfileStatistics {
}
impl DataObjectTrait for Tag {
}
impl DataObjectTrait for TaskDescription {
}
impl DataObjectTrait for TaskFilterSpec {
}
impl DataObjectTrait for TaskFilterSpecByEntity {
}
impl DataObjectTrait for TaskFilterSpecByTime {
}
impl DataObjectTrait for TaskFilterSpecByUsername {
}
impl DataObjectTrait for TaskInfo {
}
impl DataObjectTrait for TaskReason {
}
impl DataObjectTrait for TaskReasonAlarm {
}
impl DataObjectTrait for TaskReasonSchedule {
}
impl DataObjectTrait for TaskReasonSystem {
}
impl DataObjectTrait for TaskReasonUser {
}
impl DataObjectTrait for UpdateVirtualMachineFilesResult {
}
impl DataObjectTrait for UpdateVirtualMachineFilesResultFailedVmFileInfo {
}
impl DataObjectTrait for UserSearchResult {
}
impl DataObjectTrait for PosixUserSearchResult {
}
impl DataObjectTrait for UserSession {
}
impl DataObjectTrait for VVolVmConfigFileUpdateResult {
}
impl DataObjectTrait for VVolVmConfigFileUpdateResultFailedVmConfigFileInfo {
}
impl DataObjectTrait for VasaStorageArray {
}
impl DataObjectTrait for VasaStorageArrayDiscoveryFcTransport {
}
impl DataObjectTrait for VasaStorageArrayDiscoveryIpTransport {
}
impl DataObjectTrait for VasaStorageArrayDiscoverySvcInfo {
}
impl DataObjectTrait for VasaProviderContainerSpec {
}
impl DataObjectTrait for VimVasaProvider {
}
impl DataObjectTrait for VimVasaProviderStatePerArray {
}
impl DataObjectTrait for VimVasaProviderVirtualHostConfig {
}
impl DataObjectTrait for VimVasaProviderInfo {
}
impl DataObjectTrait for VirtualAppLinkInfo {
}
impl DataObjectTrait for VirtualDiskSpec {
}
impl DataObjectTrait for DeviceBackedVirtualDiskSpec {
}
impl DataObjectTrait for FileBackedVirtualDiskSpec {
}
impl DataObjectTrait for SeSparseVirtualDiskSpec {
}
impl DataObjectTrait for VirtualMachineConnection {
}
impl DataObjectTrait for VirtualMachineMksConnection {
}
impl DataObjectTrait for DiskChangeInfo {
}
impl DataObjectTrait for DiskChangeExtent {
}
impl DataObjectTrait for VirtualMachineDisplayTopology {
}
impl DataObjectTrait for VirtualMachineMksTicket {
}
impl DataObjectTrait for StorageRequirement {
}
impl DataObjectTrait for VirtualMachineTicket {
}
impl DataObjectTrait for VirtualMachineWipeResult {
}
impl DataObjectTrait for VsanUpgradeSystemNetworkPartitionInfo {
}
impl DataObjectTrait for VsanUpgradeSystemPreflightCheckIssue {
}
impl DataObjectTrait for VsanUpgradeSystemApiBrokenIssue {
}
impl DataObjectTrait for VsanUpgradeSystemAutoClaimEnabledOnHostsIssue {
}
impl DataObjectTrait for VsanUpgradeSystemHostsDisconnectedIssue {
}
impl DataObjectTrait for VsanUpgradeSystemMissingHostsInClusterIssue {
}
impl DataObjectTrait for VsanUpgradeSystemNetworkPartitionIssue {
}
impl DataObjectTrait for VsanUpgradeSystemNotEnoughFreeCapacityIssue {
}
impl DataObjectTrait for VsanUpgradeSystemRogueHostsInClusterIssue {
}
impl DataObjectTrait for VsanUpgradeSystemV2ObjectsPresentDuringDowngradeIssue {
}
impl DataObjectTrait for VsanUpgradeSystemWrongEsxVersionIssue {
}
impl DataObjectTrait for VsanUpgradeSystemPreflightCheckResult {
}
impl DataObjectTrait for VsanUpgradeSystemUpgradeHistoryItem {
}
impl DataObjectTrait for VsanUpgradeSystemUpgradeHistoryDiskGroupOp {
}
impl DataObjectTrait for VsanUpgradeSystemUpgradeHistoryPreflightFail {
}
impl DataObjectTrait for VsanUpgradeSystemUpgradeStatus {
}
impl DataObjectTrait for Action {
}
impl DataObjectTrait for CreateTaskAction {
}
impl DataObjectTrait for MethodAction {
}
impl DataObjectTrait for RunScriptAction {
}
impl DataObjectTrait for SendEmailAction {
}
impl DataObjectTrait for SendSnmpAction {
}
impl DataObjectTrait for MethodActionArgument {
}
impl DataObjectTrait for AlarmAction {
}
impl DataObjectTrait for AlarmTriggeringAction {
}
impl DataObjectTrait for GroupAlarmAction {
}
impl DataObjectTrait for AlarmDescription {
}
impl DataObjectTrait for AlarmExpression {
}
impl DataObjectTrait for AndAlarmExpression {
}
impl DataObjectTrait for EventAlarmExpression {
}
impl DataObjectTrait for MetricAlarmExpression {
}
impl DataObjectTrait for OrAlarmExpression {
}
impl DataObjectTrait for StateAlarmExpression {
}
impl DataObjectTrait for AlarmFilterSpec {
}
impl DataObjectTrait for AlarmSetting {
}
impl DataObjectTrait for AlarmSpec {
}
impl DataObjectTrait for AlarmInfo {
}
impl DataObjectTrait for AlarmState {
}
impl DataObjectTrait for AlarmTriggeringActionTransitionSpec {
}
impl DataObjectTrait for EventAlarmExpressionComparison {
}
impl DataObjectTrait for ClusterAction {
}
impl DataObjectTrait for ClusterClusterInitialPlacementAction {
}
impl DataObjectTrait for ClusterHostInfraUpdateHaModeAction {
}
impl DataObjectTrait for ClusterHostPowerAction {
}
impl DataObjectTrait for ClusterInitialPlacementAction {
}
impl DataObjectTrait for ClusterMigrationAction {
}
impl DataObjectTrait for PlacementAction {
}
impl DataObjectTrait for HbrDiskMigrationAction {
}
impl DataObjectTrait for StorageMigrationAction {
}
impl DataObjectTrait for StoragePlacementAction {
}
impl DataObjectTrait for ClusterActionHistory {
}
impl DataObjectTrait for ClusterAttemptedVmInfo {
}
impl DataObjectTrait for ClusterConfigInfo {
}
impl DataObjectTrait for ClusterConfigSpec {
}
impl DataObjectTrait for ClusterCryptoConfigInfo {
}
impl DataObjectTrait for ClusterDasAamNodeState {
}
impl DataObjectTrait for ClusterDasAdmissionControlInfo {
}
impl DataObjectTrait for ClusterFailoverHostAdmissionControlInfo {
}
impl DataObjectTrait for ClusterFailoverLevelAdmissionControlInfo {
}
impl DataObjectTrait for ClusterFailoverResourcesAdmissionControlInfo {
}
impl DataObjectTrait for ClusterDasAdmissionControlPolicy {
}
impl DataObjectTrait for ClusterFailoverHostAdmissionControlPolicy {
}
impl DataObjectTrait for ClusterFailoverLevelAdmissionControlPolicy {
}
impl DataObjectTrait for ClusterFailoverResourcesAdmissionControlPolicy {
}
impl DataObjectTrait for ClusterDasAdvancedRuntimeInfo {
}
impl DataObjectTrait for ClusterDasFailoverLevelAdvancedRuntimeInfo {
}
impl DataObjectTrait for DasHeartbeatDatastoreInfo {
}
impl DataObjectTrait for ClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo {
}
impl DataObjectTrait for ClusterDasConfigInfo {
}
impl DataObjectTrait for ClusterDasData {
}
impl DataObjectTrait for ClusterDasDataSummary {
}
impl DataObjectTrait for ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots {
}
impl DataObjectTrait for ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo {
}
impl DataObjectTrait for ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots {
}
impl DataObjectTrait for ClusterDasFdmHostState {
}
impl DataObjectTrait for ClusterDasHostInfo {
}
impl DataObjectTrait for ClusterDasAamHostInfo {
}
impl DataObjectTrait for ClusterDasHostRecommendation {
}
impl DataObjectTrait for ClusterDasVmConfigInfo {
}
impl DataObjectTrait for ClusterDasVmSettings {
}
impl DataObjectTrait for ClusterDpmConfigInfo {
}
impl DataObjectTrait for ClusterDpmHostConfigInfo {
}
impl DataObjectTrait for ClusterDrsConfigInfo {
}
impl DataObjectTrait for ClusterDrsFaults {
}
impl DataObjectTrait for ClusterDrsFaultsFaultsByVm {
}
impl DataObjectTrait for ClusterDrsFaultsFaultsByVirtualDisk {
}
impl DataObjectTrait for ClusterDrsMigration {
}
impl DataObjectTrait for ClusterDrsRecommendation {
}
impl DataObjectTrait for ClusterDrsVmConfigInfo {
}
impl DataObjectTrait for ClusterEvcManagerCheckResult {
}
impl DataObjectTrait for ClusterEvcManagerEvcState {
}
impl DataObjectTrait for ClusterEnterMaintenanceResult {
}
impl DataObjectTrait for ClusterFailoverHostAdmissionControlInfoHostStatus {
}
impl DataObjectTrait for ClusterGroupInfo {
}
impl DataObjectTrait for ClusterHostGroup {
}
impl DataObjectTrait for ClusterVmGroup {
}
impl DataObjectTrait for ClusterHostRecommendation {
}
impl DataObjectTrait for ClusterInfraUpdateHaConfigInfo {
}
impl DataObjectTrait for ClusterNotAttemptedVmInfo {
}
impl DataObjectTrait for ClusterOrchestrationInfo {
}
impl DataObjectTrait for PlacementResult {
}
impl DataObjectTrait for PlacementSpec {
}
impl DataObjectTrait for ClusterPowerOnVmResult {
}
impl DataObjectTrait for ClusterPreemptibleVmPairInfo {
}
impl DataObjectTrait for ClusterProactiveDrsConfigInfo {
}
impl DataObjectTrait for ClusterRecommendation {
}
impl DataObjectTrait for ClusterResourceUsageSummary {
}
impl DataObjectTrait for ClusterRuleInfo {
}
impl DataObjectTrait for ClusterAffinityRuleSpec {
}
impl DataObjectTrait for ClusterAntiAffinityRuleSpec {
}
impl DataObjectTrait for ClusterDependencyRuleInfo {
}
impl DataObjectTrait for ClusterVmHostRuleInfo {
}
impl DataObjectTrait for VirtualDiskAntiAffinityRuleSpec {
}
impl DataObjectTrait for VirtualDiskRuleSpec {
}
impl DataObjectTrait for ClusterSlotPolicy {
}
impl DataObjectTrait for ClusterFixedSizeSlotPolicy {
}
impl DataObjectTrait for ClusterSystemVMsConfigInfo {
}
impl DataObjectTrait for ClusterSystemVMsConfigSpec {
}
impl DataObjectTrait for ClusterUsageSummary {
}
impl DataObjectTrait for ClusterVmComponentProtectionSettings {
}
impl DataObjectTrait for ClusterVmOrchestrationInfo {
}
impl DataObjectTrait for ClusterVmReadiness {
}
impl DataObjectTrait for ClusterVmToolsMonitoringSettings {
}
impl DataObjectTrait for DistributedVirtualPort {
}
impl DataObjectTrait for DvPortConfigInfo {
}
impl DataObjectTrait for DvPortConfigSpec {
}
impl DataObjectTrait for DvsFilterParameter {
}
impl DataObjectTrait for DvsHostLocalPortInfo {
}
impl DataObjectTrait for DvPortStatus {
}
impl DataObjectTrait for DvPortSetting {
}
impl DataObjectTrait for VMwareDvsPortSetting {
}
impl DataObjectTrait for DvPortState {
}
impl DataObjectTrait for DvPortgroupConfigInfo {
}
impl DataObjectTrait for DvPortgroupConfigSpec {
}
impl DataObjectTrait for DistributedVirtualPortgroupNsxPortgroupOperationResult {
}
impl DataObjectTrait for DvPortgroupPolicy {
}
impl DataObjectTrait for VMwareDvsPortgroupPolicy {
}
impl DataObjectTrait for DistributedVirtualPortgroupProblem {
}
impl DataObjectTrait for DistributedVirtualPortgroupInfo {
}
impl DataObjectTrait for DistributedVirtualSwitchInfo {
}
impl DataObjectTrait for DistributedVirtualSwitchManagerCompatibilityResult {
}
impl DataObjectTrait for DvsManagerDvsConfigTarget {
}
impl DataObjectTrait for DistributedVirtualSwitchManagerDvsProductSpec {
}
impl DataObjectTrait for DistributedVirtualSwitchManagerHostContainer {
}
impl DataObjectTrait for DistributedVirtualSwitchManagerHostDvsFilterSpec {
}
impl DataObjectTrait for DistributedVirtualSwitchManagerHostArrayFilter {
}
impl DataObjectTrait for DistributedVirtualSwitchManagerHostContainerFilter {
}
impl DataObjectTrait for DistributedVirtualSwitchManagerHostDvsMembershipFilter {
}
impl DataObjectTrait for DistributedVirtualSwitchManagerImportResult {
}
impl DataObjectTrait for DvsManagerPhysicalNicsList {
}
impl DataObjectTrait for EntityBackup {
}
impl DataObjectTrait for EntityBackupConfig {
}
impl DataObjectTrait for DistributedVirtualSwitchHostMember {
}
impl DataObjectTrait for DistributedVirtualSwitchHostMemberBacking {
}
impl DataObjectTrait for DistributedVirtualSwitchHostMemberPnicBacking {
}
impl DataObjectTrait for DistributedVirtualSwitchHostMemberConfigInfo {
}
impl DataObjectTrait for DistributedVirtualSwitchHostMemberConfigSpec {
}
impl DataObjectTrait for HostMemberHealthCheckResult {
}
impl DataObjectTrait for HostMemberUplinkHealthCheckResult {
}
impl DataObjectTrait for VMwareDvsMtuHealthCheckResult {
}
impl DataObjectTrait for VMwareDvsVlanHealthCheckResult {
}
impl DataObjectTrait for VMwareDvsTeamingHealthCheckResult {
}
impl DataObjectTrait for DistributedVirtualSwitchHostMemberPnicSpec {
}
impl DataObjectTrait for HostMemberRuntimeInfo {
}
impl DataObjectTrait for DistributedVirtualSwitchHostMemberRuntimeState {
}
impl DataObjectTrait for DistributedVirtualSwitchHostMemberTransportZoneInfo {
}
impl DataObjectTrait for DistributedVirtualSwitchHostProductSpec {
}
impl DataObjectTrait for DistributedVirtualSwitchKeyedOpaqueBlob {
}
impl DataObjectTrait for DistributedVirtualSwitchNetworkOffloadSpec {
}
impl DataObjectTrait for DvsNetworkResourcePool {
}
impl DataObjectTrait for DvsNetworkResourcePoolAllocationInfo {
}
impl DataObjectTrait for DvsNetworkResourcePoolConfigSpec {
}
impl DataObjectTrait for DistributedVirtualSwitchPortConnectee {
}
impl DataObjectTrait for DistributedVirtualSwitchPortConnection {
}
impl DataObjectTrait for DistributedVirtualSwitchPortCriteria {
}
impl DataObjectTrait for DistributedVirtualSwitchPortStatistics {
}
impl DataObjectTrait for DistributedVirtualSwitchProductSpec {
}
impl DataObjectTrait for DvsTrafficRule {
}
impl DataObjectTrait for DvsNetworkRuleAction {
}
impl DataObjectTrait for DvsAcceptNetworkRuleAction {
}
impl DataObjectTrait for DvsCopyNetworkRuleAction {
}
impl DataObjectTrait for DvsDropNetworkRuleAction {
}
impl DataObjectTrait for DvsGreEncapNetworkRuleAction {
}
impl DataObjectTrait for DvsLogNetworkRuleAction {
}
impl DataObjectTrait for DvsMacRewriteNetworkRuleAction {
}
impl DataObjectTrait for DvsPuntNetworkRuleAction {
}
impl DataObjectTrait for DvsRateLimitNetworkRuleAction {
}
impl DataObjectTrait for DvsUpdateTagNetworkRuleAction {
}
impl DataObjectTrait for DvsNetworkRuleQualifier {
}
impl DataObjectTrait for DvsIpNetworkRuleQualifier {
}
impl DataObjectTrait for DvsMacNetworkRuleQualifier {
}
impl DataObjectTrait for DvsSystemTrafficNetworkRuleQualifier {
}
impl DataObjectTrait for DvsTrafficRuleset {
}
impl DataObjectTrait for DvsVmVnicNetworkResourcePool {
}
impl DataObjectTrait for DvsVmVnicResourcePoolConfigSpec {
}
impl DataObjectTrait for DvsVmVnicResourceAllocation {
}
impl DataObjectTrait for DvsVmVnicNetworkResourcePoolRuntimeInfo {
}
impl DataObjectTrait for DvsVnicAllocatedResource {
}
impl DataObjectTrait for VMwareDvsDpuCapability {
}
impl DataObjectTrait for VMwareIpfixConfig {
}
impl DataObjectTrait for VMwareDvsIpfixCapability {
}
impl DataObjectTrait for VMwareDvsLacpCapability {
}
impl DataObjectTrait for VMwareDvsLacpGroupConfig {
}
impl DataObjectTrait for VMwareDvsLacpGroupSpec {
}
impl DataObjectTrait for VMwareDvsLagIpfixConfig {
}
impl DataObjectTrait for VMwareDvsLagVlanConfig {
}
impl DataObjectTrait for VMwareDvsMtuCapability {
}
impl DataObjectTrait for VMwareDvsPvlanConfigSpec {
}
impl DataObjectTrait for VMwareDvsPvlanMapEntry {
}
impl DataObjectTrait for VMwareDvsVspanConfigSpec {
}
impl DataObjectTrait for VMwareDvsVspanCapability {
}
impl DataObjectTrait for VMwareVspanPort {
}
impl DataObjectTrait for VMwareVspanSession {
}
impl DataObjectTrait for CryptoKeyId {
}
impl DataObjectTrait for CryptoKeyPlain {
}
impl DataObjectTrait for CryptoKeyResult {
}
impl DataObjectTrait for CryptoManagerHostKeyStatus {
}
impl DataObjectTrait for CryptoManagerKmipCertSignRequest {
}
impl DataObjectTrait for CryptoManagerKmipCertificateInfo {
}
impl DataObjectTrait for CryptoManagerKmipClusterStatus {
}
impl DataObjectTrait for CryptoManagerKmipCryptoKeyStatus {
}
impl DataObjectTrait for CryptoManagerKmipCustomAttributeSpec {
}
impl DataObjectTrait for CryptoManagerKmipServerCertInfo {
}
impl DataObjectTrait for CryptoManagerKmipServerStatus {
}
impl DataObjectTrait for CryptoSpec {
}
impl DataObjectTrait for CryptoSpecDecrypt {
}
impl DataObjectTrait for CryptoSpecDeepRecrypt {
}
impl DataObjectTrait for CryptoSpecEncrypt {
}
impl DataObjectTrait for CryptoSpecNoOp {
}
impl DataObjectTrait for CryptoSpecRegister {
}
impl DataObjectTrait for CryptoSpecShallowRecrypt {
}
impl DataObjectTrait for KeyProviderId {
}
impl DataObjectTrait for KmipClusterInfo {
}
impl DataObjectTrait for KmipServerInfo {
}
impl DataObjectTrait for KmipServerSpec {
}
impl DataObjectTrait for KmipServerStatus {
}
impl DataObjectTrait for ChangesInfoEventArgument {
}
impl DataObjectTrait for DvsOutOfSyncHostArgument {
}
impl DataObjectTrait for Event {
}
impl DataObjectTrait for AlarmEvent {
}
impl DataObjectTrait for AlarmAcknowledgedEvent {
}
impl DataObjectTrait for AlarmActionTriggeredEvent {
}
impl DataObjectTrait for AlarmClearedEvent {
}
impl DataObjectTrait for AlarmCreatedEvent {
}
impl DataObjectTrait for AlarmEmailCompletedEvent {
}
impl DataObjectTrait for AlarmEmailFailedEvent {
}
impl DataObjectTrait for AlarmReconfiguredEvent {
}
impl DataObjectTrait for AlarmRemovedEvent {
}
impl DataObjectTrait for AlarmScriptCompleteEvent {
}
impl DataObjectTrait for AlarmScriptFailedEvent {
}
impl DataObjectTrait for AlarmSnmpCompletedEvent {
}
impl DataObjectTrait for AlarmSnmpFailedEvent {
}
impl DataObjectTrait for AlarmStatusChangedEvent {
}
impl DataObjectTrait for AuthorizationEvent {
}
impl DataObjectTrait for PermissionEvent {
}
impl DataObjectTrait for PermissionAddedEvent {
}
impl DataObjectTrait for PermissionRemovedEvent {
}
impl DataObjectTrait for PermissionUpdatedEvent {
}
impl DataObjectTrait for RoleEvent {
}
impl DataObjectTrait for RoleAddedEvent {
}
impl DataObjectTrait for RoleRemovedEvent {
}
impl DataObjectTrait for RoleUpdatedEvent {
}
impl DataObjectTrait for ClusterEvent {
}
impl DataObjectTrait for ClusterComplianceCheckedEvent {
}
impl DataObjectTrait for ClusterCreatedEvent {
}
impl DataObjectTrait for ClusterDestroyedEvent {
}
impl DataObjectTrait for ClusterOvercommittedEvent {
}
impl DataObjectTrait for HostOvercommittedEvent {
}
impl DataObjectTrait for ClusterReconfiguredEvent {
}
impl DataObjectTrait for ClusterStatusChangedEvent {
}
impl DataObjectTrait for HostStatusChangedEvent {
}
impl DataObjectTrait for DasAdmissionControlDisabledEvent {
}
impl DataObjectTrait for DasAdmissionControlEnabledEvent {
}
impl DataObjectTrait for DasAgentFoundEvent {
}
impl DataObjectTrait for DasAgentUnavailableEvent {
}
impl DataObjectTrait for DasClusterIsolatedEvent {
}
impl DataObjectTrait for DasDisabledEvent {
}
impl DataObjectTrait for DasEnabledEvent {
}
impl DataObjectTrait for DasHostFailedEvent {
}
impl DataObjectTrait for DasHostIsolatedEvent {
}
impl DataObjectTrait for DrsDisabledEvent {
}
impl DataObjectTrait for DrsEnabledEvent {
}
impl DataObjectTrait for DrsInvocationFailedEvent {
}
impl DataObjectTrait for DrsRecoveredFromFailureEvent {
}
impl DataObjectTrait for FailoverLevelRestored {
}
impl DataObjectTrait for HostMonitoringStateChangedEvent {
}
impl DataObjectTrait for InsufficientFailoverResourcesEvent {
}
impl DataObjectTrait for VmHealthMonitoringStateChangedEvent {
}
impl DataObjectTrait for CustomFieldEvent {
}
impl DataObjectTrait for CustomFieldDefEvent {
}
impl DataObjectTrait for CustomFieldDefAddedEvent {
}
impl DataObjectTrait for CustomFieldDefRemovedEvent {
}
impl DataObjectTrait for CustomFieldDefRenamedEvent {
}
impl DataObjectTrait for CustomFieldValueChangedEvent {
}
impl DataObjectTrait for DvPortgroupEvent {
}
impl DataObjectTrait for DvPortgroupCreatedEvent {
}
impl DataObjectTrait for DvPortgroupDestroyedEvent {
}
impl DataObjectTrait for DvPortgroupReconfiguredEvent {
}
impl DataObjectTrait for DvPortgroupRenamedEvent {
}
impl DataObjectTrait for DvpgImportEvent {
}
impl DataObjectTrait for DvpgRestoreEvent {
}
impl DataObjectTrait for DatacenterEvent {
}
impl DataObjectTrait for DatacenterCreatedEvent {
}
impl DataObjectTrait for DatacenterRenamedEvent {
}
impl DataObjectTrait for DatastoreEvent {
}
impl DataObjectTrait for DatastoreCapacityIncreasedEvent {
}
impl DataObjectTrait for DatastoreDestroyedEvent {
}
impl DataObjectTrait for DatastoreDuplicatedEvent {
}
impl DataObjectTrait for DatastoreFileEvent {
}
impl DataObjectTrait for DatastoreFileCopiedEvent {
}
impl DataObjectTrait for DatastoreFileDeletedEvent {
}
impl DataObjectTrait for DatastoreFileMovedEvent {
}
impl DataObjectTrait for DatastoreIormReconfiguredEvent {
}
impl DataObjectTrait for DatastoreRenamedEvent {
}
impl DataObjectTrait for NonViWorkloadDetectedOnDatastoreEvent {
}
impl DataObjectTrait for DvsEvent {
}
impl DataObjectTrait for DvsCreatedEvent {
}
impl DataObjectTrait for DvsDestroyedEvent {
}
impl DataObjectTrait for DvsHostBackInSyncEvent {
}
impl DataObjectTrait for DvsHostJoinedEvent {
}
impl DataObjectTrait for DvsHostLeftEvent {
}
impl DataObjectTrait for DvsHostStatusUpdated {
}
impl DataObjectTrait for DvsHostWentOutOfSyncEvent {
}
impl DataObjectTrait for DvsImportEvent {
}
impl DataObjectTrait for DvsMergedEvent {
}
impl DataObjectTrait for DvsPortBlockedEvent {
}
impl DataObjectTrait for DvsPortConnectedEvent {
}
impl DataObjectTrait for DvsPortCreatedEvent {
}
impl DataObjectTrait for DvsPortDeletedEvent {
}
impl DataObjectTrait for DvsPortDisconnectedEvent {
}
impl DataObjectTrait for DvsPortEnteredPassthruEvent {
}
impl DataObjectTrait for DvsPortExitedPassthruEvent {
}
impl DataObjectTrait for DvsPortJoinPortgroupEvent {
}
impl DataObjectTrait for DvsPortLeavePortgroupEvent {
}
impl DataObjectTrait for DvsPortLinkDownEvent {
}
impl DataObjectTrait for DvsPortLinkUpEvent {
}
impl DataObjectTrait for DvsPortReconfiguredEvent {
}
impl DataObjectTrait for DvsPortRuntimeChangeEvent {
}
impl DataObjectTrait for DvsPortUnblockedEvent {
}
impl DataObjectTrait for DvsPortVendorSpecificStateChangeEvent {
}
impl DataObjectTrait for DvsReconfiguredEvent {
}
impl DataObjectTrait for DvsRenamedEvent {
}
impl DataObjectTrait for DvsRestoreEvent {
}
impl DataObjectTrait for DvsUpgradeAvailableEvent {
}
impl DataObjectTrait for DvsUpgradeInProgressEvent {
}
impl DataObjectTrait for DvsUpgradeRejectedEvent {
}
impl DataObjectTrait for DvsUpgradedEvent {
}
impl DataObjectTrait for HostLocalPortCreatedEvent {
}
impl DataObjectTrait for OutOfSyncDvsHost {
}
impl DataObjectTrait for RecoveryEvent {
}
impl DataObjectTrait for RollbackEvent {
}
impl DataObjectTrait for VmVnicPoolReservationViolationClearEvent {
}
impl DataObjectTrait for VmVnicPoolReservationViolationRaiseEvent {
}
impl DataObjectTrait for EventEx {
}
impl DataObjectTrait for GeneralEvent {
}
impl DataObjectTrait for ExtendedEvent {
}
impl DataObjectTrait for GeneralHostErrorEvent {
}
impl DataObjectTrait for GeneralHostInfoEvent {
}
impl DataObjectTrait for GeneralHostWarningEvent {
}
impl DataObjectTrait for GeneralUserEvent {
}
impl DataObjectTrait for GeneralVmErrorEvent {
}
impl DataObjectTrait for GeneralVmInfoEvent {
}
impl DataObjectTrait for GeneralVmWarningEvent {
}
impl DataObjectTrait for HealthStatusChangedEvent {
}
impl DataObjectTrait for HostEvent {
}
impl DataObjectTrait for AccountCreatedEvent {
}
impl DataObjectTrait for AccountRemovedEvent {
}
impl DataObjectTrait for AccountUpdatedEvent {
}
impl DataObjectTrait for AdminPasswordNotChangedEvent {
}
impl DataObjectTrait for CanceledHostOperationEvent {
}
impl DataObjectTrait for DatastoreDiscoveredEvent {
}
impl DataObjectTrait for DatastorePrincipalConfigured {
}
impl DataObjectTrait for DatastoreRemovedOnHostEvent {
}
impl DataObjectTrait for DatastoreRenamedOnHostEvent {
}
impl DataObjectTrait for DrsResourceConfigureFailedEvent {
}
impl DataObjectTrait for DrsResourceConfigureSyncedEvent {
}
impl DataObjectTrait for DuplicateIpDetectedEvent {
}
impl DataObjectTrait for DvsHealthStatusChangeEvent {
}
impl DataObjectTrait for MtuMatchEvent {
}
impl DataObjectTrait for MtuMismatchEvent {
}
impl DataObjectTrait for TeamingMatchEvent {
}
impl DataObjectTrait for TeamingMisMatchEvent {
}
impl DataObjectTrait for UplinkPortMtuNotSupportEvent {
}
impl DataObjectTrait for UplinkPortMtuSupportEvent {
}
impl DataObjectTrait for UplinkPortVlanTrunkedEvent {
}
impl DataObjectTrait for UplinkPortVlanUntrunkedEvent {
}
impl DataObjectTrait for EnteredMaintenanceModeEvent {
}
impl DataObjectTrait for EnteredStandbyModeEvent {
}
impl DataObjectTrait for DrsEnteredStandbyModeEvent {
}
impl DataObjectTrait for EnteringMaintenanceModeEvent {
}
impl DataObjectTrait for EnteringStandbyModeEvent {
}
impl DataObjectTrait for DrsEnteringStandbyModeEvent {
}
impl DataObjectTrait for ExitMaintenanceModeEvent {
}
impl DataObjectTrait for ExitStandbyModeFailedEvent {
}
impl DataObjectTrait for DrsExitStandbyModeFailedEvent {
}
impl DataObjectTrait for ExitedStandbyModeEvent {
}
impl DataObjectTrait for DrsExitedStandbyModeEvent {
}
impl DataObjectTrait for ExitingStandbyModeEvent {
}
impl DataObjectTrait for DrsExitingStandbyModeEvent {
}
impl DataObjectTrait for GhostDvsProxySwitchDetectedEvent {
}
impl DataObjectTrait for GhostDvsProxySwitchRemovedEvent {
}
impl DataObjectTrait for HostAddFailedEvent {
}
impl DataObjectTrait for HostAddedEvent {
}
impl DataObjectTrait for HostAdminDisableEvent {
}
impl DataObjectTrait for HostAdminEnableEvent {
}
impl DataObjectTrait for HostCnxFailedAccountFailedEvent {
}
impl DataObjectTrait for HostCnxFailedAlreadyManagedEvent {
}
impl DataObjectTrait for HostCnxFailedBadCcagentEvent {
}
impl DataObjectTrait for HostCnxFailedBadUsernameEvent {
}
impl DataObjectTrait for HostCnxFailedBadVersionEvent {
}
impl DataObjectTrait for HostCnxFailedCcagentUpgradeEvent {
}
impl DataObjectTrait for HostCnxFailedEvent {
}
impl DataObjectTrait for HostCnxFailedNetworkErrorEvent {
}
impl DataObjectTrait for HostCnxFailedNoAccessEvent {
}
impl DataObjectTrait for HostCnxFailedNoConnectionEvent {
}
impl DataObjectTrait for HostCnxFailedNoLicenseEvent {
}
impl DataObjectTrait for HostCnxFailedNotFoundEvent {
}
impl DataObjectTrait for HostCnxFailedTimeoutEvent {
}
impl DataObjectTrait for HostComplianceCheckedEvent {
}
impl DataObjectTrait for HostCompliantEvent {
}
impl DataObjectTrait for HostConfigAppliedEvent {
}
impl DataObjectTrait for HostConnectedEvent {
}
impl DataObjectTrait for HostConnectionLostEvent {
}
impl DataObjectTrait for HostDasDisabledEvent {
}
impl DataObjectTrait for HostDasDisablingEvent {
}
impl DataObjectTrait for HostDasEnabledEvent {
}
impl DataObjectTrait for HostDasEnablingEvent {
}
impl DataObjectTrait for HostDasErrorEvent {
}
impl DataObjectTrait for HostDasEvent {
}
impl DataObjectTrait for HostExtraNetworksEvent {
}
impl DataObjectTrait for HostIsolationIpPingFailedEvent {
}
impl DataObjectTrait for HostMissingNetworksEvent {
}
impl DataObjectTrait for HostNoAvailableNetworksEvent {
}
impl DataObjectTrait for HostNoHaEnabledPortGroupsEvent {
}
impl DataObjectTrait for HostNoRedundantManagementNetworkEvent {
}
impl DataObjectTrait for HostNotInClusterEvent {
}
impl DataObjectTrait for HostPrimaryAgentNotShortNameEvent {
}
impl DataObjectTrait for HostShortNameInconsistentEvent {
}
impl DataObjectTrait for HostDasOkEvent {
}
impl DataObjectTrait for HostDisconnectedEvent {
}
impl DataObjectTrait for HostEnableAdminFailedEvent {
}
impl DataObjectTrait for HostGetShortNameFailedEvent {
}
impl DataObjectTrait for HostInAuditModeEvent {
}
impl DataObjectTrait for HostIpChangedEvent {
}
impl DataObjectTrait for HostIpInconsistentEvent {
}
impl DataObjectTrait for HostIpToShortNameFailedEvent {
}
impl DataObjectTrait for HostNonCompliantEvent {
}
impl DataObjectTrait for HostProfileAppliedEvent {
}
impl DataObjectTrait for HostReconnectionFailedEvent {
}
impl DataObjectTrait for HostRemovedEvent {
}
impl DataObjectTrait for HostShortNameToIpFailedEvent {
}
impl DataObjectTrait for HostShutdownEvent {
}
impl DataObjectTrait for HostSpecificationChangedEvent {
}
impl DataObjectTrait for HostSpecificationRequireEvent {
}
impl DataObjectTrait for HostSpecificationUpdateEvent {
}
impl DataObjectTrait for HostSubSpecificationDeleteEvent {
}
impl DataObjectTrait for HostSubSpecificationUpdateEvent {
}
impl DataObjectTrait for HostSyncFailedEvent {
}
impl DataObjectTrait for HostUpgradeFailedEvent {
}
impl DataObjectTrait for HostUserWorldSwapNotEnabledEvent {
}
impl DataObjectTrait for HostVnicConnectedToCustomizedDvPortEvent {
}
impl DataObjectTrait for HostWwnChangedEvent {
}
impl DataObjectTrait for HostWwnConflictEvent {
}
impl DataObjectTrait for LocalDatastoreCreatedEvent {
}
impl DataObjectTrait for LocalTsmEnabledEvent {
}
impl DataObjectTrait for NasDatastoreCreatedEvent {
}
impl DataObjectTrait for NoDatastoresConfiguredEvent {
}
impl DataObjectTrait for RemoteTsmEnabledEvent {
}
impl DataObjectTrait for TimedOutHostOperationEvent {
}
impl DataObjectTrait for UpdatedAgentBeingRestartedEvent {
}
impl DataObjectTrait for UserAssignedToGroup {
}
impl DataObjectTrait for UserPasswordChanged {
}
impl DataObjectTrait for UserUnassignedFromGroup {
}
impl DataObjectTrait for VmfsDatastoreCreatedEvent {
}
impl DataObjectTrait for VmfsDatastoreExpandedEvent {
}
impl DataObjectTrait for VmfsDatastoreExtendedEvent {
}
impl DataObjectTrait for VcAgentUninstallFailedEvent {
}
impl DataObjectTrait for VcAgentUninstalledEvent {
}
impl DataObjectTrait for VcAgentUpgradeFailedEvent {
}
impl DataObjectTrait for VcAgentUpgradedEvent {
}
impl DataObjectTrait for VimAccountPasswordChangedEvent {
}
impl DataObjectTrait for IScsiBootFailureEvent {
}
impl DataObjectTrait for HostInventoryUnreadableEvent {
}
impl DataObjectTrait for LicenseEvent {
}
impl DataObjectTrait for AllVirtualMachinesLicensedEvent {
}
impl DataObjectTrait for HostInventoryFullEvent {
}
impl DataObjectTrait for HostLicenseExpiredEvent {
}
impl DataObjectTrait for IncorrectHostInformationEvent {
}
impl DataObjectTrait for InvalidEditionEvent {
}
impl DataObjectTrait for LicenseNonComplianceEvent {
}
impl DataObjectTrait for LicenseRestrictedEvent {
}
impl DataObjectTrait for LicenseServerAvailableEvent {
}
impl DataObjectTrait for LicenseServerUnavailableEvent {
}
impl DataObjectTrait for NoLicenseEvent {
}
impl DataObjectTrait for ServerLicenseExpiredEvent {
}
impl DataObjectTrait for UnlicensedVirtualMachinesEvent {
}
impl DataObjectTrait for UnlicensedVirtualMachinesFoundEvent {
}
impl DataObjectTrait for VMotionLicenseExpiredEvent {
}
impl DataObjectTrait for LicenseExpiredEvent {
}
impl DataObjectTrait for LockerMisconfiguredEvent {
}
impl DataObjectTrait for LockerReconfiguredEvent {
}
impl DataObjectTrait for NetworkRollbackEvent {
}
impl DataObjectTrait for ProfileEvent {
}
impl DataObjectTrait for ProfileAssociatedEvent {
}
impl DataObjectTrait for ProfileChangedEvent {
}
impl DataObjectTrait for ProfileCreatedEvent {
}
impl DataObjectTrait for ProfileDissociatedEvent {
}
impl DataObjectTrait for ProfileReferenceHostChangedEvent {
}
impl DataObjectTrait for ProfileRemovedEvent {
}
impl DataObjectTrait for ResourcePoolEvent {
}
impl DataObjectTrait for ResourcePoolCreatedEvent {
}
impl DataObjectTrait for ResourcePoolDestroyedEvent {
}
impl DataObjectTrait for ResourcePoolMovedEvent {
}
impl DataObjectTrait for ResourcePoolReconfiguredEvent {
}
impl DataObjectTrait for ResourceViolatedEvent {
}
impl DataObjectTrait for ScheduledTaskEvent {
}
impl DataObjectTrait for ScheduledTaskCompletedEvent {
}
impl DataObjectTrait for ScheduledTaskCreatedEvent {
}
impl DataObjectTrait for ScheduledTaskEmailCompletedEvent {
}
impl DataObjectTrait for ScheduledTaskEmailFailedEvent {
}
impl DataObjectTrait for ScheduledTaskFailedEvent {
}
impl DataObjectTrait for ScheduledTaskReconfiguredEvent {
}
impl DataObjectTrait for ScheduledTaskRemovedEvent {
}
impl DataObjectTrait for ScheduledTaskStartedEvent {
}
impl DataObjectTrait for SessionEvent {
}
impl DataObjectTrait for AlreadyAuthenticatedSessionEvent {
}
impl DataObjectTrait for BadUsernameSessionEvent {
}
impl DataObjectTrait for GlobalMessageChangedEvent {
}
impl DataObjectTrait for NoAccessUserEvent {
}
impl DataObjectTrait for ServerStartedSessionEvent {
}
impl DataObjectTrait for SessionTerminatedEvent {
}
impl DataObjectTrait for UserLoginSessionEvent {
}
impl DataObjectTrait for UserLogoutSessionEvent {
}
impl DataObjectTrait for TaskEvent {
}
impl DataObjectTrait for TaskTimeoutEvent {
}
impl DataObjectTrait for TemplateUpgradeEvent {
}
impl DataObjectTrait for TemplateBeingUpgradedEvent {
}
impl DataObjectTrait for TemplateUpgradeFailedEvent {
}
impl DataObjectTrait for TemplateUpgradedEvent {
}
impl DataObjectTrait for UpgradeEvent {
}
impl DataObjectTrait for ErrorUpgradeEvent {
}
impl DataObjectTrait for InfoUpgradeEvent {
}
impl DataObjectTrait for UserUpgradeEvent {
}
impl DataObjectTrait for WarningUpgradeEvent {
}
impl DataObjectTrait for VmEvent {
}
impl DataObjectTrait for CustomizationEvent {
}
impl DataObjectTrait for CustomizationFailed {
}
impl DataObjectTrait for CustomizationLinuxIdentityFailed {
}
impl DataObjectTrait for CustomizationNetworkSetupFailed {
}
impl DataObjectTrait for CustomizationSysprepFailed {
}
impl DataObjectTrait for CustomizationUnknownFailure {
}
impl DataObjectTrait for CustomizationStartedEvent {
}
impl DataObjectTrait for CustomizationSucceeded {
}
impl DataObjectTrait for DrsRuleComplianceEvent {
}
impl DataObjectTrait for DrsRuleViolationEvent {
}
impl DataObjectTrait for DrsSoftRuleViolationEvent {
}
impl DataObjectTrait for MigrationEvent {
}
impl DataObjectTrait for MigrationErrorEvent {
}
impl DataObjectTrait for MigrationHostErrorEvent {
}
impl DataObjectTrait for MigrationHostWarningEvent {
}
impl DataObjectTrait for MigrationResourceErrorEvent {
}
impl DataObjectTrait for MigrationResourceWarningEvent {
}
impl DataObjectTrait for MigrationWarningEvent {
}
impl DataObjectTrait for NoMaintenanceModeDrsRecommendationForVm {
}
impl DataObjectTrait for NotEnoughResourcesToStartVmEvent {
}
impl DataObjectTrait for VmAcquiredMksTicketEvent {
}
impl DataObjectTrait for VmAcquiredTicketEvent {
}
impl DataObjectTrait for VmAutoRenameEvent {
}
impl DataObjectTrait for VmBeingCreatedEvent {
}
impl DataObjectTrait for VmBeingDeployedEvent {
}
impl DataObjectTrait for VmBeingHotMigratedEvent {
}
impl DataObjectTrait for VmBeingMigratedEvent {
}
impl DataObjectTrait for VmCloneEvent {
}
impl DataObjectTrait for VmBeingClonedEvent {
}
impl DataObjectTrait for VmBeingClonedNoFolderEvent {
}
impl DataObjectTrait for VmCloneFailedEvent {
}
impl DataObjectTrait for VmClonedEvent {
}
impl DataObjectTrait for VmConfigMissingEvent {
}
impl DataObjectTrait for VmConnectedEvent {
}
impl DataObjectTrait for VmCreatedEvent {
}
impl DataObjectTrait for VmDasBeingResetEvent {
}
impl DataObjectTrait for VmDasBeingResetWithScreenshotEvent {
}
impl DataObjectTrait for VmDasResetFailedEvent {
}
impl DataObjectTrait for VmDasUpdateErrorEvent {
}
impl DataObjectTrait for VmDasUpdateOkEvent {
}
impl DataObjectTrait for VmDateRolledBackEvent {
}
impl DataObjectTrait for VmDeployFailedEvent {
}
impl DataObjectTrait for VmDeployedEvent {
}
impl DataObjectTrait for VmDisconnectedEvent {
}
impl DataObjectTrait for VmDiscoveredEvent {
}
impl DataObjectTrait for VmDiskFailedEvent {
}
impl DataObjectTrait for VmEmigratingEvent {
}
impl DataObjectTrait for VmEndRecordingEvent {
}
impl DataObjectTrait for VmEndReplayingEvent {
}
impl DataObjectTrait for VmFailedMigrateEvent {
}
impl DataObjectTrait for VmFailedRelayoutEvent {
}
impl DataObjectTrait for VmFailedRelayoutOnVmfs2DatastoreEvent {
}
impl DataObjectTrait for VmFailedStartingSecondaryEvent {
}
impl DataObjectTrait for VmFailedToPowerOffEvent {
}
impl DataObjectTrait for VmFailedToPowerOnEvent {
}
impl DataObjectTrait for VmFailedToRebootGuestEvent {
}
impl DataObjectTrait for VmFailedToResetEvent {
}
impl DataObjectTrait for VmFailedToShutdownGuestEvent {
}
impl DataObjectTrait for VmFailedToStandbyGuestEvent {
}
impl DataObjectTrait for VmFailedToSuspendEvent {
}
impl DataObjectTrait for VmFailedUpdatingSecondaryConfig {
}
impl DataObjectTrait for VmFailoverFailed {
}
impl DataObjectTrait for VmFaultToleranceStateChangedEvent {
}
impl DataObjectTrait for VmFaultToleranceTurnedOffEvent {
}
impl DataObjectTrait for VmFaultToleranceVmTerminatedEvent {
}
impl DataObjectTrait for VmGuestOsCrashedEvent {
}
impl DataObjectTrait for VmGuestRebootEvent {
}
impl DataObjectTrait for VmGuestShutdownEvent {
}
impl DataObjectTrait for VmGuestStandbyEvent {
}
impl DataObjectTrait for VmInstanceUuidAssignedEvent {
}
impl DataObjectTrait for VmInstanceUuidChangedEvent {
}
impl DataObjectTrait for VmInstanceUuidConflictEvent {
}
impl DataObjectTrait for VmMacAssignedEvent {
}
impl DataObjectTrait for VmMacChangedEvent {
}
impl DataObjectTrait for VmMacConflictEvent {
}
impl DataObjectTrait for VmMaxFtRestartCountReached {
}
impl DataObjectTrait for VmMaxRestartCountReached {
}
impl DataObjectTrait for VmMessageErrorEvent {
}
impl DataObjectTrait for VmMessageEvent {
}
impl DataObjectTrait for VmMessageWarningEvent {
}
impl DataObjectTrait for VmMigratedEvent {
}
impl DataObjectTrait for DrsVmMigratedEvent {
}
impl DataObjectTrait for VmNoCompatibleHostForSecondaryEvent {
}
impl DataObjectTrait for VmNoNetworkAccessEvent {
}
impl DataObjectTrait for VmOrphanedEvent {
}
impl DataObjectTrait for VmPoweredOffEvent {
}
impl DataObjectTrait for VmPowerOffOnIsolationEvent {
}
impl DataObjectTrait for VmShutdownOnIsolationEvent {
}
impl DataObjectTrait for VmPoweredOnEvent {
}
impl DataObjectTrait for DrsVmPoweredOnEvent {
}
impl DataObjectTrait for VmRestartedOnAlternateHostEvent {
}
impl DataObjectTrait for VmPoweringOnWithCustomizedDvPortEvent {
}
impl DataObjectTrait for VmPrimaryFailoverEvent {
}
impl DataObjectTrait for VmReconfiguredEvent {
}
impl DataObjectTrait for VmRegisteredEvent {
}
impl DataObjectTrait for VmRelayoutSuccessfulEvent {
}
impl DataObjectTrait for VmRelayoutUpToDateEvent {
}
impl DataObjectTrait for VmReloadFromPathEvent {
}
impl DataObjectTrait for VmReloadFromPathFailedEvent {
}
impl DataObjectTrait for VmRelocateSpecEvent {
}
impl DataObjectTrait for VmBeingRelocatedEvent {
}
impl DataObjectTrait for VmRelocateFailedEvent {
}
impl DataObjectTrait for VmRelocatedEvent {
}
impl DataObjectTrait for VmRemoteConsoleConnectedEvent {
}
impl DataObjectTrait for VmRemoteConsoleDisconnectedEvent {
}
impl DataObjectTrait for VmRemovedEvent {
}
impl DataObjectTrait for VmRenamedEvent {
}
impl DataObjectTrait for VmRequirementsExceedCurrentEvcModeEvent {
}
impl DataObjectTrait for VmResettingEvent {
}
impl DataObjectTrait for VmResourcePoolMovedEvent {
}
impl DataObjectTrait for VmResourceReallocatedEvent {
}
impl DataObjectTrait for VmResumingEvent {
}
impl DataObjectTrait for VmSecondaryAddedEvent {
}
impl DataObjectTrait for VmSecondaryDisabledBySystemEvent {
}
impl DataObjectTrait for VmSecondaryDisabledEvent {
}
impl DataObjectTrait for VmSecondaryEnabledEvent {
}
impl DataObjectTrait for VmSecondaryStartedEvent {
}
impl DataObjectTrait for VmStartRecordingEvent {
}
impl DataObjectTrait for VmStartReplayingEvent {
}
impl DataObjectTrait for VmStartingEvent {
}
impl DataObjectTrait for VmUnsupportedStartingEvent {
}
impl DataObjectTrait for VmStartingSecondaryEvent {
}
impl DataObjectTrait for VmStaticMacConflictEvent {
}
impl DataObjectTrait for VmStoppingEvent {
}
impl DataObjectTrait for VmSuspendedEvent {
}
impl DataObjectTrait for VmSuspendingEvent {
}
impl DataObjectTrait for VmTimedoutStartingSecondaryEvent {
}
impl DataObjectTrait for VmUpgradeCompleteEvent {
}
impl DataObjectTrait for VmUpgradeFailedEvent {
}
impl DataObjectTrait for VmUpgradingEvent {
}
impl DataObjectTrait for VmUuidAssignedEvent {
}
impl DataObjectTrait for VmUuidChangedEvent {
}
impl DataObjectTrait for VmUuidConflictEvent {
}
impl DataObjectTrait for VmWwnAssignedEvent {
}
impl DataObjectTrait for VmWwnChangedEvent {
}
impl DataObjectTrait for VmWwnConflictEvent {
}
impl DataObjectTrait for EventArgument {
}
impl DataObjectTrait for EntityEventArgument {
}
impl DataObjectTrait for AlarmEventArgument {
}
impl DataObjectTrait for ComputeResourceEventArgument {
}
impl DataObjectTrait for DatacenterEventArgument {
}
impl DataObjectTrait for DatastoreEventArgument {
}
impl DataObjectTrait for DvsEventArgument {
}
impl DataObjectTrait for FolderEventArgument {
}
impl DataObjectTrait for HostEventArgument {
}
impl DataObjectTrait for ManagedEntityEventArgument {
}
impl DataObjectTrait for NetworkEventArgument {
}
impl DataObjectTrait for ResourcePoolEventArgument {
}
impl DataObjectTrait for ScheduledTaskEventArgument {
}
impl DataObjectTrait for VmEventArgument {
}
impl DataObjectTrait for ProfileEventArgument {
}
impl DataObjectTrait for RoleEventArgument {
}
impl DataObjectTrait for EventDescription {
}
impl DataObjectTrait for EventArgDesc {
}
impl DataObjectTrait for EventDescriptionEventDetail {
}
impl DataObjectTrait for EventFilterSpec {
}
impl DataObjectTrait for EventFilterSpecByEntity {
}
impl DataObjectTrait for EventFilterSpecByTime {
}
impl DataObjectTrait for EventFilterSpecByUsername {
}
impl DataObjectTrait for ExtendedEventPair {
}
impl DataObjectTrait for VnicPortArgument {
}
impl DataObjectTrait for ExtExtendedProductInfo {
}
impl DataObjectTrait for ManagedByInfo {
}
impl DataObjectTrait for ExtManagedEntityInfo {
}
impl DataObjectTrait for ExtSolutionManagerInfo {
}
impl DataObjectTrait for ExtSolutionManagerInfoTabInfo {
}
impl DataObjectTrait for AnswerFileUpdateFailure {
}
impl DataObjectTrait for ConflictingConfigurationConfig {
}
impl DataObjectTrait for DatacenterMismatchArgument {
}
impl DataObjectTrait for DvsApplyOperationFaultFaultOnObject {
}
impl DataObjectTrait for DvsOperationBulkFaultFaultOnHost {
}
impl DataObjectTrait for ImportOperationBulkFaultFaultOnImport {
}
impl DataObjectTrait for MultipleCertificatesVerifyFaultThumbprintData {
}
impl DataObjectTrait for NoPermissionEntityPrivileges {
}
impl DataObjectTrait for ProfileUpdateFailedUpdateFailure {
}
impl DataObjectTrait for HostActiveDirectory {
}
impl DataObjectTrait for HostActiveDirectorySpec {
}
impl DataObjectTrait for HostAssignableHardwareBinding {
}
impl DataObjectTrait for HostAssignableHardwareConfig {
}
impl DataObjectTrait for HostAssignableHardwareConfigAttributeOverride {
}
impl DataObjectTrait for HostAuthenticationManagerInfo {
}
impl DataObjectTrait for HostAuthenticationStoreInfo {
}
impl DataObjectTrait for HostDirectoryStoreInfo {
}
impl DataObjectTrait for HostActiveDirectoryInfo {
}
impl DataObjectTrait for HostLocalAuthenticationInfo {
}
impl DataObjectTrait for AutoStartPowerInfo {
}
impl DataObjectTrait for HostAutoStartManagerConfig {
}
impl DataObjectTrait for AutoStartDefaults {
}
impl DataObjectTrait for HostBiosInfo {
}
impl DataObjectTrait for HostBootDeviceInfo {
}
impl DataObjectTrait for HostBootDevice {
}
impl DataObjectTrait for HostCacheConfigurationInfo {
}
impl DataObjectTrait for HostCacheConfigurationSpec {
}
impl DataObjectTrait for HostCapability {
}
impl DataObjectTrait for HostCertificateManagerCertificateInfo {
}
impl DataObjectTrait for HostCertificateManagerCertificateSpec {
}
impl DataObjectTrait for HostConfigChange {
}
impl DataObjectTrait for HostConfigInfo {
}
impl DataObjectTrait for HostConfigManager {
}
impl DataObjectTrait for HostConfigSpec {
}
impl DataObjectTrait for HostConnectInfo {
}
impl DataObjectTrait for HostDatastoreConnectInfo {
}
impl DataObjectTrait for HostDatastoreExistsConnectInfo {
}
impl DataObjectTrait for HostDatastoreNameConflictConnectInfo {
}
impl DataObjectTrait for HostLicenseConnectInfo {
}
impl DataObjectTrait for HostConnectInfoNetworkInfo {
}
impl DataObjectTrait for HostNewNetworkConnectInfo {
}
impl DataObjectTrait for HostConnectSpec {
}
impl DataObjectTrait for HostCpuIdInfo {
}
impl DataObjectTrait for HostCpuInfo {
}
impl DataObjectTrait for HostCpuPackage {
}
impl DataObjectTrait for HostCpuPowerManagementInfo {
}
impl DataObjectTrait for HostHyperThreadScheduleInfo {
}
impl DataObjectTrait for HostDataTransportConnectionInfo {
}
impl DataObjectTrait for HostNfcConnectionInfo {
}
impl DataObjectTrait for FileInfo {
}
impl DataObjectTrait for FloppyImageFileInfo {
}
impl DataObjectTrait for FolderFileInfo {
}
impl DataObjectTrait for IsoImageFileInfo {
}
impl DataObjectTrait for VmConfigFileInfo {
}
impl DataObjectTrait for TemplateConfigFileInfo {
}
impl DataObjectTrait for VmDiskFileInfo {
}
impl DataObjectTrait for VmLogFileInfo {
}
impl DataObjectTrait for VmNvramFileInfo {
}
impl DataObjectTrait for VmSnapshotFileInfo {
}
impl DataObjectTrait for FileQueryFlags {
}
impl DataObjectTrait for FileQuery {
}
impl DataObjectTrait for FloppyImageFileQuery {
}
impl DataObjectTrait for FolderFileQuery {
}
impl DataObjectTrait for IsoImageFileQuery {
}
impl DataObjectTrait for VmConfigFileQuery {
}
impl DataObjectTrait for TemplateConfigFileQuery {
}
impl DataObjectTrait for VmDiskFileQuery {
}
impl DataObjectTrait for VmLogFileQuery {
}
impl DataObjectTrait for VmNvramFileQuery {
}
impl DataObjectTrait for VmSnapshotFileQuery {
}
impl DataObjectTrait for HostDatastoreBrowserSearchResults {
}
impl DataObjectTrait for HostDatastoreBrowserSearchSpec {
}
impl DataObjectTrait for VmConfigFileEncryptionInfo {
}
impl DataObjectTrait for VmConfigFileQueryFlags {
}
impl DataObjectTrait for VmConfigFileQueryFilter {
}
impl DataObjectTrait for VmDiskFileEncryptionInfo {
}
impl DataObjectTrait for VmDiskFileQueryFlags {
}
impl DataObjectTrait for VmDiskFileQueryFilter {
}
impl DataObjectTrait for HostDatastoreSystemCapabilities {
}
impl DataObjectTrait for HostDatastoreSystemDatastoreResult {
}
impl DataObjectTrait for HostDatastoreSystemVvolDatastoreSpec {
}
impl DataObjectTrait for HostDateTimeConfig {
}
impl DataObjectTrait for HostDateTimeInfo {
}
impl DataObjectTrait for HostDateTimeSystemServiceTestResult {
}
impl DataObjectTrait for HostDateTimeSystemTimeZone {
}
impl DataObjectTrait for HostDeploymentInfo {
}
impl DataObjectTrait for HostDevice {
}
impl DataObjectTrait for ScsiLun {
}
impl DataObjectTrait for HostScsiDisk {
}
impl DataObjectTrait for HostDhcpService {
}
impl DataObjectTrait for HostDhcpServiceConfig {
}
impl DataObjectTrait for HostDhcpServiceSpec {
}
impl DataObjectTrait for HostDiagnosticPartition {
}
impl DataObjectTrait for HostDiagnosticPartitionCreateDescription {
}
impl DataObjectTrait for HostDiagnosticPartitionCreateOption {
}
impl DataObjectTrait for HostDiagnosticPartitionCreateSpec {
}
impl DataObjectTrait for HostDigestInfo {
}
impl DataObjectTrait for HostTpmDigestInfo {
}
impl DataObjectTrait for HostDiskConfigurationResult {
}
impl DataObjectTrait for HostDiskDimensions {
}
impl DataObjectTrait for HostDiskDimensionsChs {
}
impl DataObjectTrait for HostDiskDimensionsLba {
}
impl DataObjectTrait for HostDiskPartitionInfo {
}
impl DataObjectTrait for HostDiskPartitionBlockRange {
}
impl DataObjectTrait for HostDiskPartitionLayout {
}
impl DataObjectTrait for HostDiskPartitionAttributes {
}
impl DataObjectTrait for HostDiskPartitionSpec {
}
impl DataObjectTrait for HostDnsConfig {
}
impl DataObjectTrait for HostDnsConfigSpec {
}
impl DataObjectTrait for HostDvxClass {
}
impl DataObjectTrait for HostEnterMaintenanceResult {
}
impl DataObjectTrait for HostEsxAgentHostManagerConfigInfo {
}
impl DataObjectTrait for HostFaultToleranceManagerComponentHealthInfo {
}
impl DataObjectTrait for FcoeConfig {
}
impl DataObjectTrait for FcoeConfigFcoeCapabilities {
}
impl DataObjectTrait for FcoeConfigFcoeSpecification {
}
impl DataObjectTrait for FcoeConfigVlanRange {
}
impl DataObjectTrait for HostFeatureCapability {
}
impl DataObjectTrait for HostFeatureMask {
}
impl DataObjectTrait for HostFeatureVersionInfo {
}
impl DataObjectTrait for HostFibreChannelOverEthernetHbaLinkInfo {
}
impl DataObjectTrait for HostFileAccess {
}
impl DataObjectTrait for ModeInfo {
}
impl DataObjectTrait for HostFileSystemMountInfo {
}
impl DataObjectTrait for HostFileSystemVolume {
}
impl DataObjectTrait for HostLocalFileSystemVolume {
}
impl DataObjectTrait for HostNasVolume {
}
impl DataObjectTrait for HostPMemVolume {
}
impl DataObjectTrait for HostVfatVolume {
}
impl DataObjectTrait for HostVffsVolume {
}
impl DataObjectTrait for HostVmfsVolume {
}
impl DataObjectTrait for HostVvolVolume {
}
impl DataObjectTrait for HostFileSystemVolumeInfo {
}
impl DataObjectTrait for HostFirewallConfig {
}
impl DataObjectTrait for HostFirewallConfigRuleSetConfig {
}
impl DataObjectTrait for HostFirewallInfo {
}
impl DataObjectTrait for HostFirewallDefaultPolicy {
}
impl DataObjectTrait for HostFlagInfo {
}
impl DataObjectTrait for HostForceMountedInfo {
}
impl DataObjectTrait for HostFru {
}
impl DataObjectTrait for HostGatewaySpec {
}
impl DataObjectTrait for HostGraphicsConfig {
}
impl DataObjectTrait for HostGraphicsConfigDeviceType {
}
impl DataObjectTrait for HostGraphicsInfo {
}
impl DataObjectTrait for HostHardwareInfo {
}
impl DataObjectTrait for HostHardwareStatusInfo {
}
impl DataObjectTrait for DpuStatusInfoOperationalInfo {
}
impl DataObjectTrait for HostHardwareElementInfo {
}
impl DataObjectTrait for DpuStatusInfo {
}
impl DataObjectTrait for HostStorageElementInfo {
}
impl DataObjectTrait for HostStorageOperationalInfo {
}
impl DataObjectTrait for HostHbaCreateSpec {
}
impl DataObjectTrait for HostTcpHbaCreateSpec {
}
impl DataObjectTrait for HealthSystemRuntime {
}
impl DataObjectTrait for HostAccessControlEntry {
}
impl DataObjectTrait for HostHostBusAdapter {
}
impl DataObjectTrait for HostBlockHba {
}
impl DataObjectTrait for HostFibreChannelHba {
}
impl DataObjectTrait for HostFibreChannelOverEthernetHba {
}
impl DataObjectTrait for HostInternetScsiHba {
}
impl DataObjectTrait for HostParallelScsiHba {
}
impl DataObjectTrait for HostPcieHba {
}
impl DataObjectTrait for HostRdmaHba {
}
impl DataObjectTrait for HostSerialAttachedHba {
}
impl DataObjectTrait for HostTcpHba {
}
impl DataObjectTrait for HostProxySwitch {
}
impl DataObjectTrait for HostProxySwitchConfig {
}
impl DataObjectTrait for HostProxySwitchEnsInfo {
}
impl DataObjectTrait for HostProxySwitchHostLagConfig {
}
impl DataObjectTrait for HostProxySwitchSpec {
}
impl DataObjectTrait for HostImageProfileSummary {
}
impl DataObjectTrait for HostInternetScsiHbaAuthenticationCapabilities {
}
impl DataObjectTrait for HostInternetScsiHbaAuthenticationProperties {
}
impl DataObjectTrait for HostInternetScsiHbaDigestCapabilities {
}
impl DataObjectTrait for HostInternetScsiHbaDigestProperties {
}
impl DataObjectTrait for HostInternetScsiHbaDiscoveryCapabilities {
}
impl DataObjectTrait for HostInternetScsiHbaDiscoveryProperties {
}
impl DataObjectTrait for HostInternetScsiHbaIpCapabilities {
}
impl DataObjectTrait for HostInternetScsiHbaIpProperties {
}
impl DataObjectTrait for HostInternetScsiHbaIPv6Properties {
}
impl DataObjectTrait for HostInternetScsiHbaIscsiIpv6Address {
}
impl DataObjectTrait for HostInternetScsiHbaSendTarget {
}
impl DataObjectTrait for HostInternetScsiHbaStaticTarget {
}
impl DataObjectTrait for HostInternetScsiHbaTargetSet {
}
impl DataObjectTrait for HostIpConfig {
}
impl DataObjectTrait for HostIpConfigIpV6Address {
}
impl DataObjectTrait for HostIpConfigIpV6AddressConfiguration {
}
impl DataObjectTrait for HostIpRouteConfig {
}
impl DataObjectTrait for HostIpRouteConfigSpec {
}
impl DataObjectTrait for HostIpRouteEntry {
}
impl DataObjectTrait for HostIpRouteOp {
}
impl DataObjectTrait for HostIpRouteTableConfig {
}
impl DataObjectTrait for HostIpRouteTableInfo {
}
impl DataObjectTrait for HostIpmiInfo {
}
impl DataObjectTrait for IscsiDependencyEntity {
}
impl DataObjectTrait for IscsiMigrationDependency {
}
impl DataObjectTrait for IscsiPortInfo {
}
impl DataObjectTrait for IscsiStatus {
}
impl DataObjectTrait for KernelModuleInfo {
}
impl DataObjectTrait for KernelModuleSectionInfo {
}
impl DataObjectTrait for HostLicenseSpec {
}
impl DataObjectTrait for LinkDiscoveryProtocolConfig {
}
impl DataObjectTrait for HostAccountSpec {
}
impl DataObjectTrait for HostPosixAccountSpec {
}
impl DataObjectTrait for HostLocalFileSystemVolumeSpec {
}
impl DataObjectTrait for HostLowLevelProvisioningManagerDiskLayoutSpec {
}
impl DataObjectTrait for HostLowLevelProvisioningManagerFileDeleteResult {
}
impl DataObjectTrait for HostLowLevelProvisioningManagerFileDeleteSpec {
}
impl DataObjectTrait for HostLowLevelProvisioningManagerFileReserveResult {
}
impl DataObjectTrait for HostLowLevelProvisioningManagerFileReserveSpec {
}
impl DataObjectTrait for HostLowLevelProvisioningManagerSnapshotLayoutSpec {
}
impl DataObjectTrait for HostLowLevelProvisioningManagerVmMigrationStatus {
}
impl DataObjectTrait for HostLowLevelProvisioningManagerVmRecoveryInfo {
}
impl DataObjectTrait for HostMaintenanceSpec {
}
impl DataObjectTrait for ServiceConsoleReservationInfo {
}
impl DataObjectTrait for VirtualMachineMemoryReservationInfo {
}
impl DataObjectTrait for VirtualMachineMemoryReservationSpec {
}
impl DataObjectTrait for HostMemorySpec {
}
impl DataObjectTrait for HostMemoryTierInfo {
}
impl DataObjectTrait for HostMountInfo {
}
impl DataObjectTrait for HostMultipathInfo {
}
impl DataObjectTrait for HostMultipathInfoLogicalUnit {
}
impl DataObjectTrait for HostMultipathInfoLogicalUnitPolicy {
}
impl DataObjectTrait for HostMultipathInfoFixedLogicalUnitPolicy {
}
impl DataObjectTrait for HostMultipathInfoHppLogicalUnitPolicy {
}
impl DataObjectTrait for HostMultipathInfoLogicalUnitStorageArrayTypePolicy {
}
impl DataObjectTrait for HostMultipathInfoPath {
}
impl DataObjectTrait for HostMultipathStateInfo {
}
impl DataObjectTrait for HostMultipathStateInfoPath {
}
impl DataObjectTrait for HostNasVolumeConfig {
}
impl DataObjectTrait for HostNasVolumeSpec {
}
impl DataObjectTrait for HostNasVolumeUserInfo {
}
impl DataObjectTrait for HostNatService {
}
impl DataObjectTrait for HostNatServiceConfig {
}
impl DataObjectTrait for HostNatServiceNameServiceSpec {
}
impl DataObjectTrait for HostNatServicePortForwardSpec {
}
impl DataObjectTrait for HostNatServiceSpec {
}
impl DataObjectTrait for HostNetCapabilities {
}
impl DataObjectTrait for HostNetOffloadCapabilities {
}
impl DataObjectTrait for HostNetStackInstance {
}
impl DataObjectTrait for HostNetworkConfig {
}
impl DataObjectTrait for HostNetworkConfigNetStackSpec {
}
impl DataObjectTrait for HostNetworkConfigResult {
}
impl DataObjectTrait for HostNetworkInfo {
}
impl DataObjectTrait for HostNetworkPolicy {
}
impl DataObjectTrait for HostNicFailureCriteria {
}
impl DataObjectTrait for HostNicOrderPolicy {
}
impl DataObjectTrait for HostNicTeamingPolicy {
}
impl DataObjectTrait for HostNetworkSecurityPolicy {
}
impl DataObjectTrait for HostNetworkTrafficShapingPolicy {
}
impl DataObjectTrait for HostNtpConfig {
}
impl DataObjectTrait for HostNumaInfo {
}
impl DataObjectTrait for HostNumaNode {
}
impl DataObjectTrait for HostNumericSensorInfo {
}
impl DataObjectTrait for NvdimmDimmInfo {
}
impl DataObjectTrait for NvdimmGuid {
}
impl DataObjectTrait for NvdimmHealthInfo {
}
impl DataObjectTrait for NvdimmInterleaveSetInfo {
}
impl DataObjectTrait for NvdimmNamespaceCreateSpec {
}
impl DataObjectTrait for NvdimmNamespaceDeleteSpec {
}
impl DataObjectTrait for NvdimmNamespaceDetails {
}
impl DataObjectTrait for NvdimmNamespaceInfo {
}
impl DataObjectTrait for NvdimmSystemInfo {
}
impl DataObjectTrait for NvdimmPMemNamespaceCreateSpec {
}
impl DataObjectTrait for NvdimmRegionInfo {
}
impl DataObjectTrait for NvdimmSummary {
}
impl DataObjectTrait for HostNvmeController {
}
impl DataObjectTrait for HostNvmeDisconnectSpec {
}
impl DataObjectTrait for HostNvmeDiscoveryLog {
}
impl DataObjectTrait for HostNvmeDiscoveryLogEntry {
}
impl DataObjectTrait for HostNvmeNamespace {
}
impl DataObjectTrait for HostNvmeSpec {
}
impl DataObjectTrait for HostNvmeConnectSpec {
}
impl DataObjectTrait for HostNvmeDiscoverSpec {
}
impl DataObjectTrait for HostNvmeTopology {
}
impl DataObjectTrait for HostNvmeTopologyInterface {
}
impl DataObjectTrait for HostNvmeTransportParameters {
}
impl DataObjectTrait for HostNvmeOpaqueTransportParameters {
}
impl DataObjectTrait for HostNvmeOverFibreChannelParameters {
}
impl DataObjectTrait for HostNvmeOverRdmaParameters {
}
impl DataObjectTrait for HostNvmeOverTcpParameters {
}
impl DataObjectTrait for HostOpaqueNetworkInfo {
}
impl DataObjectTrait for HostOpaqueSwitch {
}
impl DataObjectTrait for HostOpaqueSwitchPhysicalNicZone {
}
impl DataObjectTrait for HostPatchManagerLocator {
}
impl DataObjectTrait for HostPatchManagerPatchManagerOperationSpec {
}
impl DataObjectTrait for HostPatchManagerResult {
}
impl DataObjectTrait for HostPatchManagerStatus {
}
impl DataObjectTrait for HostPatchManagerStatusPrerequisitePatch {
}
impl DataObjectTrait for HostPathSelectionPolicyOption {
}
impl DataObjectTrait for HostPciDevice {
}
impl DataObjectTrait for HostPciPassthruConfig {
}
impl DataObjectTrait for HostSriovConfig {
}
impl DataObjectTrait for HostPciPassthruInfo {
}
impl DataObjectTrait for HostSriovInfo {
}
impl DataObjectTrait for HostPersistentMemoryInfo {
}
impl DataObjectTrait for PhysicalNic {
}
impl DataObjectTrait for PhysicalNicCdpDeviceCapability {
}
impl DataObjectTrait for PhysicalNicCdpInfo {
}
impl DataObjectTrait for PhysicalNicConfig {
}
impl DataObjectTrait for PhysicalNicLinkInfo {
}
impl DataObjectTrait for LinkLayerDiscoveryProtocolInfo {
}
impl DataObjectTrait for PhysicalNicHintInfo {
}
impl DataObjectTrait for PhysicalNicHint {
}
impl DataObjectTrait for PhysicalNicIpHint {
}
impl DataObjectTrait for PhysicalNicNameHint {
}
impl DataObjectTrait for PhysicalNicSpec {
}
impl DataObjectTrait for HostPlugStoreTopology {
}
impl DataObjectTrait for HostPlugStoreTopologyAdapter {
}
impl DataObjectTrait for HostPlugStoreTopologyDevice {
}
impl DataObjectTrait for HostPlugStoreTopologyPath {
}
impl DataObjectTrait for HostPlugStoreTopologyPlugin {
}
impl DataObjectTrait for HostPlugStoreTopologyTarget {
}
impl DataObjectTrait for HostPortGroup {
}
impl DataObjectTrait for HostPortGroupConfig {
}
impl DataObjectTrait for HostPortGroupPort {
}
impl DataObjectTrait for HostPortGroupSpec {
}
impl DataObjectTrait for PowerSystemCapability {
}
impl DataObjectTrait for PowerSystemInfo {
}
impl DataObjectTrait for HostPowerPolicy {
}
impl DataObjectTrait for HostProtocolEndpoint {
}
impl DataObjectTrait for HostPtpConfig {
}
impl DataObjectTrait for HostPtpConfigPtpPort {
}
impl DataObjectTrait for HostQualifiedName {
}
impl DataObjectTrait for HostRdmaDevice {
}
impl DataObjectTrait for HostRdmaDeviceBacking {
}
impl DataObjectTrait for HostRdmaDevicePnicBacking {
}
impl DataObjectTrait for HostRdmaDeviceCapability {
}
impl DataObjectTrait for HostRdmaDeviceConnectionInfo {
}
impl DataObjectTrait for HostReliableMemoryInfo {
}
impl DataObjectTrait for HostResignatureRescanResult {
}
impl DataObjectTrait for HostFirewallRuleset {
}
impl DataObjectTrait for HostFirewallRulesetIpList {
}
impl DataObjectTrait for HostFirewallRulesetIpNetwork {
}
impl DataObjectTrait for HostFirewallRule {
}
impl DataObjectTrait for HostFirewallRulesetRulesetSpec {
}
impl DataObjectTrait for HostRuntimeInfo {
}
impl DataObjectTrait for HostRuntimeInfoNetStackInstanceRuntimeInfo {
}
impl DataObjectTrait for HostNetworkResourceRuntime {
}
impl DataObjectTrait for HostRuntimeInfoNetworkRuntimeInfo {
}
impl DataObjectTrait for HostPlacedVirtualNicIdentifier {
}
impl DataObjectTrait for HostPnicNetworkResourceInfo {
}
impl DataObjectTrait for HostRuntimeInfoStateEncryptionInfo {
}
impl DataObjectTrait for HostScsiDiskPartition {
}
impl DataObjectTrait for ScsiLunCapabilities {
}
impl DataObjectTrait for ScsiLunDescriptor {
}
impl DataObjectTrait for ScsiLunDurableName {
}
impl DataObjectTrait for HostScsiTopology {
}
impl DataObjectTrait for HostScsiTopologyInterface {
}
impl DataObjectTrait for HostScsiTopologyLun {
}
impl DataObjectTrait for HostScsiTopologyTarget {
}
impl DataObjectTrait for HostSecuritySpec {
}
impl DataObjectTrait for HostService {
}
impl DataObjectTrait for HostServiceSourcePackage {
}
impl DataObjectTrait for HostServiceConfig {
}
impl DataObjectTrait for HostServiceInfo {
}
impl DataObjectTrait for HostSevInfo {
}
impl DataObjectTrait for HostSgxInfo {
}
impl DataObjectTrait for HostSgxRegistrationInfo {
}
impl DataObjectTrait for HostSharedGpuCapabilities {
}
impl DataObjectTrait for HostSnmpSystemAgentLimits {
}
impl DataObjectTrait for HostSnmpConfigSpec {
}
impl DataObjectTrait for HostSnmpDestination {
}
impl DataObjectTrait for SoftwarePackage {
}
impl DataObjectTrait for SoftwarePackageCapability {
}
impl DataObjectTrait for Relation {
}
impl DataObjectTrait for HostSriovDevicePoolInfo {
}
impl DataObjectTrait for HostSriovNetworkDevicePoolInfo {
}
impl DataObjectTrait for HostSslThumbprintInfo {
}
impl DataObjectTrait for HostStorageArrayTypePolicyOption {
}
impl DataObjectTrait for HostStorageDeviceInfo {
}
impl DataObjectTrait for HostStorageSystemDiskLocatorLedResult {
}
impl DataObjectTrait for HostStorageSystemScsiLunResult {
}
impl DataObjectTrait for HostStorageSystemVmfsVolumeResult {
}
impl DataObjectTrait for HostListSummary {
}
impl DataObjectTrait for HostConfigSummary {
}
impl DataObjectTrait for HostListSummaryGatewaySummary {
}
impl DataObjectTrait for HostHardwareSummary {
}
impl DataObjectTrait for HostListSummaryQuickStats {
}
impl DataObjectTrait for SystemEventInfo {
}
impl DataObjectTrait for HostSystemHealthInfo {
}
impl DataObjectTrait for HostSystemIdentificationInfo {
}
impl DataObjectTrait for HostSystemInfo {
}
impl DataObjectTrait for HostSystemResourceInfo {
}
impl DataObjectTrait for HostSystemSwapConfiguration {
}
impl DataObjectTrait for HostSystemSwapConfigurationSystemSwapOption {
}
impl DataObjectTrait for HostSystemSwapConfigurationDatastoreOption {
}
impl DataObjectTrait for HostSystemSwapConfigurationDisabledOption {
}
impl DataObjectTrait for HostSystemSwapConfigurationHostCacheOption {
}
impl DataObjectTrait for HostSystemSwapConfigurationHostLocalSwapOption {
}
impl DataObjectTrait for HostTargetTransport {
}
impl DataObjectTrait for HostBlockAdapterTargetTransport {
}
impl DataObjectTrait for HostFibreChannelTargetTransport {
}
impl DataObjectTrait for HostFibreChannelOverEthernetTargetTransport {
}
impl DataObjectTrait for HostInternetScsiTargetTransport {
}
impl DataObjectTrait for HostParallelScsiTargetTransport {
}
impl DataObjectTrait for HostPcieTargetTransport {
}
impl DataObjectTrait for HostRdmaTargetTransport {
}
impl DataObjectTrait for HostSerialAttachedTargetTransport {
}
impl DataObjectTrait for HostTcpTargetTransport {
}
impl DataObjectTrait for HostTpmAttestationInfo {
}
impl DataObjectTrait for HostTpmAttestationReport {
}
impl DataObjectTrait for HostTpmEventDetails {
}
impl DataObjectTrait for HostTpmBootCompleteEventDetails {
}
impl DataObjectTrait for HostTpmBootSecurityOptionEventDetails {
}
impl DataObjectTrait for HostTpmNvTagEventDetails {
}
impl DataObjectTrait for HostTpmSignerEventDetails {
}
impl DataObjectTrait for HostTpmCommandEventDetails {
}
impl DataObjectTrait for HostTpmOptionEventDetails {
}
impl DataObjectTrait for HostTpmSoftwareComponentEventDetails {
}
impl DataObjectTrait for HostTpmVersionEventDetails {
}
impl DataObjectTrait for HostTpmEventLogEntry {
}
impl DataObjectTrait for HostTrustAuthorityAttestationInfo {
}
impl DataObjectTrait for HostUnresolvedVmfsExtent {
}
impl DataObjectTrait for HostUnresolvedVmfsResignatureSpec {
}
impl DataObjectTrait for HostUnresolvedVmfsResolutionResult {
}
impl DataObjectTrait for HostUnresolvedVmfsResolutionSpec {
}
impl DataObjectTrait for HostUnresolvedVmfsVolume {
}
impl DataObjectTrait for HostUnresolvedVmfsVolumeResolveStatus {
}
impl DataObjectTrait for HostVFlashManagerVFlashCacheConfigInfo {
}
impl DataObjectTrait for HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption {
}
impl DataObjectTrait for HostVFlashManagerVFlashCacheConfigSpec {
}
impl DataObjectTrait for HostVFlashManagerVFlashConfigInfo {
}
impl DataObjectTrait for HostVFlashManagerVFlashResourceConfigInfo {
}
impl DataObjectTrait for HostVFlashManagerVFlashResourceConfigSpec {
}
impl DataObjectTrait for HostVFlashManagerVFlashResourceRunTimeInfo {
}
impl DataObjectTrait for HostVFlashResourceConfigurationResult {
}
impl DataObjectTrait for HostVMotionConfig {
}
impl DataObjectTrait for HostVMotionInfo {
}
impl DataObjectTrait for HostVMotionManagerDstInstantCloneResult {
}
impl DataObjectTrait for HostVMotionManagerSrcInstantCloneResult {
}
impl DataObjectTrait for HostVMotionNetConfig {
}
impl DataObjectTrait for HostVffsSpec {
}
impl DataObjectTrait for HostVirtualNic {
}
impl DataObjectTrait for HostVirtualNicConfig {
}
impl DataObjectTrait for HostVirtualNicIpRouteSpec {
}
impl DataObjectTrait for HostVirtualNicOpaqueNetworkSpec {
}
impl DataObjectTrait for HostVirtualNicSpec {
}
impl DataObjectTrait for HostVirtualNicConnection {
}
impl DataObjectTrait for VirtualNicManagerNetConfig {
}
impl DataObjectTrait for HostVirtualNicManagerNicTypeSelection {
}
impl DataObjectTrait for HostVirtualNicManagerInfo {
}
impl DataObjectTrait for HostVirtualSwitch {
}
impl DataObjectTrait for HostVirtualSwitchBeaconConfig {
}
impl DataObjectTrait for HostVirtualSwitchBridge {
}
impl DataObjectTrait for HostVirtualSwitchAutoBridge {
}
impl DataObjectTrait for HostVirtualSwitchBondBridge {
}
impl DataObjectTrait for HostVirtualSwitchSimpleBridge {
}
impl DataObjectTrait for HostVirtualSwitchConfig {
}
impl DataObjectTrait for HostVirtualSwitchSpec {
}
impl DataObjectTrait for HostVmciAccessManagerAccessSpec {
}
impl DataObjectTrait for VmfsDatastoreOption {
}
impl DataObjectTrait for VmfsDatastoreBaseOption {
}
impl DataObjectTrait for VmfsDatastoreMultipleExtentOption {
}
impl DataObjectTrait for VmfsDatastoreSingleExtentOption {
}
impl DataObjectTrait for VmfsDatastoreAllExtentOption {
}
impl DataObjectTrait for VmfsDatastoreSpec {
}
impl DataObjectTrait for VmfsDatastoreCreateSpec {
}
impl DataObjectTrait for VmfsDatastoreExpandSpec {
}
impl DataObjectTrait for VmfsDatastoreExtendSpec {
}
impl DataObjectTrait for HostVmfsRescanResult {
}
impl DataObjectTrait for VmfsConfigOption {
}
impl DataObjectTrait for HostVmfsSpec {
}
impl DataObjectTrait for VmfsUnmapBandwidthSpec {
}
impl DataObjectTrait for HostVsanInternalSystemCmmdsQuery {
}
impl DataObjectTrait for HostVsanInternalSystemDeleteVsanObjectsResult {
}
impl DataObjectTrait for VsanNewPolicyBatch {
}
impl DataObjectTrait for VsanPolicyChangeBatch {
}
impl DataObjectTrait for VsanPolicyCost {
}
impl DataObjectTrait for VsanPolicySatisfiability {
}
impl DataObjectTrait for HostVsanInternalSystemVsanObjectOperationResult {
}
impl DataObjectTrait for HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult {
}
impl DataObjectTrait for HostVvolNqn {
}
impl DataObjectTrait for VVolHostPe {
}
impl DataObjectTrait for HostVvolVolumeHostVvolNqn {
}
impl DataObjectTrait for HostVvolVolumeSpecification {
}
impl DataObjectTrait for NetDhcpConfigInfo {
}
impl DataObjectTrait for NetDhcpConfigInfoDhcpOptions {
}
impl DataObjectTrait for NetDhcpConfigSpec {
}
impl DataObjectTrait for NetDhcpConfigSpecDhcpOptionsSpec {
}
impl DataObjectTrait for NetDnsConfigInfo {
}
impl DataObjectTrait for NetDnsConfigSpec {
}
impl DataObjectTrait for NetIpConfigInfo {
}
impl DataObjectTrait for NetIpConfigInfoIpAddress {
}
impl DataObjectTrait for NetIpConfigSpec {
}
impl DataObjectTrait for NetIpConfigSpecIpAddressSpec {
}
impl DataObjectTrait for NetIpRouteConfigInfo {
}
impl DataObjectTrait for NetIpRouteConfigInfoGateway {
}
impl DataObjectTrait for NetIpRouteConfigInfoIpRoute {
}
impl DataObjectTrait for NetIpRouteConfigSpec {
}
impl DataObjectTrait for NetIpRouteConfigSpecGatewaySpec {
}
impl DataObjectTrait for NetIpRouteConfigSpecIpRouteSpec {
}
impl DataObjectTrait for NetIpStackInfo {
}
impl DataObjectTrait for NetIpStackInfoDefaultRouter {
}
impl DataObjectTrait for NetIpStackInfoNetToMedia {
}
impl DataObjectTrait for NetBiosConfigInfo {
}
impl DataObjectTrait for WinNetBiosConfigInfo {
}
impl DataObjectTrait for ArrayUpdateSpec {
}
impl DataObjectTrait for ClusterDasVmConfigSpec {
}
impl DataObjectTrait for ClusterDatastoreUpdateSpec {
}
impl DataObjectTrait for ClusterDpmHostConfigSpec {
}
impl DataObjectTrait for ClusterDrsVmConfigSpec {
}
impl DataObjectTrait for ClusterGroupSpec {
}
impl DataObjectTrait for ClusterPreemptibleVmPairSpec {
}
impl DataObjectTrait for ClusterRuleSpec {
}
impl DataObjectTrait for ClusterTagCategoryUpdateSpec {
}
impl DataObjectTrait for ClusterVmOrchestrationSpec {
}
impl DataObjectTrait for StorageDrsOptionSpec {
}
impl DataObjectTrait for StorageDrsVmConfigSpec {
}
impl DataObjectTrait for VAppOvfSectionSpec {
}
impl DataObjectTrait for VAppProductSpec {
}
impl DataObjectTrait for VAppPropertySpec {
}
impl DataObjectTrait for VirtualMachineCpuIdInfoSpec {
}
impl DataObjectTrait for OptionType {
}
impl DataObjectTrait for BoolOption {
}
impl DataObjectTrait for ChoiceOption {
}
impl DataObjectTrait for FloatOption {
}
impl DataObjectTrait for IntOption {
}
impl DataObjectTrait for LongOption {
}
impl DataObjectTrait for StringOption {
}
impl DataObjectTrait for OptionValue {
}
impl DataObjectTrait for HostInternetScsiHbaParamValue {
}
impl DataObjectTrait for ApplyProfile {
}
impl DataObjectTrait for ProfileApplyProfileElement {
}
impl DataObjectTrait for ActiveDirectoryProfile {
}
impl DataObjectTrait for AuthenticationProfile {
}
impl DataObjectTrait for DateTimeProfile {
}
impl DataObjectTrait for DvsProfile {
}
impl DataObjectTrait for DvsVNicProfile {
}
impl DataObjectTrait for DvsHostVNicProfile {
}
impl DataObjectTrait for DvsServiceConsoleVNicProfile {
}
impl DataObjectTrait for FirewallProfile {
}
impl DataObjectTrait for FirewallProfileRulesetProfile {
}
impl DataObjectTrait for HostApplyProfile {
}
impl DataObjectTrait for HostMemoryProfile {
}
impl DataObjectTrait for IpAddressProfile {
}
impl DataObjectTrait for IpRouteProfile {
}
impl DataObjectTrait for NasStorageProfile {
}
impl DataObjectTrait for NetStackInstanceProfile {
}
impl DataObjectTrait for NetworkPolicyProfile {
}
impl DataObjectTrait for NetworkProfile {
}
impl DataObjectTrait for NetworkProfileDnsConfigProfile {
}
impl DataObjectTrait for NsxHostVNicProfile {
}
impl DataObjectTrait for OpaqueSwitchProfile {
}
impl DataObjectTrait for OptionProfile {
}
impl DataObjectTrait for PermissionProfile {
}
impl DataObjectTrait for PhysicalNicProfile {
}
impl DataObjectTrait for PnicUplinkProfile {
}
impl DataObjectTrait for PortGroupProfile {
}
impl DataObjectTrait for HostPortGroupProfile {
}
impl DataObjectTrait for ServiceConsolePortGroupProfile {
}
impl DataObjectTrait for VmPortGroupProfile {
}
impl DataObjectTrait for VirtualSwitchSelectionProfile {
}
impl DataObjectTrait for VlanProfile {
}
impl DataObjectTrait for SecurityProfile {
}
impl DataObjectTrait for ServiceProfile {
}
impl DataObjectTrait for StaticRouteProfile {
}
impl DataObjectTrait for StorageProfile {
}
impl DataObjectTrait for UserGroupProfile {
}
impl DataObjectTrait for UserProfile {
}
impl DataObjectTrait for VirtualSwitchProfile {
}
impl DataObjectTrait for LinkProfile {
}
impl DataObjectTrait for NumPortsProfile {
}
impl DataObjectTrait for ProfileApplyProfileProperty {
}
impl DataObjectTrait for ComplianceLocator {
}
impl DataObjectTrait for ComplianceProfile {
}
impl DataObjectTrait for ComplianceResult {
}
impl DataObjectTrait for ComplianceFailure {
}
impl DataObjectTrait for ComplianceFailureComplianceFailureValues {
}
impl DataObjectTrait for ProfileDeferredPolicyOptionParameter {
}
impl DataObjectTrait for ProfileExpression {
}
impl DataObjectTrait for ProfileCompositeExpression {
}
impl DataObjectTrait for ProfileSimpleExpression {
}
impl DataObjectTrait for ProfileExpressionMetadata {
}
impl DataObjectTrait for ProfileParameterMetadata {
}
impl DataObjectTrait for ProfileParameterMetadataParameterRelationMetadata {
}
impl DataObjectTrait for ProfilePolicy {
}
impl DataObjectTrait for ProfilePolicyMetadata {
}
impl DataObjectTrait for PolicyOption {
}
impl DataObjectTrait for CompositePolicyOption {
}
impl DataObjectTrait for ProfilePolicyOptionMetadata {
}
impl DataObjectTrait for ProfileCompositePolicyOptionMetadata {
}
impl DataObjectTrait for UserInputRequiredParameterMetadata {
}
impl DataObjectTrait for ProfileConfigInfo {
}
impl DataObjectTrait for ClusterProfileConfigInfo {
}
impl DataObjectTrait for HostProfileConfigInfo {
}
impl DataObjectTrait for ProfileCreateSpec {
}
impl DataObjectTrait for ProfileSerializedCreateSpec {
}
impl DataObjectTrait for HostProfileSerializedHostProfileSpec {
}
impl DataObjectTrait for ClusterProfileCreateSpec {
}
impl DataObjectTrait for ClusterProfileConfigSpec {
}
impl DataObjectTrait for ClusterProfileCompleteConfigSpec {
}
impl DataObjectTrait for ClusterProfileConfigServiceCreateSpec {
}
impl DataObjectTrait for HostProfileConfigSpec {
}
impl DataObjectTrait for HostProfileCompleteConfigSpec {
}
impl DataObjectTrait for HostProfileHostBasedConfigSpec {
}
impl DataObjectTrait for ProfileDescription {
}
impl DataObjectTrait for ProfileDescriptionSection {
}
impl DataObjectTrait for ProfileMetadata {
}
impl DataObjectTrait for ProfileMetadataProfileOperationMessage {
}
impl DataObjectTrait for ProfileMetadataProfileSortSpec {
}
impl DataObjectTrait for ProfilePropertyPath {
}
impl DataObjectTrait for ProfileProfileStructure {
}
impl DataObjectTrait for ProfileProfileStructureProperty {
}
impl DataObjectTrait for AnswerFile {
}
impl DataObjectTrait for AnswerFileStatusResult {
}
impl DataObjectTrait for AnswerFileStatusError {
}
impl DataObjectTrait for ProfileExecuteResult {
}
impl DataObjectTrait for ApplyHostProfileConfigurationSpec {
}
impl DataObjectTrait for ProfileExecuteError {
}
impl DataObjectTrait for HostProfileValidationFailureInfo {
}
impl DataObjectTrait for HostSpecification {
}
impl DataObjectTrait for HostSubSpecification {
}
impl DataObjectTrait for AnswerFileCreateSpec {
}
impl DataObjectTrait for AnswerFileOptionsCreateSpec {
}
impl DataObjectTrait for AnswerFileSerializedCreateSpec {
}
impl DataObjectTrait for ApplyHostProfileConfigurationResult {
}
impl DataObjectTrait for HostProfileManagerCompositionResult {
}
impl DataObjectTrait for HostProfileManagerCompositionResultResultElement {
}
impl DataObjectTrait for HostProfileManagerCompositionValidationResult {
}
impl DataObjectTrait for HostProfileManagerCompositionValidationResultResultElement {
}
impl DataObjectTrait for HostProfileManagerConfigTaskList {
}
impl DataObjectTrait for HostProfilesEntityCustomizations {
}
impl DataObjectTrait for StructuredCustomizations {
}
impl DataObjectTrait for HostProfileManagerHostToConfigSpecMap {
}
impl DataObjectTrait for ScheduledTaskDescription {
}
impl DataObjectTrait for ScheduledTaskSpec {
}
impl DataObjectTrait for ScheduledTaskInfo {
}
impl DataObjectTrait for TaskScheduler {
}
impl DataObjectTrait for AfterStartupTaskScheduler {
}
impl DataObjectTrait for OnceTaskScheduler {
}
impl DataObjectTrait for RecurrentTaskScheduler {
}
impl DataObjectTrait for HourlyTaskScheduler {
}
impl DataObjectTrait for DailyTaskScheduler {
}
impl DataObjectTrait for MonthlyTaskScheduler {
}
impl DataObjectTrait for MonthlyByDayTaskScheduler {
}
impl DataObjectTrait for MonthlyByWeekdayTaskScheduler {
}
impl DataObjectTrait for WeeklyTaskScheduler {
}
impl DataObjectTrait for ApplyStorageRecommendationResult {
}
impl DataObjectTrait for StorageDrsAutomationConfig {
}
impl DataObjectTrait for StorageDrsConfigInfo {
}
impl DataObjectTrait for StorageDrsConfigSpec {
}
impl DataObjectTrait for StorageDrsIoLoadBalanceConfig {
}
impl DataObjectTrait for PlacementAffinityRule {
}
impl DataObjectTrait for PlacementRankResult {
}
impl DataObjectTrait for PlacementRankSpec {
}
impl DataObjectTrait for StorageDrsPlacementRankVmSpec {
}
impl DataObjectTrait for StorageDrsPodConfigInfo {
}
impl DataObjectTrait for StorageDrsPodConfigSpec {
}
impl DataObjectTrait for StorageDrsPodSelectionSpec {
}
impl DataObjectTrait for PodDiskLocator {
}
impl DataObjectTrait for VmPodConfigForPlacement {
}
impl DataObjectTrait for StorageDrsSpaceLoadBalanceConfig {
}
impl DataObjectTrait for StoragePlacementResult {
}
impl DataObjectTrait for StoragePlacementSpec {
}
impl DataObjectTrait for StorageDrsVmConfigInfo {
}
impl DataObjectTrait for VAppCloneSpec {
}
impl DataObjectTrait for VAppCloneSpecNetworkMappingPair {
}
impl DataObjectTrait for VAppCloneSpecResourceMap {
}
impl DataObjectTrait for VAppEntityConfigInfo {
}
impl DataObjectTrait for VAppIpAssignmentInfo {
}
impl DataObjectTrait for IpPool {
}
impl DataObjectTrait for IpPoolAssociation {
}
impl DataObjectTrait for IpPoolIpPoolConfigInfo {
}
impl DataObjectTrait for VAppOvfSectionInfo {
}
impl DataObjectTrait for VAppProductInfo {
}
impl DataObjectTrait for VAppPropertyInfo {
}
impl DataObjectTrait for VmConfigInfo {
}
impl DataObjectTrait for VAppConfigInfo {
}
impl DataObjectTrait for VmConfigSpec {
}
impl DataObjectTrait for VAppConfigSpec {
}
impl DataObjectTrait for ClusterNetworkConfigSpec {
}
impl DataObjectTrait for FailoverNodeInfo {
}
impl DataObjectTrait for NodeDeploymentSpec {
}
impl DataObjectTrait for PassiveNodeDeploymentSpec {
}
impl DataObjectTrait for NodeNetworkSpec {
}
impl DataObjectTrait for PassiveNodeNetworkSpec {
}
impl DataObjectTrait for SourceNodeSpec {
}
impl DataObjectTrait for VchaClusterConfigInfo {
}
impl DataObjectTrait for VchaClusterConfigSpec {
}
impl DataObjectTrait for VchaClusterDeploymentSpec {
}
impl DataObjectTrait for VchaClusterNetworkSpec {
}
impl DataObjectTrait for WitnessNodeInfo {
}
impl DataObjectTrait for VchaClusterHealth {
}
impl DataObjectTrait for VchaClusterRuntimeInfo {
}
impl DataObjectTrait for VchaNodeRuntimeInfo {
}
impl DataObjectTrait for VirtualMachineAffinityInfo {
}
impl DataObjectTrait for VirtualMachineBaseIndependentFilterSpec {
}
impl DataObjectTrait for VirtualMachineEmptyIndependentFilterSpec {
}
impl DataObjectTrait for VirtualMachineIndependentFilterSpec {
}
impl DataObjectTrait for VirtualMachineBootOptions {
}
impl DataObjectTrait for VirtualMachineBootOptionsBootableDevice {
}
impl DataObjectTrait for VirtualMachineBootOptionsBootableCdromDevice {
}
impl DataObjectTrait for VirtualMachineBootOptionsBootableDiskDevice {
}
impl DataObjectTrait for VirtualMachineBootOptionsBootableEthernetDevice {
}
impl DataObjectTrait for VirtualMachineBootOptionsBootableFloppyDevice {
}
impl DataObjectTrait for VirtualMachineCapability {
}
impl DataObjectTrait for VirtualMachineCertThumbprint {
}
impl DataObjectTrait for VirtualMachineCloneSpec {
}
impl DataObjectTrait for VirtualMachineConfigInfo {
}
impl DataObjectTrait for VirtualMachineConfigInfoDatastoreUrlPair {
}
impl DataObjectTrait for VirtualMachineConfigInfoOverheadInfo {
}
impl DataObjectTrait for VirtualMachineConfigOption {
}
impl DataObjectTrait for VirtualMachineConfigOptionDescriptor {
}
impl DataObjectTrait for VirtualMachineConfigSpec {
}
impl DataObjectTrait for ConfigTarget {
}
impl DataObjectTrait for VirtualMachineConsolePreferences {
}
impl DataObjectTrait for VirtualMachineContentLibraryItemInfo {
}
impl DataObjectTrait for DatastoreOption {
}
impl DataObjectTrait for VirtualMachineDatastoreVolumeOption {
}
impl DataObjectTrait for VirtualMachineDefaultPowerOpInfo {
}
impl DataObjectTrait for VirtualMachineDeviceRuntimeInfo {
}
impl DataObjectTrait for VirtualMachineDeviceRuntimeInfoDeviceRuntimeState {
}
impl DataObjectTrait for VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState {
}
impl DataObjectTrait for VirtualMachineDvxClassInfo {
}
impl DataObjectTrait for FaultToleranceConfigInfo {
}
impl DataObjectTrait for FaultTolerancePrimaryConfigInfo {
}
impl DataObjectTrait for FaultToleranceSecondaryConfigInfo {
}
impl DataObjectTrait for FaultToleranceConfigSpec {
}
impl DataObjectTrait for FaultToleranceMetaSpec {
}
impl DataObjectTrait for FaultToleranceSecondaryOpResult {
}
impl DataObjectTrait for FaultToleranceVmConfigSpec {
}
impl DataObjectTrait for FaultToleranceDiskSpec {
}
impl DataObjectTrait for VirtualMachineFeatureRequirement {
}
impl DataObjectTrait for VirtualMachineFileInfo {
}
impl DataObjectTrait for VirtualMachineFileLayout {
}
impl DataObjectTrait for VirtualMachineFileLayoutDiskLayout {
}
impl DataObjectTrait for VirtualMachineFileLayoutSnapshotLayout {
}
impl DataObjectTrait for VirtualMachineFileLayoutEx {
}
impl DataObjectTrait for VirtualMachineFileLayoutExDiskLayout {
}
impl DataObjectTrait for VirtualMachineFileLayoutExDiskUnit {
}
impl DataObjectTrait for VirtualMachineFileLayoutExFileInfo {
}
impl DataObjectTrait for VirtualMachineFileLayoutExSnapshotLayout {
}
impl DataObjectTrait for VirtualMachineFlagInfo {
}
impl DataObjectTrait for VirtualMachineForkConfigInfo {
}
impl DataObjectTrait for GuestInfo {
}
impl DataObjectTrait for GuestInfoCustomizationInfo {
}
impl DataObjectTrait for GuestDiskInfo {
}
impl DataObjectTrait for GuestInfoNamespaceGenerationInfo {
}
impl DataObjectTrait for GuestNicInfo {
}
impl DataObjectTrait for GuestScreenInfo {
}
impl DataObjectTrait for GuestStackInfo {
}
impl DataObjectTrait for GuestInfoVirtualDiskMapping {
}
impl DataObjectTrait for VirtualMachineGuestIntegrityInfo {
}
impl DataObjectTrait for VirtualMachineGuestMonitoringModeInfo {
}
impl DataObjectTrait for GuestOsDescriptor {
}
impl DataObjectTrait for VirtualMachineGuestQuiesceSpec {
}
impl DataObjectTrait for VirtualMachineWindowsQuiesceSpec {
}
impl DataObjectTrait for VirtualMachineIdeDiskDevicePartitionInfo {
}
impl DataObjectTrait for VirtualMachineInstantCloneSpec {
}
impl DataObjectTrait for VirtualMachineLegacyNetworkSwitchInfo {
}
impl DataObjectTrait for VirtualMachineMessage {
}
impl DataObjectTrait for VirtualMachineMetadataManagerVmMetadata {
}
impl DataObjectTrait for VirtualMachineMetadataManagerVmMetadataInput {
}
impl DataObjectTrait for VirtualMachineMetadataManagerVmMetadataOwner {
}
impl DataObjectTrait for VirtualMachineMetadataManagerVmMetadataResult {
}
impl DataObjectTrait for VirtualMachineNetworkShaperInfo {
}
impl DataObjectTrait for VirtualMachineProfileDetails {
}
impl DataObjectTrait for VirtualMachineProfileDetailsDiskProfileDetails {
}
impl DataObjectTrait for VirtualMachineProfileRawData {
}
impl DataObjectTrait for VirtualMachineProfileSpec {
}
impl DataObjectTrait for VirtualMachineDefaultProfileSpec {
}
impl DataObjectTrait for VirtualMachineDefinedProfileSpec {
}
impl DataObjectTrait for VirtualMachineEmptyProfileSpec {
}
impl DataObjectTrait for VirtualMachinePropertyRelation {
}
impl DataObjectTrait for VirtualMachineQuestionInfo {
}
impl DataObjectTrait for VirtualMachineRelocateSpec {
}
impl DataObjectTrait for VirtualMachineRelocateSpecDiskLocator {
}
impl DataObjectTrait for VirtualMachineRelocateSpecDiskLocatorBackingSpec {
}
impl DataObjectTrait for ReplicationConfigSpec {
}
impl DataObjectTrait for ReplicationInfoDiskSettings {
}
impl DataObjectTrait for VirtualMachineRuntimeInfo {
}
impl DataObjectTrait for VirtualMachineRuntimeInfoDasProtectionState {
}
impl DataObjectTrait for ScheduledHardwareUpgradeInfo {
}
impl DataObjectTrait for VirtualMachineSgxInfo {
}
impl DataObjectTrait for VirtualMachineSnapshotInfo {
}
impl DataObjectTrait for VirtualMachineSnapshotTree {
}
impl DataObjectTrait for VirtualMachineSriovDevicePoolInfo {
}
impl DataObjectTrait for VirtualMachineSriovNetworkDevicePoolInfo {
}
impl DataObjectTrait for VirtualMachineStorageInfo {
}
impl DataObjectTrait for VirtualMachineUsageOnDatastore {
}
impl DataObjectTrait for VirtualMachineSummary {
}
impl DataObjectTrait for VirtualMachineConfigSummary {
}
impl DataObjectTrait for VirtualMachineGuestSummary {
}
impl DataObjectTrait for VirtualMachineQuickStats {
}
impl DataObjectTrait for VirtualMachineQuickStatsMemoryTierStats {
}
impl DataObjectTrait for VirtualMachineStorageSummary {
}
impl DataObjectTrait for VirtualMachineTargetInfo {
}
impl DataObjectTrait for VirtualMachineCdromInfo {
}
impl DataObjectTrait for VirtualMachineDatastoreInfo {
}
impl DataObjectTrait for VirtualMachineDiskDeviceInfo {
}
impl DataObjectTrait for VirtualMachineIdeDiskDeviceInfo {
}
impl DataObjectTrait for VirtualMachineScsiDiskDeviceInfo {
}
impl DataObjectTrait for VirtualMachineDynamicPassthroughInfo {
}
impl DataObjectTrait for VirtualMachineFloppyInfo {
}
impl DataObjectTrait for VirtualMachineNetworkInfo {
}
impl DataObjectTrait for OpaqueNetworkTargetInfo {
}
impl DataObjectTrait for VirtualMachineParallelInfo {
}
impl DataObjectTrait for VirtualMachinePciPassthroughInfo {
}
impl DataObjectTrait for VirtualMachineSriovInfo {
}
impl DataObjectTrait for VirtualMachinePciSharedGpuPassthroughInfo {
}
impl DataObjectTrait for VirtualMachinePrecisionClockInfo {
}
impl DataObjectTrait for VirtualMachineScsiPassthroughInfo {
}
impl DataObjectTrait for VirtualMachineSerialInfo {
}
impl DataObjectTrait for VirtualMachineSgxTargetInfo {
}
impl DataObjectTrait for VirtualMachineSoundInfo {
}
impl DataObjectTrait for VirtualMachineUsbInfo {
}
impl DataObjectTrait for VirtualMachineVFlashModuleInfo {
}
impl DataObjectTrait for VirtualMachineVMotionStunTimeInfo {
}
impl DataObjectTrait for VirtualMachineVendorDeviceGroupInfo {
}
impl DataObjectTrait for VirtualMachineVgpuDeviceInfo {
}
impl DataObjectTrait for VirtualMachineVgpuProfileInfo {
}
impl DataObjectTrait for ToolsConfigInfo {
}
impl DataObjectTrait for ToolsConfigInfoToolsLastInstallInfo {
}
impl DataObjectTrait for UsbScanCodeSpec {
}
impl DataObjectTrait for UsbScanCodeSpecKeyEvent {
}
impl DataObjectTrait for UsbScanCodeSpecModifierType {
}
impl DataObjectTrait for VirtualMachineVcpuConfig {
}
impl DataObjectTrait for VirtualMachineVendorDeviceGroupInfoComponentDeviceInfo {
}
impl DataObjectTrait for VirtualMachineVirtualDeviceGroups {
}
impl DataObjectTrait for VirtualMachineVirtualDeviceGroupsDeviceGroup {
}
impl DataObjectTrait for VirtualMachineVirtualDeviceGroupsVendorDeviceGroup {
}
impl DataObjectTrait for VirtualMachineVirtualDeviceSwap {
}
impl DataObjectTrait for VirtualMachineVirtualDeviceSwapDeviceSwapInfo {
}
impl DataObjectTrait for VirtualHardware {
}
impl DataObjectTrait for VirtualHardwareOption {
}
impl DataObjectTrait for VirtualMachineVirtualNuma {
}
impl DataObjectTrait for VirtualMachineVirtualNumaInfo {
}
impl DataObjectTrait for VirtualMachineVirtualPMem {
}
impl DataObjectTrait for CheckResult {
}
impl DataObjectTrait for CustomizationAdapterMapping {
}
impl DataObjectTrait for CustomizationGlobalIpSettings {
}
impl DataObjectTrait for CustomizationGuiRunOnce {
}
impl DataObjectTrait for CustomizationGuiUnattended {
}
impl DataObjectTrait for CustomizationIpSettings {
}
impl DataObjectTrait for CustomizationIpSettingsIpV6AddressSpec {
}
impl DataObjectTrait for CustomizationIdentification {
}
impl DataObjectTrait for CustomizationIdentitySettings {
}
impl DataObjectTrait for CustomizationCloudinitPrep {
}
impl DataObjectTrait for CustomizationLinuxPrep {
}
impl DataObjectTrait for CustomizationSysprep {
}
impl DataObjectTrait for CustomizationSysprepText {
}
impl DataObjectTrait for CustomizationIpGenerator {
}
impl DataObjectTrait for CustomizationCustomIpGenerator {
}
impl DataObjectTrait for CustomizationDhcpIpGenerator {
}
impl DataObjectTrait for CustomizationFixedIp {
}
impl DataObjectTrait for CustomizationUnknownIpGenerator {
}
impl DataObjectTrait for CustomizationIpV6Generator {
}
impl DataObjectTrait for CustomizationAutoIpV6Generator {
}
impl DataObjectTrait for CustomizationCustomIpV6Generator {
}
impl DataObjectTrait for CustomizationDhcpIpV6Generator {
}
impl DataObjectTrait for CustomizationFixedIpV6 {
}
impl DataObjectTrait for CustomizationStatelessIpV6Generator {
}
impl DataObjectTrait for CustomizationUnknownIpV6Generator {
}
impl DataObjectTrait for CustomizationLicenseFilePrintData {
}
impl DataObjectTrait for CustomizationName {
}
impl DataObjectTrait for CustomizationCustomName {
}
impl DataObjectTrait for CustomizationFixedName {
}
impl DataObjectTrait for CustomizationPrefixName {
}
impl DataObjectTrait for CustomizationUnknownName {
}
impl DataObjectTrait for CustomizationVirtualMachineName {
}
impl DataObjectTrait for CustomizationOptions {
}
impl DataObjectTrait for CustomizationLinuxOptions {
}
impl DataObjectTrait for CustomizationWinOptions {
}
impl DataObjectTrait for CustomizationPassword {
}
impl DataObjectTrait for CustomizationSpec {
}
impl DataObjectTrait for CustomizationUserData {
}
impl DataObjectTrait for HostDiskMappingInfo {
}
impl DataObjectTrait for HostDiskMappingPartitionInfo {
}
impl DataObjectTrait for HostDiskMappingOption {
}
impl DataObjectTrait for HostDiskMappingPartitionOption {
}
impl DataObjectTrait for VirtualDevice {
}
impl DataObjectTrait for VirtualCdrom {
}
impl DataObjectTrait for VirtualController {
}
impl DataObjectTrait for VirtualIdeController {
}
impl DataObjectTrait for VirtualNvdimmController {
}
impl DataObjectTrait for VirtualNvmeController {
}
impl DataObjectTrait for VirtualPciController {
}
impl DataObjectTrait for VirtualPs2Controller {
}
impl DataObjectTrait for VirtualSataController {
}
impl DataObjectTrait for VirtualAhciController {
}
impl DataObjectTrait for VirtualScsiController {
}
impl DataObjectTrait for ParaVirtualScsiController {
}
impl DataObjectTrait for VirtualBusLogicController {
}
impl DataObjectTrait for VirtualLsiLogicController {
}
impl DataObjectTrait for VirtualLsiLogicSasController {
}
impl DataObjectTrait for VirtualSioController {
}
impl DataObjectTrait for VirtualUsbController {
}
impl DataObjectTrait for VirtualUsbxhciController {
}
impl DataObjectTrait for VirtualDisk {
}
impl DataObjectTrait for VirtualEthernetCard {
}
impl DataObjectTrait for VirtualE1000 {
}
impl DataObjectTrait for VirtualE1000E {
}
impl DataObjectTrait for VirtualPcNet32 {
}
impl DataObjectTrait for VirtualSriovEthernetCard {
}
impl DataObjectTrait for VirtualVmxnet {
}
impl DataObjectTrait for VirtualVmxnet2 {
}
impl DataObjectTrait for VirtualVmxnet3 {
}
impl DataObjectTrait for VirtualVmxnet3Vrdma {
}
impl DataObjectTrait for VirtualFloppy {
}
impl DataObjectTrait for VirtualKeyboard {
}
impl DataObjectTrait for VirtualNvdimm {
}
impl DataObjectTrait for VirtualPciPassthrough {
}
impl DataObjectTrait for VirtualParallelPort {
}
impl DataObjectTrait for VirtualPointingDevice {
}
impl DataObjectTrait for VirtualPrecisionClock {
}
impl DataObjectTrait for VirtualScsiPassthrough {
}
impl DataObjectTrait for VirtualSerialPort {
}
impl DataObjectTrait for VirtualSoundCard {
}
impl DataObjectTrait for VirtualEnsoniq1371 {
}
impl DataObjectTrait for VirtualHdAudioCard {
}
impl DataObjectTrait for VirtualSoundBlaster16 {
}
impl DataObjectTrait for VirtualTpm {
}
impl DataObjectTrait for VirtualUsb {
}
impl DataObjectTrait for VirtualMachineVmciDevice {
}
impl DataObjectTrait for VirtualMachineVmirom {
}
impl DataObjectTrait for VirtualMachineVideoCard {
}
impl DataObjectTrait for VirtualWdt {
}
impl DataObjectTrait for VirtualDeviceBackingInfo {
}
impl DataObjectTrait for VirtualDeviceDeviceBackingInfo {
}
impl DataObjectTrait for VirtualCdromAtapiBackingInfo {
}
impl DataObjectTrait for VirtualCdromPassthroughBackingInfo {
}
impl DataObjectTrait for VirtualDiskRawDiskVer2BackingInfo {
}
impl DataObjectTrait for VirtualDiskPartitionedRawDiskVer2BackingInfo {
}
impl DataObjectTrait for VirtualEthernetCardLegacyNetworkBackingInfo {
}
impl DataObjectTrait for VirtualEthernetCardNetworkBackingInfo {
}
impl DataObjectTrait for VirtualFloppyDeviceBackingInfo {
}
impl DataObjectTrait for VirtualPciPassthroughDeviceBackingInfo {
}
impl DataObjectTrait for VirtualPciPassthroughDynamicBackingInfo {
}
impl DataObjectTrait for VirtualParallelPortDeviceBackingInfo {
}
impl DataObjectTrait for VirtualPointingDeviceDeviceBackingInfo {
}
impl DataObjectTrait for VirtualScsiPassthroughDeviceBackingInfo {
}
impl DataObjectTrait for VirtualSerialPortDeviceBackingInfo {
}
impl DataObjectTrait for VirtualSoundCardDeviceBackingInfo {
}
impl DataObjectTrait for VirtualUsbRemoteHostBackingInfo {
}
impl DataObjectTrait for VirtualUsbusbBackingInfo {
}
impl DataObjectTrait for VirtualDeviceFileBackingInfo {
}
impl DataObjectTrait for VirtualCdromIsoBackingInfo {
}
impl DataObjectTrait for VirtualDiskFlatVer1BackingInfo {
}
impl DataObjectTrait for VirtualDiskFlatVer2BackingInfo {
}
impl DataObjectTrait for VirtualDiskLocalPMemBackingInfo {
}
impl DataObjectTrait for VirtualDiskRawDiskMappingVer1BackingInfo {
}
impl DataObjectTrait for VirtualDiskSeSparseBackingInfo {
}
impl DataObjectTrait for VirtualDiskSparseVer1BackingInfo {
}
impl DataObjectTrait for VirtualDiskSparseVer2BackingInfo {
}
impl DataObjectTrait for VirtualFloppyImageBackingInfo {
}
impl DataObjectTrait for VirtualNvdimmBackingInfo {
}
impl DataObjectTrait for VirtualParallelPortFileBackingInfo {
}
impl DataObjectTrait for VirtualSerialPortFileBackingInfo {
}
impl DataObjectTrait for VirtualDevicePipeBackingInfo {
}
impl DataObjectTrait for VirtualSerialPortPipeBackingInfo {
}
impl DataObjectTrait for VirtualDeviceRemoteDeviceBackingInfo {
}
impl DataObjectTrait for VirtualCdromRemoteAtapiBackingInfo {
}
impl DataObjectTrait for VirtualCdromRemotePassthroughBackingInfo {
}
impl DataObjectTrait for VirtualFloppyRemoteDeviceBackingInfo {
}
impl DataObjectTrait for VirtualUsbRemoteClientBackingInfo {
}
impl DataObjectTrait for VirtualDeviceUriBackingInfo {
}
impl DataObjectTrait for VirtualSerialPortUriBackingInfo {
}
impl DataObjectTrait for VirtualEthernetCardDistributedVirtualPortBackingInfo {
}
impl DataObjectTrait for VirtualEthernetCardOpaqueNetworkBackingInfo {
}
impl DataObjectTrait for VirtualPciPassthroughDvxBackingInfo {
}
impl DataObjectTrait for VirtualPciPassthroughPluginBackingInfo {
}
impl DataObjectTrait for VirtualPciPassthroughVmiopBackingInfo {
}
impl DataObjectTrait for VirtualPrecisionClockSystemClockBackingInfo {
}
impl DataObjectTrait for VirtualSerialPortThinPrintBackingInfo {
}
impl DataObjectTrait for VirtualSriovEthernetCardSriovBackingInfo {
}
impl DataObjectTrait for VirtualDeviceBusSlotInfo {
}
impl DataObjectTrait for VirtualDevicePciBusSlotInfo {
}
impl DataObjectTrait for VirtualUsbControllerPciBusSlotInfo {
}
impl DataObjectTrait for VirtualDeviceConnectInfo {
}
impl DataObjectTrait for VirtualDeviceDeviceGroupInfo {
}
impl DataObjectTrait for VirtualDeviceOption {
}
impl DataObjectTrait for VirtualCdromOption {
}
impl DataObjectTrait for VirtualControllerOption {
}
impl DataObjectTrait for VirtualIdeControllerOption {
}
impl DataObjectTrait for VirtualNvdimmControllerOption {
}
impl DataObjectTrait for VirtualNvmeControllerOption {
}
impl DataObjectTrait for VirtualPciControllerOption {
}
impl DataObjectTrait for VirtualPs2ControllerOption {
}
impl DataObjectTrait for VirtualSataControllerOption {
}
impl DataObjectTrait for VirtualAhciControllerOption {
}
impl DataObjectTrait for VirtualScsiControllerOption {
}
impl DataObjectTrait for ParaVirtualScsiControllerOption {
}
impl DataObjectTrait for VirtualBusLogicControllerOption {
}
impl DataObjectTrait for VirtualLsiLogicControllerOption {
}
impl DataObjectTrait for VirtualLsiLogicSasControllerOption {
}
impl DataObjectTrait for VirtualSioControllerOption {
}
impl DataObjectTrait for VirtualUsbControllerOption {
}
impl DataObjectTrait for VirtualUsbxhciControllerOption {
}
impl DataObjectTrait for VirtualDiskOption {
}
impl DataObjectTrait for VirtualEthernetCardOption {
}
impl DataObjectTrait for VirtualE1000Option {
}
impl DataObjectTrait for VirtualE1000EOption {
}
impl DataObjectTrait for VirtualPcNet32Option {
}
impl DataObjectTrait for VirtualSriovEthernetCardOption {
}
impl DataObjectTrait for VirtualVmxnetOption {
}
impl DataObjectTrait for VirtualVmxnet2Option {
}
impl DataObjectTrait for VirtualVmxnet3Option {
}
impl DataObjectTrait for VirtualVmxnet3VrdmaOption {
}
impl DataObjectTrait for VirtualFloppyOption {
}
impl DataObjectTrait for VirtualKeyboardOption {
}
impl DataObjectTrait for VirtualNvdimmOption {
}
impl DataObjectTrait for VirtualPciPassthroughOption {
}
impl DataObjectTrait for VirtualParallelPortOption {
}
impl DataObjectTrait for VirtualPointingDeviceOption {
}
impl DataObjectTrait for VirtualPrecisionClockOption {
}
impl DataObjectTrait for VirtualScsiPassthroughOption {
}
impl DataObjectTrait for VirtualSerialPortOption {
}
impl DataObjectTrait for VirtualSoundCardOption {
}
impl DataObjectTrait for VirtualEnsoniq1371Option {
}
impl DataObjectTrait for VirtualHdAudioCardOption {
}
impl DataObjectTrait for VirtualSoundBlaster16Option {
}
impl DataObjectTrait for VirtualTpmOption {
}
impl DataObjectTrait for VirtualUsbOption {
}
impl DataObjectTrait for VirtualMachineVmciDeviceOption {
}
impl DataObjectTrait for VirtualVmiromOption {
}
impl DataObjectTrait for VirtualVideoCardOption {
}
impl DataObjectTrait for VirtualWdtOption {
}
impl DataObjectTrait for VirtualDeviceBackingOption {
}
impl DataObjectTrait for VirtualDeviceDeviceBackingOption {
}
impl DataObjectTrait for VirtualCdromAtapiBackingOption {
}
impl DataObjectTrait for VirtualCdromPassthroughBackingOption {
}
impl DataObjectTrait for VirtualCdromRemoteAtapiBackingOption {
}
impl DataObjectTrait for VirtualDiskRawDiskMappingVer1BackingOption {
}
impl DataObjectTrait for VirtualDiskRawDiskVer2BackingOption {
}
impl DataObjectTrait for VirtualDiskPartitionedRawDiskVer2BackingOption {
}
impl DataObjectTrait for VirtualEthernetCardLegacyNetworkBackingOption {
}
impl DataObjectTrait for VirtualEthernetCardNetworkBackingOption {
}
impl DataObjectTrait for VirtualFloppyDeviceBackingOption {
}
impl DataObjectTrait for VirtualPciPassthroughDeviceBackingOption {
}
impl DataObjectTrait for VirtualPciPassthroughDynamicBackingOption {
}
impl DataObjectTrait for VirtualParallelPortDeviceBackingOption {
}
impl DataObjectTrait for VirtualPointingDeviceBackingOption {
}
impl DataObjectTrait for VirtualScsiPassthroughDeviceBackingOption {
}
impl DataObjectTrait for VirtualSerialPortDeviceBackingOption {
}
impl DataObjectTrait for VirtualSoundCardDeviceBackingOption {
}
impl DataObjectTrait for VirtualUsbRemoteHostBackingOption {
}
impl DataObjectTrait for VirtualUsbusbBackingOption {
}
impl DataObjectTrait for VirtualDeviceFileBackingOption {
}
impl DataObjectTrait for VirtualCdromIsoBackingOption {
}
impl DataObjectTrait for VirtualDiskFlatVer1BackingOption {
}
impl DataObjectTrait for VirtualDiskFlatVer2BackingOption {
}
impl DataObjectTrait for VirtualDiskLocalPMemBackingOption {
}
impl DataObjectTrait for VirtualDiskSeSparseBackingOption {
}
impl DataObjectTrait for VirtualDiskSparseVer1BackingOption {
}
impl DataObjectTrait for VirtualDiskSparseVer2BackingOption {
}
impl DataObjectTrait for VirtualFloppyImageBackingOption {
}
impl DataObjectTrait for VirtualParallelPortFileBackingOption {
}
impl DataObjectTrait for VirtualSerialPortFileBackingOption {
}
impl DataObjectTrait for VirtualDevicePipeBackingOption {
}
impl DataObjectTrait for VirtualSerialPortPipeBackingOption {
}
impl DataObjectTrait for VirtualDeviceRemoteDeviceBackingOption {
}
impl DataObjectTrait for VirtualCdromRemotePassthroughBackingOption {
}
impl DataObjectTrait for VirtualFloppyRemoteDeviceBackingOption {
}
impl DataObjectTrait for VirtualUsbRemoteClientBackingOption {
}
impl DataObjectTrait for VirtualDeviceUriBackingOption {
}
impl DataObjectTrait for VirtualSerialPortUriBackingOption {
}
impl DataObjectTrait for VirtualEthernetCardDvPortBackingOption {
}
impl DataObjectTrait for VirtualEthernetCardOpaqueNetworkBackingOption {
}
impl DataObjectTrait for VirtualPciPassthroughDvxBackingOption {
}
impl DataObjectTrait for VirtualPciPassthroughPluginBackingOption {
}
impl DataObjectTrait for VirtualPciPassthroughVmiopBackingOption {
}
impl DataObjectTrait for VirtualPrecisionClockSystemClockBackingOption {
}
impl DataObjectTrait for VirtualSerialPortThinPrintBackingOption {
}
impl DataObjectTrait for VirtualSriovEthernetCardSriovBackingOption {
}
impl DataObjectTrait for VirtualDeviceBusSlotOption {
}
impl DataObjectTrait for VirtualDeviceConnectOption {
}
impl DataObjectTrait for VirtualDeviceConfigSpec {
}
impl DataObjectTrait for VirtualDiskConfigSpec {
}
impl DataObjectTrait for VirtualDeviceConfigSpecBackingSpec {
}
impl DataObjectTrait for VirtualDiskVFlashCacheConfigInfo {
}
impl DataObjectTrait for VirtualDiskId {
}
impl DataObjectTrait for VirtualDiskDeltaDiskFormatsSupported {
}
impl DataObjectTrait for VirtualDiskOptionVFlashCacheConfigOption {
}
impl DataObjectTrait for VirtualEthernetCardResourceAllocation {
}
impl DataObjectTrait for VirtualPciPassthroughAllowedDevice {
}
impl DataObjectTrait for VirtualMachineVmciDeviceFilterInfo {
}
impl DataObjectTrait for VirtualMachineVmciDeviceFilterSpec {
}
impl DataObjectTrait for VirtualMachineVmciDeviceOptionFilterSpecOption {
}
impl DataObjectTrait for GuestAliases {
}
impl DataObjectTrait for GuestAuthAliasInfo {
}
impl DataObjectTrait for GuestAuthSubject {
}
impl DataObjectTrait for GuestAuthAnySubject {
}
impl DataObjectTrait for GuestAuthNamedSubject {
}
impl DataObjectTrait for GuestMappedAliases {
}
impl DataObjectTrait for GuestFileAttributes {
}
impl DataObjectTrait for GuestPosixFileAttributes {
}
impl DataObjectTrait for GuestWindowsFileAttributes {
}
impl DataObjectTrait for GuestFileInfo {
}
impl DataObjectTrait for FileTransferInformation {
}
impl DataObjectTrait for GuestListFileInfo {
}
impl DataObjectTrait for GuestAuthentication {
}
impl DataObjectTrait for NamePasswordAuthentication {
}
impl DataObjectTrait for SamlTokenAuthentication {
}
impl DataObjectTrait for SspiAuthentication {
}
impl DataObjectTrait for TicketedSessionAuthentication {
}
impl DataObjectTrait for GuestProcessInfo {
}
impl DataObjectTrait for GuestProgramSpec {
}
impl DataObjectTrait for GuestWindowsProgramSpec {
}
impl DataObjectTrait for GuestRegKeySpec {
}
impl DataObjectTrait for GuestRegKeyNameSpec {
}
impl DataObjectTrait for GuestRegKeyRecordSpec {
}
impl DataObjectTrait for GuestRegValueSpec {
}
impl DataObjectTrait for GuestRegValueDataSpec {
}
impl DataObjectTrait for GuestRegValueBinarySpec {
}
impl DataObjectTrait for GuestRegValueDwordSpec {
}
impl DataObjectTrait for GuestRegValueExpandStringSpec {
}
impl DataObjectTrait for GuestRegValueMultiStringSpec {
}
impl DataObjectTrait for GuestRegValueQwordSpec {
}
impl DataObjectTrait for GuestRegValueStringSpec {
}
impl DataObjectTrait for GuestRegValueNameSpec {
}
impl DataObjectTrait for DeviceGroupId {
}
impl DataObjectTrait for FaultDomainId {
}
impl DataObjectTrait for ReplicationGroupId {
}
impl DataObjectTrait for ReplicationSpec {
}
impl DataObjectTrait for VsanClusterConfigInfo {
}
impl DataObjectTrait for VsanClusterConfigInfoHostDefaultInfo {
}
impl DataObjectTrait for VsanHostClusterStatus {
}
impl DataObjectTrait for VsanHostClusterStatusState {
}
impl DataObjectTrait for VsanHostClusterStatusStateCompletionEstimate {
}
impl DataObjectTrait for VsanHostConfigInfo {
}
impl DataObjectTrait for VsanHostConfigInfoClusterInfo {
}
impl DataObjectTrait for VsanHostFaultDomainInfo {
}
impl DataObjectTrait for VsanHostConfigInfoNetworkInfo {
}
impl DataObjectTrait for VsanHostConfigInfoNetworkInfoPortConfig {
}
impl DataObjectTrait for VsanHostConfigInfoStorageInfo {
}
impl DataObjectTrait for VsanHostDecommissionMode {
}
impl DataObjectTrait for VsanHostDiskMapInfo {
}
impl DataObjectTrait for VsanHostDiskMapResult {
}
impl DataObjectTrait for VsanHostDiskMapping {
}
impl DataObjectTrait for VsanHostDiskResult {
}
impl DataObjectTrait for VsanHostIpConfig {
}
impl DataObjectTrait for VsanHostMembershipInfo {
}
impl DataObjectTrait for VsanHostVsanDiskInfo {
}
impl DataObjectTrait for VsanHostRuntimeInfo {
}
impl DataObjectTrait for VsanHostRuntimeInfoDiskIssue {
}
impl DataObjectTrait for BaseConfigInfo {
}
impl DataObjectTrait for VStorageObjectConfigInfo {
}
impl DataObjectTrait for BaseConfigInfoBackingInfo {
}
impl DataObjectTrait for BaseConfigInfoFileBackingInfo {
}
impl DataObjectTrait for BaseConfigInfoDiskFileBackingInfo {
}
impl DataObjectTrait for BaseConfigInfoRawDiskMappingBackingInfo {
}
impl DataObjectTrait for VslmCreateSpec {
}
impl DataObjectTrait for VslmCreateSpecBackingSpec {
}
impl DataObjectTrait for VslmCreateSpecDiskFileBackingSpec {
}
impl DataObjectTrait for VslmCreateSpecRawDiskMappingBackingSpec {
}
impl DataObjectTrait for DiskCryptoSpec {
}
impl DataObjectTrait for Id {
}
impl DataObjectTrait for VslmInfrastructureObjectPolicy {
}
impl DataObjectTrait for VslmInfrastructureObjectPolicySpec {
}
impl DataObjectTrait for VslmMigrateSpec {
}
impl DataObjectTrait for VslmCloneSpec {
}
impl DataObjectTrait for VslmRelocateSpec {
}
impl DataObjectTrait for VStorageObjectStateInfo {
}
impl DataObjectTrait for VslmTagEntry {
}
impl DataObjectTrait for VslmVClockInfo {
}
impl DataObjectTrait for VStorageObject {
}
impl DataObjectTrait for VStorageObjectSnapshot {
}
impl DataObjectTrait for VStorageObjectSnapshotDetails {
}
impl DataObjectTrait for VStorageObjectSnapshotInfo {
}
impl DataObjectTrait for VStorageObjectSnapshotInfoVStorageObjectSnapshot {
}
impl DataObjectTrait for RetrieveVStorageObjSpec {
}
impl DataObjectTrait for VStorageObjectAssociations {
}
impl DataObjectTrait for VStorageObjectAssociationsVmDiskAssociations {
}
impl DataObjectTrait for DynamicArray {
}
impl DataObjectTrait for DynamicProperty {
}
impl DataObjectTrait for KeyAnyValue {
}
impl DataObjectTrait for LocalizableMessage {
}
impl DataObjectTrait for LocalizedMethodFault {
}
impl DataObjectTrait for PropertyChange {
}
impl DataObjectTrait for PropertyFilterSpec {
}
impl DataObjectTrait for PropertyFilterUpdate {
}
impl DataObjectTrait for MissingObject {
}
impl DataObjectTrait for MissingProperty {
}
impl DataObjectTrait for ObjectContent {
}
impl DataObjectTrait for ObjectSpec {
}
impl DataObjectTrait for ObjectUpdate {
}
impl DataObjectTrait for PropertySpec {
}
impl DataObjectTrait for RetrieveOptions {
}
impl DataObjectTrait for RetrieveResult {
}
impl DataObjectTrait for SelectionSpec {
}
impl DataObjectTrait for TraversalSpec {
}
impl DataObjectTrait for UpdateSet {
}
impl DataObjectTrait for WaitOptions {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DataObjectTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DataObject => Some(from.as_any_ref().downcast_ref::<DataObject>()?),
            StructType::AboutInfo => Some(from.as_any_ref().downcast_ref::<AboutInfo>()?),
            StructType::AuthorizationDescription => Some(from.as_any_ref().downcast_ref::<AuthorizationDescription>()?),
            StructType::EntityPrivilege => Some(from.as_any_ref().downcast_ref::<EntityPrivilege>()?),
            StructType::Permission => Some(from.as_any_ref().downcast_ref::<Permission>()?),
            StructType::AuthorizationPrivilege => Some(from.as_any_ref().downcast_ref::<AuthorizationPrivilege>()?),
            StructType::PrivilegeAvailability => Some(from.as_any_ref().downcast_ref::<PrivilegeAvailability>()?),
            StructType::AuthorizationRole => Some(from.as_any_ref().downcast_ref::<AuthorizationRole>()?),
            StructType::UserPrivilegeResult => Some(from.as_any_ref().downcast_ref::<UserPrivilegeResult>()?),
            StructType::BatchResult => Some(from.as_any_ref().downcast_ref::<BatchResult>()?),
            StructType::Capability => Some(from.as_any_ref().downcast_ref::<Capability>()?),
            StructType::ClusterComputeResourceClusterConfigResult => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceClusterConfigResult>()?),
            StructType::ClusterComputeResourceDvsSetting => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceDvsSetting>()?),
            StructType::ClusterComputeResourceDvsSettingDvPortgroupToServiceMapping => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceDvsSettingDvPortgroupToServiceMapping>()?),
            StructType::ClusterComputeResourceDvsProfile => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceDvsProfile>()?),
            StructType::ClusterComputeResourceDvsProfileDvPortgroupSpecToServiceMapping => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceDvsProfileDvPortgroupSpecToServiceMapping>()?),
            StructType::ClusterComputeResourceHciConfigInfo => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceHciConfigInfo>()?),
            StructType::ClusterComputeResourceHciConfigSpec => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceHciConfigSpec>()?),
            StructType::ClusterComputeResourceHostConfigurationInput => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceHostConfigurationInput>()?),
            StructType::ClusterComputeResourceHostConfigurationProfile => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceHostConfigurationProfile>()?),
            StructType::ClusterComputeResourceHostVmkNicInfo => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceHostVmkNicInfo>()?),
            StructType::ClusterComputeResourceVcProfile => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceVcProfile>()?),
            StructType::ClusterComputeResourceValidationResultBase => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceValidationResultBase>()?),
            StructType::ClusterComputeResourceDvsConfigurationValidation => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceDvsConfigurationValidation>()?),
            StructType::ClusterComputeResourceHostConfigurationValidation => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceHostConfigurationValidation>()?),
            StructType::ClusterComputeResourceVcsSlots => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceVcsSlots>()?),
            StructType::ComputeResourceConfigInfo => Some(from.as_any_ref().downcast_ref::<ComputeResourceConfigInfo>()?),
            StructType::ClusterConfigInfoEx => Some(from.as_any_ref().downcast_ref::<ClusterConfigInfoEx>()?),
            StructType::ComputeResourceConfigSpec => Some(from.as_any_ref().downcast_ref::<ComputeResourceConfigSpec>()?),
            StructType::ClusterConfigSpecEx => Some(from.as_any_ref().downcast_ref::<ClusterConfigSpecEx>()?),
            StructType::ComputeResourceHostSpbmLicenseInfo => Some(from.as_any_ref().downcast_ref::<ComputeResourceHostSpbmLicenseInfo>()?),
            StructType::ComputeResourceSummary => Some(from.as_any_ref().downcast_ref::<ComputeResourceSummary>()?),
            StructType::ClusterComputeResourceSummary => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceSummary>()?),
            StructType::CustomFieldDef => Some(from.as_any_ref().downcast_ref::<CustomFieldDef>()?),
            StructType::CustomFieldValue => Some(from.as_any_ref().downcast_ref::<CustomFieldValue>()?),
            StructType::CustomFieldStringValue => Some(from.as_any_ref().downcast_ref::<CustomFieldStringValue>()?),
            StructType::CustomizationSpecInfo => Some(from.as_any_ref().downcast_ref::<CustomizationSpecInfo>()?),
            StructType::CustomizationSpecItem => Some(from.as_any_ref().downcast_ref::<CustomizationSpecItem>()?),
            StructType::DatacenterBasicConnectInfo => Some(from.as_any_ref().downcast_ref::<DatacenterBasicConnectInfo>()?),
            StructType::DatacenterConfigInfo => Some(from.as_any_ref().downcast_ref::<DatacenterConfigInfo>()?),
            StructType::DatacenterConfigSpec => Some(from.as_any_ref().downcast_ref::<DatacenterConfigSpec>()?),
            StructType::DatastoreCapability => Some(from.as_any_ref().downcast_ref::<DatastoreCapability>()?),
            StructType::DatastoreHostMount => Some(from.as_any_ref().downcast_ref::<DatastoreHostMount>()?),
            StructType::DatastoreInfo => Some(from.as_any_ref().downcast_ref::<DatastoreInfo>()?),
            StructType::LocalDatastoreInfo => Some(from.as_any_ref().downcast_ref::<LocalDatastoreInfo>()?),
            StructType::NasDatastoreInfo => Some(from.as_any_ref().downcast_ref::<NasDatastoreInfo>()?),
            StructType::PMemDatastoreInfo => Some(from.as_any_ref().downcast_ref::<PMemDatastoreInfo>()?),
            StructType::VmfsDatastoreInfo => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreInfo>()?),
            StructType::VsanDatastoreInfo => Some(from.as_any_ref().downcast_ref::<VsanDatastoreInfo>()?),
            StructType::VvolDatastoreInfo => Some(from.as_any_ref().downcast_ref::<VvolDatastoreInfo>()?),
            StructType::DatastoreMountPathDatastorePair => Some(from.as_any_ref().downcast_ref::<DatastoreMountPathDatastorePair>()?),
            StructType::DatastoreSummary => Some(from.as_any_ref().downcast_ref::<DatastoreSummary>()?),
            StructType::DatastoreVVolContainerFailoverPair => Some(from.as_any_ref().downcast_ref::<DatastoreVVolContainerFailoverPair>()?),
            StructType::DatastoreNamespaceManagerDirectoryInfo => Some(from.as_any_ref().downcast_ref::<DatastoreNamespaceManagerDirectoryInfo>()?),
            StructType::Description => Some(from.as_any_ref().downcast_ref::<Description>()?),
            StructType::ElementDescription => Some(from.as_any_ref().downcast_ref::<ElementDescription>()?),
            StructType::EvcMode => Some(from.as_any_ref().downcast_ref::<EvcMode>()?),
            StructType::ExtendedElementDescription => Some(from.as_any_ref().downcast_ref::<ExtendedElementDescription>()?),
            StructType::FeatureEvcMode => Some(from.as_any_ref().downcast_ref::<FeatureEvcMode>()?),
            StructType::OptionDef => Some(from.as_any_ref().downcast_ref::<OptionDef>()?),
            StructType::ExtendedDescription => Some(from.as_any_ref().downcast_ref::<ExtendedDescription>()?),
            StructType::MethodDescription => Some(from.as_any_ref().downcast_ref::<MethodDescription>()?),
            StructType::TypeDescription => Some(from.as_any_ref().downcast_ref::<TypeDescription>()?),
            StructType::ScheduledTaskDetail => Some(from.as_any_ref().downcast_ref::<ScheduledTaskDetail>()?),
            StructType::DesiredSoftwareSpec => Some(from.as_any_ref().downcast_ref::<DesiredSoftwareSpec>()?),
            StructType::DesiredSoftwareSpecBaseImageSpec => Some(from.as_any_ref().downcast_ref::<DesiredSoftwareSpecBaseImageSpec>()?),
            StructType::DesiredSoftwareSpecComponentSpec => Some(from.as_any_ref().downcast_ref::<DesiredSoftwareSpecComponentSpec>()?),
            StructType::DesiredSoftwareSpecVendorAddOnSpec => Some(from.as_any_ref().downcast_ref::<DesiredSoftwareSpecVendorAddOnSpec>()?),
            StructType::DiagnosticManagerAuditRecordResult => Some(from.as_any_ref().downcast_ref::<DiagnosticManagerAuditRecordResult>()?),
            StructType::DiagnosticManagerBundleInfo => Some(from.as_any_ref().downcast_ref::<DiagnosticManagerBundleInfo>()?),
            StructType::DiagnosticManagerLogDescriptor => Some(from.as_any_ref().downcast_ref::<DiagnosticManagerLogDescriptor>()?),
            StructType::DiagnosticManagerLogHeader => Some(from.as_any_ref().downcast_ref::<DiagnosticManagerLogHeader>()?),
            StructType::DvsBackupRestoreCapability => Some(from.as_any_ref().downcast_ref::<DvsBackupRestoreCapability>()?),
            StructType::DvsCapability => Some(from.as_any_ref().downcast_ref::<DvsCapability>()?),
            StructType::DvsConfigInfo => Some(from.as_any_ref().downcast_ref::<DvsConfigInfo>()?),
            StructType::VMwareDvsConfigInfo => Some(from.as_any_ref().downcast_ref::<VMwareDvsConfigInfo>()?),
            StructType::DvsConfigSpec => Some(from.as_any_ref().downcast_ref::<DvsConfigSpec>()?),
            StructType::VMwareDvsConfigSpec => Some(from.as_any_ref().downcast_ref::<VMwareDvsConfigSpec>()?),
            StructType::DvsContactInfo => Some(from.as_any_ref().downcast_ref::<DvsContactInfo>()?),
            StructType::DvsCreateSpec => Some(from.as_any_ref().downcast_ref::<DvsCreateSpec>()?),
            StructType::DvsFeatureCapability => Some(from.as_any_ref().downcast_ref::<DvsFeatureCapability>()?),
            StructType::VMwareDvsFeatureCapability => Some(from.as_any_ref().downcast_ref::<VMwareDvsFeatureCapability>()?),
            StructType::DvsHealthCheckConfig => Some(from.as_any_ref().downcast_ref::<DvsHealthCheckConfig>()?),
            StructType::VMwareDvsHealthCheckConfig => Some(from.as_any_ref().downcast_ref::<VMwareDvsHealthCheckConfig>()?),
            StructType::VMwareDvsTeamingHealthCheckConfig => Some(from.as_any_ref().downcast_ref::<VMwareDvsTeamingHealthCheckConfig>()?),
            StructType::VMwareDvsVlanMtuHealthCheckConfig => Some(from.as_any_ref().downcast_ref::<VMwareDvsVlanMtuHealthCheckConfig>()?),
            StructType::DvsHealthCheckCapability => Some(from.as_any_ref().downcast_ref::<DvsHealthCheckCapability>()?),
            StructType::VMwareDvsHealthCheckCapability => Some(from.as_any_ref().downcast_ref::<VMwareDvsHealthCheckCapability>()?),
            StructType::DvsHostInfrastructureTrafficResource => Some(from.as_any_ref().downcast_ref::<DvsHostInfrastructureTrafficResource>()?),
            StructType::DvsHostInfrastructureTrafficResourceAllocation => Some(from.as_any_ref().downcast_ref::<DvsHostInfrastructureTrafficResourceAllocation>()?),
            StructType::DvsNetworkResourceManagementCapability => Some(from.as_any_ref().downcast_ref::<DvsNetworkResourceManagementCapability>()?),
            StructType::DvsResourceRuntimeInfo => Some(from.as_any_ref().downcast_ref::<DvsResourceRuntimeInfo>()?),
            StructType::DvsRollbackCapability => Some(from.as_any_ref().downcast_ref::<DvsRollbackCapability>()?),
            StructType::DvsRuntimeInfo => Some(from.as_any_ref().downcast_ref::<DvsRuntimeInfo>()?),
            StructType::DvsSummary => Some(from.as_any_ref().downcast_ref::<DvsSummary>()?),
            StructType::DvsPolicy => Some(from.as_any_ref().downcast_ref::<DvsPolicy>()?),
            StructType::DvsUplinkPortPolicy => Some(from.as_any_ref().downcast_ref::<DvsUplinkPortPolicy>()?),
            StructType::DvsNameArrayUplinkPortPolicy => Some(from.as_any_ref().downcast_ref::<DvsNameArrayUplinkPortPolicy>()?),
            StructType::EnumDescription => Some(from.as_any_ref().downcast_ref::<EnumDescription>()?),
            StructType::EnvironmentBrowserConfigOptionQuerySpec => Some(from.as_any_ref().downcast_ref::<EnvironmentBrowserConfigOptionQuerySpec>()?),
            StructType::Extension => Some(from.as_any_ref().downcast_ref::<Extension>()?),
            StructType::ExtensionClientInfo => Some(from.as_any_ref().downcast_ref::<ExtensionClientInfo>()?),
            StructType::ExtensionEventTypeInfo => Some(from.as_any_ref().downcast_ref::<ExtensionEventTypeInfo>()?),
            StructType::ExtensionFaultTypeInfo => Some(from.as_any_ref().downcast_ref::<ExtensionFaultTypeInfo>()?),
            StructType::ExtensionHealthInfo => Some(from.as_any_ref().downcast_ref::<ExtensionHealthInfo>()?),
            StructType::ExtensionOvfConsumerInfo => Some(from.as_any_ref().downcast_ref::<ExtensionOvfConsumerInfo>()?),
            StructType::ExtensionPrivilegeInfo => Some(from.as_any_ref().downcast_ref::<ExtensionPrivilegeInfo>()?),
            StructType::ExtensionResourceInfo => Some(from.as_any_ref().downcast_ref::<ExtensionResourceInfo>()?),
            StructType::ExtensionServerInfo => Some(from.as_any_ref().downcast_ref::<ExtensionServerInfo>()?),
            StructType::ExtensionTaskTypeInfo => Some(from.as_any_ref().downcast_ref::<ExtensionTaskTypeInfo>()?),
            StructType::ExtensionManagerIpAllocationUsage => Some(from.as_any_ref().downcast_ref::<ExtensionManagerIpAllocationUsage>()?),
            StructType::FaultsByHost => Some(from.as_any_ref().downcast_ref::<FaultsByHost>()?),
            StructType::FaultsByVm => Some(from.as_any_ref().downcast_ref::<FaultsByVm>()?),
            StructType::FileLockInfo => Some(from.as_any_ref().downcast_ref::<FileLockInfo>()?),
            StructType::FileLockInfoResult => Some(from.as_any_ref().downcast_ref::<FileLockInfoResult>()?),
            StructType::FolderBatchAddHostsToClusterResult => Some(from.as_any_ref().downcast_ref::<FolderBatchAddHostsToClusterResult>()?),
            StructType::FolderBatchAddStandaloneHostsResult => Some(from.as_any_ref().downcast_ref::<FolderBatchAddStandaloneHostsResult>()?),
            StructType::FolderFailedHostResult => Some(from.as_any_ref().downcast_ref::<FolderFailedHostResult>()?),
            StructType::FolderNewHostSpec => Some(from.as_any_ref().downcast_ref::<FolderNewHostSpec>()?),
            StructType::HbrManagerReplicationVmInfo => Some(from.as_any_ref().downcast_ref::<HbrManagerReplicationVmInfo>()?),
            StructType::ReplicationVmProgressInfo => Some(from.as_any_ref().downcast_ref::<ReplicationVmProgressInfo>()?),
            StructType::HbrManagerVmReplicationCapability => Some(from.as_any_ref().downcast_ref::<HbrManagerVmReplicationCapability>()?),
            StructType::HealthUpdate => Some(from.as_any_ref().downcast_ref::<HealthUpdate>()?),
            StructType::HealthUpdateInfo => Some(from.as_any_ref().downcast_ref::<HealthUpdateInfo>()?),
            StructType::PerfInterval => Some(from.as_any_ref().downcast_ref::<PerfInterval>()?),
            StructType::HostServiceTicket => Some(from.as_any_ref().downcast_ref::<HostServiceTicket>()?),
            StructType::HostSystemComplianceCheckState => Some(from.as_any_ref().downcast_ref::<HostSystemComplianceCheckState>()?),
            StructType::HostSystemReconnectSpec => Some(from.as_any_ref().downcast_ref::<HostSystemReconnectSpec>()?),
            StructType::HostSystemRemediationState => Some(from.as_any_ref().downcast_ref::<HostSystemRemediationState>()?),
            StructType::HttpNfcLeaseCapabilities => Some(from.as_any_ref().downcast_ref::<HttpNfcLeaseCapabilities>()?),
            StructType::HttpNfcLeaseDatastoreLeaseInfo => Some(from.as_any_ref().downcast_ref::<HttpNfcLeaseDatastoreLeaseInfo>()?),
            StructType::HttpNfcLeaseDeviceUrl => Some(from.as_any_ref().downcast_ref::<HttpNfcLeaseDeviceUrl>()?),
            StructType::HttpNfcLeaseHostInfo => Some(from.as_any_ref().downcast_ref::<HttpNfcLeaseHostInfo>()?),
            StructType::HttpNfcLeaseInfo => Some(from.as_any_ref().downcast_ref::<HttpNfcLeaseInfo>()?),
            StructType::HttpNfcLeaseManifestEntry => Some(from.as_any_ref().downcast_ref::<HttpNfcLeaseManifestEntry>()?),
            StructType::HttpNfcLeaseProbeResult => Some(from.as_any_ref().downcast_ref::<HttpNfcLeaseProbeResult>()?),
            StructType::HttpNfcLeaseSourceFile => Some(from.as_any_ref().downcast_ref::<HttpNfcLeaseSourceFile>()?),
            StructType::ImportSpec => Some(from.as_any_ref().downcast_ref::<ImportSpec>()?),
            StructType::VirtualAppImportSpec => Some(from.as_any_ref().downcast_ref::<VirtualAppImportSpec>()?),
            StructType::VirtualMachineImportSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineImportSpec>()?),
            StructType::InheritablePolicy => Some(from.as_any_ref().downcast_ref::<InheritablePolicy>()?),
            StructType::BoolPolicy => Some(from.as_any_ref().downcast_ref::<BoolPolicy>()?),
            StructType::IntPolicy => Some(from.as_any_ref().downcast_ref::<IntPolicy>()?),
            StructType::LongPolicy => Some(from.as_any_ref().downcast_ref::<LongPolicy>()?),
            StructType::StringPolicy => Some(from.as_any_ref().downcast_ref::<StringPolicy>()?),
            StructType::DvsFilterConfig => Some(from.as_any_ref().downcast_ref::<DvsFilterConfig>()?),
            StructType::DvsFilterConfigSpec => Some(from.as_any_ref().downcast_ref::<DvsFilterConfigSpec>()?),
            StructType::DvsTrafficFilterConfig => Some(from.as_any_ref().downcast_ref::<DvsTrafficFilterConfig>()?),
            StructType::DvsTrafficFilterConfigSpec => Some(from.as_any_ref().downcast_ref::<DvsTrafficFilterConfigSpec>()?),
            StructType::DvsFilterPolicy => Some(from.as_any_ref().downcast_ref::<DvsFilterPolicy>()?),
            StructType::DvsTrafficShapingPolicy => Some(from.as_any_ref().downcast_ref::<DvsTrafficShapingPolicy>()?),
            StructType::DvsVendorSpecificConfig => Some(from.as_any_ref().downcast_ref::<DvsVendorSpecificConfig>()?),
            StructType::DvsFailureCriteria => Some(from.as_any_ref().downcast_ref::<DvsFailureCriteria>()?),
            StructType::DvsMacLearningPolicy => Some(from.as_any_ref().downcast_ref::<DvsMacLearningPolicy>()?),
            StructType::DvsMacManagementPolicy => Some(from.as_any_ref().downcast_ref::<DvsMacManagementPolicy>()?),
            StructType::DvsSecurityPolicy => Some(from.as_any_ref().downcast_ref::<DvsSecurityPolicy>()?),
            StructType::VMwareUplinkLacpPolicy => Some(from.as_any_ref().downcast_ref::<VMwareUplinkLacpPolicy>()?),
            StructType::VMwareUplinkPortOrderPolicy => Some(from.as_any_ref().downcast_ref::<VMwareUplinkPortOrderPolicy>()?),
            StructType::VmwareUplinkPortTeamingPolicy => Some(from.as_any_ref().downcast_ref::<VmwareUplinkPortTeamingPolicy>()?),
            StructType::VmwareDistributedVirtualSwitchVlanSpec => Some(from.as_any_ref().downcast_ref::<VmwareDistributedVirtualSwitchVlanSpec>()?),
            StructType::VmwareDistributedVirtualSwitchPvlanSpec => Some(from.as_any_ref().downcast_ref::<VmwareDistributedVirtualSwitchPvlanSpec>()?),
            StructType::VmwareDistributedVirtualSwitchTrunkVlanSpec => Some(from.as_any_ref().downcast_ref::<VmwareDistributedVirtualSwitchTrunkVlanSpec>()?),
            StructType::VmwareDistributedVirtualSwitchVlanIdSpec => Some(from.as_any_ref().downcast_ref::<VmwareDistributedVirtualSwitchVlanIdSpec>()?),
            StructType::IoFilterInfo => Some(from.as_any_ref().downcast_ref::<IoFilterInfo>()?),
            StructType::ClusterIoFilterInfo => Some(from.as_any_ref().downcast_ref::<ClusterIoFilterInfo>()?),
            StructType::HostIoFilterInfo => Some(from.as_any_ref().downcast_ref::<HostIoFilterInfo>()?),
            StructType::IoFilterQueryIssueResult => Some(from.as_any_ref().downcast_ref::<IoFilterQueryIssueResult>()?),
            StructType::IoFilterHostIssue => Some(from.as_any_ref().downcast_ref::<IoFilterHostIssue>()?),
            StructType::IpPoolManagerIpAllocation => Some(from.as_any_ref().downcast_ref::<IpPoolManagerIpAllocation>()?),
            StructType::KeyValue => Some(from.as_any_ref().downcast_ref::<KeyValue>()?),
            StructType::LatencySensitivity => Some(from.as_any_ref().downcast_ref::<LatencySensitivity>()?),
            StructType::LicenseAssignmentManagerLicenseAssignment => Some(from.as_any_ref().downcast_ref::<LicenseAssignmentManagerLicenseAssignment>()?),
            StructType::LicenseAvailabilityInfo => Some(from.as_any_ref().downcast_ref::<LicenseAvailabilityInfo>()?),
            StructType::LicenseDiagnostics => Some(from.as_any_ref().downcast_ref::<LicenseDiagnostics>()?),
            StructType::LicenseManagerEvaluationInfo => Some(from.as_any_ref().downcast_ref::<LicenseManagerEvaluationInfo>()?),
            StructType::LicenseFeatureInfo => Some(from.as_any_ref().downcast_ref::<LicenseFeatureInfo>()?),
            StructType::HostLicensableResourceInfo => Some(from.as_any_ref().downcast_ref::<HostLicensableResourceInfo>()?),
            StructType::LicenseManagerLicenseInfo => Some(from.as_any_ref().downcast_ref::<LicenseManagerLicenseInfo>()?),
            StructType::LicenseSource => Some(from.as_any_ref().downcast_ref::<LicenseSource>()?),
            StructType::EvaluationLicenseSource => Some(from.as_any_ref().downcast_ref::<EvaluationLicenseSource>()?),
            StructType::LicenseServerSource => Some(from.as_any_ref().downcast_ref::<LicenseServerSource>()?),
            StructType::LocalLicenseSource => Some(from.as_any_ref().downcast_ref::<LocalLicenseSource>()?),
            StructType::LicenseUsageInfo => Some(from.as_any_ref().downcast_ref::<LicenseUsageInfo>()?),
            StructType::LicenseReservationInfo => Some(from.as_any_ref().downcast_ref::<LicenseReservationInfo>()?),
            StructType::LocalizationManagerMessageCatalog => Some(from.as_any_ref().downcast_ref::<LocalizationManagerMessageCatalog>()?),
            StructType::NegatableExpression => Some(from.as_any_ref().downcast_ref::<NegatableExpression>()?),
            StructType::IntExpression => Some(from.as_any_ref().downcast_ref::<IntExpression>()?),
            StructType::IpAddress => Some(from.as_any_ref().downcast_ref::<IpAddress>()?),
            StructType::IpRange => Some(from.as_any_ref().downcast_ref::<IpRange>()?),
            StructType::SingleIp => Some(from.as_any_ref().downcast_ref::<SingleIp>()?),
            StructType::MacAddress => Some(from.as_any_ref().downcast_ref::<MacAddress>()?),
            StructType::MacRange => Some(from.as_any_ref().downcast_ref::<MacRange>()?),
            StructType::SingleMac => Some(from.as_any_ref().downcast_ref::<SingleMac>()?),
            StructType::StringExpression => Some(from.as_any_ref().downcast_ref::<StringExpression>()?),
            StructType::DvsIpPort => Some(from.as_any_ref().downcast_ref::<DvsIpPort>()?),
            StructType::DvsIpPortRange => Some(from.as_any_ref().downcast_ref::<DvsIpPortRange>()?),
            StructType::DvsSingleIpPort => Some(from.as_any_ref().downcast_ref::<DvsSingleIpPort>()?),
            StructType::NetworkSummary => Some(from.as_any_ref().downcast_ref::<NetworkSummary>()?),
            StructType::OpaqueNetworkSummary => Some(from.as_any_ref().downcast_ref::<OpaqueNetworkSummary>()?),
            StructType::NumericRange => Some(from.as_any_ref().downcast_ref::<NumericRange>()?),
            StructType::OpaqueNetworkCapability => Some(from.as_any_ref().downcast_ref::<OpaqueNetworkCapability>()?),
            StructType::OvfConsumerOstNode => Some(from.as_any_ref().downcast_ref::<OvfConsumerOstNode>()?),
            StructType::OvfConsumerOvfSection => Some(from.as_any_ref().downcast_ref::<OvfConsumerOvfSection>()?),
            StructType::OvfManagerCommonParams => Some(from.as_any_ref().downcast_ref::<OvfManagerCommonParams>()?),
            StructType::OvfCreateImportSpecParams => Some(from.as_any_ref().downcast_ref::<OvfCreateImportSpecParams>()?),
            StructType::OvfParseDescriptorParams => Some(from.as_any_ref().downcast_ref::<OvfParseDescriptorParams>()?),
            StructType::OvfValidateHostParams => Some(from.as_any_ref().downcast_ref::<OvfValidateHostParams>()?),
            StructType::OvfCreateDescriptorParams => Some(from.as_any_ref().downcast_ref::<OvfCreateDescriptorParams>()?),
            StructType::OvfCreateDescriptorResult => Some(from.as_any_ref().downcast_ref::<OvfCreateDescriptorResult>()?),
            StructType::OvfCreateImportSpecResult => Some(from.as_any_ref().downcast_ref::<OvfCreateImportSpecResult>()?),
            StructType::OvfDeploymentOption => Some(from.as_any_ref().downcast_ref::<OvfDeploymentOption>()?),
            StructType::OvfFileItem => Some(from.as_any_ref().downcast_ref::<OvfFileItem>()?),
            StructType::OvfNetworkInfo => Some(from.as_any_ref().downcast_ref::<OvfNetworkInfo>()?),
            StructType::OvfNetworkMapping => Some(from.as_any_ref().downcast_ref::<OvfNetworkMapping>()?),
            StructType::OvfFile => Some(from.as_any_ref().downcast_ref::<OvfFile>()?),
            StructType::OvfOptionInfo => Some(from.as_any_ref().downcast_ref::<OvfOptionInfo>()?),
            StructType::OvfParseDescriptorResult => Some(from.as_any_ref().downcast_ref::<OvfParseDescriptorResult>()?),
            StructType::OvfResourceMap => Some(from.as_any_ref().downcast_ref::<OvfResourceMap>()?),
            StructType::OvfValidateHostResult => Some(from.as_any_ref().downcast_ref::<OvfValidateHostResult>()?),
            StructType::PasswordField => Some(from.as_any_ref().downcast_ref::<PasswordField>()?),
            StructType::PerformanceDescription => Some(from.as_any_ref().downcast_ref::<PerformanceDescription>()?),
            StructType::PerfCompositeMetric => Some(from.as_any_ref().downcast_ref::<PerfCompositeMetric>()?),
            StructType::PerfCounterInfo => Some(from.as_any_ref().downcast_ref::<PerfCounterInfo>()?),
            StructType::PerformanceManagerCounterLevelMapping => Some(from.as_any_ref().downcast_ref::<PerformanceManagerCounterLevelMapping>()?),
            StructType::PerfEntityMetricBase => Some(from.as_any_ref().downcast_ref::<PerfEntityMetricBase>()?),
            StructType::PerfEntityMetric => Some(from.as_any_ref().downcast_ref::<PerfEntityMetric>()?),
            StructType::PerfEntityMetricCsv => Some(from.as_any_ref().downcast_ref::<PerfEntityMetricCsv>()?),
            StructType::PerfMetricId => Some(from.as_any_ref().downcast_ref::<PerfMetricId>()?),
            StructType::PerfMetricSeries => Some(from.as_any_ref().downcast_ref::<PerfMetricSeries>()?),
            StructType::PerfMetricIntSeries => Some(from.as_any_ref().downcast_ref::<PerfMetricIntSeries>()?),
            StructType::PerfMetricSeriesCsv => Some(from.as_any_ref().downcast_ref::<PerfMetricSeriesCsv>()?),
            StructType::PerfProviderSummary => Some(from.as_any_ref().downcast_ref::<PerfProviderSummary>()?),
            StructType::PerfQuerySpec => Some(from.as_any_ref().downcast_ref::<PerfQuerySpec>()?),
            StructType::PerfSampleInfo => Some(from.as_any_ref().downcast_ref::<PerfSampleInfo>()?),
            StructType::PrivilegePolicyDef => Some(from.as_any_ref().downcast_ref::<PrivilegePolicyDef>()?),
            StructType::ResourceAllocationInfo => Some(from.as_any_ref().downcast_ref::<ResourceAllocationInfo>()?),
            StructType::ResourceAllocationOption => Some(from.as_any_ref().downcast_ref::<ResourceAllocationOption>()?),
            StructType::ResourceConfigOption => Some(from.as_any_ref().downcast_ref::<ResourceConfigOption>()?),
            StructType::ResourceConfigSpec => Some(from.as_any_ref().downcast_ref::<ResourceConfigSpec>()?),
            StructType::DatabaseSizeEstimate => Some(from.as_any_ref().downcast_ref::<DatabaseSizeEstimate>()?),
            StructType::DatabaseSizeParam => Some(from.as_any_ref().downcast_ref::<DatabaseSizeParam>()?),
            StructType::InventoryDescription => Some(from.as_any_ref().downcast_ref::<InventoryDescription>()?),
            StructType::PerformanceStatisticsDescription => Some(from.as_any_ref().downcast_ref::<PerformanceStatisticsDescription>()?),
            StructType::ResourcePoolResourceUsage => Some(from.as_any_ref().downcast_ref::<ResourcePoolResourceUsage>()?),
            StructType::ResourcePoolRuntimeInfo => Some(from.as_any_ref().downcast_ref::<ResourcePoolRuntimeInfo>()?),
            StructType::ResourcePoolSummary => Some(from.as_any_ref().downcast_ref::<ResourcePoolSummary>()?),
            StructType::VirtualAppSummary => Some(from.as_any_ref().downcast_ref::<VirtualAppSummary>()?),
            StructType::ResourcePoolQuickStats => Some(from.as_any_ref().downcast_ref::<ResourcePoolQuickStats>()?),
            StructType::SddcBase => Some(from.as_any_ref().downcast_ref::<SddcBase>()?),
            StructType::SelectionSet => Some(from.as_any_ref().downcast_ref::<SelectionSet>()?),
            StructType::DvPortgroupSelection => Some(from.as_any_ref().downcast_ref::<DvPortgroupSelection>()?),
            StructType::DvsSelection => Some(from.as_any_ref().downcast_ref::<DvsSelection>()?),
            StructType::HostVMotionCompatibility => Some(from.as_any_ref().downcast_ref::<HostVMotionCompatibility>()?),
            StructType::ProductComponentInfo => Some(from.as_any_ref().downcast_ref::<ProductComponentInfo>()?),
            StructType::ServiceContent => Some(from.as_any_ref().downcast_ref::<ServiceContent>()?),
            StructType::ServiceLocator => Some(from.as_any_ref().downcast_ref::<ServiceLocator>()?),
            StructType::ServiceLocatorCredential => Some(from.as_any_ref().downcast_ref::<ServiceLocatorCredential>()?),
            StructType::ServiceLocatorNamePassword => Some(from.as_any_ref().downcast_ref::<ServiceLocatorNamePassword>()?),
            StructType::ServiceLocatorSamlCredential => Some(from.as_any_ref().downcast_ref::<ServiceLocatorSamlCredential>()?),
            StructType::ServiceManagerServiceInfo => Some(from.as_any_ref().downcast_ref::<ServiceManagerServiceInfo>()?),
            StructType::SessionManagerGenericServiceTicket => Some(from.as_any_ref().downcast_ref::<SessionManagerGenericServiceTicket>()?),
            StructType::SessionManagerLocalTicket => Some(from.as_any_ref().downcast_ref::<SessionManagerLocalTicket>()?),
            StructType::SessionManagerServiceRequestSpec => Some(from.as_any_ref().downcast_ref::<SessionManagerServiceRequestSpec>()?),
            StructType::SessionManagerHttpServiceRequestSpec => Some(from.as_any_ref().downcast_ref::<SessionManagerHttpServiceRequestSpec>()?),
            StructType::SessionManagerVmomiServiceRequestSpec => Some(from.as_any_ref().downcast_ref::<SessionManagerVmomiServiceRequestSpec>()?),
            StructType::SharesInfo => Some(from.as_any_ref().downcast_ref::<SharesInfo>()?),
            StructType::SharesOption => Some(from.as_any_ref().downcast_ref::<SharesOption>()?),
            StructType::SiteInfo => Some(from.as_any_ref().downcast_ref::<SiteInfo>()?),
            StructType::StoragePodSummary => Some(from.as_any_ref().downcast_ref::<StoragePodSummary>()?),
            StructType::StorageIoAllocationInfo => Some(from.as_any_ref().downcast_ref::<StorageIoAllocationInfo>()?),
            StructType::StorageIoAllocationOption => Some(from.as_any_ref().downcast_ref::<StorageIoAllocationOption>()?),
            StructType::StorageIormInfo => Some(from.as_any_ref().downcast_ref::<StorageIormInfo>()?),
            StructType::StorageIormConfigOption => Some(from.as_any_ref().downcast_ref::<StorageIormConfigOption>()?),
            StructType::StorageIormConfigSpec => Some(from.as_any_ref().downcast_ref::<StorageIormConfigSpec>()?),
            StructType::PodStorageDrsEntry => Some(from.as_any_ref().downcast_ref::<PodStorageDrsEntry>()?),
            StructType::StoragePerformanceSummary => Some(from.as_any_ref().downcast_ref::<StoragePerformanceSummary>()?),
            StructType::StorageResourceManagerStorageProfileStatistics => Some(from.as_any_ref().downcast_ref::<StorageResourceManagerStorageProfileStatistics>()?),
            StructType::Tag => Some(from.as_any_ref().downcast_ref::<Tag>()?),
            StructType::TaskDescription => Some(from.as_any_ref().downcast_ref::<TaskDescription>()?),
            StructType::TaskFilterSpec => Some(from.as_any_ref().downcast_ref::<TaskFilterSpec>()?),
            StructType::TaskFilterSpecByEntity => Some(from.as_any_ref().downcast_ref::<TaskFilterSpecByEntity>()?),
            StructType::TaskFilterSpecByTime => Some(from.as_any_ref().downcast_ref::<TaskFilterSpecByTime>()?),
            StructType::TaskFilterSpecByUsername => Some(from.as_any_ref().downcast_ref::<TaskFilterSpecByUsername>()?),
            StructType::TaskInfo => Some(from.as_any_ref().downcast_ref::<TaskInfo>()?),
            StructType::TaskReason => Some(from.as_any_ref().downcast_ref::<TaskReason>()?),
            StructType::TaskReasonAlarm => Some(from.as_any_ref().downcast_ref::<TaskReasonAlarm>()?),
            StructType::TaskReasonSchedule => Some(from.as_any_ref().downcast_ref::<TaskReasonSchedule>()?),
            StructType::TaskReasonSystem => Some(from.as_any_ref().downcast_ref::<TaskReasonSystem>()?),
            StructType::TaskReasonUser => Some(from.as_any_ref().downcast_ref::<TaskReasonUser>()?),
            StructType::UpdateVirtualMachineFilesResult => Some(from.as_any_ref().downcast_ref::<UpdateVirtualMachineFilesResult>()?),
            StructType::UpdateVirtualMachineFilesResultFailedVmFileInfo => Some(from.as_any_ref().downcast_ref::<UpdateVirtualMachineFilesResultFailedVmFileInfo>()?),
            StructType::UserSearchResult => Some(from.as_any_ref().downcast_ref::<UserSearchResult>()?),
            StructType::PosixUserSearchResult => Some(from.as_any_ref().downcast_ref::<PosixUserSearchResult>()?),
            StructType::UserSession => Some(from.as_any_ref().downcast_ref::<UserSession>()?),
            StructType::VVolVmConfigFileUpdateResult => Some(from.as_any_ref().downcast_ref::<VVolVmConfigFileUpdateResult>()?),
            StructType::VVolVmConfigFileUpdateResultFailedVmConfigFileInfo => Some(from.as_any_ref().downcast_ref::<VVolVmConfigFileUpdateResultFailedVmConfigFileInfo>()?),
            StructType::VasaStorageArray => Some(from.as_any_ref().downcast_ref::<VasaStorageArray>()?),
            StructType::VasaStorageArrayDiscoveryFcTransport => Some(from.as_any_ref().downcast_ref::<VasaStorageArrayDiscoveryFcTransport>()?),
            StructType::VasaStorageArrayDiscoveryIpTransport => Some(from.as_any_ref().downcast_ref::<VasaStorageArrayDiscoveryIpTransport>()?),
            StructType::VasaStorageArrayDiscoverySvcInfo => Some(from.as_any_ref().downcast_ref::<VasaStorageArrayDiscoverySvcInfo>()?),
            StructType::VasaProviderContainerSpec => Some(from.as_any_ref().downcast_ref::<VasaProviderContainerSpec>()?),
            StructType::VimVasaProvider => Some(from.as_any_ref().downcast_ref::<VimVasaProvider>()?),
            StructType::VimVasaProviderStatePerArray => Some(from.as_any_ref().downcast_ref::<VimVasaProviderStatePerArray>()?),
            StructType::VimVasaProviderVirtualHostConfig => Some(from.as_any_ref().downcast_ref::<VimVasaProviderVirtualHostConfig>()?),
            StructType::VimVasaProviderInfo => Some(from.as_any_ref().downcast_ref::<VimVasaProviderInfo>()?),
            StructType::VirtualAppLinkInfo => Some(from.as_any_ref().downcast_ref::<VirtualAppLinkInfo>()?),
            StructType::VirtualDiskSpec => Some(from.as_any_ref().downcast_ref::<VirtualDiskSpec>()?),
            StructType::DeviceBackedVirtualDiskSpec => Some(from.as_any_ref().downcast_ref::<DeviceBackedVirtualDiskSpec>()?),
            StructType::FileBackedVirtualDiskSpec => Some(from.as_any_ref().downcast_ref::<FileBackedVirtualDiskSpec>()?),
            StructType::SeSparseVirtualDiskSpec => Some(from.as_any_ref().downcast_ref::<SeSparseVirtualDiskSpec>()?),
            StructType::VirtualMachineConnection => Some(from.as_any_ref().downcast_ref::<VirtualMachineConnection>()?),
            StructType::VirtualMachineMksConnection => Some(from.as_any_ref().downcast_ref::<VirtualMachineMksConnection>()?),
            StructType::DiskChangeInfo => Some(from.as_any_ref().downcast_ref::<DiskChangeInfo>()?),
            StructType::DiskChangeExtent => Some(from.as_any_ref().downcast_ref::<DiskChangeExtent>()?),
            StructType::VirtualMachineDisplayTopology => Some(from.as_any_ref().downcast_ref::<VirtualMachineDisplayTopology>()?),
            StructType::VirtualMachineMksTicket => Some(from.as_any_ref().downcast_ref::<VirtualMachineMksTicket>()?),
            StructType::StorageRequirement => Some(from.as_any_ref().downcast_ref::<StorageRequirement>()?),
            StructType::VirtualMachineTicket => Some(from.as_any_ref().downcast_ref::<VirtualMachineTicket>()?),
            StructType::VirtualMachineWipeResult => Some(from.as_any_ref().downcast_ref::<VirtualMachineWipeResult>()?),
            StructType::VsanUpgradeSystemNetworkPartitionInfo => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemNetworkPartitionInfo>()?),
            StructType::VsanUpgradeSystemPreflightCheckIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemPreflightCheckIssue>()?),
            StructType::VsanUpgradeSystemApiBrokenIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemApiBrokenIssue>()?),
            StructType::VsanUpgradeSystemAutoClaimEnabledOnHostsIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemAutoClaimEnabledOnHostsIssue>()?),
            StructType::VsanUpgradeSystemHostsDisconnectedIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemHostsDisconnectedIssue>()?),
            StructType::VsanUpgradeSystemMissingHostsInClusterIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemMissingHostsInClusterIssue>()?),
            StructType::VsanUpgradeSystemNetworkPartitionIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemNetworkPartitionIssue>()?),
            StructType::VsanUpgradeSystemNotEnoughFreeCapacityIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemNotEnoughFreeCapacityIssue>()?),
            StructType::VsanUpgradeSystemRogueHostsInClusterIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemRogueHostsInClusterIssue>()?),
            StructType::VsanUpgradeSystemV2ObjectsPresentDuringDowngradeIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemV2ObjectsPresentDuringDowngradeIssue>()?),
            StructType::VsanUpgradeSystemWrongEsxVersionIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemWrongEsxVersionIssue>()?),
            StructType::VsanUpgradeSystemPreflightCheckResult => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemPreflightCheckResult>()?),
            StructType::VsanUpgradeSystemUpgradeHistoryItem => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemUpgradeHistoryItem>()?),
            StructType::VsanUpgradeSystemUpgradeHistoryDiskGroupOp => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemUpgradeHistoryDiskGroupOp>()?),
            StructType::VsanUpgradeSystemUpgradeHistoryPreflightFail => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemUpgradeHistoryPreflightFail>()?),
            StructType::VsanUpgradeSystemUpgradeStatus => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemUpgradeStatus>()?),
            StructType::Action => Some(from.as_any_ref().downcast_ref::<Action>()?),
            StructType::CreateTaskAction => Some(from.as_any_ref().downcast_ref::<CreateTaskAction>()?),
            StructType::MethodAction => Some(from.as_any_ref().downcast_ref::<MethodAction>()?),
            StructType::RunScriptAction => Some(from.as_any_ref().downcast_ref::<RunScriptAction>()?),
            StructType::SendEmailAction => Some(from.as_any_ref().downcast_ref::<SendEmailAction>()?),
            StructType::SendSnmpAction => Some(from.as_any_ref().downcast_ref::<SendSnmpAction>()?),
            StructType::MethodActionArgument => Some(from.as_any_ref().downcast_ref::<MethodActionArgument>()?),
            StructType::AlarmAction => Some(from.as_any_ref().downcast_ref::<AlarmAction>()?),
            StructType::AlarmTriggeringAction => Some(from.as_any_ref().downcast_ref::<AlarmTriggeringAction>()?),
            StructType::GroupAlarmAction => Some(from.as_any_ref().downcast_ref::<GroupAlarmAction>()?),
            StructType::AlarmDescription => Some(from.as_any_ref().downcast_ref::<AlarmDescription>()?),
            StructType::AlarmExpression => Some(from.as_any_ref().downcast_ref::<AlarmExpression>()?),
            StructType::AndAlarmExpression => Some(from.as_any_ref().downcast_ref::<AndAlarmExpression>()?),
            StructType::EventAlarmExpression => Some(from.as_any_ref().downcast_ref::<EventAlarmExpression>()?),
            StructType::MetricAlarmExpression => Some(from.as_any_ref().downcast_ref::<MetricAlarmExpression>()?),
            StructType::OrAlarmExpression => Some(from.as_any_ref().downcast_ref::<OrAlarmExpression>()?),
            StructType::StateAlarmExpression => Some(from.as_any_ref().downcast_ref::<StateAlarmExpression>()?),
            StructType::AlarmFilterSpec => Some(from.as_any_ref().downcast_ref::<AlarmFilterSpec>()?),
            StructType::AlarmSetting => Some(from.as_any_ref().downcast_ref::<AlarmSetting>()?),
            StructType::AlarmSpec => Some(from.as_any_ref().downcast_ref::<AlarmSpec>()?),
            StructType::AlarmInfo => Some(from.as_any_ref().downcast_ref::<AlarmInfo>()?),
            StructType::AlarmState => Some(from.as_any_ref().downcast_ref::<AlarmState>()?),
            StructType::AlarmTriggeringActionTransitionSpec => Some(from.as_any_ref().downcast_ref::<AlarmTriggeringActionTransitionSpec>()?),
            StructType::EventAlarmExpressionComparison => Some(from.as_any_ref().downcast_ref::<EventAlarmExpressionComparison>()?),
            StructType::ClusterAction => Some(from.as_any_ref().downcast_ref::<ClusterAction>()?),
            StructType::ClusterClusterInitialPlacementAction => Some(from.as_any_ref().downcast_ref::<ClusterClusterInitialPlacementAction>()?),
            StructType::ClusterHostInfraUpdateHaModeAction => Some(from.as_any_ref().downcast_ref::<ClusterHostInfraUpdateHaModeAction>()?),
            StructType::ClusterHostPowerAction => Some(from.as_any_ref().downcast_ref::<ClusterHostPowerAction>()?),
            StructType::ClusterInitialPlacementAction => Some(from.as_any_ref().downcast_ref::<ClusterInitialPlacementAction>()?),
            StructType::ClusterMigrationAction => Some(from.as_any_ref().downcast_ref::<ClusterMigrationAction>()?),
            StructType::PlacementAction => Some(from.as_any_ref().downcast_ref::<PlacementAction>()?),
            StructType::HbrDiskMigrationAction => Some(from.as_any_ref().downcast_ref::<HbrDiskMigrationAction>()?),
            StructType::StorageMigrationAction => Some(from.as_any_ref().downcast_ref::<StorageMigrationAction>()?),
            StructType::StoragePlacementAction => Some(from.as_any_ref().downcast_ref::<StoragePlacementAction>()?),
            StructType::ClusterActionHistory => Some(from.as_any_ref().downcast_ref::<ClusterActionHistory>()?),
            StructType::ClusterAttemptedVmInfo => Some(from.as_any_ref().downcast_ref::<ClusterAttemptedVmInfo>()?),
            StructType::ClusterConfigInfo => Some(from.as_any_ref().downcast_ref::<ClusterConfigInfo>()?),
            StructType::ClusterConfigSpec => Some(from.as_any_ref().downcast_ref::<ClusterConfigSpec>()?),
            StructType::ClusterCryptoConfigInfo => Some(from.as_any_ref().downcast_ref::<ClusterCryptoConfigInfo>()?),
            StructType::ClusterDasAamNodeState => Some(from.as_any_ref().downcast_ref::<ClusterDasAamNodeState>()?),
            StructType::ClusterDasAdmissionControlInfo => Some(from.as_any_ref().downcast_ref::<ClusterDasAdmissionControlInfo>()?),
            StructType::ClusterFailoverHostAdmissionControlInfo => Some(from.as_any_ref().downcast_ref::<ClusterFailoverHostAdmissionControlInfo>()?),
            StructType::ClusterFailoverLevelAdmissionControlInfo => Some(from.as_any_ref().downcast_ref::<ClusterFailoverLevelAdmissionControlInfo>()?),
            StructType::ClusterFailoverResourcesAdmissionControlInfo => Some(from.as_any_ref().downcast_ref::<ClusterFailoverResourcesAdmissionControlInfo>()?),
            StructType::ClusterDasAdmissionControlPolicy => Some(from.as_any_ref().downcast_ref::<ClusterDasAdmissionControlPolicy>()?),
            StructType::ClusterFailoverHostAdmissionControlPolicy => Some(from.as_any_ref().downcast_ref::<ClusterFailoverHostAdmissionControlPolicy>()?),
            StructType::ClusterFailoverLevelAdmissionControlPolicy => Some(from.as_any_ref().downcast_ref::<ClusterFailoverLevelAdmissionControlPolicy>()?),
            StructType::ClusterFailoverResourcesAdmissionControlPolicy => Some(from.as_any_ref().downcast_ref::<ClusterFailoverResourcesAdmissionControlPolicy>()?),
            StructType::ClusterDasAdvancedRuntimeInfo => Some(from.as_any_ref().downcast_ref::<ClusterDasAdvancedRuntimeInfo>()?),
            StructType::ClusterDasFailoverLevelAdvancedRuntimeInfo => Some(from.as_any_ref().downcast_ref::<ClusterDasFailoverLevelAdvancedRuntimeInfo>()?),
            StructType::DasHeartbeatDatastoreInfo => Some(from.as_any_ref().downcast_ref::<DasHeartbeatDatastoreInfo>()?),
            StructType::ClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo => Some(from.as_any_ref().downcast_ref::<ClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo>()?),
            StructType::ClusterDasConfigInfo => Some(from.as_any_ref().downcast_ref::<ClusterDasConfigInfo>()?),
            StructType::ClusterDasData => Some(from.as_any_ref().downcast_ref::<ClusterDasData>()?),
            StructType::ClusterDasDataSummary => Some(from.as_any_ref().downcast_ref::<ClusterDasDataSummary>()?),
            StructType::ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots => Some(from.as_any_ref().downcast_ref::<ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots>()?),
            StructType::ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo => Some(from.as_any_ref().downcast_ref::<ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo>()?),
            StructType::ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots => Some(from.as_any_ref().downcast_ref::<ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots>()?),
            StructType::ClusterDasFdmHostState => Some(from.as_any_ref().downcast_ref::<ClusterDasFdmHostState>()?),
            StructType::ClusterDasHostInfo => Some(from.as_any_ref().downcast_ref::<ClusterDasHostInfo>()?),
            StructType::ClusterDasAamHostInfo => Some(from.as_any_ref().downcast_ref::<ClusterDasAamHostInfo>()?),
            StructType::ClusterDasHostRecommendation => Some(from.as_any_ref().downcast_ref::<ClusterDasHostRecommendation>()?),
            StructType::ClusterDasVmConfigInfo => Some(from.as_any_ref().downcast_ref::<ClusterDasVmConfigInfo>()?),
            StructType::ClusterDasVmSettings => Some(from.as_any_ref().downcast_ref::<ClusterDasVmSettings>()?),
            StructType::ClusterDpmConfigInfo => Some(from.as_any_ref().downcast_ref::<ClusterDpmConfigInfo>()?),
            StructType::ClusterDpmHostConfigInfo => Some(from.as_any_ref().downcast_ref::<ClusterDpmHostConfigInfo>()?),
            StructType::ClusterDrsConfigInfo => Some(from.as_any_ref().downcast_ref::<ClusterDrsConfigInfo>()?),
            StructType::ClusterDrsFaults => Some(from.as_any_ref().downcast_ref::<ClusterDrsFaults>()?),
            StructType::ClusterDrsFaultsFaultsByVm => Some(from.as_any_ref().downcast_ref::<ClusterDrsFaultsFaultsByVm>()?),
            StructType::ClusterDrsFaultsFaultsByVirtualDisk => Some(from.as_any_ref().downcast_ref::<ClusterDrsFaultsFaultsByVirtualDisk>()?),
            StructType::ClusterDrsMigration => Some(from.as_any_ref().downcast_ref::<ClusterDrsMigration>()?),
            StructType::ClusterDrsRecommendation => Some(from.as_any_ref().downcast_ref::<ClusterDrsRecommendation>()?),
            StructType::ClusterDrsVmConfigInfo => Some(from.as_any_ref().downcast_ref::<ClusterDrsVmConfigInfo>()?),
            StructType::ClusterEvcManagerCheckResult => Some(from.as_any_ref().downcast_ref::<ClusterEvcManagerCheckResult>()?),
            StructType::ClusterEvcManagerEvcState => Some(from.as_any_ref().downcast_ref::<ClusterEvcManagerEvcState>()?),
            StructType::ClusterEnterMaintenanceResult => Some(from.as_any_ref().downcast_ref::<ClusterEnterMaintenanceResult>()?),
            StructType::ClusterFailoverHostAdmissionControlInfoHostStatus => Some(from.as_any_ref().downcast_ref::<ClusterFailoverHostAdmissionControlInfoHostStatus>()?),
            StructType::ClusterGroupInfo => Some(from.as_any_ref().downcast_ref::<ClusterGroupInfo>()?),
            StructType::ClusterHostGroup => Some(from.as_any_ref().downcast_ref::<ClusterHostGroup>()?),
            StructType::ClusterVmGroup => Some(from.as_any_ref().downcast_ref::<ClusterVmGroup>()?),
            StructType::ClusterHostRecommendation => Some(from.as_any_ref().downcast_ref::<ClusterHostRecommendation>()?),
            StructType::ClusterInfraUpdateHaConfigInfo => Some(from.as_any_ref().downcast_ref::<ClusterInfraUpdateHaConfigInfo>()?),
            StructType::ClusterNotAttemptedVmInfo => Some(from.as_any_ref().downcast_ref::<ClusterNotAttemptedVmInfo>()?),
            StructType::ClusterOrchestrationInfo => Some(from.as_any_ref().downcast_ref::<ClusterOrchestrationInfo>()?),
            StructType::PlacementResult => Some(from.as_any_ref().downcast_ref::<PlacementResult>()?),
            StructType::PlacementSpec => Some(from.as_any_ref().downcast_ref::<PlacementSpec>()?),
            StructType::ClusterPowerOnVmResult => Some(from.as_any_ref().downcast_ref::<ClusterPowerOnVmResult>()?),
            StructType::ClusterPreemptibleVmPairInfo => Some(from.as_any_ref().downcast_ref::<ClusterPreemptibleVmPairInfo>()?),
            StructType::ClusterProactiveDrsConfigInfo => Some(from.as_any_ref().downcast_ref::<ClusterProactiveDrsConfigInfo>()?),
            StructType::ClusterRecommendation => Some(from.as_any_ref().downcast_ref::<ClusterRecommendation>()?),
            StructType::ClusterResourceUsageSummary => Some(from.as_any_ref().downcast_ref::<ClusterResourceUsageSummary>()?),
            StructType::ClusterRuleInfo => Some(from.as_any_ref().downcast_ref::<ClusterRuleInfo>()?),
            StructType::ClusterAffinityRuleSpec => Some(from.as_any_ref().downcast_ref::<ClusterAffinityRuleSpec>()?),
            StructType::ClusterAntiAffinityRuleSpec => Some(from.as_any_ref().downcast_ref::<ClusterAntiAffinityRuleSpec>()?),
            StructType::ClusterDependencyRuleInfo => Some(from.as_any_ref().downcast_ref::<ClusterDependencyRuleInfo>()?),
            StructType::ClusterVmHostRuleInfo => Some(from.as_any_ref().downcast_ref::<ClusterVmHostRuleInfo>()?),
            StructType::VirtualDiskAntiAffinityRuleSpec => Some(from.as_any_ref().downcast_ref::<VirtualDiskAntiAffinityRuleSpec>()?),
            StructType::VirtualDiskRuleSpec => Some(from.as_any_ref().downcast_ref::<VirtualDiskRuleSpec>()?),
            StructType::ClusterSlotPolicy => Some(from.as_any_ref().downcast_ref::<ClusterSlotPolicy>()?),
            StructType::ClusterFixedSizeSlotPolicy => Some(from.as_any_ref().downcast_ref::<ClusterFixedSizeSlotPolicy>()?),
            StructType::ClusterSystemVMsConfigInfo => Some(from.as_any_ref().downcast_ref::<ClusterSystemVMsConfigInfo>()?),
            StructType::ClusterSystemVMsConfigSpec => Some(from.as_any_ref().downcast_ref::<ClusterSystemVMsConfigSpec>()?),
            StructType::ClusterUsageSummary => Some(from.as_any_ref().downcast_ref::<ClusterUsageSummary>()?),
            StructType::ClusterVmComponentProtectionSettings => Some(from.as_any_ref().downcast_ref::<ClusterVmComponentProtectionSettings>()?),
            StructType::ClusterVmOrchestrationInfo => Some(from.as_any_ref().downcast_ref::<ClusterVmOrchestrationInfo>()?),
            StructType::ClusterVmReadiness => Some(from.as_any_ref().downcast_ref::<ClusterVmReadiness>()?),
            StructType::ClusterVmToolsMonitoringSettings => Some(from.as_any_ref().downcast_ref::<ClusterVmToolsMonitoringSettings>()?),
            StructType::DistributedVirtualPort => Some(from.as_any_ref().downcast_ref::<DistributedVirtualPort>()?),
            StructType::DvPortConfigInfo => Some(from.as_any_ref().downcast_ref::<DvPortConfigInfo>()?),
            StructType::DvPortConfigSpec => Some(from.as_any_ref().downcast_ref::<DvPortConfigSpec>()?),
            StructType::DvsFilterParameter => Some(from.as_any_ref().downcast_ref::<DvsFilterParameter>()?),
            StructType::DvsHostLocalPortInfo => Some(from.as_any_ref().downcast_ref::<DvsHostLocalPortInfo>()?),
            StructType::DvPortStatus => Some(from.as_any_ref().downcast_ref::<DvPortStatus>()?),
            StructType::DvPortSetting => Some(from.as_any_ref().downcast_ref::<DvPortSetting>()?),
            StructType::VMwareDvsPortSetting => Some(from.as_any_ref().downcast_ref::<VMwareDvsPortSetting>()?),
            StructType::DvPortState => Some(from.as_any_ref().downcast_ref::<DvPortState>()?),
            StructType::DvPortgroupConfigInfo => Some(from.as_any_ref().downcast_ref::<DvPortgroupConfigInfo>()?),
            StructType::DvPortgroupConfigSpec => Some(from.as_any_ref().downcast_ref::<DvPortgroupConfigSpec>()?),
            StructType::DistributedVirtualPortgroupNsxPortgroupOperationResult => Some(from.as_any_ref().downcast_ref::<DistributedVirtualPortgroupNsxPortgroupOperationResult>()?),
            StructType::DvPortgroupPolicy => Some(from.as_any_ref().downcast_ref::<DvPortgroupPolicy>()?),
            StructType::VMwareDvsPortgroupPolicy => Some(from.as_any_ref().downcast_ref::<VMwareDvsPortgroupPolicy>()?),
            StructType::DistributedVirtualPortgroupProblem => Some(from.as_any_ref().downcast_ref::<DistributedVirtualPortgroupProblem>()?),
            StructType::DistributedVirtualPortgroupInfo => Some(from.as_any_ref().downcast_ref::<DistributedVirtualPortgroupInfo>()?),
            StructType::DistributedVirtualSwitchInfo => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchInfo>()?),
            StructType::DistributedVirtualSwitchManagerCompatibilityResult => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchManagerCompatibilityResult>()?),
            StructType::DvsManagerDvsConfigTarget => Some(from.as_any_ref().downcast_ref::<DvsManagerDvsConfigTarget>()?),
            StructType::DistributedVirtualSwitchManagerDvsProductSpec => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchManagerDvsProductSpec>()?),
            StructType::DistributedVirtualSwitchManagerHostContainer => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchManagerHostContainer>()?),
            StructType::DistributedVirtualSwitchManagerHostDvsFilterSpec => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchManagerHostDvsFilterSpec>()?),
            StructType::DistributedVirtualSwitchManagerHostArrayFilter => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchManagerHostArrayFilter>()?),
            StructType::DistributedVirtualSwitchManagerHostContainerFilter => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchManagerHostContainerFilter>()?),
            StructType::DistributedVirtualSwitchManagerHostDvsMembershipFilter => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchManagerHostDvsMembershipFilter>()?),
            StructType::DistributedVirtualSwitchManagerImportResult => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchManagerImportResult>()?),
            StructType::DvsManagerPhysicalNicsList => Some(from.as_any_ref().downcast_ref::<DvsManagerPhysicalNicsList>()?),
            StructType::EntityBackup => Some(from.as_any_ref().downcast_ref::<EntityBackup>()?),
            StructType::EntityBackupConfig => Some(from.as_any_ref().downcast_ref::<EntityBackupConfig>()?),
            StructType::DistributedVirtualSwitchHostMember => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchHostMember>()?),
            StructType::DistributedVirtualSwitchHostMemberBacking => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchHostMemberBacking>()?),
            StructType::DistributedVirtualSwitchHostMemberPnicBacking => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchHostMemberPnicBacking>()?),
            StructType::DistributedVirtualSwitchHostMemberConfigInfo => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchHostMemberConfigInfo>()?),
            StructType::DistributedVirtualSwitchHostMemberConfigSpec => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchHostMemberConfigSpec>()?),
            StructType::HostMemberHealthCheckResult => Some(from.as_any_ref().downcast_ref::<HostMemberHealthCheckResult>()?),
            StructType::HostMemberUplinkHealthCheckResult => Some(from.as_any_ref().downcast_ref::<HostMemberUplinkHealthCheckResult>()?),
            StructType::VMwareDvsMtuHealthCheckResult => Some(from.as_any_ref().downcast_ref::<VMwareDvsMtuHealthCheckResult>()?),
            StructType::VMwareDvsVlanHealthCheckResult => Some(from.as_any_ref().downcast_ref::<VMwareDvsVlanHealthCheckResult>()?),
            StructType::VMwareDvsTeamingHealthCheckResult => Some(from.as_any_ref().downcast_ref::<VMwareDvsTeamingHealthCheckResult>()?),
            StructType::DistributedVirtualSwitchHostMemberPnicSpec => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchHostMemberPnicSpec>()?),
            StructType::HostMemberRuntimeInfo => Some(from.as_any_ref().downcast_ref::<HostMemberRuntimeInfo>()?),
            StructType::DistributedVirtualSwitchHostMemberRuntimeState => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchHostMemberRuntimeState>()?),
            StructType::DistributedVirtualSwitchHostMemberTransportZoneInfo => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchHostMemberTransportZoneInfo>()?),
            StructType::DistributedVirtualSwitchHostProductSpec => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchHostProductSpec>()?),
            StructType::DistributedVirtualSwitchKeyedOpaqueBlob => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchKeyedOpaqueBlob>()?),
            StructType::DistributedVirtualSwitchNetworkOffloadSpec => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchNetworkOffloadSpec>()?),
            StructType::DvsNetworkResourcePool => Some(from.as_any_ref().downcast_ref::<DvsNetworkResourcePool>()?),
            StructType::DvsNetworkResourcePoolAllocationInfo => Some(from.as_any_ref().downcast_ref::<DvsNetworkResourcePoolAllocationInfo>()?),
            StructType::DvsNetworkResourcePoolConfigSpec => Some(from.as_any_ref().downcast_ref::<DvsNetworkResourcePoolConfigSpec>()?),
            StructType::DistributedVirtualSwitchPortConnectee => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchPortConnectee>()?),
            StructType::DistributedVirtualSwitchPortConnection => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchPortConnection>()?),
            StructType::DistributedVirtualSwitchPortCriteria => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchPortCriteria>()?),
            StructType::DistributedVirtualSwitchPortStatistics => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchPortStatistics>()?),
            StructType::DistributedVirtualSwitchProductSpec => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchProductSpec>()?),
            StructType::DvsTrafficRule => Some(from.as_any_ref().downcast_ref::<DvsTrafficRule>()?),
            StructType::DvsNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsNetworkRuleAction>()?),
            StructType::DvsAcceptNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsAcceptNetworkRuleAction>()?),
            StructType::DvsCopyNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsCopyNetworkRuleAction>()?),
            StructType::DvsDropNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsDropNetworkRuleAction>()?),
            StructType::DvsGreEncapNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsGreEncapNetworkRuleAction>()?),
            StructType::DvsLogNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsLogNetworkRuleAction>()?),
            StructType::DvsMacRewriteNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsMacRewriteNetworkRuleAction>()?),
            StructType::DvsPuntNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsPuntNetworkRuleAction>()?),
            StructType::DvsRateLimitNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsRateLimitNetworkRuleAction>()?),
            StructType::DvsUpdateTagNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsUpdateTagNetworkRuleAction>()?),
            StructType::DvsNetworkRuleQualifier => Some(from.as_any_ref().downcast_ref::<DvsNetworkRuleQualifier>()?),
            StructType::DvsIpNetworkRuleQualifier => Some(from.as_any_ref().downcast_ref::<DvsIpNetworkRuleQualifier>()?),
            StructType::DvsMacNetworkRuleQualifier => Some(from.as_any_ref().downcast_ref::<DvsMacNetworkRuleQualifier>()?),
            StructType::DvsSystemTrafficNetworkRuleQualifier => Some(from.as_any_ref().downcast_ref::<DvsSystemTrafficNetworkRuleQualifier>()?),
            StructType::DvsTrafficRuleset => Some(from.as_any_ref().downcast_ref::<DvsTrafficRuleset>()?),
            StructType::DvsVmVnicNetworkResourcePool => Some(from.as_any_ref().downcast_ref::<DvsVmVnicNetworkResourcePool>()?),
            StructType::DvsVmVnicResourcePoolConfigSpec => Some(from.as_any_ref().downcast_ref::<DvsVmVnicResourcePoolConfigSpec>()?),
            StructType::DvsVmVnicResourceAllocation => Some(from.as_any_ref().downcast_ref::<DvsVmVnicResourceAllocation>()?),
            StructType::DvsVmVnicNetworkResourcePoolRuntimeInfo => Some(from.as_any_ref().downcast_ref::<DvsVmVnicNetworkResourcePoolRuntimeInfo>()?),
            StructType::DvsVnicAllocatedResource => Some(from.as_any_ref().downcast_ref::<DvsVnicAllocatedResource>()?),
            StructType::VMwareDvsDpuCapability => Some(from.as_any_ref().downcast_ref::<VMwareDvsDpuCapability>()?),
            StructType::VMwareIpfixConfig => Some(from.as_any_ref().downcast_ref::<VMwareIpfixConfig>()?),
            StructType::VMwareDvsIpfixCapability => Some(from.as_any_ref().downcast_ref::<VMwareDvsIpfixCapability>()?),
            StructType::VMwareDvsLacpCapability => Some(from.as_any_ref().downcast_ref::<VMwareDvsLacpCapability>()?),
            StructType::VMwareDvsLacpGroupConfig => Some(from.as_any_ref().downcast_ref::<VMwareDvsLacpGroupConfig>()?),
            StructType::VMwareDvsLacpGroupSpec => Some(from.as_any_ref().downcast_ref::<VMwareDvsLacpGroupSpec>()?),
            StructType::VMwareDvsLagIpfixConfig => Some(from.as_any_ref().downcast_ref::<VMwareDvsLagIpfixConfig>()?),
            StructType::VMwareDvsLagVlanConfig => Some(from.as_any_ref().downcast_ref::<VMwareDvsLagVlanConfig>()?),
            StructType::VMwareDvsMtuCapability => Some(from.as_any_ref().downcast_ref::<VMwareDvsMtuCapability>()?),
            StructType::VMwareDvsPvlanConfigSpec => Some(from.as_any_ref().downcast_ref::<VMwareDvsPvlanConfigSpec>()?),
            StructType::VMwareDvsPvlanMapEntry => Some(from.as_any_ref().downcast_ref::<VMwareDvsPvlanMapEntry>()?),
            StructType::VMwareDvsVspanConfigSpec => Some(from.as_any_ref().downcast_ref::<VMwareDvsVspanConfigSpec>()?),
            StructType::VMwareDvsVspanCapability => Some(from.as_any_ref().downcast_ref::<VMwareDvsVspanCapability>()?),
            StructType::VMwareVspanPort => Some(from.as_any_ref().downcast_ref::<VMwareVspanPort>()?),
            StructType::VMwareVspanSession => Some(from.as_any_ref().downcast_ref::<VMwareVspanSession>()?),
            StructType::CryptoKeyId => Some(from.as_any_ref().downcast_ref::<CryptoKeyId>()?),
            StructType::CryptoKeyPlain => Some(from.as_any_ref().downcast_ref::<CryptoKeyPlain>()?),
            StructType::CryptoKeyResult => Some(from.as_any_ref().downcast_ref::<CryptoKeyResult>()?),
            StructType::CryptoManagerHostKeyStatus => Some(from.as_any_ref().downcast_ref::<CryptoManagerHostKeyStatus>()?),
            StructType::CryptoManagerKmipCertSignRequest => Some(from.as_any_ref().downcast_ref::<CryptoManagerKmipCertSignRequest>()?),
            StructType::CryptoManagerKmipCertificateInfo => Some(from.as_any_ref().downcast_ref::<CryptoManagerKmipCertificateInfo>()?),
            StructType::CryptoManagerKmipClusterStatus => Some(from.as_any_ref().downcast_ref::<CryptoManagerKmipClusterStatus>()?),
            StructType::CryptoManagerKmipCryptoKeyStatus => Some(from.as_any_ref().downcast_ref::<CryptoManagerKmipCryptoKeyStatus>()?),
            StructType::CryptoManagerKmipCustomAttributeSpec => Some(from.as_any_ref().downcast_ref::<CryptoManagerKmipCustomAttributeSpec>()?),
            StructType::CryptoManagerKmipServerCertInfo => Some(from.as_any_ref().downcast_ref::<CryptoManagerKmipServerCertInfo>()?),
            StructType::CryptoManagerKmipServerStatus => Some(from.as_any_ref().downcast_ref::<CryptoManagerKmipServerStatus>()?),
            StructType::CryptoSpec => Some(from.as_any_ref().downcast_ref::<CryptoSpec>()?),
            StructType::CryptoSpecDecrypt => Some(from.as_any_ref().downcast_ref::<CryptoSpecDecrypt>()?),
            StructType::CryptoSpecDeepRecrypt => Some(from.as_any_ref().downcast_ref::<CryptoSpecDeepRecrypt>()?),
            StructType::CryptoSpecEncrypt => Some(from.as_any_ref().downcast_ref::<CryptoSpecEncrypt>()?),
            StructType::CryptoSpecNoOp => Some(from.as_any_ref().downcast_ref::<CryptoSpecNoOp>()?),
            StructType::CryptoSpecRegister => Some(from.as_any_ref().downcast_ref::<CryptoSpecRegister>()?),
            StructType::CryptoSpecShallowRecrypt => Some(from.as_any_ref().downcast_ref::<CryptoSpecShallowRecrypt>()?),
            StructType::KeyProviderId => Some(from.as_any_ref().downcast_ref::<KeyProviderId>()?),
            StructType::KmipClusterInfo => Some(from.as_any_ref().downcast_ref::<KmipClusterInfo>()?),
            StructType::KmipServerInfo => Some(from.as_any_ref().downcast_ref::<KmipServerInfo>()?),
            StructType::KmipServerSpec => Some(from.as_any_ref().downcast_ref::<KmipServerSpec>()?),
            StructType::KmipServerStatus => Some(from.as_any_ref().downcast_ref::<KmipServerStatus>()?),
            StructType::ChangesInfoEventArgument => Some(from.as_any_ref().downcast_ref::<ChangesInfoEventArgument>()?),
            StructType::DvsOutOfSyncHostArgument => Some(from.as_any_ref().downcast_ref::<DvsOutOfSyncHostArgument>()?),
            StructType::Event => Some(from.as_any_ref().downcast_ref::<Event>()?),
            StructType::AlarmEvent => Some(from.as_any_ref().downcast_ref::<AlarmEvent>()?),
            StructType::AlarmAcknowledgedEvent => Some(from.as_any_ref().downcast_ref::<AlarmAcknowledgedEvent>()?),
            StructType::AlarmActionTriggeredEvent => Some(from.as_any_ref().downcast_ref::<AlarmActionTriggeredEvent>()?),
            StructType::AlarmClearedEvent => Some(from.as_any_ref().downcast_ref::<AlarmClearedEvent>()?),
            StructType::AlarmCreatedEvent => Some(from.as_any_ref().downcast_ref::<AlarmCreatedEvent>()?),
            StructType::AlarmEmailCompletedEvent => Some(from.as_any_ref().downcast_ref::<AlarmEmailCompletedEvent>()?),
            StructType::AlarmEmailFailedEvent => Some(from.as_any_ref().downcast_ref::<AlarmEmailFailedEvent>()?),
            StructType::AlarmReconfiguredEvent => Some(from.as_any_ref().downcast_ref::<AlarmReconfiguredEvent>()?),
            StructType::AlarmRemovedEvent => Some(from.as_any_ref().downcast_ref::<AlarmRemovedEvent>()?),
            StructType::AlarmScriptCompleteEvent => Some(from.as_any_ref().downcast_ref::<AlarmScriptCompleteEvent>()?),
            StructType::AlarmScriptFailedEvent => Some(from.as_any_ref().downcast_ref::<AlarmScriptFailedEvent>()?),
            StructType::AlarmSnmpCompletedEvent => Some(from.as_any_ref().downcast_ref::<AlarmSnmpCompletedEvent>()?),
            StructType::AlarmSnmpFailedEvent => Some(from.as_any_ref().downcast_ref::<AlarmSnmpFailedEvent>()?),
            StructType::AlarmStatusChangedEvent => Some(from.as_any_ref().downcast_ref::<AlarmStatusChangedEvent>()?),
            StructType::AuthorizationEvent => Some(from.as_any_ref().downcast_ref::<AuthorizationEvent>()?),
            StructType::PermissionEvent => Some(from.as_any_ref().downcast_ref::<PermissionEvent>()?),
            StructType::PermissionAddedEvent => Some(from.as_any_ref().downcast_ref::<PermissionAddedEvent>()?),
            StructType::PermissionRemovedEvent => Some(from.as_any_ref().downcast_ref::<PermissionRemovedEvent>()?),
            StructType::PermissionUpdatedEvent => Some(from.as_any_ref().downcast_ref::<PermissionUpdatedEvent>()?),
            StructType::RoleEvent => Some(from.as_any_ref().downcast_ref::<RoleEvent>()?),
            StructType::RoleAddedEvent => Some(from.as_any_ref().downcast_ref::<RoleAddedEvent>()?),
            StructType::RoleRemovedEvent => Some(from.as_any_ref().downcast_ref::<RoleRemovedEvent>()?),
            StructType::RoleUpdatedEvent => Some(from.as_any_ref().downcast_ref::<RoleUpdatedEvent>()?),
            StructType::ClusterEvent => Some(from.as_any_ref().downcast_ref::<ClusterEvent>()?),
            StructType::ClusterComplianceCheckedEvent => Some(from.as_any_ref().downcast_ref::<ClusterComplianceCheckedEvent>()?),
            StructType::ClusterCreatedEvent => Some(from.as_any_ref().downcast_ref::<ClusterCreatedEvent>()?),
            StructType::ClusterDestroyedEvent => Some(from.as_any_ref().downcast_ref::<ClusterDestroyedEvent>()?),
            StructType::ClusterOvercommittedEvent => Some(from.as_any_ref().downcast_ref::<ClusterOvercommittedEvent>()?),
            StructType::HostOvercommittedEvent => Some(from.as_any_ref().downcast_ref::<HostOvercommittedEvent>()?),
            StructType::ClusterReconfiguredEvent => Some(from.as_any_ref().downcast_ref::<ClusterReconfiguredEvent>()?),
            StructType::ClusterStatusChangedEvent => Some(from.as_any_ref().downcast_ref::<ClusterStatusChangedEvent>()?),
            StructType::HostStatusChangedEvent => Some(from.as_any_ref().downcast_ref::<HostStatusChangedEvent>()?),
            StructType::DasAdmissionControlDisabledEvent => Some(from.as_any_ref().downcast_ref::<DasAdmissionControlDisabledEvent>()?),
            StructType::DasAdmissionControlEnabledEvent => Some(from.as_any_ref().downcast_ref::<DasAdmissionControlEnabledEvent>()?),
            StructType::DasAgentFoundEvent => Some(from.as_any_ref().downcast_ref::<DasAgentFoundEvent>()?),
            StructType::DasAgentUnavailableEvent => Some(from.as_any_ref().downcast_ref::<DasAgentUnavailableEvent>()?),
            StructType::DasClusterIsolatedEvent => Some(from.as_any_ref().downcast_ref::<DasClusterIsolatedEvent>()?),
            StructType::DasDisabledEvent => Some(from.as_any_ref().downcast_ref::<DasDisabledEvent>()?),
            StructType::DasEnabledEvent => Some(from.as_any_ref().downcast_ref::<DasEnabledEvent>()?),
            StructType::DasHostFailedEvent => Some(from.as_any_ref().downcast_ref::<DasHostFailedEvent>()?),
            StructType::DasHostIsolatedEvent => Some(from.as_any_ref().downcast_ref::<DasHostIsolatedEvent>()?),
            StructType::DrsDisabledEvent => Some(from.as_any_ref().downcast_ref::<DrsDisabledEvent>()?),
            StructType::DrsEnabledEvent => Some(from.as_any_ref().downcast_ref::<DrsEnabledEvent>()?),
            StructType::DrsInvocationFailedEvent => Some(from.as_any_ref().downcast_ref::<DrsInvocationFailedEvent>()?),
            StructType::DrsRecoveredFromFailureEvent => Some(from.as_any_ref().downcast_ref::<DrsRecoveredFromFailureEvent>()?),
            StructType::FailoverLevelRestored => Some(from.as_any_ref().downcast_ref::<FailoverLevelRestored>()?),
            StructType::HostMonitoringStateChangedEvent => Some(from.as_any_ref().downcast_ref::<HostMonitoringStateChangedEvent>()?),
            StructType::InsufficientFailoverResourcesEvent => Some(from.as_any_ref().downcast_ref::<InsufficientFailoverResourcesEvent>()?),
            StructType::VmHealthMonitoringStateChangedEvent => Some(from.as_any_ref().downcast_ref::<VmHealthMonitoringStateChangedEvent>()?),
            StructType::CustomFieldEvent => Some(from.as_any_ref().downcast_ref::<CustomFieldEvent>()?),
            StructType::CustomFieldDefEvent => Some(from.as_any_ref().downcast_ref::<CustomFieldDefEvent>()?),
            StructType::CustomFieldDefAddedEvent => Some(from.as_any_ref().downcast_ref::<CustomFieldDefAddedEvent>()?),
            StructType::CustomFieldDefRemovedEvent => Some(from.as_any_ref().downcast_ref::<CustomFieldDefRemovedEvent>()?),
            StructType::CustomFieldDefRenamedEvent => Some(from.as_any_ref().downcast_ref::<CustomFieldDefRenamedEvent>()?),
            StructType::CustomFieldValueChangedEvent => Some(from.as_any_ref().downcast_ref::<CustomFieldValueChangedEvent>()?),
            StructType::DvPortgroupEvent => Some(from.as_any_ref().downcast_ref::<DvPortgroupEvent>()?),
            StructType::DvPortgroupCreatedEvent => Some(from.as_any_ref().downcast_ref::<DvPortgroupCreatedEvent>()?),
            StructType::DvPortgroupDestroyedEvent => Some(from.as_any_ref().downcast_ref::<DvPortgroupDestroyedEvent>()?),
            StructType::DvPortgroupReconfiguredEvent => Some(from.as_any_ref().downcast_ref::<DvPortgroupReconfiguredEvent>()?),
            StructType::DvPortgroupRenamedEvent => Some(from.as_any_ref().downcast_ref::<DvPortgroupRenamedEvent>()?),
            StructType::DvpgImportEvent => Some(from.as_any_ref().downcast_ref::<DvpgImportEvent>()?),
            StructType::DvpgRestoreEvent => Some(from.as_any_ref().downcast_ref::<DvpgRestoreEvent>()?),
            StructType::DatacenterEvent => Some(from.as_any_ref().downcast_ref::<DatacenterEvent>()?),
            StructType::DatacenterCreatedEvent => Some(from.as_any_ref().downcast_ref::<DatacenterCreatedEvent>()?),
            StructType::DatacenterRenamedEvent => Some(from.as_any_ref().downcast_ref::<DatacenterRenamedEvent>()?),
            StructType::DatastoreEvent => Some(from.as_any_ref().downcast_ref::<DatastoreEvent>()?),
            StructType::DatastoreCapacityIncreasedEvent => Some(from.as_any_ref().downcast_ref::<DatastoreCapacityIncreasedEvent>()?),
            StructType::DatastoreDestroyedEvent => Some(from.as_any_ref().downcast_ref::<DatastoreDestroyedEvent>()?),
            StructType::DatastoreDuplicatedEvent => Some(from.as_any_ref().downcast_ref::<DatastoreDuplicatedEvent>()?),
            StructType::DatastoreFileEvent => Some(from.as_any_ref().downcast_ref::<DatastoreFileEvent>()?),
            StructType::DatastoreFileCopiedEvent => Some(from.as_any_ref().downcast_ref::<DatastoreFileCopiedEvent>()?),
            StructType::DatastoreFileDeletedEvent => Some(from.as_any_ref().downcast_ref::<DatastoreFileDeletedEvent>()?),
            StructType::DatastoreFileMovedEvent => Some(from.as_any_ref().downcast_ref::<DatastoreFileMovedEvent>()?),
            StructType::DatastoreIormReconfiguredEvent => Some(from.as_any_ref().downcast_ref::<DatastoreIormReconfiguredEvent>()?),
            StructType::DatastoreRenamedEvent => Some(from.as_any_ref().downcast_ref::<DatastoreRenamedEvent>()?),
            StructType::NonViWorkloadDetectedOnDatastoreEvent => Some(from.as_any_ref().downcast_ref::<NonViWorkloadDetectedOnDatastoreEvent>()?),
            StructType::DvsEvent => Some(from.as_any_ref().downcast_ref::<DvsEvent>()?),
            StructType::DvsCreatedEvent => Some(from.as_any_ref().downcast_ref::<DvsCreatedEvent>()?),
            StructType::DvsDestroyedEvent => Some(from.as_any_ref().downcast_ref::<DvsDestroyedEvent>()?),
            StructType::DvsHostBackInSyncEvent => Some(from.as_any_ref().downcast_ref::<DvsHostBackInSyncEvent>()?),
            StructType::DvsHostJoinedEvent => Some(from.as_any_ref().downcast_ref::<DvsHostJoinedEvent>()?),
            StructType::DvsHostLeftEvent => Some(from.as_any_ref().downcast_ref::<DvsHostLeftEvent>()?),
            StructType::DvsHostStatusUpdated => Some(from.as_any_ref().downcast_ref::<DvsHostStatusUpdated>()?),
            StructType::DvsHostWentOutOfSyncEvent => Some(from.as_any_ref().downcast_ref::<DvsHostWentOutOfSyncEvent>()?),
            StructType::DvsImportEvent => Some(from.as_any_ref().downcast_ref::<DvsImportEvent>()?),
            StructType::DvsMergedEvent => Some(from.as_any_ref().downcast_ref::<DvsMergedEvent>()?),
            StructType::DvsPortBlockedEvent => Some(from.as_any_ref().downcast_ref::<DvsPortBlockedEvent>()?),
            StructType::DvsPortConnectedEvent => Some(from.as_any_ref().downcast_ref::<DvsPortConnectedEvent>()?),
            StructType::DvsPortCreatedEvent => Some(from.as_any_ref().downcast_ref::<DvsPortCreatedEvent>()?),
            StructType::DvsPortDeletedEvent => Some(from.as_any_ref().downcast_ref::<DvsPortDeletedEvent>()?),
            StructType::DvsPortDisconnectedEvent => Some(from.as_any_ref().downcast_ref::<DvsPortDisconnectedEvent>()?),
            StructType::DvsPortEnteredPassthruEvent => Some(from.as_any_ref().downcast_ref::<DvsPortEnteredPassthruEvent>()?),
            StructType::DvsPortExitedPassthruEvent => Some(from.as_any_ref().downcast_ref::<DvsPortExitedPassthruEvent>()?),
            StructType::DvsPortJoinPortgroupEvent => Some(from.as_any_ref().downcast_ref::<DvsPortJoinPortgroupEvent>()?),
            StructType::DvsPortLeavePortgroupEvent => Some(from.as_any_ref().downcast_ref::<DvsPortLeavePortgroupEvent>()?),
            StructType::DvsPortLinkDownEvent => Some(from.as_any_ref().downcast_ref::<DvsPortLinkDownEvent>()?),
            StructType::DvsPortLinkUpEvent => Some(from.as_any_ref().downcast_ref::<DvsPortLinkUpEvent>()?),
            StructType::DvsPortReconfiguredEvent => Some(from.as_any_ref().downcast_ref::<DvsPortReconfiguredEvent>()?),
            StructType::DvsPortRuntimeChangeEvent => Some(from.as_any_ref().downcast_ref::<DvsPortRuntimeChangeEvent>()?),
            StructType::DvsPortUnblockedEvent => Some(from.as_any_ref().downcast_ref::<DvsPortUnblockedEvent>()?),
            StructType::DvsPortVendorSpecificStateChangeEvent => Some(from.as_any_ref().downcast_ref::<DvsPortVendorSpecificStateChangeEvent>()?),
            StructType::DvsReconfiguredEvent => Some(from.as_any_ref().downcast_ref::<DvsReconfiguredEvent>()?),
            StructType::DvsRenamedEvent => Some(from.as_any_ref().downcast_ref::<DvsRenamedEvent>()?),
            StructType::DvsRestoreEvent => Some(from.as_any_ref().downcast_ref::<DvsRestoreEvent>()?),
            StructType::DvsUpgradeAvailableEvent => Some(from.as_any_ref().downcast_ref::<DvsUpgradeAvailableEvent>()?),
            StructType::DvsUpgradeInProgressEvent => Some(from.as_any_ref().downcast_ref::<DvsUpgradeInProgressEvent>()?),
            StructType::DvsUpgradeRejectedEvent => Some(from.as_any_ref().downcast_ref::<DvsUpgradeRejectedEvent>()?),
            StructType::DvsUpgradedEvent => Some(from.as_any_ref().downcast_ref::<DvsUpgradedEvent>()?),
            StructType::HostLocalPortCreatedEvent => Some(from.as_any_ref().downcast_ref::<HostLocalPortCreatedEvent>()?),
            StructType::OutOfSyncDvsHost => Some(from.as_any_ref().downcast_ref::<OutOfSyncDvsHost>()?),
            StructType::RecoveryEvent => Some(from.as_any_ref().downcast_ref::<RecoveryEvent>()?),
            StructType::RollbackEvent => Some(from.as_any_ref().downcast_ref::<RollbackEvent>()?),
            StructType::VmVnicPoolReservationViolationClearEvent => Some(from.as_any_ref().downcast_ref::<VmVnicPoolReservationViolationClearEvent>()?),
            StructType::VmVnicPoolReservationViolationRaiseEvent => Some(from.as_any_ref().downcast_ref::<VmVnicPoolReservationViolationRaiseEvent>()?),
            StructType::EventEx => Some(from.as_any_ref().downcast_ref::<EventEx>()?),
            StructType::GeneralEvent => Some(from.as_any_ref().downcast_ref::<GeneralEvent>()?),
            StructType::ExtendedEvent => Some(from.as_any_ref().downcast_ref::<ExtendedEvent>()?),
            StructType::GeneralHostErrorEvent => Some(from.as_any_ref().downcast_ref::<GeneralHostErrorEvent>()?),
            StructType::GeneralHostInfoEvent => Some(from.as_any_ref().downcast_ref::<GeneralHostInfoEvent>()?),
            StructType::GeneralHostWarningEvent => Some(from.as_any_ref().downcast_ref::<GeneralHostWarningEvent>()?),
            StructType::GeneralUserEvent => Some(from.as_any_ref().downcast_ref::<GeneralUserEvent>()?),
            StructType::GeneralVmErrorEvent => Some(from.as_any_ref().downcast_ref::<GeneralVmErrorEvent>()?),
            StructType::GeneralVmInfoEvent => Some(from.as_any_ref().downcast_ref::<GeneralVmInfoEvent>()?),
            StructType::GeneralVmWarningEvent => Some(from.as_any_ref().downcast_ref::<GeneralVmWarningEvent>()?),
            StructType::HealthStatusChangedEvent => Some(from.as_any_ref().downcast_ref::<HealthStatusChangedEvent>()?),
            StructType::HostEvent => Some(from.as_any_ref().downcast_ref::<HostEvent>()?),
            StructType::AccountCreatedEvent => Some(from.as_any_ref().downcast_ref::<AccountCreatedEvent>()?),
            StructType::AccountRemovedEvent => Some(from.as_any_ref().downcast_ref::<AccountRemovedEvent>()?),
            StructType::AccountUpdatedEvent => Some(from.as_any_ref().downcast_ref::<AccountUpdatedEvent>()?),
            StructType::AdminPasswordNotChangedEvent => Some(from.as_any_ref().downcast_ref::<AdminPasswordNotChangedEvent>()?),
            StructType::CanceledHostOperationEvent => Some(from.as_any_ref().downcast_ref::<CanceledHostOperationEvent>()?),
            StructType::DatastoreDiscoveredEvent => Some(from.as_any_ref().downcast_ref::<DatastoreDiscoveredEvent>()?),
            StructType::DatastorePrincipalConfigured => Some(from.as_any_ref().downcast_ref::<DatastorePrincipalConfigured>()?),
            StructType::DatastoreRemovedOnHostEvent => Some(from.as_any_ref().downcast_ref::<DatastoreRemovedOnHostEvent>()?),
            StructType::DatastoreRenamedOnHostEvent => Some(from.as_any_ref().downcast_ref::<DatastoreRenamedOnHostEvent>()?),
            StructType::DrsResourceConfigureFailedEvent => Some(from.as_any_ref().downcast_ref::<DrsResourceConfigureFailedEvent>()?),
            StructType::DrsResourceConfigureSyncedEvent => Some(from.as_any_ref().downcast_ref::<DrsResourceConfigureSyncedEvent>()?),
            StructType::DuplicateIpDetectedEvent => Some(from.as_any_ref().downcast_ref::<DuplicateIpDetectedEvent>()?),
            StructType::DvsHealthStatusChangeEvent => Some(from.as_any_ref().downcast_ref::<DvsHealthStatusChangeEvent>()?),
            StructType::MtuMatchEvent => Some(from.as_any_ref().downcast_ref::<MtuMatchEvent>()?),
            StructType::MtuMismatchEvent => Some(from.as_any_ref().downcast_ref::<MtuMismatchEvent>()?),
            StructType::TeamingMatchEvent => Some(from.as_any_ref().downcast_ref::<TeamingMatchEvent>()?),
            StructType::TeamingMisMatchEvent => Some(from.as_any_ref().downcast_ref::<TeamingMisMatchEvent>()?),
            StructType::UplinkPortMtuNotSupportEvent => Some(from.as_any_ref().downcast_ref::<UplinkPortMtuNotSupportEvent>()?),
            StructType::UplinkPortMtuSupportEvent => Some(from.as_any_ref().downcast_ref::<UplinkPortMtuSupportEvent>()?),
            StructType::UplinkPortVlanTrunkedEvent => Some(from.as_any_ref().downcast_ref::<UplinkPortVlanTrunkedEvent>()?),
            StructType::UplinkPortVlanUntrunkedEvent => Some(from.as_any_ref().downcast_ref::<UplinkPortVlanUntrunkedEvent>()?),
            StructType::EnteredMaintenanceModeEvent => Some(from.as_any_ref().downcast_ref::<EnteredMaintenanceModeEvent>()?),
            StructType::EnteredStandbyModeEvent => Some(from.as_any_ref().downcast_ref::<EnteredStandbyModeEvent>()?),
            StructType::DrsEnteredStandbyModeEvent => Some(from.as_any_ref().downcast_ref::<DrsEnteredStandbyModeEvent>()?),
            StructType::EnteringMaintenanceModeEvent => Some(from.as_any_ref().downcast_ref::<EnteringMaintenanceModeEvent>()?),
            StructType::EnteringStandbyModeEvent => Some(from.as_any_ref().downcast_ref::<EnteringStandbyModeEvent>()?),
            StructType::DrsEnteringStandbyModeEvent => Some(from.as_any_ref().downcast_ref::<DrsEnteringStandbyModeEvent>()?),
            StructType::ExitMaintenanceModeEvent => Some(from.as_any_ref().downcast_ref::<ExitMaintenanceModeEvent>()?),
            StructType::ExitStandbyModeFailedEvent => Some(from.as_any_ref().downcast_ref::<ExitStandbyModeFailedEvent>()?),
            StructType::DrsExitStandbyModeFailedEvent => Some(from.as_any_ref().downcast_ref::<DrsExitStandbyModeFailedEvent>()?),
            StructType::ExitedStandbyModeEvent => Some(from.as_any_ref().downcast_ref::<ExitedStandbyModeEvent>()?),
            StructType::DrsExitedStandbyModeEvent => Some(from.as_any_ref().downcast_ref::<DrsExitedStandbyModeEvent>()?),
            StructType::ExitingStandbyModeEvent => Some(from.as_any_ref().downcast_ref::<ExitingStandbyModeEvent>()?),
            StructType::DrsExitingStandbyModeEvent => Some(from.as_any_ref().downcast_ref::<DrsExitingStandbyModeEvent>()?),
            StructType::GhostDvsProxySwitchDetectedEvent => Some(from.as_any_ref().downcast_ref::<GhostDvsProxySwitchDetectedEvent>()?),
            StructType::GhostDvsProxySwitchRemovedEvent => Some(from.as_any_ref().downcast_ref::<GhostDvsProxySwitchRemovedEvent>()?),
            StructType::HostAddFailedEvent => Some(from.as_any_ref().downcast_ref::<HostAddFailedEvent>()?),
            StructType::HostAddedEvent => Some(from.as_any_ref().downcast_ref::<HostAddedEvent>()?),
            StructType::HostAdminDisableEvent => Some(from.as_any_ref().downcast_ref::<HostAdminDisableEvent>()?),
            StructType::HostAdminEnableEvent => Some(from.as_any_ref().downcast_ref::<HostAdminEnableEvent>()?),
            StructType::HostCnxFailedAccountFailedEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedAccountFailedEvent>()?),
            StructType::HostCnxFailedAlreadyManagedEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedAlreadyManagedEvent>()?),
            StructType::HostCnxFailedBadCcagentEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedBadCcagentEvent>()?),
            StructType::HostCnxFailedBadUsernameEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedBadUsernameEvent>()?),
            StructType::HostCnxFailedBadVersionEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedBadVersionEvent>()?),
            StructType::HostCnxFailedCcagentUpgradeEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedCcagentUpgradeEvent>()?),
            StructType::HostCnxFailedEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedEvent>()?),
            StructType::HostCnxFailedNetworkErrorEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedNetworkErrorEvent>()?),
            StructType::HostCnxFailedNoAccessEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedNoAccessEvent>()?),
            StructType::HostCnxFailedNoConnectionEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedNoConnectionEvent>()?),
            StructType::HostCnxFailedNoLicenseEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedNoLicenseEvent>()?),
            StructType::HostCnxFailedNotFoundEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedNotFoundEvent>()?),
            StructType::HostCnxFailedTimeoutEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedTimeoutEvent>()?),
            StructType::HostComplianceCheckedEvent => Some(from.as_any_ref().downcast_ref::<HostComplianceCheckedEvent>()?),
            StructType::HostCompliantEvent => Some(from.as_any_ref().downcast_ref::<HostCompliantEvent>()?),
            StructType::HostConfigAppliedEvent => Some(from.as_any_ref().downcast_ref::<HostConfigAppliedEvent>()?),
            StructType::HostConnectedEvent => Some(from.as_any_ref().downcast_ref::<HostConnectedEvent>()?),
            StructType::HostConnectionLostEvent => Some(from.as_any_ref().downcast_ref::<HostConnectionLostEvent>()?),
            StructType::HostDasDisabledEvent => Some(from.as_any_ref().downcast_ref::<HostDasDisabledEvent>()?),
            StructType::HostDasDisablingEvent => Some(from.as_any_ref().downcast_ref::<HostDasDisablingEvent>()?),
            StructType::HostDasEnabledEvent => Some(from.as_any_ref().downcast_ref::<HostDasEnabledEvent>()?),
            StructType::HostDasEnablingEvent => Some(from.as_any_ref().downcast_ref::<HostDasEnablingEvent>()?),
            StructType::HostDasErrorEvent => Some(from.as_any_ref().downcast_ref::<HostDasErrorEvent>()?),
            StructType::HostDasEvent => Some(from.as_any_ref().downcast_ref::<HostDasEvent>()?),
            StructType::HostExtraNetworksEvent => Some(from.as_any_ref().downcast_ref::<HostExtraNetworksEvent>()?),
            StructType::HostIsolationIpPingFailedEvent => Some(from.as_any_ref().downcast_ref::<HostIsolationIpPingFailedEvent>()?),
            StructType::HostMissingNetworksEvent => Some(from.as_any_ref().downcast_ref::<HostMissingNetworksEvent>()?),
            StructType::HostNoAvailableNetworksEvent => Some(from.as_any_ref().downcast_ref::<HostNoAvailableNetworksEvent>()?),
            StructType::HostNoHaEnabledPortGroupsEvent => Some(from.as_any_ref().downcast_ref::<HostNoHaEnabledPortGroupsEvent>()?),
            StructType::HostNoRedundantManagementNetworkEvent => Some(from.as_any_ref().downcast_ref::<HostNoRedundantManagementNetworkEvent>()?),
            StructType::HostNotInClusterEvent => Some(from.as_any_ref().downcast_ref::<HostNotInClusterEvent>()?),
            StructType::HostPrimaryAgentNotShortNameEvent => Some(from.as_any_ref().downcast_ref::<HostPrimaryAgentNotShortNameEvent>()?),
            StructType::HostShortNameInconsistentEvent => Some(from.as_any_ref().downcast_ref::<HostShortNameInconsistentEvent>()?),
            StructType::HostDasOkEvent => Some(from.as_any_ref().downcast_ref::<HostDasOkEvent>()?),
            StructType::HostDisconnectedEvent => Some(from.as_any_ref().downcast_ref::<HostDisconnectedEvent>()?),
            StructType::HostEnableAdminFailedEvent => Some(from.as_any_ref().downcast_ref::<HostEnableAdminFailedEvent>()?),
            StructType::HostGetShortNameFailedEvent => Some(from.as_any_ref().downcast_ref::<HostGetShortNameFailedEvent>()?),
            StructType::HostInAuditModeEvent => Some(from.as_any_ref().downcast_ref::<HostInAuditModeEvent>()?),
            StructType::HostIpChangedEvent => Some(from.as_any_ref().downcast_ref::<HostIpChangedEvent>()?),
            StructType::HostIpInconsistentEvent => Some(from.as_any_ref().downcast_ref::<HostIpInconsistentEvent>()?),
            StructType::HostIpToShortNameFailedEvent => Some(from.as_any_ref().downcast_ref::<HostIpToShortNameFailedEvent>()?),
            StructType::HostNonCompliantEvent => Some(from.as_any_ref().downcast_ref::<HostNonCompliantEvent>()?),
            StructType::HostProfileAppliedEvent => Some(from.as_any_ref().downcast_ref::<HostProfileAppliedEvent>()?),
            StructType::HostReconnectionFailedEvent => Some(from.as_any_ref().downcast_ref::<HostReconnectionFailedEvent>()?),
            StructType::HostRemovedEvent => Some(from.as_any_ref().downcast_ref::<HostRemovedEvent>()?),
            StructType::HostShortNameToIpFailedEvent => Some(from.as_any_ref().downcast_ref::<HostShortNameToIpFailedEvent>()?),
            StructType::HostShutdownEvent => Some(from.as_any_ref().downcast_ref::<HostShutdownEvent>()?),
            StructType::HostSpecificationChangedEvent => Some(from.as_any_ref().downcast_ref::<HostSpecificationChangedEvent>()?),
            StructType::HostSpecificationRequireEvent => Some(from.as_any_ref().downcast_ref::<HostSpecificationRequireEvent>()?),
            StructType::HostSpecificationUpdateEvent => Some(from.as_any_ref().downcast_ref::<HostSpecificationUpdateEvent>()?),
            StructType::HostSubSpecificationDeleteEvent => Some(from.as_any_ref().downcast_ref::<HostSubSpecificationDeleteEvent>()?),
            StructType::HostSubSpecificationUpdateEvent => Some(from.as_any_ref().downcast_ref::<HostSubSpecificationUpdateEvent>()?),
            StructType::HostSyncFailedEvent => Some(from.as_any_ref().downcast_ref::<HostSyncFailedEvent>()?),
            StructType::HostUpgradeFailedEvent => Some(from.as_any_ref().downcast_ref::<HostUpgradeFailedEvent>()?),
            StructType::HostUserWorldSwapNotEnabledEvent => Some(from.as_any_ref().downcast_ref::<HostUserWorldSwapNotEnabledEvent>()?),
            StructType::HostVnicConnectedToCustomizedDvPortEvent => Some(from.as_any_ref().downcast_ref::<HostVnicConnectedToCustomizedDvPortEvent>()?),
            StructType::HostWwnChangedEvent => Some(from.as_any_ref().downcast_ref::<HostWwnChangedEvent>()?),
            StructType::HostWwnConflictEvent => Some(from.as_any_ref().downcast_ref::<HostWwnConflictEvent>()?),
            StructType::LocalDatastoreCreatedEvent => Some(from.as_any_ref().downcast_ref::<LocalDatastoreCreatedEvent>()?),
            StructType::LocalTsmEnabledEvent => Some(from.as_any_ref().downcast_ref::<LocalTsmEnabledEvent>()?),
            StructType::NasDatastoreCreatedEvent => Some(from.as_any_ref().downcast_ref::<NasDatastoreCreatedEvent>()?),
            StructType::NoDatastoresConfiguredEvent => Some(from.as_any_ref().downcast_ref::<NoDatastoresConfiguredEvent>()?),
            StructType::RemoteTsmEnabledEvent => Some(from.as_any_ref().downcast_ref::<RemoteTsmEnabledEvent>()?),
            StructType::TimedOutHostOperationEvent => Some(from.as_any_ref().downcast_ref::<TimedOutHostOperationEvent>()?),
            StructType::UpdatedAgentBeingRestartedEvent => Some(from.as_any_ref().downcast_ref::<UpdatedAgentBeingRestartedEvent>()?),
            StructType::UserAssignedToGroup => Some(from.as_any_ref().downcast_ref::<UserAssignedToGroup>()?),
            StructType::UserPasswordChanged => Some(from.as_any_ref().downcast_ref::<UserPasswordChanged>()?),
            StructType::UserUnassignedFromGroup => Some(from.as_any_ref().downcast_ref::<UserUnassignedFromGroup>()?),
            StructType::VmfsDatastoreCreatedEvent => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreCreatedEvent>()?),
            StructType::VmfsDatastoreExpandedEvent => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreExpandedEvent>()?),
            StructType::VmfsDatastoreExtendedEvent => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreExtendedEvent>()?),
            StructType::VcAgentUninstallFailedEvent => Some(from.as_any_ref().downcast_ref::<VcAgentUninstallFailedEvent>()?),
            StructType::VcAgentUninstalledEvent => Some(from.as_any_ref().downcast_ref::<VcAgentUninstalledEvent>()?),
            StructType::VcAgentUpgradeFailedEvent => Some(from.as_any_ref().downcast_ref::<VcAgentUpgradeFailedEvent>()?),
            StructType::VcAgentUpgradedEvent => Some(from.as_any_ref().downcast_ref::<VcAgentUpgradedEvent>()?),
            StructType::VimAccountPasswordChangedEvent => Some(from.as_any_ref().downcast_ref::<VimAccountPasswordChangedEvent>()?),
            StructType::IScsiBootFailureEvent => Some(from.as_any_ref().downcast_ref::<IScsiBootFailureEvent>()?),
            StructType::HostInventoryUnreadableEvent => Some(from.as_any_ref().downcast_ref::<HostInventoryUnreadableEvent>()?),
            StructType::LicenseEvent => Some(from.as_any_ref().downcast_ref::<LicenseEvent>()?),
            StructType::AllVirtualMachinesLicensedEvent => Some(from.as_any_ref().downcast_ref::<AllVirtualMachinesLicensedEvent>()?),
            StructType::HostInventoryFullEvent => Some(from.as_any_ref().downcast_ref::<HostInventoryFullEvent>()?),
            StructType::HostLicenseExpiredEvent => Some(from.as_any_ref().downcast_ref::<HostLicenseExpiredEvent>()?),
            StructType::IncorrectHostInformationEvent => Some(from.as_any_ref().downcast_ref::<IncorrectHostInformationEvent>()?),
            StructType::InvalidEditionEvent => Some(from.as_any_ref().downcast_ref::<InvalidEditionEvent>()?),
            StructType::LicenseNonComplianceEvent => Some(from.as_any_ref().downcast_ref::<LicenseNonComplianceEvent>()?),
            StructType::LicenseRestrictedEvent => Some(from.as_any_ref().downcast_ref::<LicenseRestrictedEvent>()?),
            StructType::LicenseServerAvailableEvent => Some(from.as_any_ref().downcast_ref::<LicenseServerAvailableEvent>()?),
            StructType::LicenseServerUnavailableEvent => Some(from.as_any_ref().downcast_ref::<LicenseServerUnavailableEvent>()?),
            StructType::NoLicenseEvent => Some(from.as_any_ref().downcast_ref::<NoLicenseEvent>()?),
            StructType::ServerLicenseExpiredEvent => Some(from.as_any_ref().downcast_ref::<ServerLicenseExpiredEvent>()?),
            StructType::UnlicensedVirtualMachinesEvent => Some(from.as_any_ref().downcast_ref::<UnlicensedVirtualMachinesEvent>()?),
            StructType::UnlicensedVirtualMachinesFoundEvent => Some(from.as_any_ref().downcast_ref::<UnlicensedVirtualMachinesFoundEvent>()?),
            StructType::VMotionLicenseExpiredEvent => Some(from.as_any_ref().downcast_ref::<VMotionLicenseExpiredEvent>()?),
            StructType::LicenseExpiredEvent => Some(from.as_any_ref().downcast_ref::<LicenseExpiredEvent>()?),
            StructType::LockerMisconfiguredEvent => Some(from.as_any_ref().downcast_ref::<LockerMisconfiguredEvent>()?),
            StructType::LockerReconfiguredEvent => Some(from.as_any_ref().downcast_ref::<LockerReconfiguredEvent>()?),
            StructType::NetworkRollbackEvent => Some(from.as_any_ref().downcast_ref::<NetworkRollbackEvent>()?),
            StructType::ProfileEvent => Some(from.as_any_ref().downcast_ref::<ProfileEvent>()?),
            StructType::ProfileAssociatedEvent => Some(from.as_any_ref().downcast_ref::<ProfileAssociatedEvent>()?),
            StructType::ProfileChangedEvent => Some(from.as_any_ref().downcast_ref::<ProfileChangedEvent>()?),
            StructType::ProfileCreatedEvent => Some(from.as_any_ref().downcast_ref::<ProfileCreatedEvent>()?),
            StructType::ProfileDissociatedEvent => Some(from.as_any_ref().downcast_ref::<ProfileDissociatedEvent>()?),
            StructType::ProfileReferenceHostChangedEvent => Some(from.as_any_ref().downcast_ref::<ProfileReferenceHostChangedEvent>()?),
            StructType::ProfileRemovedEvent => Some(from.as_any_ref().downcast_ref::<ProfileRemovedEvent>()?),
            StructType::ResourcePoolEvent => Some(from.as_any_ref().downcast_ref::<ResourcePoolEvent>()?),
            StructType::ResourcePoolCreatedEvent => Some(from.as_any_ref().downcast_ref::<ResourcePoolCreatedEvent>()?),
            StructType::ResourcePoolDestroyedEvent => Some(from.as_any_ref().downcast_ref::<ResourcePoolDestroyedEvent>()?),
            StructType::ResourcePoolMovedEvent => Some(from.as_any_ref().downcast_ref::<ResourcePoolMovedEvent>()?),
            StructType::ResourcePoolReconfiguredEvent => Some(from.as_any_ref().downcast_ref::<ResourcePoolReconfiguredEvent>()?),
            StructType::ResourceViolatedEvent => Some(from.as_any_ref().downcast_ref::<ResourceViolatedEvent>()?),
            StructType::ScheduledTaskEvent => Some(from.as_any_ref().downcast_ref::<ScheduledTaskEvent>()?),
            StructType::ScheduledTaskCompletedEvent => Some(from.as_any_ref().downcast_ref::<ScheduledTaskCompletedEvent>()?),
            StructType::ScheduledTaskCreatedEvent => Some(from.as_any_ref().downcast_ref::<ScheduledTaskCreatedEvent>()?),
            StructType::ScheduledTaskEmailCompletedEvent => Some(from.as_any_ref().downcast_ref::<ScheduledTaskEmailCompletedEvent>()?),
            StructType::ScheduledTaskEmailFailedEvent => Some(from.as_any_ref().downcast_ref::<ScheduledTaskEmailFailedEvent>()?),
            StructType::ScheduledTaskFailedEvent => Some(from.as_any_ref().downcast_ref::<ScheduledTaskFailedEvent>()?),
            StructType::ScheduledTaskReconfiguredEvent => Some(from.as_any_ref().downcast_ref::<ScheduledTaskReconfiguredEvent>()?),
            StructType::ScheduledTaskRemovedEvent => Some(from.as_any_ref().downcast_ref::<ScheduledTaskRemovedEvent>()?),
            StructType::ScheduledTaskStartedEvent => Some(from.as_any_ref().downcast_ref::<ScheduledTaskStartedEvent>()?),
            StructType::SessionEvent => Some(from.as_any_ref().downcast_ref::<SessionEvent>()?),
            StructType::AlreadyAuthenticatedSessionEvent => Some(from.as_any_ref().downcast_ref::<AlreadyAuthenticatedSessionEvent>()?),
            StructType::BadUsernameSessionEvent => Some(from.as_any_ref().downcast_ref::<BadUsernameSessionEvent>()?),
            StructType::GlobalMessageChangedEvent => Some(from.as_any_ref().downcast_ref::<GlobalMessageChangedEvent>()?),
            StructType::NoAccessUserEvent => Some(from.as_any_ref().downcast_ref::<NoAccessUserEvent>()?),
            StructType::ServerStartedSessionEvent => Some(from.as_any_ref().downcast_ref::<ServerStartedSessionEvent>()?),
            StructType::SessionTerminatedEvent => Some(from.as_any_ref().downcast_ref::<SessionTerminatedEvent>()?),
            StructType::UserLoginSessionEvent => Some(from.as_any_ref().downcast_ref::<UserLoginSessionEvent>()?),
            StructType::UserLogoutSessionEvent => Some(from.as_any_ref().downcast_ref::<UserLogoutSessionEvent>()?),
            StructType::TaskEvent => Some(from.as_any_ref().downcast_ref::<TaskEvent>()?),
            StructType::TaskTimeoutEvent => Some(from.as_any_ref().downcast_ref::<TaskTimeoutEvent>()?),
            StructType::TemplateUpgradeEvent => Some(from.as_any_ref().downcast_ref::<TemplateUpgradeEvent>()?),
            StructType::TemplateBeingUpgradedEvent => Some(from.as_any_ref().downcast_ref::<TemplateBeingUpgradedEvent>()?),
            StructType::TemplateUpgradeFailedEvent => Some(from.as_any_ref().downcast_ref::<TemplateUpgradeFailedEvent>()?),
            StructType::TemplateUpgradedEvent => Some(from.as_any_ref().downcast_ref::<TemplateUpgradedEvent>()?),
            StructType::UpgradeEvent => Some(from.as_any_ref().downcast_ref::<UpgradeEvent>()?),
            StructType::ErrorUpgradeEvent => Some(from.as_any_ref().downcast_ref::<ErrorUpgradeEvent>()?),
            StructType::InfoUpgradeEvent => Some(from.as_any_ref().downcast_ref::<InfoUpgradeEvent>()?),
            StructType::UserUpgradeEvent => Some(from.as_any_ref().downcast_ref::<UserUpgradeEvent>()?),
            StructType::WarningUpgradeEvent => Some(from.as_any_ref().downcast_ref::<WarningUpgradeEvent>()?),
            StructType::VmEvent => Some(from.as_any_ref().downcast_ref::<VmEvent>()?),
            StructType::CustomizationEvent => Some(from.as_any_ref().downcast_ref::<CustomizationEvent>()?),
            StructType::CustomizationFailed => Some(from.as_any_ref().downcast_ref::<CustomizationFailed>()?),
            StructType::CustomizationLinuxIdentityFailed => Some(from.as_any_ref().downcast_ref::<CustomizationLinuxIdentityFailed>()?),
            StructType::CustomizationNetworkSetupFailed => Some(from.as_any_ref().downcast_ref::<CustomizationNetworkSetupFailed>()?),
            StructType::CustomizationSysprepFailed => Some(from.as_any_ref().downcast_ref::<CustomizationSysprepFailed>()?),
            StructType::CustomizationUnknownFailure => Some(from.as_any_ref().downcast_ref::<CustomizationUnknownFailure>()?),
            StructType::CustomizationStartedEvent => Some(from.as_any_ref().downcast_ref::<CustomizationStartedEvent>()?),
            StructType::CustomizationSucceeded => Some(from.as_any_ref().downcast_ref::<CustomizationSucceeded>()?),
            StructType::DrsRuleComplianceEvent => Some(from.as_any_ref().downcast_ref::<DrsRuleComplianceEvent>()?),
            StructType::DrsRuleViolationEvent => Some(from.as_any_ref().downcast_ref::<DrsRuleViolationEvent>()?),
            StructType::DrsSoftRuleViolationEvent => Some(from.as_any_ref().downcast_ref::<DrsSoftRuleViolationEvent>()?),
            StructType::MigrationEvent => Some(from.as_any_ref().downcast_ref::<MigrationEvent>()?),
            StructType::MigrationErrorEvent => Some(from.as_any_ref().downcast_ref::<MigrationErrorEvent>()?),
            StructType::MigrationHostErrorEvent => Some(from.as_any_ref().downcast_ref::<MigrationHostErrorEvent>()?),
            StructType::MigrationHostWarningEvent => Some(from.as_any_ref().downcast_ref::<MigrationHostWarningEvent>()?),
            StructType::MigrationResourceErrorEvent => Some(from.as_any_ref().downcast_ref::<MigrationResourceErrorEvent>()?),
            StructType::MigrationResourceWarningEvent => Some(from.as_any_ref().downcast_ref::<MigrationResourceWarningEvent>()?),
            StructType::MigrationWarningEvent => Some(from.as_any_ref().downcast_ref::<MigrationWarningEvent>()?),
            StructType::NoMaintenanceModeDrsRecommendationForVm => Some(from.as_any_ref().downcast_ref::<NoMaintenanceModeDrsRecommendationForVm>()?),
            StructType::NotEnoughResourcesToStartVmEvent => Some(from.as_any_ref().downcast_ref::<NotEnoughResourcesToStartVmEvent>()?),
            StructType::VmAcquiredMksTicketEvent => Some(from.as_any_ref().downcast_ref::<VmAcquiredMksTicketEvent>()?),
            StructType::VmAcquiredTicketEvent => Some(from.as_any_ref().downcast_ref::<VmAcquiredTicketEvent>()?),
            StructType::VmAutoRenameEvent => Some(from.as_any_ref().downcast_ref::<VmAutoRenameEvent>()?),
            StructType::VmBeingCreatedEvent => Some(from.as_any_ref().downcast_ref::<VmBeingCreatedEvent>()?),
            StructType::VmBeingDeployedEvent => Some(from.as_any_ref().downcast_ref::<VmBeingDeployedEvent>()?),
            StructType::VmBeingHotMigratedEvent => Some(from.as_any_ref().downcast_ref::<VmBeingHotMigratedEvent>()?),
            StructType::VmBeingMigratedEvent => Some(from.as_any_ref().downcast_ref::<VmBeingMigratedEvent>()?),
            StructType::VmCloneEvent => Some(from.as_any_ref().downcast_ref::<VmCloneEvent>()?),
            StructType::VmBeingClonedEvent => Some(from.as_any_ref().downcast_ref::<VmBeingClonedEvent>()?),
            StructType::VmBeingClonedNoFolderEvent => Some(from.as_any_ref().downcast_ref::<VmBeingClonedNoFolderEvent>()?),
            StructType::VmCloneFailedEvent => Some(from.as_any_ref().downcast_ref::<VmCloneFailedEvent>()?),
            StructType::VmClonedEvent => Some(from.as_any_ref().downcast_ref::<VmClonedEvent>()?),
            StructType::VmConfigMissingEvent => Some(from.as_any_ref().downcast_ref::<VmConfigMissingEvent>()?),
            StructType::VmConnectedEvent => Some(from.as_any_ref().downcast_ref::<VmConnectedEvent>()?),
            StructType::VmCreatedEvent => Some(from.as_any_ref().downcast_ref::<VmCreatedEvent>()?),
            StructType::VmDasBeingResetEvent => Some(from.as_any_ref().downcast_ref::<VmDasBeingResetEvent>()?),
            StructType::VmDasBeingResetWithScreenshotEvent => Some(from.as_any_ref().downcast_ref::<VmDasBeingResetWithScreenshotEvent>()?),
            StructType::VmDasResetFailedEvent => Some(from.as_any_ref().downcast_ref::<VmDasResetFailedEvent>()?),
            StructType::VmDasUpdateErrorEvent => Some(from.as_any_ref().downcast_ref::<VmDasUpdateErrorEvent>()?),
            StructType::VmDasUpdateOkEvent => Some(from.as_any_ref().downcast_ref::<VmDasUpdateOkEvent>()?),
            StructType::VmDateRolledBackEvent => Some(from.as_any_ref().downcast_ref::<VmDateRolledBackEvent>()?),
            StructType::VmDeployFailedEvent => Some(from.as_any_ref().downcast_ref::<VmDeployFailedEvent>()?),
            StructType::VmDeployedEvent => Some(from.as_any_ref().downcast_ref::<VmDeployedEvent>()?),
            StructType::VmDisconnectedEvent => Some(from.as_any_ref().downcast_ref::<VmDisconnectedEvent>()?),
            StructType::VmDiscoveredEvent => Some(from.as_any_ref().downcast_ref::<VmDiscoveredEvent>()?),
            StructType::VmDiskFailedEvent => Some(from.as_any_ref().downcast_ref::<VmDiskFailedEvent>()?),
            StructType::VmEmigratingEvent => Some(from.as_any_ref().downcast_ref::<VmEmigratingEvent>()?),
            StructType::VmEndRecordingEvent => Some(from.as_any_ref().downcast_ref::<VmEndRecordingEvent>()?),
            StructType::VmEndReplayingEvent => Some(from.as_any_ref().downcast_ref::<VmEndReplayingEvent>()?),
            StructType::VmFailedMigrateEvent => Some(from.as_any_ref().downcast_ref::<VmFailedMigrateEvent>()?),
            StructType::VmFailedRelayoutEvent => Some(from.as_any_ref().downcast_ref::<VmFailedRelayoutEvent>()?),
            StructType::VmFailedRelayoutOnVmfs2DatastoreEvent => Some(from.as_any_ref().downcast_ref::<VmFailedRelayoutOnVmfs2DatastoreEvent>()?),
            StructType::VmFailedStartingSecondaryEvent => Some(from.as_any_ref().downcast_ref::<VmFailedStartingSecondaryEvent>()?),
            StructType::VmFailedToPowerOffEvent => Some(from.as_any_ref().downcast_ref::<VmFailedToPowerOffEvent>()?),
            StructType::VmFailedToPowerOnEvent => Some(from.as_any_ref().downcast_ref::<VmFailedToPowerOnEvent>()?),
            StructType::VmFailedToRebootGuestEvent => Some(from.as_any_ref().downcast_ref::<VmFailedToRebootGuestEvent>()?),
            StructType::VmFailedToResetEvent => Some(from.as_any_ref().downcast_ref::<VmFailedToResetEvent>()?),
            StructType::VmFailedToShutdownGuestEvent => Some(from.as_any_ref().downcast_ref::<VmFailedToShutdownGuestEvent>()?),
            StructType::VmFailedToStandbyGuestEvent => Some(from.as_any_ref().downcast_ref::<VmFailedToStandbyGuestEvent>()?),
            StructType::VmFailedToSuspendEvent => Some(from.as_any_ref().downcast_ref::<VmFailedToSuspendEvent>()?),
            StructType::VmFailedUpdatingSecondaryConfig => Some(from.as_any_ref().downcast_ref::<VmFailedUpdatingSecondaryConfig>()?),
            StructType::VmFailoverFailed => Some(from.as_any_ref().downcast_ref::<VmFailoverFailed>()?),
            StructType::VmFaultToleranceStateChangedEvent => Some(from.as_any_ref().downcast_ref::<VmFaultToleranceStateChangedEvent>()?),
            StructType::VmFaultToleranceTurnedOffEvent => Some(from.as_any_ref().downcast_ref::<VmFaultToleranceTurnedOffEvent>()?),
            StructType::VmFaultToleranceVmTerminatedEvent => Some(from.as_any_ref().downcast_ref::<VmFaultToleranceVmTerminatedEvent>()?),
            StructType::VmGuestOsCrashedEvent => Some(from.as_any_ref().downcast_ref::<VmGuestOsCrashedEvent>()?),
            StructType::VmGuestRebootEvent => Some(from.as_any_ref().downcast_ref::<VmGuestRebootEvent>()?),
            StructType::VmGuestShutdownEvent => Some(from.as_any_ref().downcast_ref::<VmGuestShutdownEvent>()?),
            StructType::VmGuestStandbyEvent => Some(from.as_any_ref().downcast_ref::<VmGuestStandbyEvent>()?),
            StructType::VmInstanceUuidAssignedEvent => Some(from.as_any_ref().downcast_ref::<VmInstanceUuidAssignedEvent>()?),
            StructType::VmInstanceUuidChangedEvent => Some(from.as_any_ref().downcast_ref::<VmInstanceUuidChangedEvent>()?),
            StructType::VmInstanceUuidConflictEvent => Some(from.as_any_ref().downcast_ref::<VmInstanceUuidConflictEvent>()?),
            StructType::VmMacAssignedEvent => Some(from.as_any_ref().downcast_ref::<VmMacAssignedEvent>()?),
            StructType::VmMacChangedEvent => Some(from.as_any_ref().downcast_ref::<VmMacChangedEvent>()?),
            StructType::VmMacConflictEvent => Some(from.as_any_ref().downcast_ref::<VmMacConflictEvent>()?),
            StructType::VmMaxFtRestartCountReached => Some(from.as_any_ref().downcast_ref::<VmMaxFtRestartCountReached>()?),
            StructType::VmMaxRestartCountReached => Some(from.as_any_ref().downcast_ref::<VmMaxRestartCountReached>()?),
            StructType::VmMessageErrorEvent => Some(from.as_any_ref().downcast_ref::<VmMessageErrorEvent>()?),
            StructType::VmMessageEvent => Some(from.as_any_ref().downcast_ref::<VmMessageEvent>()?),
            StructType::VmMessageWarningEvent => Some(from.as_any_ref().downcast_ref::<VmMessageWarningEvent>()?),
            StructType::VmMigratedEvent => Some(from.as_any_ref().downcast_ref::<VmMigratedEvent>()?),
            StructType::DrsVmMigratedEvent => Some(from.as_any_ref().downcast_ref::<DrsVmMigratedEvent>()?),
            StructType::VmNoCompatibleHostForSecondaryEvent => Some(from.as_any_ref().downcast_ref::<VmNoCompatibleHostForSecondaryEvent>()?),
            StructType::VmNoNetworkAccessEvent => Some(from.as_any_ref().downcast_ref::<VmNoNetworkAccessEvent>()?),
            StructType::VmOrphanedEvent => Some(from.as_any_ref().downcast_ref::<VmOrphanedEvent>()?),
            StructType::VmPoweredOffEvent => Some(from.as_any_ref().downcast_ref::<VmPoweredOffEvent>()?),
            StructType::VmPowerOffOnIsolationEvent => Some(from.as_any_ref().downcast_ref::<VmPowerOffOnIsolationEvent>()?),
            StructType::VmShutdownOnIsolationEvent => Some(from.as_any_ref().downcast_ref::<VmShutdownOnIsolationEvent>()?),
            StructType::VmPoweredOnEvent => Some(from.as_any_ref().downcast_ref::<VmPoweredOnEvent>()?),
            StructType::DrsVmPoweredOnEvent => Some(from.as_any_ref().downcast_ref::<DrsVmPoweredOnEvent>()?),
            StructType::VmRestartedOnAlternateHostEvent => Some(from.as_any_ref().downcast_ref::<VmRestartedOnAlternateHostEvent>()?),
            StructType::VmPoweringOnWithCustomizedDvPortEvent => Some(from.as_any_ref().downcast_ref::<VmPoweringOnWithCustomizedDvPortEvent>()?),
            StructType::VmPrimaryFailoverEvent => Some(from.as_any_ref().downcast_ref::<VmPrimaryFailoverEvent>()?),
            StructType::VmReconfiguredEvent => Some(from.as_any_ref().downcast_ref::<VmReconfiguredEvent>()?),
            StructType::VmRegisteredEvent => Some(from.as_any_ref().downcast_ref::<VmRegisteredEvent>()?),
            StructType::VmRelayoutSuccessfulEvent => Some(from.as_any_ref().downcast_ref::<VmRelayoutSuccessfulEvent>()?),
            StructType::VmRelayoutUpToDateEvent => Some(from.as_any_ref().downcast_ref::<VmRelayoutUpToDateEvent>()?),
            StructType::VmReloadFromPathEvent => Some(from.as_any_ref().downcast_ref::<VmReloadFromPathEvent>()?),
            StructType::VmReloadFromPathFailedEvent => Some(from.as_any_ref().downcast_ref::<VmReloadFromPathFailedEvent>()?),
            StructType::VmRelocateSpecEvent => Some(from.as_any_ref().downcast_ref::<VmRelocateSpecEvent>()?),
            StructType::VmBeingRelocatedEvent => Some(from.as_any_ref().downcast_ref::<VmBeingRelocatedEvent>()?),
            StructType::VmRelocateFailedEvent => Some(from.as_any_ref().downcast_ref::<VmRelocateFailedEvent>()?),
            StructType::VmRelocatedEvent => Some(from.as_any_ref().downcast_ref::<VmRelocatedEvent>()?),
            StructType::VmRemoteConsoleConnectedEvent => Some(from.as_any_ref().downcast_ref::<VmRemoteConsoleConnectedEvent>()?),
            StructType::VmRemoteConsoleDisconnectedEvent => Some(from.as_any_ref().downcast_ref::<VmRemoteConsoleDisconnectedEvent>()?),
            StructType::VmRemovedEvent => Some(from.as_any_ref().downcast_ref::<VmRemovedEvent>()?),
            StructType::VmRenamedEvent => Some(from.as_any_ref().downcast_ref::<VmRenamedEvent>()?),
            StructType::VmRequirementsExceedCurrentEvcModeEvent => Some(from.as_any_ref().downcast_ref::<VmRequirementsExceedCurrentEvcModeEvent>()?),
            StructType::VmResettingEvent => Some(from.as_any_ref().downcast_ref::<VmResettingEvent>()?),
            StructType::VmResourcePoolMovedEvent => Some(from.as_any_ref().downcast_ref::<VmResourcePoolMovedEvent>()?),
            StructType::VmResourceReallocatedEvent => Some(from.as_any_ref().downcast_ref::<VmResourceReallocatedEvent>()?),
            StructType::VmResumingEvent => Some(from.as_any_ref().downcast_ref::<VmResumingEvent>()?),
            StructType::VmSecondaryAddedEvent => Some(from.as_any_ref().downcast_ref::<VmSecondaryAddedEvent>()?),
            StructType::VmSecondaryDisabledBySystemEvent => Some(from.as_any_ref().downcast_ref::<VmSecondaryDisabledBySystemEvent>()?),
            StructType::VmSecondaryDisabledEvent => Some(from.as_any_ref().downcast_ref::<VmSecondaryDisabledEvent>()?),
            StructType::VmSecondaryEnabledEvent => Some(from.as_any_ref().downcast_ref::<VmSecondaryEnabledEvent>()?),
            StructType::VmSecondaryStartedEvent => Some(from.as_any_ref().downcast_ref::<VmSecondaryStartedEvent>()?),
            StructType::VmStartRecordingEvent => Some(from.as_any_ref().downcast_ref::<VmStartRecordingEvent>()?),
            StructType::VmStartReplayingEvent => Some(from.as_any_ref().downcast_ref::<VmStartReplayingEvent>()?),
            StructType::VmStartingEvent => Some(from.as_any_ref().downcast_ref::<VmStartingEvent>()?),
            StructType::VmUnsupportedStartingEvent => Some(from.as_any_ref().downcast_ref::<VmUnsupportedStartingEvent>()?),
            StructType::VmStartingSecondaryEvent => Some(from.as_any_ref().downcast_ref::<VmStartingSecondaryEvent>()?),
            StructType::VmStaticMacConflictEvent => Some(from.as_any_ref().downcast_ref::<VmStaticMacConflictEvent>()?),
            StructType::VmStoppingEvent => Some(from.as_any_ref().downcast_ref::<VmStoppingEvent>()?),
            StructType::VmSuspendedEvent => Some(from.as_any_ref().downcast_ref::<VmSuspendedEvent>()?),
            StructType::VmSuspendingEvent => Some(from.as_any_ref().downcast_ref::<VmSuspendingEvent>()?),
            StructType::VmTimedoutStartingSecondaryEvent => Some(from.as_any_ref().downcast_ref::<VmTimedoutStartingSecondaryEvent>()?),
            StructType::VmUpgradeCompleteEvent => Some(from.as_any_ref().downcast_ref::<VmUpgradeCompleteEvent>()?),
            StructType::VmUpgradeFailedEvent => Some(from.as_any_ref().downcast_ref::<VmUpgradeFailedEvent>()?),
            StructType::VmUpgradingEvent => Some(from.as_any_ref().downcast_ref::<VmUpgradingEvent>()?),
            StructType::VmUuidAssignedEvent => Some(from.as_any_ref().downcast_ref::<VmUuidAssignedEvent>()?),
            StructType::VmUuidChangedEvent => Some(from.as_any_ref().downcast_ref::<VmUuidChangedEvent>()?),
            StructType::VmUuidConflictEvent => Some(from.as_any_ref().downcast_ref::<VmUuidConflictEvent>()?),
            StructType::VmWwnAssignedEvent => Some(from.as_any_ref().downcast_ref::<VmWwnAssignedEvent>()?),
            StructType::VmWwnChangedEvent => Some(from.as_any_ref().downcast_ref::<VmWwnChangedEvent>()?),
            StructType::VmWwnConflictEvent => Some(from.as_any_ref().downcast_ref::<VmWwnConflictEvent>()?),
            StructType::EventArgument => Some(from.as_any_ref().downcast_ref::<EventArgument>()?),
            StructType::EntityEventArgument => Some(from.as_any_ref().downcast_ref::<EntityEventArgument>()?),
            StructType::AlarmEventArgument => Some(from.as_any_ref().downcast_ref::<AlarmEventArgument>()?),
            StructType::ComputeResourceEventArgument => Some(from.as_any_ref().downcast_ref::<ComputeResourceEventArgument>()?),
            StructType::DatacenterEventArgument => Some(from.as_any_ref().downcast_ref::<DatacenterEventArgument>()?),
            StructType::DatastoreEventArgument => Some(from.as_any_ref().downcast_ref::<DatastoreEventArgument>()?),
            StructType::DvsEventArgument => Some(from.as_any_ref().downcast_ref::<DvsEventArgument>()?),
            StructType::FolderEventArgument => Some(from.as_any_ref().downcast_ref::<FolderEventArgument>()?),
            StructType::HostEventArgument => Some(from.as_any_ref().downcast_ref::<HostEventArgument>()?),
            StructType::ManagedEntityEventArgument => Some(from.as_any_ref().downcast_ref::<ManagedEntityEventArgument>()?),
            StructType::NetworkEventArgument => Some(from.as_any_ref().downcast_ref::<NetworkEventArgument>()?),
            StructType::ResourcePoolEventArgument => Some(from.as_any_ref().downcast_ref::<ResourcePoolEventArgument>()?),
            StructType::ScheduledTaskEventArgument => Some(from.as_any_ref().downcast_ref::<ScheduledTaskEventArgument>()?),
            StructType::VmEventArgument => Some(from.as_any_ref().downcast_ref::<VmEventArgument>()?),
            StructType::ProfileEventArgument => Some(from.as_any_ref().downcast_ref::<ProfileEventArgument>()?),
            StructType::RoleEventArgument => Some(from.as_any_ref().downcast_ref::<RoleEventArgument>()?),
            StructType::EventDescription => Some(from.as_any_ref().downcast_ref::<EventDescription>()?),
            StructType::EventArgDesc => Some(from.as_any_ref().downcast_ref::<EventArgDesc>()?),
            StructType::EventDescriptionEventDetail => Some(from.as_any_ref().downcast_ref::<EventDescriptionEventDetail>()?),
            StructType::EventFilterSpec => Some(from.as_any_ref().downcast_ref::<EventFilterSpec>()?),
            StructType::EventFilterSpecByEntity => Some(from.as_any_ref().downcast_ref::<EventFilterSpecByEntity>()?),
            StructType::EventFilterSpecByTime => Some(from.as_any_ref().downcast_ref::<EventFilterSpecByTime>()?),
            StructType::EventFilterSpecByUsername => Some(from.as_any_ref().downcast_ref::<EventFilterSpecByUsername>()?),
            StructType::ExtendedEventPair => Some(from.as_any_ref().downcast_ref::<ExtendedEventPair>()?),
            StructType::VnicPortArgument => Some(from.as_any_ref().downcast_ref::<VnicPortArgument>()?),
            StructType::ExtExtendedProductInfo => Some(from.as_any_ref().downcast_ref::<ExtExtendedProductInfo>()?),
            StructType::ManagedByInfo => Some(from.as_any_ref().downcast_ref::<ManagedByInfo>()?),
            StructType::ExtManagedEntityInfo => Some(from.as_any_ref().downcast_ref::<ExtManagedEntityInfo>()?),
            StructType::ExtSolutionManagerInfo => Some(from.as_any_ref().downcast_ref::<ExtSolutionManagerInfo>()?),
            StructType::ExtSolutionManagerInfoTabInfo => Some(from.as_any_ref().downcast_ref::<ExtSolutionManagerInfoTabInfo>()?),
            StructType::AnswerFileUpdateFailure => Some(from.as_any_ref().downcast_ref::<AnswerFileUpdateFailure>()?),
            StructType::ConflictingConfigurationConfig => Some(from.as_any_ref().downcast_ref::<ConflictingConfigurationConfig>()?),
            StructType::DatacenterMismatchArgument => Some(from.as_any_ref().downcast_ref::<DatacenterMismatchArgument>()?),
            StructType::DvsApplyOperationFaultFaultOnObject => Some(from.as_any_ref().downcast_ref::<DvsApplyOperationFaultFaultOnObject>()?),
            StructType::DvsOperationBulkFaultFaultOnHost => Some(from.as_any_ref().downcast_ref::<DvsOperationBulkFaultFaultOnHost>()?),
            StructType::ImportOperationBulkFaultFaultOnImport => Some(from.as_any_ref().downcast_ref::<ImportOperationBulkFaultFaultOnImport>()?),
            StructType::MultipleCertificatesVerifyFaultThumbprintData => Some(from.as_any_ref().downcast_ref::<MultipleCertificatesVerifyFaultThumbprintData>()?),
            StructType::NoPermissionEntityPrivileges => Some(from.as_any_ref().downcast_ref::<NoPermissionEntityPrivileges>()?),
            StructType::ProfileUpdateFailedUpdateFailure => Some(from.as_any_ref().downcast_ref::<ProfileUpdateFailedUpdateFailure>()?),
            StructType::HostActiveDirectory => Some(from.as_any_ref().downcast_ref::<HostActiveDirectory>()?),
            StructType::HostActiveDirectorySpec => Some(from.as_any_ref().downcast_ref::<HostActiveDirectorySpec>()?),
            StructType::HostAssignableHardwareBinding => Some(from.as_any_ref().downcast_ref::<HostAssignableHardwareBinding>()?),
            StructType::HostAssignableHardwareConfig => Some(from.as_any_ref().downcast_ref::<HostAssignableHardwareConfig>()?),
            StructType::HostAssignableHardwareConfigAttributeOverride => Some(from.as_any_ref().downcast_ref::<HostAssignableHardwareConfigAttributeOverride>()?),
            StructType::HostAuthenticationManagerInfo => Some(from.as_any_ref().downcast_ref::<HostAuthenticationManagerInfo>()?),
            StructType::HostAuthenticationStoreInfo => Some(from.as_any_ref().downcast_ref::<HostAuthenticationStoreInfo>()?),
            StructType::HostDirectoryStoreInfo => Some(from.as_any_ref().downcast_ref::<HostDirectoryStoreInfo>()?),
            StructType::HostActiveDirectoryInfo => Some(from.as_any_ref().downcast_ref::<HostActiveDirectoryInfo>()?),
            StructType::HostLocalAuthenticationInfo => Some(from.as_any_ref().downcast_ref::<HostLocalAuthenticationInfo>()?),
            StructType::AutoStartPowerInfo => Some(from.as_any_ref().downcast_ref::<AutoStartPowerInfo>()?),
            StructType::HostAutoStartManagerConfig => Some(from.as_any_ref().downcast_ref::<HostAutoStartManagerConfig>()?),
            StructType::AutoStartDefaults => Some(from.as_any_ref().downcast_ref::<AutoStartDefaults>()?),
            StructType::HostBiosInfo => Some(from.as_any_ref().downcast_ref::<HostBiosInfo>()?),
            StructType::HostBootDeviceInfo => Some(from.as_any_ref().downcast_ref::<HostBootDeviceInfo>()?),
            StructType::HostBootDevice => Some(from.as_any_ref().downcast_ref::<HostBootDevice>()?),
            StructType::HostCacheConfigurationInfo => Some(from.as_any_ref().downcast_ref::<HostCacheConfigurationInfo>()?),
            StructType::HostCacheConfigurationSpec => Some(from.as_any_ref().downcast_ref::<HostCacheConfigurationSpec>()?),
            StructType::HostCapability => Some(from.as_any_ref().downcast_ref::<HostCapability>()?),
            StructType::HostCertificateManagerCertificateInfo => Some(from.as_any_ref().downcast_ref::<HostCertificateManagerCertificateInfo>()?),
            StructType::HostCertificateManagerCertificateSpec => Some(from.as_any_ref().downcast_ref::<HostCertificateManagerCertificateSpec>()?),
            StructType::HostConfigChange => Some(from.as_any_ref().downcast_ref::<HostConfigChange>()?),
            StructType::HostConfigInfo => Some(from.as_any_ref().downcast_ref::<HostConfigInfo>()?),
            StructType::HostConfigManager => Some(from.as_any_ref().downcast_ref::<HostConfigManager>()?),
            StructType::HostConfigSpec => Some(from.as_any_ref().downcast_ref::<HostConfigSpec>()?),
            StructType::HostConnectInfo => Some(from.as_any_ref().downcast_ref::<HostConnectInfo>()?),
            StructType::HostDatastoreConnectInfo => Some(from.as_any_ref().downcast_ref::<HostDatastoreConnectInfo>()?),
            StructType::HostDatastoreExistsConnectInfo => Some(from.as_any_ref().downcast_ref::<HostDatastoreExistsConnectInfo>()?),
            StructType::HostDatastoreNameConflictConnectInfo => Some(from.as_any_ref().downcast_ref::<HostDatastoreNameConflictConnectInfo>()?),
            StructType::HostLicenseConnectInfo => Some(from.as_any_ref().downcast_ref::<HostLicenseConnectInfo>()?),
            StructType::HostConnectInfoNetworkInfo => Some(from.as_any_ref().downcast_ref::<HostConnectInfoNetworkInfo>()?),
            StructType::HostNewNetworkConnectInfo => Some(from.as_any_ref().downcast_ref::<HostNewNetworkConnectInfo>()?),
            StructType::HostConnectSpec => Some(from.as_any_ref().downcast_ref::<HostConnectSpec>()?),
            StructType::HostCpuIdInfo => Some(from.as_any_ref().downcast_ref::<HostCpuIdInfo>()?),
            StructType::HostCpuInfo => Some(from.as_any_ref().downcast_ref::<HostCpuInfo>()?),
            StructType::HostCpuPackage => Some(from.as_any_ref().downcast_ref::<HostCpuPackage>()?),
            StructType::HostCpuPowerManagementInfo => Some(from.as_any_ref().downcast_ref::<HostCpuPowerManagementInfo>()?),
            StructType::HostHyperThreadScheduleInfo => Some(from.as_any_ref().downcast_ref::<HostHyperThreadScheduleInfo>()?),
            StructType::HostDataTransportConnectionInfo => Some(from.as_any_ref().downcast_ref::<HostDataTransportConnectionInfo>()?),
            StructType::HostNfcConnectionInfo => Some(from.as_any_ref().downcast_ref::<HostNfcConnectionInfo>()?),
            StructType::FileInfo => Some(from.as_any_ref().downcast_ref::<FileInfo>()?),
            StructType::FloppyImageFileInfo => Some(from.as_any_ref().downcast_ref::<FloppyImageFileInfo>()?),
            StructType::FolderFileInfo => Some(from.as_any_ref().downcast_ref::<FolderFileInfo>()?),
            StructType::IsoImageFileInfo => Some(from.as_any_ref().downcast_ref::<IsoImageFileInfo>()?),
            StructType::VmConfigFileInfo => Some(from.as_any_ref().downcast_ref::<VmConfigFileInfo>()?),
            StructType::TemplateConfigFileInfo => Some(from.as_any_ref().downcast_ref::<TemplateConfigFileInfo>()?),
            StructType::VmDiskFileInfo => Some(from.as_any_ref().downcast_ref::<VmDiskFileInfo>()?),
            StructType::VmLogFileInfo => Some(from.as_any_ref().downcast_ref::<VmLogFileInfo>()?),
            StructType::VmNvramFileInfo => Some(from.as_any_ref().downcast_ref::<VmNvramFileInfo>()?),
            StructType::VmSnapshotFileInfo => Some(from.as_any_ref().downcast_ref::<VmSnapshotFileInfo>()?),
            StructType::FileQueryFlags => Some(from.as_any_ref().downcast_ref::<FileQueryFlags>()?),
            StructType::FileQuery => Some(from.as_any_ref().downcast_ref::<FileQuery>()?),
            StructType::FloppyImageFileQuery => Some(from.as_any_ref().downcast_ref::<FloppyImageFileQuery>()?),
            StructType::FolderFileQuery => Some(from.as_any_ref().downcast_ref::<FolderFileQuery>()?),
            StructType::IsoImageFileQuery => Some(from.as_any_ref().downcast_ref::<IsoImageFileQuery>()?),
            StructType::VmConfigFileQuery => Some(from.as_any_ref().downcast_ref::<VmConfigFileQuery>()?),
            StructType::TemplateConfigFileQuery => Some(from.as_any_ref().downcast_ref::<TemplateConfigFileQuery>()?),
            StructType::VmDiskFileQuery => Some(from.as_any_ref().downcast_ref::<VmDiskFileQuery>()?),
            StructType::VmLogFileQuery => Some(from.as_any_ref().downcast_ref::<VmLogFileQuery>()?),
            StructType::VmNvramFileQuery => Some(from.as_any_ref().downcast_ref::<VmNvramFileQuery>()?),
            StructType::VmSnapshotFileQuery => Some(from.as_any_ref().downcast_ref::<VmSnapshotFileQuery>()?),
            StructType::HostDatastoreBrowserSearchResults => Some(from.as_any_ref().downcast_ref::<HostDatastoreBrowserSearchResults>()?),
            StructType::HostDatastoreBrowserSearchSpec => Some(from.as_any_ref().downcast_ref::<HostDatastoreBrowserSearchSpec>()?),
            StructType::VmConfigFileEncryptionInfo => Some(from.as_any_ref().downcast_ref::<VmConfigFileEncryptionInfo>()?),
            StructType::VmConfigFileQueryFlags => Some(from.as_any_ref().downcast_ref::<VmConfigFileQueryFlags>()?),
            StructType::VmConfigFileQueryFilter => Some(from.as_any_ref().downcast_ref::<VmConfigFileQueryFilter>()?),
            StructType::VmDiskFileEncryptionInfo => Some(from.as_any_ref().downcast_ref::<VmDiskFileEncryptionInfo>()?),
            StructType::VmDiskFileQueryFlags => Some(from.as_any_ref().downcast_ref::<VmDiskFileQueryFlags>()?),
            StructType::VmDiskFileQueryFilter => Some(from.as_any_ref().downcast_ref::<VmDiskFileQueryFilter>()?),
            StructType::HostDatastoreSystemCapabilities => Some(from.as_any_ref().downcast_ref::<HostDatastoreSystemCapabilities>()?),
            StructType::HostDatastoreSystemDatastoreResult => Some(from.as_any_ref().downcast_ref::<HostDatastoreSystemDatastoreResult>()?),
            StructType::HostDatastoreSystemVvolDatastoreSpec => Some(from.as_any_ref().downcast_ref::<HostDatastoreSystemVvolDatastoreSpec>()?),
            StructType::HostDateTimeConfig => Some(from.as_any_ref().downcast_ref::<HostDateTimeConfig>()?),
            StructType::HostDateTimeInfo => Some(from.as_any_ref().downcast_ref::<HostDateTimeInfo>()?),
            StructType::HostDateTimeSystemServiceTestResult => Some(from.as_any_ref().downcast_ref::<HostDateTimeSystemServiceTestResult>()?),
            StructType::HostDateTimeSystemTimeZone => Some(from.as_any_ref().downcast_ref::<HostDateTimeSystemTimeZone>()?),
            StructType::HostDeploymentInfo => Some(from.as_any_ref().downcast_ref::<HostDeploymentInfo>()?),
            StructType::HostDevice => Some(from.as_any_ref().downcast_ref::<HostDevice>()?),
            StructType::ScsiLun => Some(from.as_any_ref().downcast_ref::<ScsiLun>()?),
            StructType::HostScsiDisk => Some(from.as_any_ref().downcast_ref::<HostScsiDisk>()?),
            StructType::HostDhcpService => Some(from.as_any_ref().downcast_ref::<HostDhcpService>()?),
            StructType::HostDhcpServiceConfig => Some(from.as_any_ref().downcast_ref::<HostDhcpServiceConfig>()?),
            StructType::HostDhcpServiceSpec => Some(from.as_any_ref().downcast_ref::<HostDhcpServiceSpec>()?),
            StructType::HostDiagnosticPartition => Some(from.as_any_ref().downcast_ref::<HostDiagnosticPartition>()?),
            StructType::HostDiagnosticPartitionCreateDescription => Some(from.as_any_ref().downcast_ref::<HostDiagnosticPartitionCreateDescription>()?),
            StructType::HostDiagnosticPartitionCreateOption => Some(from.as_any_ref().downcast_ref::<HostDiagnosticPartitionCreateOption>()?),
            StructType::HostDiagnosticPartitionCreateSpec => Some(from.as_any_ref().downcast_ref::<HostDiagnosticPartitionCreateSpec>()?),
            StructType::HostDigestInfo => Some(from.as_any_ref().downcast_ref::<HostDigestInfo>()?),
            StructType::HostTpmDigestInfo => Some(from.as_any_ref().downcast_ref::<HostTpmDigestInfo>()?),
            StructType::HostDiskConfigurationResult => Some(from.as_any_ref().downcast_ref::<HostDiskConfigurationResult>()?),
            StructType::HostDiskDimensions => Some(from.as_any_ref().downcast_ref::<HostDiskDimensions>()?),
            StructType::HostDiskDimensionsChs => Some(from.as_any_ref().downcast_ref::<HostDiskDimensionsChs>()?),
            StructType::HostDiskDimensionsLba => Some(from.as_any_ref().downcast_ref::<HostDiskDimensionsLba>()?),
            StructType::HostDiskPartitionInfo => Some(from.as_any_ref().downcast_ref::<HostDiskPartitionInfo>()?),
            StructType::HostDiskPartitionBlockRange => Some(from.as_any_ref().downcast_ref::<HostDiskPartitionBlockRange>()?),
            StructType::HostDiskPartitionLayout => Some(from.as_any_ref().downcast_ref::<HostDiskPartitionLayout>()?),
            StructType::HostDiskPartitionAttributes => Some(from.as_any_ref().downcast_ref::<HostDiskPartitionAttributes>()?),
            StructType::HostDiskPartitionSpec => Some(from.as_any_ref().downcast_ref::<HostDiskPartitionSpec>()?),
            StructType::HostDnsConfig => Some(from.as_any_ref().downcast_ref::<HostDnsConfig>()?),
            StructType::HostDnsConfigSpec => Some(from.as_any_ref().downcast_ref::<HostDnsConfigSpec>()?),
            StructType::HostDvxClass => Some(from.as_any_ref().downcast_ref::<HostDvxClass>()?),
            StructType::HostEnterMaintenanceResult => Some(from.as_any_ref().downcast_ref::<HostEnterMaintenanceResult>()?),
            StructType::HostEsxAgentHostManagerConfigInfo => Some(from.as_any_ref().downcast_ref::<HostEsxAgentHostManagerConfigInfo>()?),
            StructType::HostFaultToleranceManagerComponentHealthInfo => Some(from.as_any_ref().downcast_ref::<HostFaultToleranceManagerComponentHealthInfo>()?),
            StructType::FcoeConfig => Some(from.as_any_ref().downcast_ref::<FcoeConfig>()?),
            StructType::FcoeConfigFcoeCapabilities => Some(from.as_any_ref().downcast_ref::<FcoeConfigFcoeCapabilities>()?),
            StructType::FcoeConfigFcoeSpecification => Some(from.as_any_ref().downcast_ref::<FcoeConfigFcoeSpecification>()?),
            StructType::FcoeConfigVlanRange => Some(from.as_any_ref().downcast_ref::<FcoeConfigVlanRange>()?),
            StructType::HostFeatureCapability => Some(from.as_any_ref().downcast_ref::<HostFeatureCapability>()?),
            StructType::HostFeatureMask => Some(from.as_any_ref().downcast_ref::<HostFeatureMask>()?),
            StructType::HostFeatureVersionInfo => Some(from.as_any_ref().downcast_ref::<HostFeatureVersionInfo>()?),
            StructType::HostFibreChannelOverEthernetHbaLinkInfo => Some(from.as_any_ref().downcast_ref::<HostFibreChannelOverEthernetHbaLinkInfo>()?),
            StructType::HostFileAccess => Some(from.as_any_ref().downcast_ref::<HostFileAccess>()?),
            StructType::ModeInfo => Some(from.as_any_ref().downcast_ref::<ModeInfo>()?),
            StructType::HostFileSystemMountInfo => Some(from.as_any_ref().downcast_ref::<HostFileSystemMountInfo>()?),
            StructType::HostFileSystemVolume => Some(from.as_any_ref().downcast_ref::<HostFileSystemVolume>()?),
            StructType::HostLocalFileSystemVolume => Some(from.as_any_ref().downcast_ref::<HostLocalFileSystemVolume>()?),
            StructType::HostNasVolume => Some(from.as_any_ref().downcast_ref::<HostNasVolume>()?),
            StructType::HostPMemVolume => Some(from.as_any_ref().downcast_ref::<HostPMemVolume>()?),
            StructType::HostVfatVolume => Some(from.as_any_ref().downcast_ref::<HostVfatVolume>()?),
            StructType::HostVffsVolume => Some(from.as_any_ref().downcast_ref::<HostVffsVolume>()?),
            StructType::HostVmfsVolume => Some(from.as_any_ref().downcast_ref::<HostVmfsVolume>()?),
            StructType::HostVvolVolume => Some(from.as_any_ref().downcast_ref::<HostVvolVolume>()?),
            StructType::HostFileSystemVolumeInfo => Some(from.as_any_ref().downcast_ref::<HostFileSystemVolumeInfo>()?),
            StructType::HostFirewallConfig => Some(from.as_any_ref().downcast_ref::<HostFirewallConfig>()?),
            StructType::HostFirewallConfigRuleSetConfig => Some(from.as_any_ref().downcast_ref::<HostFirewallConfigRuleSetConfig>()?),
            StructType::HostFirewallInfo => Some(from.as_any_ref().downcast_ref::<HostFirewallInfo>()?),
            StructType::HostFirewallDefaultPolicy => Some(from.as_any_ref().downcast_ref::<HostFirewallDefaultPolicy>()?),
            StructType::HostFlagInfo => Some(from.as_any_ref().downcast_ref::<HostFlagInfo>()?),
            StructType::HostForceMountedInfo => Some(from.as_any_ref().downcast_ref::<HostForceMountedInfo>()?),
            StructType::HostFru => Some(from.as_any_ref().downcast_ref::<HostFru>()?),
            StructType::HostGatewaySpec => Some(from.as_any_ref().downcast_ref::<HostGatewaySpec>()?),
            StructType::HostGraphicsConfig => Some(from.as_any_ref().downcast_ref::<HostGraphicsConfig>()?),
            StructType::HostGraphicsConfigDeviceType => Some(from.as_any_ref().downcast_ref::<HostGraphicsConfigDeviceType>()?),
            StructType::HostGraphicsInfo => Some(from.as_any_ref().downcast_ref::<HostGraphicsInfo>()?),
            StructType::HostHardwareInfo => Some(from.as_any_ref().downcast_ref::<HostHardwareInfo>()?),
            StructType::HostHardwareStatusInfo => Some(from.as_any_ref().downcast_ref::<HostHardwareStatusInfo>()?),
            StructType::DpuStatusInfoOperationalInfo => Some(from.as_any_ref().downcast_ref::<DpuStatusInfoOperationalInfo>()?),
            StructType::HostHardwareElementInfo => Some(from.as_any_ref().downcast_ref::<HostHardwareElementInfo>()?),
            StructType::DpuStatusInfo => Some(from.as_any_ref().downcast_ref::<DpuStatusInfo>()?),
            StructType::HostStorageElementInfo => Some(from.as_any_ref().downcast_ref::<HostStorageElementInfo>()?),
            StructType::HostStorageOperationalInfo => Some(from.as_any_ref().downcast_ref::<HostStorageOperationalInfo>()?),
            StructType::HostHbaCreateSpec => Some(from.as_any_ref().downcast_ref::<HostHbaCreateSpec>()?),
            StructType::HostTcpHbaCreateSpec => Some(from.as_any_ref().downcast_ref::<HostTcpHbaCreateSpec>()?),
            StructType::HealthSystemRuntime => Some(from.as_any_ref().downcast_ref::<HealthSystemRuntime>()?),
            StructType::HostAccessControlEntry => Some(from.as_any_ref().downcast_ref::<HostAccessControlEntry>()?),
            StructType::HostHostBusAdapter => Some(from.as_any_ref().downcast_ref::<HostHostBusAdapter>()?),
            StructType::HostBlockHba => Some(from.as_any_ref().downcast_ref::<HostBlockHba>()?),
            StructType::HostFibreChannelHba => Some(from.as_any_ref().downcast_ref::<HostFibreChannelHba>()?),
            StructType::HostFibreChannelOverEthernetHba => Some(from.as_any_ref().downcast_ref::<HostFibreChannelOverEthernetHba>()?),
            StructType::HostInternetScsiHba => Some(from.as_any_ref().downcast_ref::<HostInternetScsiHba>()?),
            StructType::HostParallelScsiHba => Some(from.as_any_ref().downcast_ref::<HostParallelScsiHba>()?),
            StructType::HostPcieHba => Some(from.as_any_ref().downcast_ref::<HostPcieHba>()?),
            StructType::HostRdmaHba => Some(from.as_any_ref().downcast_ref::<HostRdmaHba>()?),
            StructType::HostSerialAttachedHba => Some(from.as_any_ref().downcast_ref::<HostSerialAttachedHba>()?),
            StructType::HostTcpHba => Some(from.as_any_ref().downcast_ref::<HostTcpHba>()?),
            StructType::HostProxySwitch => Some(from.as_any_ref().downcast_ref::<HostProxySwitch>()?),
            StructType::HostProxySwitchConfig => Some(from.as_any_ref().downcast_ref::<HostProxySwitchConfig>()?),
            StructType::HostProxySwitchEnsInfo => Some(from.as_any_ref().downcast_ref::<HostProxySwitchEnsInfo>()?),
            StructType::HostProxySwitchHostLagConfig => Some(from.as_any_ref().downcast_ref::<HostProxySwitchHostLagConfig>()?),
            StructType::HostProxySwitchSpec => Some(from.as_any_ref().downcast_ref::<HostProxySwitchSpec>()?),
            StructType::HostImageProfileSummary => Some(from.as_any_ref().downcast_ref::<HostImageProfileSummary>()?),
            StructType::HostInternetScsiHbaAuthenticationCapabilities => Some(from.as_any_ref().downcast_ref::<HostInternetScsiHbaAuthenticationCapabilities>()?),
            StructType::HostInternetScsiHbaAuthenticationProperties => Some(from.as_any_ref().downcast_ref::<HostInternetScsiHbaAuthenticationProperties>()?),
            StructType::HostInternetScsiHbaDigestCapabilities => Some(from.as_any_ref().downcast_ref::<HostInternetScsiHbaDigestCapabilities>()?),
            StructType::HostInternetScsiHbaDigestProperties => Some(from.as_any_ref().downcast_ref::<HostInternetScsiHbaDigestProperties>()?),
            StructType::HostInternetScsiHbaDiscoveryCapabilities => Some(from.as_any_ref().downcast_ref::<HostInternetScsiHbaDiscoveryCapabilities>()?),
            StructType::HostInternetScsiHbaDiscoveryProperties => Some(from.as_any_ref().downcast_ref::<HostInternetScsiHbaDiscoveryProperties>()?),
            StructType::HostInternetScsiHbaIpCapabilities => Some(from.as_any_ref().downcast_ref::<HostInternetScsiHbaIpCapabilities>()?),
            StructType::HostInternetScsiHbaIpProperties => Some(from.as_any_ref().downcast_ref::<HostInternetScsiHbaIpProperties>()?),
            StructType::HostInternetScsiHbaIPv6Properties => Some(from.as_any_ref().downcast_ref::<HostInternetScsiHbaIPv6Properties>()?),
            StructType::HostInternetScsiHbaIscsiIpv6Address => Some(from.as_any_ref().downcast_ref::<HostInternetScsiHbaIscsiIpv6Address>()?),
            StructType::HostInternetScsiHbaSendTarget => Some(from.as_any_ref().downcast_ref::<HostInternetScsiHbaSendTarget>()?),
            StructType::HostInternetScsiHbaStaticTarget => Some(from.as_any_ref().downcast_ref::<HostInternetScsiHbaStaticTarget>()?),
            StructType::HostInternetScsiHbaTargetSet => Some(from.as_any_ref().downcast_ref::<HostInternetScsiHbaTargetSet>()?),
            StructType::HostIpConfig => Some(from.as_any_ref().downcast_ref::<HostIpConfig>()?),
            StructType::HostIpConfigIpV6Address => Some(from.as_any_ref().downcast_ref::<HostIpConfigIpV6Address>()?),
            StructType::HostIpConfigIpV6AddressConfiguration => Some(from.as_any_ref().downcast_ref::<HostIpConfigIpV6AddressConfiguration>()?),
            StructType::HostIpRouteConfig => Some(from.as_any_ref().downcast_ref::<HostIpRouteConfig>()?),
            StructType::HostIpRouteConfigSpec => Some(from.as_any_ref().downcast_ref::<HostIpRouteConfigSpec>()?),
            StructType::HostIpRouteEntry => Some(from.as_any_ref().downcast_ref::<HostIpRouteEntry>()?),
            StructType::HostIpRouteOp => Some(from.as_any_ref().downcast_ref::<HostIpRouteOp>()?),
            StructType::HostIpRouteTableConfig => Some(from.as_any_ref().downcast_ref::<HostIpRouteTableConfig>()?),
            StructType::HostIpRouteTableInfo => Some(from.as_any_ref().downcast_ref::<HostIpRouteTableInfo>()?),
            StructType::HostIpmiInfo => Some(from.as_any_ref().downcast_ref::<HostIpmiInfo>()?),
            StructType::IscsiDependencyEntity => Some(from.as_any_ref().downcast_ref::<IscsiDependencyEntity>()?),
            StructType::IscsiMigrationDependency => Some(from.as_any_ref().downcast_ref::<IscsiMigrationDependency>()?),
            StructType::IscsiPortInfo => Some(from.as_any_ref().downcast_ref::<IscsiPortInfo>()?),
            StructType::IscsiStatus => Some(from.as_any_ref().downcast_ref::<IscsiStatus>()?),
            StructType::KernelModuleInfo => Some(from.as_any_ref().downcast_ref::<KernelModuleInfo>()?),
            StructType::KernelModuleSectionInfo => Some(from.as_any_ref().downcast_ref::<KernelModuleSectionInfo>()?),
            StructType::HostLicenseSpec => Some(from.as_any_ref().downcast_ref::<HostLicenseSpec>()?),
            StructType::LinkDiscoveryProtocolConfig => Some(from.as_any_ref().downcast_ref::<LinkDiscoveryProtocolConfig>()?),
            StructType::HostAccountSpec => Some(from.as_any_ref().downcast_ref::<HostAccountSpec>()?),
            StructType::HostPosixAccountSpec => Some(from.as_any_ref().downcast_ref::<HostPosixAccountSpec>()?),
            StructType::HostLocalFileSystemVolumeSpec => Some(from.as_any_ref().downcast_ref::<HostLocalFileSystemVolumeSpec>()?),
            StructType::HostLowLevelProvisioningManagerDiskLayoutSpec => Some(from.as_any_ref().downcast_ref::<HostLowLevelProvisioningManagerDiskLayoutSpec>()?),
            StructType::HostLowLevelProvisioningManagerFileDeleteResult => Some(from.as_any_ref().downcast_ref::<HostLowLevelProvisioningManagerFileDeleteResult>()?),
            StructType::HostLowLevelProvisioningManagerFileDeleteSpec => Some(from.as_any_ref().downcast_ref::<HostLowLevelProvisioningManagerFileDeleteSpec>()?),
            StructType::HostLowLevelProvisioningManagerFileReserveResult => Some(from.as_any_ref().downcast_ref::<HostLowLevelProvisioningManagerFileReserveResult>()?),
            StructType::HostLowLevelProvisioningManagerFileReserveSpec => Some(from.as_any_ref().downcast_ref::<HostLowLevelProvisioningManagerFileReserveSpec>()?),
            StructType::HostLowLevelProvisioningManagerSnapshotLayoutSpec => Some(from.as_any_ref().downcast_ref::<HostLowLevelProvisioningManagerSnapshotLayoutSpec>()?),
            StructType::HostLowLevelProvisioningManagerVmMigrationStatus => Some(from.as_any_ref().downcast_ref::<HostLowLevelProvisioningManagerVmMigrationStatus>()?),
            StructType::HostLowLevelProvisioningManagerVmRecoveryInfo => Some(from.as_any_ref().downcast_ref::<HostLowLevelProvisioningManagerVmRecoveryInfo>()?),
            StructType::HostMaintenanceSpec => Some(from.as_any_ref().downcast_ref::<HostMaintenanceSpec>()?),
            StructType::ServiceConsoleReservationInfo => Some(from.as_any_ref().downcast_ref::<ServiceConsoleReservationInfo>()?),
            StructType::VirtualMachineMemoryReservationInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineMemoryReservationInfo>()?),
            StructType::VirtualMachineMemoryReservationSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineMemoryReservationSpec>()?),
            StructType::HostMemorySpec => Some(from.as_any_ref().downcast_ref::<HostMemorySpec>()?),
            StructType::HostMemoryTierInfo => Some(from.as_any_ref().downcast_ref::<HostMemoryTierInfo>()?),
            StructType::HostMountInfo => Some(from.as_any_ref().downcast_ref::<HostMountInfo>()?),
            StructType::HostMultipathInfo => Some(from.as_any_ref().downcast_ref::<HostMultipathInfo>()?),
            StructType::HostMultipathInfoLogicalUnit => Some(from.as_any_ref().downcast_ref::<HostMultipathInfoLogicalUnit>()?),
            StructType::HostMultipathInfoLogicalUnitPolicy => Some(from.as_any_ref().downcast_ref::<HostMultipathInfoLogicalUnitPolicy>()?),
            StructType::HostMultipathInfoFixedLogicalUnitPolicy => Some(from.as_any_ref().downcast_ref::<HostMultipathInfoFixedLogicalUnitPolicy>()?),
            StructType::HostMultipathInfoHppLogicalUnitPolicy => Some(from.as_any_ref().downcast_ref::<HostMultipathInfoHppLogicalUnitPolicy>()?),
            StructType::HostMultipathInfoLogicalUnitStorageArrayTypePolicy => Some(from.as_any_ref().downcast_ref::<HostMultipathInfoLogicalUnitStorageArrayTypePolicy>()?),
            StructType::HostMultipathInfoPath => Some(from.as_any_ref().downcast_ref::<HostMultipathInfoPath>()?),
            StructType::HostMultipathStateInfo => Some(from.as_any_ref().downcast_ref::<HostMultipathStateInfo>()?),
            StructType::HostMultipathStateInfoPath => Some(from.as_any_ref().downcast_ref::<HostMultipathStateInfoPath>()?),
            StructType::HostNasVolumeConfig => Some(from.as_any_ref().downcast_ref::<HostNasVolumeConfig>()?),
            StructType::HostNasVolumeSpec => Some(from.as_any_ref().downcast_ref::<HostNasVolumeSpec>()?),
            StructType::HostNasVolumeUserInfo => Some(from.as_any_ref().downcast_ref::<HostNasVolumeUserInfo>()?),
            StructType::HostNatService => Some(from.as_any_ref().downcast_ref::<HostNatService>()?),
            StructType::HostNatServiceConfig => Some(from.as_any_ref().downcast_ref::<HostNatServiceConfig>()?),
            StructType::HostNatServiceNameServiceSpec => Some(from.as_any_ref().downcast_ref::<HostNatServiceNameServiceSpec>()?),
            StructType::HostNatServicePortForwardSpec => Some(from.as_any_ref().downcast_ref::<HostNatServicePortForwardSpec>()?),
            StructType::HostNatServiceSpec => Some(from.as_any_ref().downcast_ref::<HostNatServiceSpec>()?),
            StructType::HostNetCapabilities => Some(from.as_any_ref().downcast_ref::<HostNetCapabilities>()?),
            StructType::HostNetOffloadCapabilities => Some(from.as_any_ref().downcast_ref::<HostNetOffloadCapabilities>()?),
            StructType::HostNetStackInstance => Some(from.as_any_ref().downcast_ref::<HostNetStackInstance>()?),
            StructType::HostNetworkConfig => Some(from.as_any_ref().downcast_ref::<HostNetworkConfig>()?),
            StructType::HostNetworkConfigNetStackSpec => Some(from.as_any_ref().downcast_ref::<HostNetworkConfigNetStackSpec>()?),
            StructType::HostNetworkConfigResult => Some(from.as_any_ref().downcast_ref::<HostNetworkConfigResult>()?),
            StructType::HostNetworkInfo => Some(from.as_any_ref().downcast_ref::<HostNetworkInfo>()?),
            StructType::HostNetworkPolicy => Some(from.as_any_ref().downcast_ref::<HostNetworkPolicy>()?),
            StructType::HostNicFailureCriteria => Some(from.as_any_ref().downcast_ref::<HostNicFailureCriteria>()?),
            StructType::HostNicOrderPolicy => Some(from.as_any_ref().downcast_ref::<HostNicOrderPolicy>()?),
            StructType::HostNicTeamingPolicy => Some(from.as_any_ref().downcast_ref::<HostNicTeamingPolicy>()?),
            StructType::HostNetworkSecurityPolicy => Some(from.as_any_ref().downcast_ref::<HostNetworkSecurityPolicy>()?),
            StructType::HostNetworkTrafficShapingPolicy => Some(from.as_any_ref().downcast_ref::<HostNetworkTrafficShapingPolicy>()?),
            StructType::HostNtpConfig => Some(from.as_any_ref().downcast_ref::<HostNtpConfig>()?),
            StructType::HostNumaInfo => Some(from.as_any_ref().downcast_ref::<HostNumaInfo>()?),
            StructType::HostNumaNode => Some(from.as_any_ref().downcast_ref::<HostNumaNode>()?),
            StructType::HostNumericSensorInfo => Some(from.as_any_ref().downcast_ref::<HostNumericSensorInfo>()?),
            StructType::NvdimmDimmInfo => Some(from.as_any_ref().downcast_ref::<NvdimmDimmInfo>()?),
            StructType::NvdimmGuid => Some(from.as_any_ref().downcast_ref::<NvdimmGuid>()?),
            StructType::NvdimmHealthInfo => Some(from.as_any_ref().downcast_ref::<NvdimmHealthInfo>()?),
            StructType::NvdimmInterleaveSetInfo => Some(from.as_any_ref().downcast_ref::<NvdimmInterleaveSetInfo>()?),
            StructType::NvdimmNamespaceCreateSpec => Some(from.as_any_ref().downcast_ref::<NvdimmNamespaceCreateSpec>()?),
            StructType::NvdimmNamespaceDeleteSpec => Some(from.as_any_ref().downcast_ref::<NvdimmNamespaceDeleteSpec>()?),
            StructType::NvdimmNamespaceDetails => Some(from.as_any_ref().downcast_ref::<NvdimmNamespaceDetails>()?),
            StructType::NvdimmNamespaceInfo => Some(from.as_any_ref().downcast_ref::<NvdimmNamespaceInfo>()?),
            StructType::NvdimmSystemInfo => Some(from.as_any_ref().downcast_ref::<NvdimmSystemInfo>()?),
            StructType::NvdimmPMemNamespaceCreateSpec => Some(from.as_any_ref().downcast_ref::<NvdimmPMemNamespaceCreateSpec>()?),
            StructType::NvdimmRegionInfo => Some(from.as_any_ref().downcast_ref::<NvdimmRegionInfo>()?),
            StructType::NvdimmSummary => Some(from.as_any_ref().downcast_ref::<NvdimmSummary>()?),
            StructType::HostNvmeController => Some(from.as_any_ref().downcast_ref::<HostNvmeController>()?),
            StructType::HostNvmeDisconnectSpec => Some(from.as_any_ref().downcast_ref::<HostNvmeDisconnectSpec>()?),
            StructType::HostNvmeDiscoveryLog => Some(from.as_any_ref().downcast_ref::<HostNvmeDiscoveryLog>()?),
            StructType::HostNvmeDiscoveryLogEntry => Some(from.as_any_ref().downcast_ref::<HostNvmeDiscoveryLogEntry>()?),
            StructType::HostNvmeNamespace => Some(from.as_any_ref().downcast_ref::<HostNvmeNamespace>()?),
            StructType::HostNvmeSpec => Some(from.as_any_ref().downcast_ref::<HostNvmeSpec>()?),
            StructType::HostNvmeConnectSpec => Some(from.as_any_ref().downcast_ref::<HostNvmeConnectSpec>()?),
            StructType::HostNvmeDiscoverSpec => Some(from.as_any_ref().downcast_ref::<HostNvmeDiscoverSpec>()?),
            StructType::HostNvmeTopology => Some(from.as_any_ref().downcast_ref::<HostNvmeTopology>()?),
            StructType::HostNvmeTopologyInterface => Some(from.as_any_ref().downcast_ref::<HostNvmeTopologyInterface>()?),
            StructType::HostNvmeTransportParameters => Some(from.as_any_ref().downcast_ref::<HostNvmeTransportParameters>()?),
            StructType::HostNvmeOpaqueTransportParameters => Some(from.as_any_ref().downcast_ref::<HostNvmeOpaqueTransportParameters>()?),
            StructType::HostNvmeOverFibreChannelParameters => Some(from.as_any_ref().downcast_ref::<HostNvmeOverFibreChannelParameters>()?),
            StructType::HostNvmeOverRdmaParameters => Some(from.as_any_ref().downcast_ref::<HostNvmeOverRdmaParameters>()?),
            StructType::HostNvmeOverTcpParameters => Some(from.as_any_ref().downcast_ref::<HostNvmeOverTcpParameters>()?),
            StructType::HostOpaqueNetworkInfo => Some(from.as_any_ref().downcast_ref::<HostOpaqueNetworkInfo>()?),
            StructType::HostOpaqueSwitch => Some(from.as_any_ref().downcast_ref::<HostOpaqueSwitch>()?),
            StructType::HostOpaqueSwitchPhysicalNicZone => Some(from.as_any_ref().downcast_ref::<HostOpaqueSwitchPhysicalNicZone>()?),
            StructType::HostPatchManagerLocator => Some(from.as_any_ref().downcast_ref::<HostPatchManagerLocator>()?),
            StructType::HostPatchManagerPatchManagerOperationSpec => Some(from.as_any_ref().downcast_ref::<HostPatchManagerPatchManagerOperationSpec>()?),
            StructType::HostPatchManagerResult => Some(from.as_any_ref().downcast_ref::<HostPatchManagerResult>()?),
            StructType::HostPatchManagerStatus => Some(from.as_any_ref().downcast_ref::<HostPatchManagerStatus>()?),
            StructType::HostPatchManagerStatusPrerequisitePatch => Some(from.as_any_ref().downcast_ref::<HostPatchManagerStatusPrerequisitePatch>()?),
            StructType::HostPathSelectionPolicyOption => Some(from.as_any_ref().downcast_ref::<HostPathSelectionPolicyOption>()?),
            StructType::HostPciDevice => Some(from.as_any_ref().downcast_ref::<HostPciDevice>()?),
            StructType::HostPciPassthruConfig => Some(from.as_any_ref().downcast_ref::<HostPciPassthruConfig>()?),
            StructType::HostSriovConfig => Some(from.as_any_ref().downcast_ref::<HostSriovConfig>()?),
            StructType::HostPciPassthruInfo => Some(from.as_any_ref().downcast_ref::<HostPciPassthruInfo>()?),
            StructType::HostSriovInfo => Some(from.as_any_ref().downcast_ref::<HostSriovInfo>()?),
            StructType::HostPersistentMemoryInfo => Some(from.as_any_ref().downcast_ref::<HostPersistentMemoryInfo>()?),
            StructType::PhysicalNic => Some(from.as_any_ref().downcast_ref::<PhysicalNic>()?),
            StructType::PhysicalNicCdpDeviceCapability => Some(from.as_any_ref().downcast_ref::<PhysicalNicCdpDeviceCapability>()?),
            StructType::PhysicalNicCdpInfo => Some(from.as_any_ref().downcast_ref::<PhysicalNicCdpInfo>()?),
            StructType::PhysicalNicConfig => Some(from.as_any_ref().downcast_ref::<PhysicalNicConfig>()?),
            StructType::PhysicalNicLinkInfo => Some(from.as_any_ref().downcast_ref::<PhysicalNicLinkInfo>()?),
            StructType::LinkLayerDiscoveryProtocolInfo => Some(from.as_any_ref().downcast_ref::<LinkLayerDiscoveryProtocolInfo>()?),
            StructType::PhysicalNicHintInfo => Some(from.as_any_ref().downcast_ref::<PhysicalNicHintInfo>()?),
            StructType::PhysicalNicHint => Some(from.as_any_ref().downcast_ref::<PhysicalNicHint>()?),
            StructType::PhysicalNicIpHint => Some(from.as_any_ref().downcast_ref::<PhysicalNicIpHint>()?),
            StructType::PhysicalNicNameHint => Some(from.as_any_ref().downcast_ref::<PhysicalNicNameHint>()?),
            StructType::PhysicalNicSpec => Some(from.as_any_ref().downcast_ref::<PhysicalNicSpec>()?),
            StructType::HostPlugStoreTopology => Some(from.as_any_ref().downcast_ref::<HostPlugStoreTopology>()?),
            StructType::HostPlugStoreTopologyAdapter => Some(from.as_any_ref().downcast_ref::<HostPlugStoreTopologyAdapter>()?),
            StructType::HostPlugStoreTopologyDevice => Some(from.as_any_ref().downcast_ref::<HostPlugStoreTopologyDevice>()?),
            StructType::HostPlugStoreTopologyPath => Some(from.as_any_ref().downcast_ref::<HostPlugStoreTopologyPath>()?),
            StructType::HostPlugStoreTopologyPlugin => Some(from.as_any_ref().downcast_ref::<HostPlugStoreTopologyPlugin>()?),
            StructType::HostPlugStoreTopologyTarget => Some(from.as_any_ref().downcast_ref::<HostPlugStoreTopologyTarget>()?),
            StructType::HostPortGroup => Some(from.as_any_ref().downcast_ref::<HostPortGroup>()?),
            StructType::HostPortGroupConfig => Some(from.as_any_ref().downcast_ref::<HostPortGroupConfig>()?),
            StructType::HostPortGroupPort => Some(from.as_any_ref().downcast_ref::<HostPortGroupPort>()?),
            StructType::HostPortGroupSpec => Some(from.as_any_ref().downcast_ref::<HostPortGroupSpec>()?),
            StructType::PowerSystemCapability => Some(from.as_any_ref().downcast_ref::<PowerSystemCapability>()?),
            StructType::PowerSystemInfo => Some(from.as_any_ref().downcast_ref::<PowerSystemInfo>()?),
            StructType::HostPowerPolicy => Some(from.as_any_ref().downcast_ref::<HostPowerPolicy>()?),
            StructType::HostProtocolEndpoint => Some(from.as_any_ref().downcast_ref::<HostProtocolEndpoint>()?),
            StructType::HostPtpConfig => Some(from.as_any_ref().downcast_ref::<HostPtpConfig>()?),
            StructType::HostPtpConfigPtpPort => Some(from.as_any_ref().downcast_ref::<HostPtpConfigPtpPort>()?),
            StructType::HostQualifiedName => Some(from.as_any_ref().downcast_ref::<HostQualifiedName>()?),
            StructType::HostRdmaDevice => Some(from.as_any_ref().downcast_ref::<HostRdmaDevice>()?),
            StructType::HostRdmaDeviceBacking => Some(from.as_any_ref().downcast_ref::<HostRdmaDeviceBacking>()?),
            StructType::HostRdmaDevicePnicBacking => Some(from.as_any_ref().downcast_ref::<HostRdmaDevicePnicBacking>()?),
            StructType::HostRdmaDeviceCapability => Some(from.as_any_ref().downcast_ref::<HostRdmaDeviceCapability>()?),
            StructType::HostRdmaDeviceConnectionInfo => Some(from.as_any_ref().downcast_ref::<HostRdmaDeviceConnectionInfo>()?),
            StructType::HostReliableMemoryInfo => Some(from.as_any_ref().downcast_ref::<HostReliableMemoryInfo>()?),
            StructType::HostResignatureRescanResult => Some(from.as_any_ref().downcast_ref::<HostResignatureRescanResult>()?),
            StructType::HostFirewallRuleset => Some(from.as_any_ref().downcast_ref::<HostFirewallRuleset>()?),
            StructType::HostFirewallRulesetIpList => Some(from.as_any_ref().downcast_ref::<HostFirewallRulesetIpList>()?),
            StructType::HostFirewallRulesetIpNetwork => Some(from.as_any_ref().downcast_ref::<HostFirewallRulesetIpNetwork>()?),
            StructType::HostFirewallRule => Some(from.as_any_ref().downcast_ref::<HostFirewallRule>()?),
            StructType::HostFirewallRulesetRulesetSpec => Some(from.as_any_ref().downcast_ref::<HostFirewallRulesetRulesetSpec>()?),
            StructType::HostRuntimeInfo => Some(from.as_any_ref().downcast_ref::<HostRuntimeInfo>()?),
            StructType::HostRuntimeInfoNetStackInstanceRuntimeInfo => Some(from.as_any_ref().downcast_ref::<HostRuntimeInfoNetStackInstanceRuntimeInfo>()?),
            StructType::HostNetworkResourceRuntime => Some(from.as_any_ref().downcast_ref::<HostNetworkResourceRuntime>()?),
            StructType::HostRuntimeInfoNetworkRuntimeInfo => Some(from.as_any_ref().downcast_ref::<HostRuntimeInfoNetworkRuntimeInfo>()?),
            StructType::HostPlacedVirtualNicIdentifier => Some(from.as_any_ref().downcast_ref::<HostPlacedVirtualNicIdentifier>()?),
            StructType::HostPnicNetworkResourceInfo => Some(from.as_any_ref().downcast_ref::<HostPnicNetworkResourceInfo>()?),
            StructType::HostRuntimeInfoStateEncryptionInfo => Some(from.as_any_ref().downcast_ref::<HostRuntimeInfoStateEncryptionInfo>()?),
            StructType::HostScsiDiskPartition => Some(from.as_any_ref().downcast_ref::<HostScsiDiskPartition>()?),
            StructType::ScsiLunCapabilities => Some(from.as_any_ref().downcast_ref::<ScsiLunCapabilities>()?),
            StructType::ScsiLunDescriptor => Some(from.as_any_ref().downcast_ref::<ScsiLunDescriptor>()?),
            StructType::ScsiLunDurableName => Some(from.as_any_ref().downcast_ref::<ScsiLunDurableName>()?),
            StructType::HostScsiTopology => Some(from.as_any_ref().downcast_ref::<HostScsiTopology>()?),
            StructType::HostScsiTopologyInterface => Some(from.as_any_ref().downcast_ref::<HostScsiTopologyInterface>()?),
            StructType::HostScsiTopologyLun => Some(from.as_any_ref().downcast_ref::<HostScsiTopologyLun>()?),
            StructType::HostScsiTopologyTarget => Some(from.as_any_ref().downcast_ref::<HostScsiTopologyTarget>()?),
            StructType::HostSecuritySpec => Some(from.as_any_ref().downcast_ref::<HostSecuritySpec>()?),
            StructType::HostService => Some(from.as_any_ref().downcast_ref::<HostService>()?),
            StructType::HostServiceSourcePackage => Some(from.as_any_ref().downcast_ref::<HostServiceSourcePackage>()?),
            StructType::HostServiceConfig => Some(from.as_any_ref().downcast_ref::<HostServiceConfig>()?),
            StructType::HostServiceInfo => Some(from.as_any_ref().downcast_ref::<HostServiceInfo>()?),
            StructType::HostSevInfo => Some(from.as_any_ref().downcast_ref::<HostSevInfo>()?),
            StructType::HostSgxInfo => Some(from.as_any_ref().downcast_ref::<HostSgxInfo>()?),
            StructType::HostSgxRegistrationInfo => Some(from.as_any_ref().downcast_ref::<HostSgxRegistrationInfo>()?),
            StructType::HostSharedGpuCapabilities => Some(from.as_any_ref().downcast_ref::<HostSharedGpuCapabilities>()?),
            StructType::HostSnmpSystemAgentLimits => Some(from.as_any_ref().downcast_ref::<HostSnmpSystemAgentLimits>()?),
            StructType::HostSnmpConfigSpec => Some(from.as_any_ref().downcast_ref::<HostSnmpConfigSpec>()?),
            StructType::HostSnmpDestination => Some(from.as_any_ref().downcast_ref::<HostSnmpDestination>()?),
            StructType::SoftwarePackage => Some(from.as_any_ref().downcast_ref::<SoftwarePackage>()?),
            StructType::SoftwarePackageCapability => Some(from.as_any_ref().downcast_ref::<SoftwarePackageCapability>()?),
            StructType::Relation => Some(from.as_any_ref().downcast_ref::<Relation>()?),
            StructType::HostSriovDevicePoolInfo => Some(from.as_any_ref().downcast_ref::<HostSriovDevicePoolInfo>()?),
            StructType::HostSriovNetworkDevicePoolInfo => Some(from.as_any_ref().downcast_ref::<HostSriovNetworkDevicePoolInfo>()?),
            StructType::HostSslThumbprintInfo => Some(from.as_any_ref().downcast_ref::<HostSslThumbprintInfo>()?),
            StructType::HostStorageArrayTypePolicyOption => Some(from.as_any_ref().downcast_ref::<HostStorageArrayTypePolicyOption>()?),
            StructType::HostStorageDeviceInfo => Some(from.as_any_ref().downcast_ref::<HostStorageDeviceInfo>()?),
            StructType::HostStorageSystemDiskLocatorLedResult => Some(from.as_any_ref().downcast_ref::<HostStorageSystemDiskLocatorLedResult>()?),
            StructType::HostStorageSystemScsiLunResult => Some(from.as_any_ref().downcast_ref::<HostStorageSystemScsiLunResult>()?),
            StructType::HostStorageSystemVmfsVolumeResult => Some(from.as_any_ref().downcast_ref::<HostStorageSystemVmfsVolumeResult>()?),
            StructType::HostListSummary => Some(from.as_any_ref().downcast_ref::<HostListSummary>()?),
            StructType::HostConfigSummary => Some(from.as_any_ref().downcast_ref::<HostConfigSummary>()?),
            StructType::HostListSummaryGatewaySummary => Some(from.as_any_ref().downcast_ref::<HostListSummaryGatewaySummary>()?),
            StructType::HostHardwareSummary => Some(from.as_any_ref().downcast_ref::<HostHardwareSummary>()?),
            StructType::HostListSummaryQuickStats => Some(from.as_any_ref().downcast_ref::<HostListSummaryQuickStats>()?),
            StructType::SystemEventInfo => Some(from.as_any_ref().downcast_ref::<SystemEventInfo>()?),
            StructType::HostSystemHealthInfo => Some(from.as_any_ref().downcast_ref::<HostSystemHealthInfo>()?),
            StructType::HostSystemIdentificationInfo => Some(from.as_any_ref().downcast_ref::<HostSystemIdentificationInfo>()?),
            StructType::HostSystemInfo => Some(from.as_any_ref().downcast_ref::<HostSystemInfo>()?),
            StructType::HostSystemResourceInfo => Some(from.as_any_ref().downcast_ref::<HostSystemResourceInfo>()?),
            StructType::HostSystemSwapConfiguration => Some(from.as_any_ref().downcast_ref::<HostSystemSwapConfiguration>()?),
            StructType::HostSystemSwapConfigurationSystemSwapOption => Some(from.as_any_ref().downcast_ref::<HostSystemSwapConfigurationSystemSwapOption>()?),
            StructType::HostSystemSwapConfigurationDatastoreOption => Some(from.as_any_ref().downcast_ref::<HostSystemSwapConfigurationDatastoreOption>()?),
            StructType::HostSystemSwapConfigurationDisabledOption => Some(from.as_any_ref().downcast_ref::<HostSystemSwapConfigurationDisabledOption>()?),
            StructType::HostSystemSwapConfigurationHostCacheOption => Some(from.as_any_ref().downcast_ref::<HostSystemSwapConfigurationHostCacheOption>()?),
            StructType::HostSystemSwapConfigurationHostLocalSwapOption => Some(from.as_any_ref().downcast_ref::<HostSystemSwapConfigurationHostLocalSwapOption>()?),
            StructType::HostTargetTransport => Some(from.as_any_ref().downcast_ref::<HostTargetTransport>()?),
            StructType::HostBlockAdapterTargetTransport => Some(from.as_any_ref().downcast_ref::<HostBlockAdapterTargetTransport>()?),
            StructType::HostFibreChannelTargetTransport => Some(from.as_any_ref().downcast_ref::<HostFibreChannelTargetTransport>()?),
            StructType::HostFibreChannelOverEthernetTargetTransport => Some(from.as_any_ref().downcast_ref::<HostFibreChannelOverEthernetTargetTransport>()?),
            StructType::HostInternetScsiTargetTransport => Some(from.as_any_ref().downcast_ref::<HostInternetScsiTargetTransport>()?),
            StructType::HostParallelScsiTargetTransport => Some(from.as_any_ref().downcast_ref::<HostParallelScsiTargetTransport>()?),
            StructType::HostPcieTargetTransport => Some(from.as_any_ref().downcast_ref::<HostPcieTargetTransport>()?),
            StructType::HostRdmaTargetTransport => Some(from.as_any_ref().downcast_ref::<HostRdmaTargetTransport>()?),
            StructType::HostSerialAttachedTargetTransport => Some(from.as_any_ref().downcast_ref::<HostSerialAttachedTargetTransport>()?),
            StructType::HostTcpTargetTransport => Some(from.as_any_ref().downcast_ref::<HostTcpTargetTransport>()?),
            StructType::HostTpmAttestationInfo => Some(from.as_any_ref().downcast_ref::<HostTpmAttestationInfo>()?),
            StructType::HostTpmAttestationReport => Some(from.as_any_ref().downcast_ref::<HostTpmAttestationReport>()?),
            StructType::HostTpmEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmEventDetails>()?),
            StructType::HostTpmBootCompleteEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmBootCompleteEventDetails>()?),
            StructType::HostTpmBootSecurityOptionEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmBootSecurityOptionEventDetails>()?),
            StructType::HostTpmNvTagEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmNvTagEventDetails>()?),
            StructType::HostTpmSignerEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmSignerEventDetails>()?),
            StructType::HostTpmCommandEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmCommandEventDetails>()?),
            StructType::HostTpmOptionEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmOptionEventDetails>()?),
            StructType::HostTpmSoftwareComponentEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmSoftwareComponentEventDetails>()?),
            StructType::HostTpmVersionEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmVersionEventDetails>()?),
            StructType::HostTpmEventLogEntry => Some(from.as_any_ref().downcast_ref::<HostTpmEventLogEntry>()?),
            StructType::HostTrustAuthorityAttestationInfo => Some(from.as_any_ref().downcast_ref::<HostTrustAuthorityAttestationInfo>()?),
            StructType::HostUnresolvedVmfsExtent => Some(from.as_any_ref().downcast_ref::<HostUnresolvedVmfsExtent>()?),
            StructType::HostUnresolvedVmfsResignatureSpec => Some(from.as_any_ref().downcast_ref::<HostUnresolvedVmfsResignatureSpec>()?),
            StructType::HostUnresolvedVmfsResolutionResult => Some(from.as_any_ref().downcast_ref::<HostUnresolvedVmfsResolutionResult>()?),
            StructType::HostUnresolvedVmfsResolutionSpec => Some(from.as_any_ref().downcast_ref::<HostUnresolvedVmfsResolutionSpec>()?),
            StructType::HostUnresolvedVmfsVolume => Some(from.as_any_ref().downcast_ref::<HostUnresolvedVmfsVolume>()?),
            StructType::HostUnresolvedVmfsVolumeResolveStatus => Some(from.as_any_ref().downcast_ref::<HostUnresolvedVmfsVolumeResolveStatus>()?),
            StructType::HostVFlashManagerVFlashCacheConfigInfo => Some(from.as_any_ref().downcast_ref::<HostVFlashManagerVFlashCacheConfigInfo>()?),
            StructType::HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption => Some(from.as_any_ref().downcast_ref::<HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption>()?),
            StructType::HostVFlashManagerVFlashCacheConfigSpec => Some(from.as_any_ref().downcast_ref::<HostVFlashManagerVFlashCacheConfigSpec>()?),
            StructType::HostVFlashManagerVFlashConfigInfo => Some(from.as_any_ref().downcast_ref::<HostVFlashManagerVFlashConfigInfo>()?),
            StructType::HostVFlashManagerVFlashResourceConfigInfo => Some(from.as_any_ref().downcast_ref::<HostVFlashManagerVFlashResourceConfigInfo>()?),
            StructType::HostVFlashManagerVFlashResourceConfigSpec => Some(from.as_any_ref().downcast_ref::<HostVFlashManagerVFlashResourceConfigSpec>()?),
            StructType::HostVFlashManagerVFlashResourceRunTimeInfo => Some(from.as_any_ref().downcast_ref::<HostVFlashManagerVFlashResourceRunTimeInfo>()?),
            StructType::HostVFlashResourceConfigurationResult => Some(from.as_any_ref().downcast_ref::<HostVFlashResourceConfigurationResult>()?),
            StructType::HostVMotionConfig => Some(from.as_any_ref().downcast_ref::<HostVMotionConfig>()?),
            StructType::HostVMotionInfo => Some(from.as_any_ref().downcast_ref::<HostVMotionInfo>()?),
            StructType::HostVMotionManagerDstInstantCloneResult => Some(from.as_any_ref().downcast_ref::<HostVMotionManagerDstInstantCloneResult>()?),
            StructType::HostVMotionManagerSrcInstantCloneResult => Some(from.as_any_ref().downcast_ref::<HostVMotionManagerSrcInstantCloneResult>()?),
            StructType::HostVMotionNetConfig => Some(from.as_any_ref().downcast_ref::<HostVMotionNetConfig>()?),
            StructType::HostVffsSpec => Some(from.as_any_ref().downcast_ref::<HostVffsSpec>()?),
            StructType::HostVirtualNic => Some(from.as_any_ref().downcast_ref::<HostVirtualNic>()?),
            StructType::HostVirtualNicConfig => Some(from.as_any_ref().downcast_ref::<HostVirtualNicConfig>()?),
            StructType::HostVirtualNicIpRouteSpec => Some(from.as_any_ref().downcast_ref::<HostVirtualNicIpRouteSpec>()?),
            StructType::HostVirtualNicOpaqueNetworkSpec => Some(from.as_any_ref().downcast_ref::<HostVirtualNicOpaqueNetworkSpec>()?),
            StructType::HostVirtualNicSpec => Some(from.as_any_ref().downcast_ref::<HostVirtualNicSpec>()?),
            StructType::HostVirtualNicConnection => Some(from.as_any_ref().downcast_ref::<HostVirtualNicConnection>()?),
            StructType::VirtualNicManagerNetConfig => Some(from.as_any_ref().downcast_ref::<VirtualNicManagerNetConfig>()?),
            StructType::HostVirtualNicManagerNicTypeSelection => Some(from.as_any_ref().downcast_ref::<HostVirtualNicManagerNicTypeSelection>()?),
            StructType::HostVirtualNicManagerInfo => Some(from.as_any_ref().downcast_ref::<HostVirtualNicManagerInfo>()?),
            StructType::HostVirtualSwitch => Some(from.as_any_ref().downcast_ref::<HostVirtualSwitch>()?),
            StructType::HostVirtualSwitchBeaconConfig => Some(from.as_any_ref().downcast_ref::<HostVirtualSwitchBeaconConfig>()?),
            StructType::HostVirtualSwitchBridge => Some(from.as_any_ref().downcast_ref::<HostVirtualSwitchBridge>()?),
            StructType::HostVirtualSwitchAutoBridge => Some(from.as_any_ref().downcast_ref::<HostVirtualSwitchAutoBridge>()?),
            StructType::HostVirtualSwitchBondBridge => Some(from.as_any_ref().downcast_ref::<HostVirtualSwitchBondBridge>()?),
            StructType::HostVirtualSwitchSimpleBridge => Some(from.as_any_ref().downcast_ref::<HostVirtualSwitchSimpleBridge>()?),
            StructType::HostVirtualSwitchConfig => Some(from.as_any_ref().downcast_ref::<HostVirtualSwitchConfig>()?),
            StructType::HostVirtualSwitchSpec => Some(from.as_any_ref().downcast_ref::<HostVirtualSwitchSpec>()?),
            StructType::HostVmciAccessManagerAccessSpec => Some(from.as_any_ref().downcast_ref::<HostVmciAccessManagerAccessSpec>()?),
            StructType::VmfsDatastoreOption => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreOption>()?),
            StructType::VmfsDatastoreBaseOption => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreBaseOption>()?),
            StructType::VmfsDatastoreMultipleExtentOption => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreMultipleExtentOption>()?),
            StructType::VmfsDatastoreSingleExtentOption => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreSingleExtentOption>()?),
            StructType::VmfsDatastoreAllExtentOption => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreAllExtentOption>()?),
            StructType::VmfsDatastoreSpec => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreSpec>()?),
            StructType::VmfsDatastoreCreateSpec => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreCreateSpec>()?),
            StructType::VmfsDatastoreExpandSpec => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreExpandSpec>()?),
            StructType::VmfsDatastoreExtendSpec => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreExtendSpec>()?),
            StructType::HostVmfsRescanResult => Some(from.as_any_ref().downcast_ref::<HostVmfsRescanResult>()?),
            StructType::VmfsConfigOption => Some(from.as_any_ref().downcast_ref::<VmfsConfigOption>()?),
            StructType::HostVmfsSpec => Some(from.as_any_ref().downcast_ref::<HostVmfsSpec>()?),
            StructType::VmfsUnmapBandwidthSpec => Some(from.as_any_ref().downcast_ref::<VmfsUnmapBandwidthSpec>()?),
            StructType::HostVsanInternalSystemCmmdsQuery => Some(from.as_any_ref().downcast_ref::<HostVsanInternalSystemCmmdsQuery>()?),
            StructType::HostVsanInternalSystemDeleteVsanObjectsResult => Some(from.as_any_ref().downcast_ref::<HostVsanInternalSystemDeleteVsanObjectsResult>()?),
            StructType::VsanNewPolicyBatch => Some(from.as_any_ref().downcast_ref::<VsanNewPolicyBatch>()?),
            StructType::VsanPolicyChangeBatch => Some(from.as_any_ref().downcast_ref::<VsanPolicyChangeBatch>()?),
            StructType::VsanPolicyCost => Some(from.as_any_ref().downcast_ref::<VsanPolicyCost>()?),
            StructType::VsanPolicySatisfiability => Some(from.as_any_ref().downcast_ref::<VsanPolicySatisfiability>()?),
            StructType::HostVsanInternalSystemVsanObjectOperationResult => Some(from.as_any_ref().downcast_ref::<HostVsanInternalSystemVsanObjectOperationResult>()?),
            StructType::HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult => Some(from.as_any_ref().downcast_ref::<HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult>()?),
            StructType::HostVvolNqn => Some(from.as_any_ref().downcast_ref::<HostVvolNqn>()?),
            StructType::VVolHostPe => Some(from.as_any_ref().downcast_ref::<VVolHostPe>()?),
            StructType::HostVvolVolumeHostVvolNqn => Some(from.as_any_ref().downcast_ref::<HostVvolVolumeHostVvolNqn>()?),
            StructType::HostVvolVolumeSpecification => Some(from.as_any_ref().downcast_ref::<HostVvolVolumeSpecification>()?),
            StructType::NetDhcpConfigInfo => Some(from.as_any_ref().downcast_ref::<NetDhcpConfigInfo>()?),
            StructType::NetDhcpConfigInfoDhcpOptions => Some(from.as_any_ref().downcast_ref::<NetDhcpConfigInfoDhcpOptions>()?),
            StructType::NetDhcpConfigSpec => Some(from.as_any_ref().downcast_ref::<NetDhcpConfigSpec>()?),
            StructType::NetDhcpConfigSpecDhcpOptionsSpec => Some(from.as_any_ref().downcast_ref::<NetDhcpConfigSpecDhcpOptionsSpec>()?),
            StructType::NetDnsConfigInfo => Some(from.as_any_ref().downcast_ref::<NetDnsConfigInfo>()?),
            StructType::NetDnsConfigSpec => Some(from.as_any_ref().downcast_ref::<NetDnsConfigSpec>()?),
            StructType::NetIpConfigInfo => Some(from.as_any_ref().downcast_ref::<NetIpConfigInfo>()?),
            StructType::NetIpConfigInfoIpAddress => Some(from.as_any_ref().downcast_ref::<NetIpConfigInfoIpAddress>()?),
            StructType::NetIpConfigSpec => Some(from.as_any_ref().downcast_ref::<NetIpConfigSpec>()?),
            StructType::NetIpConfigSpecIpAddressSpec => Some(from.as_any_ref().downcast_ref::<NetIpConfigSpecIpAddressSpec>()?),
            StructType::NetIpRouteConfigInfo => Some(from.as_any_ref().downcast_ref::<NetIpRouteConfigInfo>()?),
            StructType::NetIpRouteConfigInfoGateway => Some(from.as_any_ref().downcast_ref::<NetIpRouteConfigInfoGateway>()?),
            StructType::NetIpRouteConfigInfoIpRoute => Some(from.as_any_ref().downcast_ref::<NetIpRouteConfigInfoIpRoute>()?),
            StructType::NetIpRouteConfigSpec => Some(from.as_any_ref().downcast_ref::<NetIpRouteConfigSpec>()?),
            StructType::NetIpRouteConfigSpecGatewaySpec => Some(from.as_any_ref().downcast_ref::<NetIpRouteConfigSpecGatewaySpec>()?),
            StructType::NetIpRouteConfigSpecIpRouteSpec => Some(from.as_any_ref().downcast_ref::<NetIpRouteConfigSpecIpRouteSpec>()?),
            StructType::NetIpStackInfo => Some(from.as_any_ref().downcast_ref::<NetIpStackInfo>()?),
            StructType::NetIpStackInfoDefaultRouter => Some(from.as_any_ref().downcast_ref::<NetIpStackInfoDefaultRouter>()?),
            StructType::NetIpStackInfoNetToMedia => Some(from.as_any_ref().downcast_ref::<NetIpStackInfoNetToMedia>()?),
            StructType::NetBiosConfigInfo => Some(from.as_any_ref().downcast_ref::<NetBiosConfigInfo>()?),
            StructType::WinNetBiosConfigInfo => Some(from.as_any_ref().downcast_ref::<WinNetBiosConfigInfo>()?),
            StructType::ArrayUpdateSpec => Some(from.as_any_ref().downcast_ref::<ArrayUpdateSpec>()?),
            StructType::ClusterDasVmConfigSpec => Some(from.as_any_ref().downcast_ref::<ClusterDasVmConfigSpec>()?),
            StructType::ClusterDatastoreUpdateSpec => Some(from.as_any_ref().downcast_ref::<ClusterDatastoreUpdateSpec>()?),
            StructType::ClusterDpmHostConfigSpec => Some(from.as_any_ref().downcast_ref::<ClusterDpmHostConfigSpec>()?),
            StructType::ClusterDrsVmConfigSpec => Some(from.as_any_ref().downcast_ref::<ClusterDrsVmConfigSpec>()?),
            StructType::ClusterGroupSpec => Some(from.as_any_ref().downcast_ref::<ClusterGroupSpec>()?),
            StructType::ClusterPreemptibleVmPairSpec => Some(from.as_any_ref().downcast_ref::<ClusterPreemptibleVmPairSpec>()?),
            StructType::ClusterRuleSpec => Some(from.as_any_ref().downcast_ref::<ClusterRuleSpec>()?),
            StructType::ClusterTagCategoryUpdateSpec => Some(from.as_any_ref().downcast_ref::<ClusterTagCategoryUpdateSpec>()?),
            StructType::ClusterVmOrchestrationSpec => Some(from.as_any_ref().downcast_ref::<ClusterVmOrchestrationSpec>()?),
            StructType::StorageDrsOptionSpec => Some(from.as_any_ref().downcast_ref::<StorageDrsOptionSpec>()?),
            StructType::StorageDrsVmConfigSpec => Some(from.as_any_ref().downcast_ref::<StorageDrsVmConfigSpec>()?),
            StructType::VAppOvfSectionSpec => Some(from.as_any_ref().downcast_ref::<VAppOvfSectionSpec>()?),
            StructType::VAppProductSpec => Some(from.as_any_ref().downcast_ref::<VAppProductSpec>()?),
            StructType::VAppPropertySpec => Some(from.as_any_ref().downcast_ref::<VAppPropertySpec>()?),
            StructType::VirtualMachineCpuIdInfoSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineCpuIdInfoSpec>()?),
            StructType::OptionType => Some(from.as_any_ref().downcast_ref::<OptionType>()?),
            StructType::BoolOption => Some(from.as_any_ref().downcast_ref::<BoolOption>()?),
            StructType::ChoiceOption => Some(from.as_any_ref().downcast_ref::<ChoiceOption>()?),
            StructType::FloatOption => Some(from.as_any_ref().downcast_ref::<FloatOption>()?),
            StructType::IntOption => Some(from.as_any_ref().downcast_ref::<IntOption>()?),
            StructType::LongOption => Some(from.as_any_ref().downcast_ref::<LongOption>()?),
            StructType::StringOption => Some(from.as_any_ref().downcast_ref::<StringOption>()?),
            StructType::OptionValue => Some(from.as_any_ref().downcast_ref::<OptionValue>()?),
            StructType::HostInternetScsiHbaParamValue => Some(from.as_any_ref().downcast_ref::<HostInternetScsiHbaParamValue>()?),
            StructType::ApplyProfile => Some(from.as_any_ref().downcast_ref::<ApplyProfile>()?),
            StructType::ProfileApplyProfileElement => Some(from.as_any_ref().downcast_ref::<ProfileApplyProfileElement>()?),
            StructType::ActiveDirectoryProfile => Some(from.as_any_ref().downcast_ref::<ActiveDirectoryProfile>()?),
            StructType::AuthenticationProfile => Some(from.as_any_ref().downcast_ref::<AuthenticationProfile>()?),
            StructType::DateTimeProfile => Some(from.as_any_ref().downcast_ref::<DateTimeProfile>()?),
            StructType::DvsProfile => Some(from.as_any_ref().downcast_ref::<DvsProfile>()?),
            StructType::DvsVNicProfile => Some(from.as_any_ref().downcast_ref::<DvsVNicProfile>()?),
            StructType::DvsHostVNicProfile => Some(from.as_any_ref().downcast_ref::<DvsHostVNicProfile>()?),
            StructType::DvsServiceConsoleVNicProfile => Some(from.as_any_ref().downcast_ref::<DvsServiceConsoleVNicProfile>()?),
            StructType::FirewallProfile => Some(from.as_any_ref().downcast_ref::<FirewallProfile>()?),
            StructType::FirewallProfileRulesetProfile => Some(from.as_any_ref().downcast_ref::<FirewallProfileRulesetProfile>()?),
            StructType::HostApplyProfile => Some(from.as_any_ref().downcast_ref::<HostApplyProfile>()?),
            StructType::HostMemoryProfile => Some(from.as_any_ref().downcast_ref::<HostMemoryProfile>()?),
            StructType::IpAddressProfile => Some(from.as_any_ref().downcast_ref::<IpAddressProfile>()?),
            StructType::IpRouteProfile => Some(from.as_any_ref().downcast_ref::<IpRouteProfile>()?),
            StructType::NasStorageProfile => Some(from.as_any_ref().downcast_ref::<NasStorageProfile>()?),
            StructType::NetStackInstanceProfile => Some(from.as_any_ref().downcast_ref::<NetStackInstanceProfile>()?),
            StructType::NetworkPolicyProfile => Some(from.as_any_ref().downcast_ref::<NetworkPolicyProfile>()?),
            StructType::NetworkProfile => Some(from.as_any_ref().downcast_ref::<NetworkProfile>()?),
            StructType::NetworkProfileDnsConfigProfile => Some(from.as_any_ref().downcast_ref::<NetworkProfileDnsConfigProfile>()?),
            StructType::NsxHostVNicProfile => Some(from.as_any_ref().downcast_ref::<NsxHostVNicProfile>()?),
            StructType::OpaqueSwitchProfile => Some(from.as_any_ref().downcast_ref::<OpaqueSwitchProfile>()?),
            StructType::OptionProfile => Some(from.as_any_ref().downcast_ref::<OptionProfile>()?),
            StructType::PermissionProfile => Some(from.as_any_ref().downcast_ref::<PermissionProfile>()?),
            StructType::PhysicalNicProfile => Some(from.as_any_ref().downcast_ref::<PhysicalNicProfile>()?),
            StructType::PnicUplinkProfile => Some(from.as_any_ref().downcast_ref::<PnicUplinkProfile>()?),
            StructType::PortGroupProfile => Some(from.as_any_ref().downcast_ref::<PortGroupProfile>()?),
            StructType::HostPortGroupProfile => Some(from.as_any_ref().downcast_ref::<HostPortGroupProfile>()?),
            StructType::ServiceConsolePortGroupProfile => Some(from.as_any_ref().downcast_ref::<ServiceConsolePortGroupProfile>()?),
            StructType::VmPortGroupProfile => Some(from.as_any_ref().downcast_ref::<VmPortGroupProfile>()?),
            StructType::VirtualSwitchSelectionProfile => Some(from.as_any_ref().downcast_ref::<VirtualSwitchSelectionProfile>()?),
            StructType::VlanProfile => Some(from.as_any_ref().downcast_ref::<VlanProfile>()?),
            StructType::SecurityProfile => Some(from.as_any_ref().downcast_ref::<SecurityProfile>()?),
            StructType::ServiceProfile => Some(from.as_any_ref().downcast_ref::<ServiceProfile>()?),
            StructType::StaticRouteProfile => Some(from.as_any_ref().downcast_ref::<StaticRouteProfile>()?),
            StructType::StorageProfile => Some(from.as_any_ref().downcast_ref::<StorageProfile>()?),
            StructType::UserGroupProfile => Some(from.as_any_ref().downcast_ref::<UserGroupProfile>()?),
            StructType::UserProfile => Some(from.as_any_ref().downcast_ref::<UserProfile>()?),
            StructType::VirtualSwitchProfile => Some(from.as_any_ref().downcast_ref::<VirtualSwitchProfile>()?),
            StructType::LinkProfile => Some(from.as_any_ref().downcast_ref::<LinkProfile>()?),
            StructType::NumPortsProfile => Some(from.as_any_ref().downcast_ref::<NumPortsProfile>()?),
            StructType::ProfileApplyProfileProperty => Some(from.as_any_ref().downcast_ref::<ProfileApplyProfileProperty>()?),
            StructType::ComplianceLocator => Some(from.as_any_ref().downcast_ref::<ComplianceLocator>()?),
            StructType::ComplianceProfile => Some(from.as_any_ref().downcast_ref::<ComplianceProfile>()?),
            StructType::ComplianceResult => Some(from.as_any_ref().downcast_ref::<ComplianceResult>()?),
            StructType::ComplianceFailure => Some(from.as_any_ref().downcast_ref::<ComplianceFailure>()?),
            StructType::ComplianceFailureComplianceFailureValues => Some(from.as_any_ref().downcast_ref::<ComplianceFailureComplianceFailureValues>()?),
            StructType::ProfileDeferredPolicyOptionParameter => Some(from.as_any_ref().downcast_ref::<ProfileDeferredPolicyOptionParameter>()?),
            StructType::ProfileExpression => Some(from.as_any_ref().downcast_ref::<ProfileExpression>()?),
            StructType::ProfileCompositeExpression => Some(from.as_any_ref().downcast_ref::<ProfileCompositeExpression>()?),
            StructType::ProfileSimpleExpression => Some(from.as_any_ref().downcast_ref::<ProfileSimpleExpression>()?),
            StructType::ProfileExpressionMetadata => Some(from.as_any_ref().downcast_ref::<ProfileExpressionMetadata>()?),
            StructType::ProfileParameterMetadata => Some(from.as_any_ref().downcast_ref::<ProfileParameterMetadata>()?),
            StructType::ProfileParameterMetadataParameterRelationMetadata => Some(from.as_any_ref().downcast_ref::<ProfileParameterMetadataParameterRelationMetadata>()?),
            StructType::ProfilePolicy => Some(from.as_any_ref().downcast_ref::<ProfilePolicy>()?),
            StructType::ProfilePolicyMetadata => Some(from.as_any_ref().downcast_ref::<ProfilePolicyMetadata>()?),
            StructType::PolicyOption => Some(from.as_any_ref().downcast_ref::<PolicyOption>()?),
            StructType::CompositePolicyOption => Some(from.as_any_ref().downcast_ref::<CompositePolicyOption>()?),
            StructType::ProfilePolicyOptionMetadata => Some(from.as_any_ref().downcast_ref::<ProfilePolicyOptionMetadata>()?),
            StructType::ProfileCompositePolicyOptionMetadata => Some(from.as_any_ref().downcast_ref::<ProfileCompositePolicyOptionMetadata>()?),
            StructType::UserInputRequiredParameterMetadata => Some(from.as_any_ref().downcast_ref::<UserInputRequiredParameterMetadata>()?),
            StructType::ProfileConfigInfo => Some(from.as_any_ref().downcast_ref::<ProfileConfigInfo>()?),
            StructType::ClusterProfileConfigInfo => Some(from.as_any_ref().downcast_ref::<ClusterProfileConfigInfo>()?),
            StructType::HostProfileConfigInfo => Some(from.as_any_ref().downcast_ref::<HostProfileConfigInfo>()?),
            StructType::ProfileCreateSpec => Some(from.as_any_ref().downcast_ref::<ProfileCreateSpec>()?),
            StructType::ProfileSerializedCreateSpec => Some(from.as_any_ref().downcast_ref::<ProfileSerializedCreateSpec>()?),
            StructType::HostProfileSerializedHostProfileSpec => Some(from.as_any_ref().downcast_ref::<HostProfileSerializedHostProfileSpec>()?),
            StructType::ClusterProfileCreateSpec => Some(from.as_any_ref().downcast_ref::<ClusterProfileCreateSpec>()?),
            StructType::ClusterProfileConfigSpec => Some(from.as_any_ref().downcast_ref::<ClusterProfileConfigSpec>()?),
            StructType::ClusterProfileCompleteConfigSpec => Some(from.as_any_ref().downcast_ref::<ClusterProfileCompleteConfigSpec>()?),
            StructType::ClusterProfileConfigServiceCreateSpec => Some(from.as_any_ref().downcast_ref::<ClusterProfileConfigServiceCreateSpec>()?),
            StructType::HostProfileConfigSpec => Some(from.as_any_ref().downcast_ref::<HostProfileConfigSpec>()?),
            StructType::HostProfileCompleteConfigSpec => Some(from.as_any_ref().downcast_ref::<HostProfileCompleteConfigSpec>()?),
            StructType::HostProfileHostBasedConfigSpec => Some(from.as_any_ref().downcast_ref::<HostProfileHostBasedConfigSpec>()?),
            StructType::ProfileDescription => Some(from.as_any_ref().downcast_ref::<ProfileDescription>()?),
            StructType::ProfileDescriptionSection => Some(from.as_any_ref().downcast_ref::<ProfileDescriptionSection>()?),
            StructType::ProfileMetadata => Some(from.as_any_ref().downcast_ref::<ProfileMetadata>()?),
            StructType::ProfileMetadataProfileOperationMessage => Some(from.as_any_ref().downcast_ref::<ProfileMetadataProfileOperationMessage>()?),
            StructType::ProfileMetadataProfileSortSpec => Some(from.as_any_ref().downcast_ref::<ProfileMetadataProfileSortSpec>()?),
            StructType::ProfilePropertyPath => Some(from.as_any_ref().downcast_ref::<ProfilePropertyPath>()?),
            StructType::ProfileProfileStructure => Some(from.as_any_ref().downcast_ref::<ProfileProfileStructure>()?),
            StructType::ProfileProfileStructureProperty => Some(from.as_any_ref().downcast_ref::<ProfileProfileStructureProperty>()?),
            StructType::AnswerFile => Some(from.as_any_ref().downcast_ref::<AnswerFile>()?),
            StructType::AnswerFileStatusResult => Some(from.as_any_ref().downcast_ref::<AnswerFileStatusResult>()?),
            StructType::AnswerFileStatusError => Some(from.as_any_ref().downcast_ref::<AnswerFileStatusError>()?),
            StructType::ProfileExecuteResult => Some(from.as_any_ref().downcast_ref::<ProfileExecuteResult>()?),
            StructType::ApplyHostProfileConfigurationSpec => Some(from.as_any_ref().downcast_ref::<ApplyHostProfileConfigurationSpec>()?),
            StructType::ProfileExecuteError => Some(from.as_any_ref().downcast_ref::<ProfileExecuteError>()?),
            StructType::HostProfileValidationFailureInfo => Some(from.as_any_ref().downcast_ref::<HostProfileValidationFailureInfo>()?),
            StructType::HostSpecification => Some(from.as_any_ref().downcast_ref::<HostSpecification>()?),
            StructType::HostSubSpecification => Some(from.as_any_ref().downcast_ref::<HostSubSpecification>()?),
            StructType::AnswerFileCreateSpec => Some(from.as_any_ref().downcast_ref::<AnswerFileCreateSpec>()?),
            StructType::AnswerFileOptionsCreateSpec => Some(from.as_any_ref().downcast_ref::<AnswerFileOptionsCreateSpec>()?),
            StructType::AnswerFileSerializedCreateSpec => Some(from.as_any_ref().downcast_ref::<AnswerFileSerializedCreateSpec>()?),
            StructType::ApplyHostProfileConfigurationResult => Some(from.as_any_ref().downcast_ref::<ApplyHostProfileConfigurationResult>()?),
            StructType::HostProfileManagerCompositionResult => Some(from.as_any_ref().downcast_ref::<HostProfileManagerCompositionResult>()?),
            StructType::HostProfileManagerCompositionResultResultElement => Some(from.as_any_ref().downcast_ref::<HostProfileManagerCompositionResultResultElement>()?),
            StructType::HostProfileManagerCompositionValidationResult => Some(from.as_any_ref().downcast_ref::<HostProfileManagerCompositionValidationResult>()?),
            StructType::HostProfileManagerCompositionValidationResultResultElement => Some(from.as_any_ref().downcast_ref::<HostProfileManagerCompositionValidationResultResultElement>()?),
            StructType::HostProfileManagerConfigTaskList => Some(from.as_any_ref().downcast_ref::<HostProfileManagerConfigTaskList>()?),
            StructType::HostProfilesEntityCustomizations => Some(from.as_any_ref().downcast_ref::<HostProfilesEntityCustomizations>()?),
            StructType::StructuredCustomizations => Some(from.as_any_ref().downcast_ref::<StructuredCustomizations>()?),
            StructType::HostProfileManagerHostToConfigSpecMap => Some(from.as_any_ref().downcast_ref::<HostProfileManagerHostToConfigSpecMap>()?),
            StructType::ScheduledTaskDescription => Some(from.as_any_ref().downcast_ref::<ScheduledTaskDescription>()?),
            StructType::ScheduledTaskSpec => Some(from.as_any_ref().downcast_ref::<ScheduledTaskSpec>()?),
            StructType::ScheduledTaskInfo => Some(from.as_any_ref().downcast_ref::<ScheduledTaskInfo>()?),
            StructType::TaskScheduler => Some(from.as_any_ref().downcast_ref::<TaskScheduler>()?),
            StructType::AfterStartupTaskScheduler => Some(from.as_any_ref().downcast_ref::<AfterStartupTaskScheduler>()?),
            StructType::OnceTaskScheduler => Some(from.as_any_ref().downcast_ref::<OnceTaskScheduler>()?),
            StructType::RecurrentTaskScheduler => Some(from.as_any_ref().downcast_ref::<RecurrentTaskScheduler>()?),
            StructType::HourlyTaskScheduler => Some(from.as_any_ref().downcast_ref::<HourlyTaskScheduler>()?),
            StructType::DailyTaskScheduler => Some(from.as_any_ref().downcast_ref::<DailyTaskScheduler>()?),
            StructType::MonthlyTaskScheduler => Some(from.as_any_ref().downcast_ref::<MonthlyTaskScheduler>()?),
            StructType::MonthlyByDayTaskScheduler => Some(from.as_any_ref().downcast_ref::<MonthlyByDayTaskScheduler>()?),
            StructType::MonthlyByWeekdayTaskScheduler => Some(from.as_any_ref().downcast_ref::<MonthlyByWeekdayTaskScheduler>()?),
            StructType::WeeklyTaskScheduler => Some(from.as_any_ref().downcast_ref::<WeeklyTaskScheduler>()?),
            StructType::ApplyStorageRecommendationResult => Some(from.as_any_ref().downcast_ref::<ApplyStorageRecommendationResult>()?),
            StructType::StorageDrsAutomationConfig => Some(from.as_any_ref().downcast_ref::<StorageDrsAutomationConfig>()?),
            StructType::StorageDrsConfigInfo => Some(from.as_any_ref().downcast_ref::<StorageDrsConfigInfo>()?),
            StructType::StorageDrsConfigSpec => Some(from.as_any_ref().downcast_ref::<StorageDrsConfigSpec>()?),
            StructType::StorageDrsIoLoadBalanceConfig => Some(from.as_any_ref().downcast_ref::<StorageDrsIoLoadBalanceConfig>()?),
            StructType::PlacementAffinityRule => Some(from.as_any_ref().downcast_ref::<PlacementAffinityRule>()?),
            StructType::PlacementRankResult => Some(from.as_any_ref().downcast_ref::<PlacementRankResult>()?),
            StructType::PlacementRankSpec => Some(from.as_any_ref().downcast_ref::<PlacementRankSpec>()?),
            StructType::StorageDrsPlacementRankVmSpec => Some(from.as_any_ref().downcast_ref::<StorageDrsPlacementRankVmSpec>()?),
            StructType::StorageDrsPodConfigInfo => Some(from.as_any_ref().downcast_ref::<StorageDrsPodConfigInfo>()?),
            StructType::StorageDrsPodConfigSpec => Some(from.as_any_ref().downcast_ref::<StorageDrsPodConfigSpec>()?),
            StructType::StorageDrsPodSelectionSpec => Some(from.as_any_ref().downcast_ref::<StorageDrsPodSelectionSpec>()?),
            StructType::PodDiskLocator => Some(from.as_any_ref().downcast_ref::<PodDiskLocator>()?),
            StructType::VmPodConfigForPlacement => Some(from.as_any_ref().downcast_ref::<VmPodConfigForPlacement>()?),
            StructType::StorageDrsSpaceLoadBalanceConfig => Some(from.as_any_ref().downcast_ref::<StorageDrsSpaceLoadBalanceConfig>()?),
            StructType::StoragePlacementResult => Some(from.as_any_ref().downcast_ref::<StoragePlacementResult>()?),
            StructType::StoragePlacementSpec => Some(from.as_any_ref().downcast_ref::<StoragePlacementSpec>()?),
            StructType::StorageDrsVmConfigInfo => Some(from.as_any_ref().downcast_ref::<StorageDrsVmConfigInfo>()?),
            StructType::VAppCloneSpec => Some(from.as_any_ref().downcast_ref::<VAppCloneSpec>()?),
            StructType::VAppCloneSpecNetworkMappingPair => Some(from.as_any_ref().downcast_ref::<VAppCloneSpecNetworkMappingPair>()?),
            StructType::VAppCloneSpecResourceMap => Some(from.as_any_ref().downcast_ref::<VAppCloneSpecResourceMap>()?),
            StructType::VAppEntityConfigInfo => Some(from.as_any_ref().downcast_ref::<VAppEntityConfigInfo>()?),
            StructType::VAppIpAssignmentInfo => Some(from.as_any_ref().downcast_ref::<VAppIpAssignmentInfo>()?),
            StructType::IpPool => Some(from.as_any_ref().downcast_ref::<IpPool>()?),
            StructType::IpPoolAssociation => Some(from.as_any_ref().downcast_ref::<IpPoolAssociation>()?),
            StructType::IpPoolIpPoolConfigInfo => Some(from.as_any_ref().downcast_ref::<IpPoolIpPoolConfigInfo>()?),
            StructType::VAppOvfSectionInfo => Some(from.as_any_ref().downcast_ref::<VAppOvfSectionInfo>()?),
            StructType::VAppProductInfo => Some(from.as_any_ref().downcast_ref::<VAppProductInfo>()?),
            StructType::VAppPropertyInfo => Some(from.as_any_ref().downcast_ref::<VAppPropertyInfo>()?),
            StructType::VmConfigInfo => Some(from.as_any_ref().downcast_ref::<VmConfigInfo>()?),
            StructType::VAppConfigInfo => Some(from.as_any_ref().downcast_ref::<VAppConfigInfo>()?),
            StructType::VmConfigSpec => Some(from.as_any_ref().downcast_ref::<VmConfigSpec>()?),
            StructType::VAppConfigSpec => Some(from.as_any_ref().downcast_ref::<VAppConfigSpec>()?),
            StructType::ClusterNetworkConfigSpec => Some(from.as_any_ref().downcast_ref::<ClusterNetworkConfigSpec>()?),
            StructType::FailoverNodeInfo => Some(from.as_any_ref().downcast_ref::<FailoverNodeInfo>()?),
            StructType::NodeDeploymentSpec => Some(from.as_any_ref().downcast_ref::<NodeDeploymentSpec>()?),
            StructType::PassiveNodeDeploymentSpec => Some(from.as_any_ref().downcast_ref::<PassiveNodeDeploymentSpec>()?),
            StructType::NodeNetworkSpec => Some(from.as_any_ref().downcast_ref::<NodeNetworkSpec>()?),
            StructType::PassiveNodeNetworkSpec => Some(from.as_any_ref().downcast_ref::<PassiveNodeNetworkSpec>()?),
            StructType::SourceNodeSpec => Some(from.as_any_ref().downcast_ref::<SourceNodeSpec>()?),
            StructType::VchaClusterConfigInfo => Some(from.as_any_ref().downcast_ref::<VchaClusterConfigInfo>()?),
            StructType::VchaClusterConfigSpec => Some(from.as_any_ref().downcast_ref::<VchaClusterConfigSpec>()?),
            StructType::VchaClusterDeploymentSpec => Some(from.as_any_ref().downcast_ref::<VchaClusterDeploymentSpec>()?),
            StructType::VchaClusterNetworkSpec => Some(from.as_any_ref().downcast_ref::<VchaClusterNetworkSpec>()?),
            StructType::WitnessNodeInfo => Some(from.as_any_ref().downcast_ref::<WitnessNodeInfo>()?),
            StructType::VchaClusterHealth => Some(from.as_any_ref().downcast_ref::<VchaClusterHealth>()?),
            StructType::VchaClusterRuntimeInfo => Some(from.as_any_ref().downcast_ref::<VchaClusterRuntimeInfo>()?),
            StructType::VchaNodeRuntimeInfo => Some(from.as_any_ref().downcast_ref::<VchaNodeRuntimeInfo>()?),
            StructType::VirtualMachineAffinityInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineAffinityInfo>()?),
            StructType::VirtualMachineBaseIndependentFilterSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineBaseIndependentFilterSpec>()?),
            StructType::VirtualMachineEmptyIndependentFilterSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineEmptyIndependentFilterSpec>()?),
            StructType::VirtualMachineIndependentFilterSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineIndependentFilterSpec>()?),
            StructType::VirtualMachineBootOptions => Some(from.as_any_ref().downcast_ref::<VirtualMachineBootOptions>()?),
            StructType::VirtualMachineBootOptionsBootableDevice => Some(from.as_any_ref().downcast_ref::<VirtualMachineBootOptionsBootableDevice>()?),
            StructType::VirtualMachineBootOptionsBootableCdromDevice => Some(from.as_any_ref().downcast_ref::<VirtualMachineBootOptionsBootableCdromDevice>()?),
            StructType::VirtualMachineBootOptionsBootableDiskDevice => Some(from.as_any_ref().downcast_ref::<VirtualMachineBootOptionsBootableDiskDevice>()?),
            StructType::VirtualMachineBootOptionsBootableEthernetDevice => Some(from.as_any_ref().downcast_ref::<VirtualMachineBootOptionsBootableEthernetDevice>()?),
            StructType::VirtualMachineBootOptionsBootableFloppyDevice => Some(from.as_any_ref().downcast_ref::<VirtualMachineBootOptionsBootableFloppyDevice>()?),
            StructType::VirtualMachineCapability => Some(from.as_any_ref().downcast_ref::<VirtualMachineCapability>()?),
            StructType::VirtualMachineCertThumbprint => Some(from.as_any_ref().downcast_ref::<VirtualMachineCertThumbprint>()?),
            StructType::VirtualMachineCloneSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineCloneSpec>()?),
            StructType::VirtualMachineConfigInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineConfigInfo>()?),
            StructType::VirtualMachineConfigInfoDatastoreUrlPair => Some(from.as_any_ref().downcast_ref::<VirtualMachineConfigInfoDatastoreUrlPair>()?),
            StructType::VirtualMachineConfigInfoOverheadInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineConfigInfoOverheadInfo>()?),
            StructType::VirtualMachineConfigOption => Some(from.as_any_ref().downcast_ref::<VirtualMachineConfigOption>()?),
            StructType::VirtualMachineConfigOptionDescriptor => Some(from.as_any_ref().downcast_ref::<VirtualMachineConfigOptionDescriptor>()?),
            StructType::VirtualMachineConfigSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineConfigSpec>()?),
            StructType::ConfigTarget => Some(from.as_any_ref().downcast_ref::<ConfigTarget>()?),
            StructType::VirtualMachineConsolePreferences => Some(from.as_any_ref().downcast_ref::<VirtualMachineConsolePreferences>()?),
            StructType::VirtualMachineContentLibraryItemInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineContentLibraryItemInfo>()?),
            StructType::DatastoreOption => Some(from.as_any_ref().downcast_ref::<DatastoreOption>()?),
            StructType::VirtualMachineDatastoreVolumeOption => Some(from.as_any_ref().downcast_ref::<VirtualMachineDatastoreVolumeOption>()?),
            StructType::VirtualMachineDefaultPowerOpInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineDefaultPowerOpInfo>()?),
            StructType::VirtualMachineDeviceRuntimeInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineDeviceRuntimeInfo>()?),
            StructType::VirtualMachineDeviceRuntimeInfoDeviceRuntimeState => Some(from.as_any_ref().downcast_ref::<VirtualMachineDeviceRuntimeInfoDeviceRuntimeState>()?),
            StructType::VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState => Some(from.as_any_ref().downcast_ref::<VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState>()?),
            StructType::VirtualMachineDvxClassInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineDvxClassInfo>()?),
            StructType::FaultToleranceConfigInfo => Some(from.as_any_ref().downcast_ref::<FaultToleranceConfigInfo>()?),
            StructType::FaultTolerancePrimaryConfigInfo => Some(from.as_any_ref().downcast_ref::<FaultTolerancePrimaryConfigInfo>()?),
            StructType::FaultToleranceSecondaryConfigInfo => Some(from.as_any_ref().downcast_ref::<FaultToleranceSecondaryConfigInfo>()?),
            StructType::FaultToleranceConfigSpec => Some(from.as_any_ref().downcast_ref::<FaultToleranceConfigSpec>()?),
            StructType::FaultToleranceMetaSpec => Some(from.as_any_ref().downcast_ref::<FaultToleranceMetaSpec>()?),
            StructType::FaultToleranceSecondaryOpResult => Some(from.as_any_ref().downcast_ref::<FaultToleranceSecondaryOpResult>()?),
            StructType::FaultToleranceVmConfigSpec => Some(from.as_any_ref().downcast_ref::<FaultToleranceVmConfigSpec>()?),
            StructType::FaultToleranceDiskSpec => Some(from.as_any_ref().downcast_ref::<FaultToleranceDiskSpec>()?),
            StructType::VirtualMachineFeatureRequirement => Some(from.as_any_ref().downcast_ref::<VirtualMachineFeatureRequirement>()?),
            StructType::VirtualMachineFileInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineFileInfo>()?),
            StructType::VirtualMachineFileLayout => Some(from.as_any_ref().downcast_ref::<VirtualMachineFileLayout>()?),
            StructType::VirtualMachineFileLayoutDiskLayout => Some(from.as_any_ref().downcast_ref::<VirtualMachineFileLayoutDiskLayout>()?),
            StructType::VirtualMachineFileLayoutSnapshotLayout => Some(from.as_any_ref().downcast_ref::<VirtualMachineFileLayoutSnapshotLayout>()?),
            StructType::VirtualMachineFileLayoutEx => Some(from.as_any_ref().downcast_ref::<VirtualMachineFileLayoutEx>()?),
            StructType::VirtualMachineFileLayoutExDiskLayout => Some(from.as_any_ref().downcast_ref::<VirtualMachineFileLayoutExDiskLayout>()?),
            StructType::VirtualMachineFileLayoutExDiskUnit => Some(from.as_any_ref().downcast_ref::<VirtualMachineFileLayoutExDiskUnit>()?),
            StructType::VirtualMachineFileLayoutExFileInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineFileLayoutExFileInfo>()?),
            StructType::VirtualMachineFileLayoutExSnapshotLayout => Some(from.as_any_ref().downcast_ref::<VirtualMachineFileLayoutExSnapshotLayout>()?),
            StructType::VirtualMachineFlagInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineFlagInfo>()?),
            StructType::VirtualMachineForkConfigInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineForkConfigInfo>()?),
            StructType::GuestInfo => Some(from.as_any_ref().downcast_ref::<GuestInfo>()?),
            StructType::GuestInfoCustomizationInfo => Some(from.as_any_ref().downcast_ref::<GuestInfoCustomizationInfo>()?),
            StructType::GuestDiskInfo => Some(from.as_any_ref().downcast_ref::<GuestDiskInfo>()?),
            StructType::GuestInfoNamespaceGenerationInfo => Some(from.as_any_ref().downcast_ref::<GuestInfoNamespaceGenerationInfo>()?),
            StructType::GuestNicInfo => Some(from.as_any_ref().downcast_ref::<GuestNicInfo>()?),
            StructType::GuestScreenInfo => Some(from.as_any_ref().downcast_ref::<GuestScreenInfo>()?),
            StructType::GuestStackInfo => Some(from.as_any_ref().downcast_ref::<GuestStackInfo>()?),
            StructType::GuestInfoVirtualDiskMapping => Some(from.as_any_ref().downcast_ref::<GuestInfoVirtualDiskMapping>()?),
            StructType::VirtualMachineGuestIntegrityInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineGuestIntegrityInfo>()?),
            StructType::VirtualMachineGuestMonitoringModeInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineGuestMonitoringModeInfo>()?),
            StructType::GuestOsDescriptor => Some(from.as_any_ref().downcast_ref::<GuestOsDescriptor>()?),
            StructType::VirtualMachineGuestQuiesceSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineGuestQuiesceSpec>()?),
            StructType::VirtualMachineWindowsQuiesceSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineWindowsQuiesceSpec>()?),
            StructType::VirtualMachineIdeDiskDevicePartitionInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineIdeDiskDevicePartitionInfo>()?),
            StructType::VirtualMachineInstantCloneSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineInstantCloneSpec>()?),
            StructType::VirtualMachineLegacyNetworkSwitchInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineLegacyNetworkSwitchInfo>()?),
            StructType::VirtualMachineMessage => Some(from.as_any_ref().downcast_ref::<VirtualMachineMessage>()?),
            StructType::VirtualMachineMetadataManagerVmMetadata => Some(from.as_any_ref().downcast_ref::<VirtualMachineMetadataManagerVmMetadata>()?),
            StructType::VirtualMachineMetadataManagerVmMetadataInput => Some(from.as_any_ref().downcast_ref::<VirtualMachineMetadataManagerVmMetadataInput>()?),
            StructType::VirtualMachineMetadataManagerVmMetadataOwner => Some(from.as_any_ref().downcast_ref::<VirtualMachineMetadataManagerVmMetadataOwner>()?),
            StructType::VirtualMachineMetadataManagerVmMetadataResult => Some(from.as_any_ref().downcast_ref::<VirtualMachineMetadataManagerVmMetadataResult>()?),
            StructType::VirtualMachineNetworkShaperInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineNetworkShaperInfo>()?),
            StructType::VirtualMachineProfileDetails => Some(from.as_any_ref().downcast_ref::<VirtualMachineProfileDetails>()?),
            StructType::VirtualMachineProfileDetailsDiskProfileDetails => Some(from.as_any_ref().downcast_ref::<VirtualMachineProfileDetailsDiskProfileDetails>()?),
            StructType::VirtualMachineProfileRawData => Some(from.as_any_ref().downcast_ref::<VirtualMachineProfileRawData>()?),
            StructType::VirtualMachineProfileSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineProfileSpec>()?),
            StructType::VirtualMachineDefaultProfileSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineDefaultProfileSpec>()?),
            StructType::VirtualMachineDefinedProfileSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineDefinedProfileSpec>()?),
            StructType::VirtualMachineEmptyProfileSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineEmptyProfileSpec>()?),
            StructType::VirtualMachinePropertyRelation => Some(from.as_any_ref().downcast_ref::<VirtualMachinePropertyRelation>()?),
            StructType::VirtualMachineQuestionInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineQuestionInfo>()?),
            StructType::VirtualMachineRelocateSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineRelocateSpec>()?),
            StructType::VirtualMachineRelocateSpecDiskLocator => Some(from.as_any_ref().downcast_ref::<VirtualMachineRelocateSpecDiskLocator>()?),
            StructType::VirtualMachineRelocateSpecDiskLocatorBackingSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineRelocateSpecDiskLocatorBackingSpec>()?),
            StructType::ReplicationConfigSpec => Some(from.as_any_ref().downcast_ref::<ReplicationConfigSpec>()?),
            StructType::ReplicationInfoDiskSettings => Some(from.as_any_ref().downcast_ref::<ReplicationInfoDiskSettings>()?),
            StructType::VirtualMachineRuntimeInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineRuntimeInfo>()?),
            StructType::VirtualMachineRuntimeInfoDasProtectionState => Some(from.as_any_ref().downcast_ref::<VirtualMachineRuntimeInfoDasProtectionState>()?),
            StructType::ScheduledHardwareUpgradeInfo => Some(from.as_any_ref().downcast_ref::<ScheduledHardwareUpgradeInfo>()?),
            StructType::VirtualMachineSgxInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineSgxInfo>()?),
            StructType::VirtualMachineSnapshotInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineSnapshotInfo>()?),
            StructType::VirtualMachineSnapshotTree => Some(from.as_any_ref().downcast_ref::<VirtualMachineSnapshotTree>()?),
            StructType::VirtualMachineSriovDevicePoolInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineSriovDevicePoolInfo>()?),
            StructType::VirtualMachineSriovNetworkDevicePoolInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineSriovNetworkDevicePoolInfo>()?),
            StructType::VirtualMachineStorageInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineStorageInfo>()?),
            StructType::VirtualMachineUsageOnDatastore => Some(from.as_any_ref().downcast_ref::<VirtualMachineUsageOnDatastore>()?),
            StructType::VirtualMachineSummary => Some(from.as_any_ref().downcast_ref::<VirtualMachineSummary>()?),
            StructType::VirtualMachineConfigSummary => Some(from.as_any_ref().downcast_ref::<VirtualMachineConfigSummary>()?),
            StructType::VirtualMachineGuestSummary => Some(from.as_any_ref().downcast_ref::<VirtualMachineGuestSummary>()?),
            StructType::VirtualMachineQuickStats => Some(from.as_any_ref().downcast_ref::<VirtualMachineQuickStats>()?),
            StructType::VirtualMachineQuickStatsMemoryTierStats => Some(from.as_any_ref().downcast_ref::<VirtualMachineQuickStatsMemoryTierStats>()?),
            StructType::VirtualMachineStorageSummary => Some(from.as_any_ref().downcast_ref::<VirtualMachineStorageSummary>()?),
            StructType::VirtualMachineTargetInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineTargetInfo>()?),
            StructType::VirtualMachineCdromInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineCdromInfo>()?),
            StructType::VirtualMachineDatastoreInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineDatastoreInfo>()?),
            StructType::VirtualMachineDiskDeviceInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineDiskDeviceInfo>()?),
            StructType::VirtualMachineIdeDiskDeviceInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineIdeDiskDeviceInfo>()?),
            StructType::VirtualMachineScsiDiskDeviceInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineScsiDiskDeviceInfo>()?),
            StructType::VirtualMachineDynamicPassthroughInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineDynamicPassthroughInfo>()?),
            StructType::VirtualMachineFloppyInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineFloppyInfo>()?),
            StructType::VirtualMachineNetworkInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineNetworkInfo>()?),
            StructType::OpaqueNetworkTargetInfo => Some(from.as_any_ref().downcast_ref::<OpaqueNetworkTargetInfo>()?),
            StructType::VirtualMachineParallelInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineParallelInfo>()?),
            StructType::VirtualMachinePciPassthroughInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachinePciPassthroughInfo>()?),
            StructType::VirtualMachineSriovInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineSriovInfo>()?),
            StructType::VirtualMachinePciSharedGpuPassthroughInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachinePciSharedGpuPassthroughInfo>()?),
            StructType::VirtualMachinePrecisionClockInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachinePrecisionClockInfo>()?),
            StructType::VirtualMachineScsiPassthroughInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineScsiPassthroughInfo>()?),
            StructType::VirtualMachineSerialInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineSerialInfo>()?),
            StructType::VirtualMachineSgxTargetInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineSgxTargetInfo>()?),
            StructType::VirtualMachineSoundInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineSoundInfo>()?),
            StructType::VirtualMachineUsbInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineUsbInfo>()?),
            StructType::VirtualMachineVFlashModuleInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineVFlashModuleInfo>()?),
            StructType::VirtualMachineVMotionStunTimeInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineVMotionStunTimeInfo>()?),
            StructType::VirtualMachineVendorDeviceGroupInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineVendorDeviceGroupInfo>()?),
            StructType::VirtualMachineVgpuDeviceInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineVgpuDeviceInfo>()?),
            StructType::VirtualMachineVgpuProfileInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineVgpuProfileInfo>()?),
            StructType::ToolsConfigInfo => Some(from.as_any_ref().downcast_ref::<ToolsConfigInfo>()?),
            StructType::ToolsConfigInfoToolsLastInstallInfo => Some(from.as_any_ref().downcast_ref::<ToolsConfigInfoToolsLastInstallInfo>()?),
            StructType::UsbScanCodeSpec => Some(from.as_any_ref().downcast_ref::<UsbScanCodeSpec>()?),
            StructType::UsbScanCodeSpecKeyEvent => Some(from.as_any_ref().downcast_ref::<UsbScanCodeSpecKeyEvent>()?),
            StructType::UsbScanCodeSpecModifierType => Some(from.as_any_ref().downcast_ref::<UsbScanCodeSpecModifierType>()?),
            StructType::VirtualMachineVcpuConfig => Some(from.as_any_ref().downcast_ref::<VirtualMachineVcpuConfig>()?),
            StructType::VirtualMachineVendorDeviceGroupInfoComponentDeviceInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineVendorDeviceGroupInfoComponentDeviceInfo>()?),
            StructType::VirtualMachineVirtualDeviceGroups => Some(from.as_any_ref().downcast_ref::<VirtualMachineVirtualDeviceGroups>()?),
            StructType::VirtualMachineVirtualDeviceGroupsDeviceGroup => Some(from.as_any_ref().downcast_ref::<VirtualMachineVirtualDeviceGroupsDeviceGroup>()?),
            StructType::VirtualMachineVirtualDeviceGroupsVendorDeviceGroup => Some(from.as_any_ref().downcast_ref::<VirtualMachineVirtualDeviceGroupsVendorDeviceGroup>()?),
            StructType::VirtualMachineVirtualDeviceSwap => Some(from.as_any_ref().downcast_ref::<VirtualMachineVirtualDeviceSwap>()?),
            StructType::VirtualMachineVirtualDeviceSwapDeviceSwapInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineVirtualDeviceSwapDeviceSwapInfo>()?),
            StructType::VirtualHardware => Some(from.as_any_ref().downcast_ref::<VirtualHardware>()?),
            StructType::VirtualHardwareOption => Some(from.as_any_ref().downcast_ref::<VirtualHardwareOption>()?),
            StructType::VirtualMachineVirtualNuma => Some(from.as_any_ref().downcast_ref::<VirtualMachineVirtualNuma>()?),
            StructType::VirtualMachineVirtualNumaInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineVirtualNumaInfo>()?),
            StructType::VirtualMachineVirtualPMem => Some(from.as_any_ref().downcast_ref::<VirtualMachineVirtualPMem>()?),
            StructType::CheckResult => Some(from.as_any_ref().downcast_ref::<CheckResult>()?),
            StructType::CustomizationAdapterMapping => Some(from.as_any_ref().downcast_ref::<CustomizationAdapterMapping>()?),
            StructType::CustomizationGlobalIpSettings => Some(from.as_any_ref().downcast_ref::<CustomizationGlobalIpSettings>()?),
            StructType::CustomizationGuiRunOnce => Some(from.as_any_ref().downcast_ref::<CustomizationGuiRunOnce>()?),
            StructType::CustomizationGuiUnattended => Some(from.as_any_ref().downcast_ref::<CustomizationGuiUnattended>()?),
            StructType::CustomizationIpSettings => Some(from.as_any_ref().downcast_ref::<CustomizationIpSettings>()?),
            StructType::CustomizationIpSettingsIpV6AddressSpec => Some(from.as_any_ref().downcast_ref::<CustomizationIpSettingsIpV6AddressSpec>()?),
            StructType::CustomizationIdentification => Some(from.as_any_ref().downcast_ref::<CustomizationIdentification>()?),
            StructType::CustomizationIdentitySettings => Some(from.as_any_ref().downcast_ref::<CustomizationIdentitySettings>()?),
            StructType::CustomizationCloudinitPrep => Some(from.as_any_ref().downcast_ref::<CustomizationCloudinitPrep>()?),
            StructType::CustomizationLinuxPrep => Some(from.as_any_ref().downcast_ref::<CustomizationLinuxPrep>()?),
            StructType::CustomizationSysprep => Some(from.as_any_ref().downcast_ref::<CustomizationSysprep>()?),
            StructType::CustomizationSysprepText => Some(from.as_any_ref().downcast_ref::<CustomizationSysprepText>()?),
            StructType::CustomizationIpGenerator => Some(from.as_any_ref().downcast_ref::<CustomizationIpGenerator>()?),
            StructType::CustomizationCustomIpGenerator => Some(from.as_any_ref().downcast_ref::<CustomizationCustomIpGenerator>()?),
            StructType::CustomizationDhcpIpGenerator => Some(from.as_any_ref().downcast_ref::<CustomizationDhcpIpGenerator>()?),
            StructType::CustomizationFixedIp => Some(from.as_any_ref().downcast_ref::<CustomizationFixedIp>()?),
            StructType::CustomizationUnknownIpGenerator => Some(from.as_any_ref().downcast_ref::<CustomizationUnknownIpGenerator>()?),
            StructType::CustomizationIpV6Generator => Some(from.as_any_ref().downcast_ref::<CustomizationIpV6Generator>()?),
            StructType::CustomizationAutoIpV6Generator => Some(from.as_any_ref().downcast_ref::<CustomizationAutoIpV6Generator>()?),
            StructType::CustomizationCustomIpV6Generator => Some(from.as_any_ref().downcast_ref::<CustomizationCustomIpV6Generator>()?),
            StructType::CustomizationDhcpIpV6Generator => Some(from.as_any_ref().downcast_ref::<CustomizationDhcpIpV6Generator>()?),
            StructType::CustomizationFixedIpV6 => Some(from.as_any_ref().downcast_ref::<CustomizationFixedIpV6>()?),
            StructType::CustomizationStatelessIpV6Generator => Some(from.as_any_ref().downcast_ref::<CustomizationStatelessIpV6Generator>()?),
            StructType::CustomizationUnknownIpV6Generator => Some(from.as_any_ref().downcast_ref::<CustomizationUnknownIpV6Generator>()?),
            StructType::CustomizationLicenseFilePrintData => Some(from.as_any_ref().downcast_ref::<CustomizationLicenseFilePrintData>()?),
            StructType::CustomizationName => Some(from.as_any_ref().downcast_ref::<CustomizationName>()?),
            StructType::CustomizationCustomName => Some(from.as_any_ref().downcast_ref::<CustomizationCustomName>()?),
            StructType::CustomizationFixedName => Some(from.as_any_ref().downcast_ref::<CustomizationFixedName>()?),
            StructType::CustomizationPrefixName => Some(from.as_any_ref().downcast_ref::<CustomizationPrefixName>()?),
            StructType::CustomizationUnknownName => Some(from.as_any_ref().downcast_ref::<CustomizationUnknownName>()?),
            StructType::CustomizationVirtualMachineName => Some(from.as_any_ref().downcast_ref::<CustomizationVirtualMachineName>()?),
            StructType::CustomizationOptions => Some(from.as_any_ref().downcast_ref::<CustomizationOptions>()?),
            StructType::CustomizationLinuxOptions => Some(from.as_any_ref().downcast_ref::<CustomizationLinuxOptions>()?),
            StructType::CustomizationWinOptions => Some(from.as_any_ref().downcast_ref::<CustomizationWinOptions>()?),
            StructType::CustomizationPassword => Some(from.as_any_ref().downcast_ref::<CustomizationPassword>()?),
            StructType::CustomizationSpec => Some(from.as_any_ref().downcast_ref::<CustomizationSpec>()?),
            StructType::CustomizationUserData => Some(from.as_any_ref().downcast_ref::<CustomizationUserData>()?),
            StructType::HostDiskMappingInfo => Some(from.as_any_ref().downcast_ref::<HostDiskMappingInfo>()?),
            StructType::HostDiskMappingPartitionInfo => Some(from.as_any_ref().downcast_ref::<HostDiskMappingPartitionInfo>()?),
            StructType::HostDiskMappingOption => Some(from.as_any_ref().downcast_ref::<HostDiskMappingOption>()?),
            StructType::HostDiskMappingPartitionOption => Some(from.as_any_ref().downcast_ref::<HostDiskMappingPartitionOption>()?),
            StructType::VirtualDevice => Some(from.as_any_ref().downcast_ref::<VirtualDevice>()?),
            StructType::VirtualCdrom => Some(from.as_any_ref().downcast_ref::<VirtualCdrom>()?),
            StructType::VirtualController => Some(from.as_any_ref().downcast_ref::<VirtualController>()?),
            StructType::VirtualIdeController => Some(from.as_any_ref().downcast_ref::<VirtualIdeController>()?),
            StructType::VirtualNvdimmController => Some(from.as_any_ref().downcast_ref::<VirtualNvdimmController>()?),
            StructType::VirtualNvmeController => Some(from.as_any_ref().downcast_ref::<VirtualNvmeController>()?),
            StructType::VirtualPciController => Some(from.as_any_ref().downcast_ref::<VirtualPciController>()?),
            StructType::VirtualPs2Controller => Some(from.as_any_ref().downcast_ref::<VirtualPs2Controller>()?),
            StructType::VirtualSataController => Some(from.as_any_ref().downcast_ref::<VirtualSataController>()?),
            StructType::VirtualAhciController => Some(from.as_any_ref().downcast_ref::<VirtualAhciController>()?),
            StructType::VirtualScsiController => Some(from.as_any_ref().downcast_ref::<VirtualScsiController>()?),
            StructType::ParaVirtualScsiController => Some(from.as_any_ref().downcast_ref::<ParaVirtualScsiController>()?),
            StructType::VirtualBusLogicController => Some(from.as_any_ref().downcast_ref::<VirtualBusLogicController>()?),
            StructType::VirtualLsiLogicController => Some(from.as_any_ref().downcast_ref::<VirtualLsiLogicController>()?),
            StructType::VirtualLsiLogicSasController => Some(from.as_any_ref().downcast_ref::<VirtualLsiLogicSasController>()?),
            StructType::VirtualSioController => Some(from.as_any_ref().downcast_ref::<VirtualSioController>()?),
            StructType::VirtualUsbController => Some(from.as_any_ref().downcast_ref::<VirtualUsbController>()?),
            StructType::VirtualUsbxhciController => Some(from.as_any_ref().downcast_ref::<VirtualUsbxhciController>()?),
            StructType::VirtualDisk => Some(from.as_any_ref().downcast_ref::<VirtualDisk>()?),
            StructType::VirtualEthernetCard => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCard>()?),
            StructType::VirtualE1000 => Some(from.as_any_ref().downcast_ref::<VirtualE1000>()?),
            StructType::VirtualE1000E => Some(from.as_any_ref().downcast_ref::<VirtualE1000E>()?),
            StructType::VirtualPcNet32 => Some(from.as_any_ref().downcast_ref::<VirtualPcNet32>()?),
            StructType::VirtualSriovEthernetCard => Some(from.as_any_ref().downcast_ref::<VirtualSriovEthernetCard>()?),
            StructType::VirtualVmxnet => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet>()?),
            StructType::VirtualVmxnet2 => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet2>()?),
            StructType::VirtualVmxnet3 => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3>()?),
            StructType::VirtualVmxnet3Vrdma => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3Vrdma>()?),
            StructType::VirtualFloppy => Some(from.as_any_ref().downcast_ref::<VirtualFloppy>()?),
            StructType::VirtualKeyboard => Some(from.as_any_ref().downcast_ref::<VirtualKeyboard>()?),
            StructType::VirtualNvdimm => Some(from.as_any_ref().downcast_ref::<VirtualNvdimm>()?),
            StructType::VirtualPciPassthrough => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthrough>()?),
            StructType::VirtualParallelPort => Some(from.as_any_ref().downcast_ref::<VirtualParallelPort>()?),
            StructType::VirtualPointingDevice => Some(from.as_any_ref().downcast_ref::<VirtualPointingDevice>()?),
            StructType::VirtualPrecisionClock => Some(from.as_any_ref().downcast_ref::<VirtualPrecisionClock>()?),
            StructType::VirtualScsiPassthrough => Some(from.as_any_ref().downcast_ref::<VirtualScsiPassthrough>()?),
            StructType::VirtualSerialPort => Some(from.as_any_ref().downcast_ref::<VirtualSerialPort>()?),
            StructType::VirtualSoundCard => Some(from.as_any_ref().downcast_ref::<VirtualSoundCard>()?),
            StructType::VirtualEnsoniq1371 => Some(from.as_any_ref().downcast_ref::<VirtualEnsoniq1371>()?),
            StructType::VirtualHdAudioCard => Some(from.as_any_ref().downcast_ref::<VirtualHdAudioCard>()?),
            StructType::VirtualSoundBlaster16 => Some(from.as_any_ref().downcast_ref::<VirtualSoundBlaster16>()?),
            StructType::VirtualTpm => Some(from.as_any_ref().downcast_ref::<VirtualTpm>()?),
            StructType::VirtualUsb => Some(from.as_any_ref().downcast_ref::<VirtualUsb>()?),
            StructType::VirtualMachineVmciDevice => Some(from.as_any_ref().downcast_ref::<VirtualMachineVmciDevice>()?),
            StructType::VirtualMachineVmirom => Some(from.as_any_ref().downcast_ref::<VirtualMachineVmirom>()?),
            StructType::VirtualMachineVideoCard => Some(from.as_any_ref().downcast_ref::<VirtualMachineVideoCard>()?),
            StructType::VirtualWdt => Some(from.as_any_ref().downcast_ref::<VirtualWdt>()?),
            StructType::VirtualDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDeviceBackingInfo>()?),
            StructType::VirtualDeviceDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDeviceDeviceBackingInfo>()?),
            StructType::VirtualCdromAtapiBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualCdromAtapiBackingInfo>()?),
            StructType::VirtualCdromPassthroughBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualCdromPassthroughBackingInfo>()?),
            StructType::VirtualDiskRawDiskVer2BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskRawDiskVer2BackingInfo>()?),
            StructType::VirtualDiskPartitionedRawDiskVer2BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskPartitionedRawDiskVer2BackingInfo>()?),
            StructType::VirtualEthernetCardLegacyNetworkBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardLegacyNetworkBackingInfo>()?),
            StructType::VirtualEthernetCardNetworkBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardNetworkBackingInfo>()?),
            StructType::VirtualFloppyDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualFloppyDeviceBackingInfo>()?),
            StructType::VirtualPciPassthroughDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughDeviceBackingInfo>()?),
            StructType::VirtualPciPassthroughDynamicBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughDynamicBackingInfo>()?),
            StructType::VirtualParallelPortDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualParallelPortDeviceBackingInfo>()?),
            StructType::VirtualPointingDeviceDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPointingDeviceDeviceBackingInfo>()?),
            StructType::VirtualScsiPassthroughDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualScsiPassthroughDeviceBackingInfo>()?),
            StructType::VirtualSerialPortDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortDeviceBackingInfo>()?),
            StructType::VirtualSoundCardDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSoundCardDeviceBackingInfo>()?),
            StructType::VirtualUsbRemoteHostBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualUsbRemoteHostBackingInfo>()?),
            StructType::VirtualUsbusbBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualUsbusbBackingInfo>()?),
            StructType::VirtualDeviceFileBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDeviceFileBackingInfo>()?),
            StructType::VirtualCdromIsoBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualCdromIsoBackingInfo>()?),
            StructType::VirtualDiskFlatVer1BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskFlatVer1BackingInfo>()?),
            StructType::VirtualDiskFlatVer2BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskFlatVer2BackingInfo>()?),
            StructType::VirtualDiskLocalPMemBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskLocalPMemBackingInfo>()?),
            StructType::VirtualDiskRawDiskMappingVer1BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskRawDiskMappingVer1BackingInfo>()?),
            StructType::VirtualDiskSeSparseBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskSeSparseBackingInfo>()?),
            StructType::VirtualDiskSparseVer1BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskSparseVer1BackingInfo>()?),
            StructType::VirtualDiskSparseVer2BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskSparseVer2BackingInfo>()?),
            StructType::VirtualFloppyImageBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualFloppyImageBackingInfo>()?),
            StructType::VirtualNvdimmBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualNvdimmBackingInfo>()?),
            StructType::VirtualParallelPortFileBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualParallelPortFileBackingInfo>()?),
            StructType::VirtualSerialPortFileBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortFileBackingInfo>()?),
            StructType::VirtualDevicePipeBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDevicePipeBackingInfo>()?),
            StructType::VirtualSerialPortPipeBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortPipeBackingInfo>()?),
            StructType::VirtualDeviceRemoteDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDeviceRemoteDeviceBackingInfo>()?),
            StructType::VirtualCdromRemoteAtapiBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualCdromRemoteAtapiBackingInfo>()?),
            StructType::VirtualCdromRemotePassthroughBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualCdromRemotePassthroughBackingInfo>()?),
            StructType::VirtualFloppyRemoteDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualFloppyRemoteDeviceBackingInfo>()?),
            StructType::VirtualUsbRemoteClientBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualUsbRemoteClientBackingInfo>()?),
            StructType::VirtualDeviceUriBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDeviceUriBackingInfo>()?),
            StructType::VirtualSerialPortUriBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortUriBackingInfo>()?),
            StructType::VirtualEthernetCardDistributedVirtualPortBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardDistributedVirtualPortBackingInfo>()?),
            StructType::VirtualEthernetCardOpaqueNetworkBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardOpaqueNetworkBackingInfo>()?),
            StructType::VirtualPciPassthroughDvxBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughDvxBackingInfo>()?),
            StructType::VirtualPciPassthroughPluginBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughPluginBackingInfo>()?),
            StructType::VirtualPciPassthroughVmiopBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughVmiopBackingInfo>()?),
            StructType::VirtualPrecisionClockSystemClockBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPrecisionClockSystemClockBackingInfo>()?),
            StructType::VirtualSerialPortThinPrintBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortThinPrintBackingInfo>()?),
            StructType::VirtualSriovEthernetCardSriovBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSriovEthernetCardSriovBackingInfo>()?),
            StructType::VirtualDeviceBusSlotInfo => Some(from.as_any_ref().downcast_ref::<VirtualDeviceBusSlotInfo>()?),
            StructType::VirtualDevicePciBusSlotInfo => Some(from.as_any_ref().downcast_ref::<VirtualDevicePciBusSlotInfo>()?),
            StructType::VirtualUsbControllerPciBusSlotInfo => Some(from.as_any_ref().downcast_ref::<VirtualUsbControllerPciBusSlotInfo>()?),
            StructType::VirtualDeviceConnectInfo => Some(from.as_any_ref().downcast_ref::<VirtualDeviceConnectInfo>()?),
            StructType::VirtualDeviceDeviceGroupInfo => Some(from.as_any_ref().downcast_ref::<VirtualDeviceDeviceGroupInfo>()?),
            StructType::VirtualDeviceOption => Some(from.as_any_ref().downcast_ref::<VirtualDeviceOption>()?),
            StructType::VirtualCdromOption => Some(from.as_any_ref().downcast_ref::<VirtualCdromOption>()?),
            StructType::VirtualControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualControllerOption>()?),
            StructType::VirtualIdeControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualIdeControllerOption>()?),
            StructType::VirtualNvdimmControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualNvdimmControllerOption>()?),
            StructType::VirtualNvmeControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualNvmeControllerOption>()?),
            StructType::VirtualPciControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualPciControllerOption>()?),
            StructType::VirtualPs2ControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualPs2ControllerOption>()?),
            StructType::VirtualSataControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualSataControllerOption>()?),
            StructType::VirtualAhciControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualAhciControllerOption>()?),
            StructType::VirtualScsiControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualScsiControllerOption>()?),
            StructType::ParaVirtualScsiControllerOption => Some(from.as_any_ref().downcast_ref::<ParaVirtualScsiControllerOption>()?),
            StructType::VirtualBusLogicControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualBusLogicControllerOption>()?),
            StructType::VirtualLsiLogicControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualLsiLogicControllerOption>()?),
            StructType::VirtualLsiLogicSasControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualLsiLogicSasControllerOption>()?),
            StructType::VirtualSioControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualSioControllerOption>()?),
            StructType::VirtualUsbControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualUsbControllerOption>()?),
            StructType::VirtualUsbxhciControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualUsbxhciControllerOption>()?),
            StructType::VirtualDiskOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskOption>()?),
            StructType::VirtualEthernetCardOption => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardOption>()?),
            StructType::VirtualE1000Option => Some(from.as_any_ref().downcast_ref::<VirtualE1000Option>()?),
            StructType::VirtualE1000EOption => Some(from.as_any_ref().downcast_ref::<VirtualE1000EOption>()?),
            StructType::VirtualPcNet32Option => Some(from.as_any_ref().downcast_ref::<VirtualPcNet32Option>()?),
            StructType::VirtualSriovEthernetCardOption => Some(from.as_any_ref().downcast_ref::<VirtualSriovEthernetCardOption>()?),
            StructType::VirtualVmxnetOption => Some(from.as_any_ref().downcast_ref::<VirtualVmxnetOption>()?),
            StructType::VirtualVmxnet2Option => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet2Option>()?),
            StructType::VirtualVmxnet3Option => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3Option>()?),
            StructType::VirtualVmxnet3VrdmaOption => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3VrdmaOption>()?),
            StructType::VirtualFloppyOption => Some(from.as_any_ref().downcast_ref::<VirtualFloppyOption>()?),
            StructType::VirtualKeyboardOption => Some(from.as_any_ref().downcast_ref::<VirtualKeyboardOption>()?),
            StructType::VirtualNvdimmOption => Some(from.as_any_ref().downcast_ref::<VirtualNvdimmOption>()?),
            StructType::VirtualPciPassthroughOption => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughOption>()?),
            StructType::VirtualParallelPortOption => Some(from.as_any_ref().downcast_ref::<VirtualParallelPortOption>()?),
            StructType::VirtualPointingDeviceOption => Some(from.as_any_ref().downcast_ref::<VirtualPointingDeviceOption>()?),
            StructType::VirtualPrecisionClockOption => Some(from.as_any_ref().downcast_ref::<VirtualPrecisionClockOption>()?),
            StructType::VirtualScsiPassthroughOption => Some(from.as_any_ref().downcast_ref::<VirtualScsiPassthroughOption>()?),
            StructType::VirtualSerialPortOption => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortOption>()?),
            StructType::VirtualSoundCardOption => Some(from.as_any_ref().downcast_ref::<VirtualSoundCardOption>()?),
            StructType::VirtualEnsoniq1371Option => Some(from.as_any_ref().downcast_ref::<VirtualEnsoniq1371Option>()?),
            StructType::VirtualHdAudioCardOption => Some(from.as_any_ref().downcast_ref::<VirtualHdAudioCardOption>()?),
            StructType::VirtualSoundBlaster16Option => Some(from.as_any_ref().downcast_ref::<VirtualSoundBlaster16Option>()?),
            StructType::VirtualTpmOption => Some(from.as_any_ref().downcast_ref::<VirtualTpmOption>()?),
            StructType::VirtualUsbOption => Some(from.as_any_ref().downcast_ref::<VirtualUsbOption>()?),
            StructType::VirtualMachineVmciDeviceOption => Some(from.as_any_ref().downcast_ref::<VirtualMachineVmciDeviceOption>()?),
            StructType::VirtualVmiromOption => Some(from.as_any_ref().downcast_ref::<VirtualVmiromOption>()?),
            StructType::VirtualVideoCardOption => Some(from.as_any_ref().downcast_ref::<VirtualVideoCardOption>()?),
            StructType::VirtualWdtOption => Some(from.as_any_ref().downcast_ref::<VirtualWdtOption>()?),
            StructType::VirtualDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDeviceBackingOption>()?),
            StructType::VirtualDeviceDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDeviceDeviceBackingOption>()?),
            StructType::VirtualCdromAtapiBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualCdromAtapiBackingOption>()?),
            StructType::VirtualCdromPassthroughBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualCdromPassthroughBackingOption>()?),
            StructType::VirtualCdromRemoteAtapiBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualCdromRemoteAtapiBackingOption>()?),
            StructType::VirtualDiskRawDiskMappingVer1BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskRawDiskMappingVer1BackingOption>()?),
            StructType::VirtualDiskRawDiskVer2BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskRawDiskVer2BackingOption>()?),
            StructType::VirtualDiskPartitionedRawDiskVer2BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskPartitionedRawDiskVer2BackingOption>()?),
            StructType::VirtualEthernetCardLegacyNetworkBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardLegacyNetworkBackingOption>()?),
            StructType::VirtualEthernetCardNetworkBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardNetworkBackingOption>()?),
            StructType::VirtualFloppyDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualFloppyDeviceBackingOption>()?),
            StructType::VirtualPciPassthroughDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughDeviceBackingOption>()?),
            StructType::VirtualPciPassthroughDynamicBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughDynamicBackingOption>()?),
            StructType::VirtualParallelPortDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualParallelPortDeviceBackingOption>()?),
            StructType::VirtualPointingDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPointingDeviceBackingOption>()?),
            StructType::VirtualScsiPassthroughDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualScsiPassthroughDeviceBackingOption>()?),
            StructType::VirtualSerialPortDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortDeviceBackingOption>()?),
            StructType::VirtualSoundCardDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSoundCardDeviceBackingOption>()?),
            StructType::VirtualUsbRemoteHostBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualUsbRemoteHostBackingOption>()?),
            StructType::VirtualUsbusbBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualUsbusbBackingOption>()?),
            StructType::VirtualDeviceFileBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDeviceFileBackingOption>()?),
            StructType::VirtualCdromIsoBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualCdromIsoBackingOption>()?),
            StructType::VirtualDiskFlatVer1BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskFlatVer1BackingOption>()?),
            StructType::VirtualDiskFlatVer2BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskFlatVer2BackingOption>()?),
            StructType::VirtualDiskLocalPMemBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskLocalPMemBackingOption>()?),
            StructType::VirtualDiskSeSparseBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskSeSparseBackingOption>()?),
            StructType::VirtualDiskSparseVer1BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskSparseVer1BackingOption>()?),
            StructType::VirtualDiskSparseVer2BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskSparseVer2BackingOption>()?),
            StructType::VirtualFloppyImageBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualFloppyImageBackingOption>()?),
            StructType::VirtualParallelPortFileBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualParallelPortFileBackingOption>()?),
            StructType::VirtualSerialPortFileBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortFileBackingOption>()?),
            StructType::VirtualDevicePipeBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDevicePipeBackingOption>()?),
            StructType::VirtualSerialPortPipeBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortPipeBackingOption>()?),
            StructType::VirtualDeviceRemoteDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDeviceRemoteDeviceBackingOption>()?),
            StructType::VirtualCdromRemotePassthroughBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualCdromRemotePassthroughBackingOption>()?),
            StructType::VirtualFloppyRemoteDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualFloppyRemoteDeviceBackingOption>()?),
            StructType::VirtualUsbRemoteClientBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualUsbRemoteClientBackingOption>()?),
            StructType::VirtualDeviceUriBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDeviceUriBackingOption>()?),
            StructType::VirtualSerialPortUriBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortUriBackingOption>()?),
            StructType::VirtualEthernetCardDvPortBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardDvPortBackingOption>()?),
            StructType::VirtualEthernetCardOpaqueNetworkBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardOpaqueNetworkBackingOption>()?),
            StructType::VirtualPciPassthroughDvxBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughDvxBackingOption>()?),
            StructType::VirtualPciPassthroughPluginBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughPluginBackingOption>()?),
            StructType::VirtualPciPassthroughVmiopBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughVmiopBackingOption>()?),
            StructType::VirtualPrecisionClockSystemClockBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPrecisionClockSystemClockBackingOption>()?),
            StructType::VirtualSerialPortThinPrintBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortThinPrintBackingOption>()?),
            StructType::VirtualSriovEthernetCardSriovBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSriovEthernetCardSriovBackingOption>()?),
            StructType::VirtualDeviceBusSlotOption => Some(from.as_any_ref().downcast_ref::<VirtualDeviceBusSlotOption>()?),
            StructType::VirtualDeviceConnectOption => Some(from.as_any_ref().downcast_ref::<VirtualDeviceConnectOption>()?),
            StructType::VirtualDeviceConfigSpec => Some(from.as_any_ref().downcast_ref::<VirtualDeviceConfigSpec>()?),
            StructType::VirtualDiskConfigSpec => Some(from.as_any_ref().downcast_ref::<VirtualDiskConfigSpec>()?),
            StructType::VirtualDeviceConfigSpecBackingSpec => Some(from.as_any_ref().downcast_ref::<VirtualDeviceConfigSpecBackingSpec>()?),
            StructType::VirtualDiskVFlashCacheConfigInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskVFlashCacheConfigInfo>()?),
            StructType::VirtualDiskId => Some(from.as_any_ref().downcast_ref::<VirtualDiskId>()?),
            StructType::VirtualDiskDeltaDiskFormatsSupported => Some(from.as_any_ref().downcast_ref::<VirtualDiskDeltaDiskFormatsSupported>()?),
            StructType::VirtualDiskOptionVFlashCacheConfigOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskOptionVFlashCacheConfigOption>()?),
            StructType::VirtualEthernetCardResourceAllocation => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardResourceAllocation>()?),
            StructType::VirtualPciPassthroughAllowedDevice => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughAllowedDevice>()?),
            StructType::VirtualMachineVmciDeviceFilterInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineVmciDeviceFilterInfo>()?),
            StructType::VirtualMachineVmciDeviceFilterSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineVmciDeviceFilterSpec>()?),
            StructType::VirtualMachineVmciDeviceOptionFilterSpecOption => Some(from.as_any_ref().downcast_ref::<VirtualMachineVmciDeviceOptionFilterSpecOption>()?),
            StructType::GuestAliases => Some(from.as_any_ref().downcast_ref::<GuestAliases>()?),
            StructType::GuestAuthAliasInfo => Some(from.as_any_ref().downcast_ref::<GuestAuthAliasInfo>()?),
            StructType::GuestAuthSubject => Some(from.as_any_ref().downcast_ref::<GuestAuthSubject>()?),
            StructType::GuestAuthAnySubject => Some(from.as_any_ref().downcast_ref::<GuestAuthAnySubject>()?),
            StructType::GuestAuthNamedSubject => Some(from.as_any_ref().downcast_ref::<GuestAuthNamedSubject>()?),
            StructType::GuestMappedAliases => Some(from.as_any_ref().downcast_ref::<GuestMappedAliases>()?),
            StructType::GuestFileAttributes => Some(from.as_any_ref().downcast_ref::<GuestFileAttributes>()?),
            StructType::GuestPosixFileAttributes => Some(from.as_any_ref().downcast_ref::<GuestPosixFileAttributes>()?),
            StructType::GuestWindowsFileAttributes => Some(from.as_any_ref().downcast_ref::<GuestWindowsFileAttributes>()?),
            StructType::GuestFileInfo => Some(from.as_any_ref().downcast_ref::<GuestFileInfo>()?),
            StructType::FileTransferInformation => Some(from.as_any_ref().downcast_ref::<FileTransferInformation>()?),
            StructType::GuestListFileInfo => Some(from.as_any_ref().downcast_ref::<GuestListFileInfo>()?),
            StructType::GuestAuthentication => Some(from.as_any_ref().downcast_ref::<GuestAuthentication>()?),
            StructType::NamePasswordAuthentication => Some(from.as_any_ref().downcast_ref::<NamePasswordAuthentication>()?),
            StructType::SamlTokenAuthentication => Some(from.as_any_ref().downcast_ref::<SamlTokenAuthentication>()?),
            StructType::SspiAuthentication => Some(from.as_any_ref().downcast_ref::<SspiAuthentication>()?),
            StructType::TicketedSessionAuthentication => Some(from.as_any_ref().downcast_ref::<TicketedSessionAuthentication>()?),
            StructType::GuestProcessInfo => Some(from.as_any_ref().downcast_ref::<GuestProcessInfo>()?),
            StructType::GuestProgramSpec => Some(from.as_any_ref().downcast_ref::<GuestProgramSpec>()?),
            StructType::GuestWindowsProgramSpec => Some(from.as_any_ref().downcast_ref::<GuestWindowsProgramSpec>()?),
            StructType::GuestRegKeySpec => Some(from.as_any_ref().downcast_ref::<GuestRegKeySpec>()?),
            StructType::GuestRegKeyNameSpec => Some(from.as_any_ref().downcast_ref::<GuestRegKeyNameSpec>()?),
            StructType::GuestRegKeyRecordSpec => Some(from.as_any_ref().downcast_ref::<GuestRegKeyRecordSpec>()?),
            StructType::GuestRegValueSpec => Some(from.as_any_ref().downcast_ref::<GuestRegValueSpec>()?),
            StructType::GuestRegValueDataSpec => Some(from.as_any_ref().downcast_ref::<GuestRegValueDataSpec>()?),
            StructType::GuestRegValueBinarySpec => Some(from.as_any_ref().downcast_ref::<GuestRegValueBinarySpec>()?),
            StructType::GuestRegValueDwordSpec => Some(from.as_any_ref().downcast_ref::<GuestRegValueDwordSpec>()?),
            StructType::GuestRegValueExpandStringSpec => Some(from.as_any_ref().downcast_ref::<GuestRegValueExpandStringSpec>()?),
            StructType::GuestRegValueMultiStringSpec => Some(from.as_any_ref().downcast_ref::<GuestRegValueMultiStringSpec>()?),
            StructType::GuestRegValueQwordSpec => Some(from.as_any_ref().downcast_ref::<GuestRegValueQwordSpec>()?),
            StructType::GuestRegValueStringSpec => Some(from.as_any_ref().downcast_ref::<GuestRegValueStringSpec>()?),
            StructType::GuestRegValueNameSpec => Some(from.as_any_ref().downcast_ref::<GuestRegValueNameSpec>()?),
            StructType::DeviceGroupId => Some(from.as_any_ref().downcast_ref::<DeviceGroupId>()?),
            StructType::FaultDomainId => Some(from.as_any_ref().downcast_ref::<FaultDomainId>()?),
            StructType::ReplicationGroupId => Some(from.as_any_ref().downcast_ref::<ReplicationGroupId>()?),
            StructType::ReplicationSpec => Some(from.as_any_ref().downcast_ref::<ReplicationSpec>()?),
            StructType::VsanClusterConfigInfo => Some(from.as_any_ref().downcast_ref::<VsanClusterConfigInfo>()?),
            StructType::VsanClusterConfigInfoHostDefaultInfo => Some(from.as_any_ref().downcast_ref::<VsanClusterConfigInfoHostDefaultInfo>()?),
            StructType::VsanHostClusterStatus => Some(from.as_any_ref().downcast_ref::<VsanHostClusterStatus>()?),
            StructType::VsanHostClusterStatusState => Some(from.as_any_ref().downcast_ref::<VsanHostClusterStatusState>()?),
            StructType::VsanHostClusterStatusStateCompletionEstimate => Some(from.as_any_ref().downcast_ref::<VsanHostClusterStatusStateCompletionEstimate>()?),
            StructType::VsanHostConfigInfo => Some(from.as_any_ref().downcast_ref::<VsanHostConfigInfo>()?),
            StructType::VsanHostConfigInfoClusterInfo => Some(from.as_any_ref().downcast_ref::<VsanHostConfigInfoClusterInfo>()?),
            StructType::VsanHostFaultDomainInfo => Some(from.as_any_ref().downcast_ref::<VsanHostFaultDomainInfo>()?),
            StructType::VsanHostConfigInfoNetworkInfo => Some(from.as_any_ref().downcast_ref::<VsanHostConfigInfoNetworkInfo>()?),
            StructType::VsanHostConfigInfoNetworkInfoPortConfig => Some(from.as_any_ref().downcast_ref::<VsanHostConfigInfoNetworkInfoPortConfig>()?),
            StructType::VsanHostConfigInfoStorageInfo => Some(from.as_any_ref().downcast_ref::<VsanHostConfigInfoStorageInfo>()?),
            StructType::VsanHostDecommissionMode => Some(from.as_any_ref().downcast_ref::<VsanHostDecommissionMode>()?),
            StructType::VsanHostDiskMapInfo => Some(from.as_any_ref().downcast_ref::<VsanHostDiskMapInfo>()?),
            StructType::VsanHostDiskMapResult => Some(from.as_any_ref().downcast_ref::<VsanHostDiskMapResult>()?),
            StructType::VsanHostDiskMapping => Some(from.as_any_ref().downcast_ref::<VsanHostDiskMapping>()?),
            StructType::VsanHostDiskResult => Some(from.as_any_ref().downcast_ref::<VsanHostDiskResult>()?),
            StructType::VsanHostIpConfig => Some(from.as_any_ref().downcast_ref::<VsanHostIpConfig>()?),
            StructType::VsanHostMembershipInfo => Some(from.as_any_ref().downcast_ref::<VsanHostMembershipInfo>()?),
            StructType::VsanHostVsanDiskInfo => Some(from.as_any_ref().downcast_ref::<VsanHostVsanDiskInfo>()?),
            StructType::VsanHostRuntimeInfo => Some(from.as_any_ref().downcast_ref::<VsanHostRuntimeInfo>()?),
            StructType::VsanHostRuntimeInfoDiskIssue => Some(from.as_any_ref().downcast_ref::<VsanHostRuntimeInfoDiskIssue>()?),
            StructType::BaseConfigInfo => Some(from.as_any_ref().downcast_ref::<BaseConfigInfo>()?),
            StructType::VStorageObjectConfigInfo => Some(from.as_any_ref().downcast_ref::<VStorageObjectConfigInfo>()?),
            StructType::BaseConfigInfoBackingInfo => Some(from.as_any_ref().downcast_ref::<BaseConfigInfoBackingInfo>()?),
            StructType::BaseConfigInfoFileBackingInfo => Some(from.as_any_ref().downcast_ref::<BaseConfigInfoFileBackingInfo>()?),
            StructType::BaseConfigInfoDiskFileBackingInfo => Some(from.as_any_ref().downcast_ref::<BaseConfigInfoDiskFileBackingInfo>()?),
            StructType::BaseConfigInfoRawDiskMappingBackingInfo => Some(from.as_any_ref().downcast_ref::<BaseConfigInfoRawDiskMappingBackingInfo>()?),
            StructType::VslmCreateSpec => Some(from.as_any_ref().downcast_ref::<VslmCreateSpec>()?),
            StructType::VslmCreateSpecBackingSpec => Some(from.as_any_ref().downcast_ref::<VslmCreateSpecBackingSpec>()?),
            StructType::VslmCreateSpecDiskFileBackingSpec => Some(from.as_any_ref().downcast_ref::<VslmCreateSpecDiskFileBackingSpec>()?),
            StructType::VslmCreateSpecRawDiskMappingBackingSpec => Some(from.as_any_ref().downcast_ref::<VslmCreateSpecRawDiskMappingBackingSpec>()?),
            StructType::DiskCryptoSpec => Some(from.as_any_ref().downcast_ref::<DiskCryptoSpec>()?),
            StructType::Id => Some(from.as_any_ref().downcast_ref::<Id>()?),
            StructType::VslmInfrastructureObjectPolicy => Some(from.as_any_ref().downcast_ref::<VslmInfrastructureObjectPolicy>()?),
            StructType::VslmInfrastructureObjectPolicySpec => Some(from.as_any_ref().downcast_ref::<VslmInfrastructureObjectPolicySpec>()?),
            StructType::VslmMigrateSpec => Some(from.as_any_ref().downcast_ref::<VslmMigrateSpec>()?),
            StructType::VslmCloneSpec => Some(from.as_any_ref().downcast_ref::<VslmCloneSpec>()?),
            StructType::VslmRelocateSpec => Some(from.as_any_ref().downcast_ref::<VslmRelocateSpec>()?),
            StructType::VStorageObjectStateInfo => Some(from.as_any_ref().downcast_ref::<VStorageObjectStateInfo>()?),
            StructType::VslmTagEntry => Some(from.as_any_ref().downcast_ref::<VslmTagEntry>()?),
            StructType::VslmVClockInfo => Some(from.as_any_ref().downcast_ref::<VslmVClockInfo>()?),
            StructType::VStorageObject => Some(from.as_any_ref().downcast_ref::<VStorageObject>()?),
            StructType::VStorageObjectSnapshot => Some(from.as_any_ref().downcast_ref::<VStorageObjectSnapshot>()?),
            StructType::VStorageObjectSnapshotDetails => Some(from.as_any_ref().downcast_ref::<VStorageObjectSnapshotDetails>()?),
            StructType::VStorageObjectSnapshotInfo => Some(from.as_any_ref().downcast_ref::<VStorageObjectSnapshotInfo>()?),
            StructType::VStorageObjectSnapshotInfoVStorageObjectSnapshot => Some(from.as_any_ref().downcast_ref::<VStorageObjectSnapshotInfoVStorageObjectSnapshot>()?),
            StructType::RetrieveVStorageObjSpec => Some(from.as_any_ref().downcast_ref::<RetrieveVStorageObjSpec>()?),
            StructType::VStorageObjectAssociations => Some(from.as_any_ref().downcast_ref::<VStorageObjectAssociations>()?),
            StructType::VStorageObjectAssociationsVmDiskAssociations => Some(from.as_any_ref().downcast_ref::<VStorageObjectAssociationsVmDiskAssociations>()?),
            StructType::DynamicArray => Some(from.as_any_ref().downcast_ref::<DynamicArray>()?),
            StructType::DynamicProperty => Some(from.as_any_ref().downcast_ref::<DynamicProperty>()?),
            StructType::KeyAnyValue => Some(from.as_any_ref().downcast_ref::<KeyAnyValue>()?),
            StructType::LocalizableMessage => Some(from.as_any_ref().downcast_ref::<LocalizableMessage>()?),
            StructType::LocalizedMethodFault => Some(from.as_any_ref().downcast_ref::<LocalizedMethodFault>()?),
            StructType::PropertyChange => Some(from.as_any_ref().downcast_ref::<PropertyChange>()?),
            StructType::PropertyFilterSpec => Some(from.as_any_ref().downcast_ref::<PropertyFilterSpec>()?),
            StructType::PropertyFilterUpdate => Some(from.as_any_ref().downcast_ref::<PropertyFilterUpdate>()?),
            StructType::MissingObject => Some(from.as_any_ref().downcast_ref::<MissingObject>()?),
            StructType::MissingProperty => Some(from.as_any_ref().downcast_ref::<MissingProperty>()?),
            StructType::ObjectContent => Some(from.as_any_ref().downcast_ref::<ObjectContent>()?),
            StructType::ObjectSpec => Some(from.as_any_ref().downcast_ref::<ObjectSpec>()?),
            StructType::ObjectUpdate => Some(from.as_any_ref().downcast_ref::<ObjectUpdate>()?),
            StructType::PropertySpec => Some(from.as_any_ref().downcast_ref::<PropertySpec>()?),
            StructType::RetrieveOptions => Some(from.as_any_ref().downcast_ref::<RetrieveOptions>()?),
            StructType::RetrieveResult => Some(from.as_any_ref().downcast_ref::<RetrieveResult>()?),
            StructType::SelectionSpec => Some(from.as_any_ref().downcast_ref::<SelectionSpec>()?),
            StructType::TraversalSpec => Some(from.as_any_ref().downcast_ref::<TraversalSpec>()?),
            StructType::UpdateSet => Some(from.as_any_ref().downcast_ref::<UpdateSet>()?),
            StructType::WaitOptions => Some(from.as_any_ref().downcast_ref::<WaitOptions>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DataObject => Ok(from.as_any_box().downcast::<DataObject>()?),
            StructType::AboutInfo => Ok(from.as_any_box().downcast::<AboutInfo>()?),
            StructType::AuthorizationDescription => Ok(from.as_any_box().downcast::<AuthorizationDescription>()?),
            StructType::EntityPrivilege => Ok(from.as_any_box().downcast::<EntityPrivilege>()?),
            StructType::Permission => Ok(from.as_any_box().downcast::<Permission>()?),
            StructType::AuthorizationPrivilege => Ok(from.as_any_box().downcast::<AuthorizationPrivilege>()?),
            StructType::PrivilegeAvailability => Ok(from.as_any_box().downcast::<PrivilegeAvailability>()?),
            StructType::AuthorizationRole => Ok(from.as_any_box().downcast::<AuthorizationRole>()?),
            StructType::UserPrivilegeResult => Ok(from.as_any_box().downcast::<UserPrivilegeResult>()?),
            StructType::BatchResult => Ok(from.as_any_box().downcast::<BatchResult>()?),
            StructType::Capability => Ok(from.as_any_box().downcast::<Capability>()?),
            StructType::ClusterComputeResourceClusterConfigResult => Ok(from.as_any_box().downcast::<ClusterComputeResourceClusterConfigResult>()?),
            StructType::ClusterComputeResourceDvsSetting => Ok(from.as_any_box().downcast::<ClusterComputeResourceDvsSetting>()?),
            StructType::ClusterComputeResourceDvsSettingDvPortgroupToServiceMapping => Ok(from.as_any_box().downcast::<ClusterComputeResourceDvsSettingDvPortgroupToServiceMapping>()?),
            StructType::ClusterComputeResourceDvsProfile => Ok(from.as_any_box().downcast::<ClusterComputeResourceDvsProfile>()?),
            StructType::ClusterComputeResourceDvsProfileDvPortgroupSpecToServiceMapping => Ok(from.as_any_box().downcast::<ClusterComputeResourceDvsProfileDvPortgroupSpecToServiceMapping>()?),
            StructType::ClusterComputeResourceHciConfigInfo => Ok(from.as_any_box().downcast::<ClusterComputeResourceHciConfigInfo>()?),
            StructType::ClusterComputeResourceHciConfigSpec => Ok(from.as_any_box().downcast::<ClusterComputeResourceHciConfigSpec>()?),
            StructType::ClusterComputeResourceHostConfigurationInput => Ok(from.as_any_box().downcast::<ClusterComputeResourceHostConfigurationInput>()?),
            StructType::ClusterComputeResourceHostConfigurationProfile => Ok(from.as_any_box().downcast::<ClusterComputeResourceHostConfigurationProfile>()?),
            StructType::ClusterComputeResourceHostVmkNicInfo => Ok(from.as_any_box().downcast::<ClusterComputeResourceHostVmkNicInfo>()?),
            StructType::ClusterComputeResourceVcProfile => Ok(from.as_any_box().downcast::<ClusterComputeResourceVcProfile>()?),
            StructType::ClusterComputeResourceValidationResultBase => Ok(from.as_any_box().downcast::<ClusterComputeResourceValidationResultBase>()?),
            StructType::ClusterComputeResourceDvsConfigurationValidation => Ok(from.as_any_box().downcast::<ClusterComputeResourceDvsConfigurationValidation>()?),
            StructType::ClusterComputeResourceHostConfigurationValidation => Ok(from.as_any_box().downcast::<ClusterComputeResourceHostConfigurationValidation>()?),
            StructType::ClusterComputeResourceVcsSlots => Ok(from.as_any_box().downcast::<ClusterComputeResourceVcsSlots>()?),
            StructType::ComputeResourceConfigInfo => Ok(from.as_any_box().downcast::<ComputeResourceConfigInfo>()?),
            StructType::ClusterConfigInfoEx => Ok(from.as_any_box().downcast::<ClusterConfigInfoEx>()?),
            StructType::ComputeResourceConfigSpec => Ok(from.as_any_box().downcast::<ComputeResourceConfigSpec>()?),
            StructType::ClusterConfigSpecEx => Ok(from.as_any_box().downcast::<ClusterConfigSpecEx>()?),
            StructType::ComputeResourceHostSpbmLicenseInfo => Ok(from.as_any_box().downcast::<ComputeResourceHostSpbmLicenseInfo>()?),
            StructType::ComputeResourceSummary => Ok(from.as_any_box().downcast::<ComputeResourceSummary>()?),
            StructType::ClusterComputeResourceSummary => Ok(from.as_any_box().downcast::<ClusterComputeResourceSummary>()?),
            StructType::CustomFieldDef => Ok(from.as_any_box().downcast::<CustomFieldDef>()?),
            StructType::CustomFieldValue => Ok(from.as_any_box().downcast::<CustomFieldValue>()?),
            StructType::CustomFieldStringValue => Ok(from.as_any_box().downcast::<CustomFieldStringValue>()?),
            StructType::CustomizationSpecInfo => Ok(from.as_any_box().downcast::<CustomizationSpecInfo>()?),
            StructType::CustomizationSpecItem => Ok(from.as_any_box().downcast::<CustomizationSpecItem>()?),
            StructType::DatacenterBasicConnectInfo => Ok(from.as_any_box().downcast::<DatacenterBasicConnectInfo>()?),
            StructType::DatacenterConfigInfo => Ok(from.as_any_box().downcast::<DatacenterConfigInfo>()?),
            StructType::DatacenterConfigSpec => Ok(from.as_any_box().downcast::<DatacenterConfigSpec>()?),
            StructType::DatastoreCapability => Ok(from.as_any_box().downcast::<DatastoreCapability>()?),
            StructType::DatastoreHostMount => Ok(from.as_any_box().downcast::<DatastoreHostMount>()?),
            StructType::DatastoreInfo => Ok(from.as_any_box().downcast::<DatastoreInfo>()?),
            StructType::LocalDatastoreInfo => Ok(from.as_any_box().downcast::<LocalDatastoreInfo>()?),
            StructType::NasDatastoreInfo => Ok(from.as_any_box().downcast::<NasDatastoreInfo>()?),
            StructType::PMemDatastoreInfo => Ok(from.as_any_box().downcast::<PMemDatastoreInfo>()?),
            StructType::VmfsDatastoreInfo => Ok(from.as_any_box().downcast::<VmfsDatastoreInfo>()?),
            StructType::VsanDatastoreInfo => Ok(from.as_any_box().downcast::<VsanDatastoreInfo>()?),
            StructType::VvolDatastoreInfo => Ok(from.as_any_box().downcast::<VvolDatastoreInfo>()?),
            StructType::DatastoreMountPathDatastorePair => Ok(from.as_any_box().downcast::<DatastoreMountPathDatastorePair>()?),
            StructType::DatastoreSummary => Ok(from.as_any_box().downcast::<DatastoreSummary>()?),
            StructType::DatastoreVVolContainerFailoverPair => Ok(from.as_any_box().downcast::<DatastoreVVolContainerFailoverPair>()?),
            StructType::DatastoreNamespaceManagerDirectoryInfo => Ok(from.as_any_box().downcast::<DatastoreNamespaceManagerDirectoryInfo>()?),
            StructType::Description => Ok(from.as_any_box().downcast::<Description>()?),
            StructType::ElementDescription => Ok(from.as_any_box().downcast::<ElementDescription>()?),
            StructType::EvcMode => Ok(from.as_any_box().downcast::<EvcMode>()?),
            StructType::ExtendedElementDescription => Ok(from.as_any_box().downcast::<ExtendedElementDescription>()?),
            StructType::FeatureEvcMode => Ok(from.as_any_box().downcast::<FeatureEvcMode>()?),
            StructType::OptionDef => Ok(from.as_any_box().downcast::<OptionDef>()?),
            StructType::ExtendedDescription => Ok(from.as_any_box().downcast::<ExtendedDescription>()?),
            StructType::MethodDescription => Ok(from.as_any_box().downcast::<MethodDescription>()?),
            StructType::TypeDescription => Ok(from.as_any_box().downcast::<TypeDescription>()?),
            StructType::ScheduledTaskDetail => Ok(from.as_any_box().downcast::<ScheduledTaskDetail>()?),
            StructType::DesiredSoftwareSpec => Ok(from.as_any_box().downcast::<DesiredSoftwareSpec>()?),
            StructType::DesiredSoftwareSpecBaseImageSpec => Ok(from.as_any_box().downcast::<DesiredSoftwareSpecBaseImageSpec>()?),
            StructType::DesiredSoftwareSpecComponentSpec => Ok(from.as_any_box().downcast::<DesiredSoftwareSpecComponentSpec>()?),
            StructType::DesiredSoftwareSpecVendorAddOnSpec => Ok(from.as_any_box().downcast::<DesiredSoftwareSpecVendorAddOnSpec>()?),
            StructType::DiagnosticManagerAuditRecordResult => Ok(from.as_any_box().downcast::<DiagnosticManagerAuditRecordResult>()?),
            StructType::DiagnosticManagerBundleInfo => Ok(from.as_any_box().downcast::<DiagnosticManagerBundleInfo>()?),
            StructType::DiagnosticManagerLogDescriptor => Ok(from.as_any_box().downcast::<DiagnosticManagerLogDescriptor>()?),
            StructType::DiagnosticManagerLogHeader => Ok(from.as_any_box().downcast::<DiagnosticManagerLogHeader>()?),
            StructType::DvsBackupRestoreCapability => Ok(from.as_any_box().downcast::<DvsBackupRestoreCapability>()?),
            StructType::DvsCapability => Ok(from.as_any_box().downcast::<DvsCapability>()?),
            StructType::DvsConfigInfo => Ok(from.as_any_box().downcast::<DvsConfigInfo>()?),
            StructType::VMwareDvsConfigInfo => Ok(from.as_any_box().downcast::<VMwareDvsConfigInfo>()?),
            StructType::DvsConfigSpec => Ok(from.as_any_box().downcast::<DvsConfigSpec>()?),
            StructType::VMwareDvsConfigSpec => Ok(from.as_any_box().downcast::<VMwareDvsConfigSpec>()?),
            StructType::DvsContactInfo => Ok(from.as_any_box().downcast::<DvsContactInfo>()?),
            StructType::DvsCreateSpec => Ok(from.as_any_box().downcast::<DvsCreateSpec>()?),
            StructType::DvsFeatureCapability => Ok(from.as_any_box().downcast::<DvsFeatureCapability>()?),
            StructType::VMwareDvsFeatureCapability => Ok(from.as_any_box().downcast::<VMwareDvsFeatureCapability>()?),
            StructType::DvsHealthCheckConfig => Ok(from.as_any_box().downcast::<DvsHealthCheckConfig>()?),
            StructType::VMwareDvsHealthCheckConfig => Ok(from.as_any_box().downcast::<VMwareDvsHealthCheckConfig>()?),
            StructType::VMwareDvsTeamingHealthCheckConfig => Ok(from.as_any_box().downcast::<VMwareDvsTeamingHealthCheckConfig>()?),
            StructType::VMwareDvsVlanMtuHealthCheckConfig => Ok(from.as_any_box().downcast::<VMwareDvsVlanMtuHealthCheckConfig>()?),
            StructType::DvsHealthCheckCapability => Ok(from.as_any_box().downcast::<DvsHealthCheckCapability>()?),
            StructType::VMwareDvsHealthCheckCapability => Ok(from.as_any_box().downcast::<VMwareDvsHealthCheckCapability>()?),
            StructType::DvsHostInfrastructureTrafficResource => Ok(from.as_any_box().downcast::<DvsHostInfrastructureTrafficResource>()?),
            StructType::DvsHostInfrastructureTrafficResourceAllocation => Ok(from.as_any_box().downcast::<DvsHostInfrastructureTrafficResourceAllocation>()?),
            StructType::DvsNetworkResourceManagementCapability => Ok(from.as_any_box().downcast::<DvsNetworkResourceManagementCapability>()?),
            StructType::DvsResourceRuntimeInfo => Ok(from.as_any_box().downcast::<DvsResourceRuntimeInfo>()?),
            StructType::DvsRollbackCapability => Ok(from.as_any_box().downcast::<DvsRollbackCapability>()?),
            StructType::DvsRuntimeInfo => Ok(from.as_any_box().downcast::<DvsRuntimeInfo>()?),
            StructType::DvsSummary => Ok(from.as_any_box().downcast::<DvsSummary>()?),
            StructType::DvsPolicy => Ok(from.as_any_box().downcast::<DvsPolicy>()?),
            StructType::DvsUplinkPortPolicy => Ok(from.as_any_box().downcast::<DvsUplinkPortPolicy>()?),
            StructType::DvsNameArrayUplinkPortPolicy => Ok(from.as_any_box().downcast::<DvsNameArrayUplinkPortPolicy>()?),
            StructType::EnumDescription => Ok(from.as_any_box().downcast::<EnumDescription>()?),
            StructType::EnvironmentBrowserConfigOptionQuerySpec => Ok(from.as_any_box().downcast::<EnvironmentBrowserConfigOptionQuerySpec>()?),
            StructType::Extension => Ok(from.as_any_box().downcast::<Extension>()?),
            StructType::ExtensionClientInfo => Ok(from.as_any_box().downcast::<ExtensionClientInfo>()?),
            StructType::ExtensionEventTypeInfo => Ok(from.as_any_box().downcast::<ExtensionEventTypeInfo>()?),
            StructType::ExtensionFaultTypeInfo => Ok(from.as_any_box().downcast::<ExtensionFaultTypeInfo>()?),
            StructType::ExtensionHealthInfo => Ok(from.as_any_box().downcast::<ExtensionHealthInfo>()?),
            StructType::ExtensionOvfConsumerInfo => Ok(from.as_any_box().downcast::<ExtensionOvfConsumerInfo>()?),
            StructType::ExtensionPrivilegeInfo => Ok(from.as_any_box().downcast::<ExtensionPrivilegeInfo>()?),
            StructType::ExtensionResourceInfo => Ok(from.as_any_box().downcast::<ExtensionResourceInfo>()?),
            StructType::ExtensionServerInfo => Ok(from.as_any_box().downcast::<ExtensionServerInfo>()?),
            StructType::ExtensionTaskTypeInfo => Ok(from.as_any_box().downcast::<ExtensionTaskTypeInfo>()?),
            StructType::ExtensionManagerIpAllocationUsage => Ok(from.as_any_box().downcast::<ExtensionManagerIpAllocationUsage>()?),
            StructType::FaultsByHost => Ok(from.as_any_box().downcast::<FaultsByHost>()?),
            StructType::FaultsByVm => Ok(from.as_any_box().downcast::<FaultsByVm>()?),
            StructType::FileLockInfo => Ok(from.as_any_box().downcast::<FileLockInfo>()?),
            StructType::FileLockInfoResult => Ok(from.as_any_box().downcast::<FileLockInfoResult>()?),
            StructType::FolderBatchAddHostsToClusterResult => Ok(from.as_any_box().downcast::<FolderBatchAddHostsToClusterResult>()?),
            StructType::FolderBatchAddStandaloneHostsResult => Ok(from.as_any_box().downcast::<FolderBatchAddStandaloneHostsResult>()?),
            StructType::FolderFailedHostResult => Ok(from.as_any_box().downcast::<FolderFailedHostResult>()?),
            StructType::FolderNewHostSpec => Ok(from.as_any_box().downcast::<FolderNewHostSpec>()?),
            StructType::HbrManagerReplicationVmInfo => Ok(from.as_any_box().downcast::<HbrManagerReplicationVmInfo>()?),
            StructType::ReplicationVmProgressInfo => Ok(from.as_any_box().downcast::<ReplicationVmProgressInfo>()?),
            StructType::HbrManagerVmReplicationCapability => Ok(from.as_any_box().downcast::<HbrManagerVmReplicationCapability>()?),
            StructType::HealthUpdate => Ok(from.as_any_box().downcast::<HealthUpdate>()?),
            StructType::HealthUpdateInfo => Ok(from.as_any_box().downcast::<HealthUpdateInfo>()?),
            StructType::PerfInterval => Ok(from.as_any_box().downcast::<PerfInterval>()?),
            StructType::HostServiceTicket => Ok(from.as_any_box().downcast::<HostServiceTicket>()?),
            StructType::HostSystemComplianceCheckState => Ok(from.as_any_box().downcast::<HostSystemComplianceCheckState>()?),
            StructType::HostSystemReconnectSpec => Ok(from.as_any_box().downcast::<HostSystemReconnectSpec>()?),
            StructType::HostSystemRemediationState => Ok(from.as_any_box().downcast::<HostSystemRemediationState>()?),
            StructType::HttpNfcLeaseCapabilities => Ok(from.as_any_box().downcast::<HttpNfcLeaseCapabilities>()?),
            StructType::HttpNfcLeaseDatastoreLeaseInfo => Ok(from.as_any_box().downcast::<HttpNfcLeaseDatastoreLeaseInfo>()?),
            StructType::HttpNfcLeaseDeviceUrl => Ok(from.as_any_box().downcast::<HttpNfcLeaseDeviceUrl>()?),
            StructType::HttpNfcLeaseHostInfo => Ok(from.as_any_box().downcast::<HttpNfcLeaseHostInfo>()?),
            StructType::HttpNfcLeaseInfo => Ok(from.as_any_box().downcast::<HttpNfcLeaseInfo>()?),
            StructType::HttpNfcLeaseManifestEntry => Ok(from.as_any_box().downcast::<HttpNfcLeaseManifestEntry>()?),
            StructType::HttpNfcLeaseProbeResult => Ok(from.as_any_box().downcast::<HttpNfcLeaseProbeResult>()?),
            StructType::HttpNfcLeaseSourceFile => Ok(from.as_any_box().downcast::<HttpNfcLeaseSourceFile>()?),
            StructType::ImportSpec => Ok(from.as_any_box().downcast::<ImportSpec>()?),
            StructType::VirtualAppImportSpec => Ok(from.as_any_box().downcast::<VirtualAppImportSpec>()?),
            StructType::VirtualMachineImportSpec => Ok(from.as_any_box().downcast::<VirtualMachineImportSpec>()?),
            StructType::InheritablePolicy => Ok(from.as_any_box().downcast::<InheritablePolicy>()?),
            StructType::BoolPolicy => Ok(from.as_any_box().downcast::<BoolPolicy>()?),
            StructType::IntPolicy => Ok(from.as_any_box().downcast::<IntPolicy>()?),
            StructType::LongPolicy => Ok(from.as_any_box().downcast::<LongPolicy>()?),
            StructType::StringPolicy => Ok(from.as_any_box().downcast::<StringPolicy>()?),
            StructType::DvsFilterConfig => Ok(from.as_any_box().downcast::<DvsFilterConfig>()?),
            StructType::DvsFilterConfigSpec => Ok(from.as_any_box().downcast::<DvsFilterConfigSpec>()?),
            StructType::DvsTrafficFilterConfig => Ok(from.as_any_box().downcast::<DvsTrafficFilterConfig>()?),
            StructType::DvsTrafficFilterConfigSpec => Ok(from.as_any_box().downcast::<DvsTrafficFilterConfigSpec>()?),
            StructType::DvsFilterPolicy => Ok(from.as_any_box().downcast::<DvsFilterPolicy>()?),
            StructType::DvsTrafficShapingPolicy => Ok(from.as_any_box().downcast::<DvsTrafficShapingPolicy>()?),
            StructType::DvsVendorSpecificConfig => Ok(from.as_any_box().downcast::<DvsVendorSpecificConfig>()?),
            StructType::DvsFailureCriteria => Ok(from.as_any_box().downcast::<DvsFailureCriteria>()?),
            StructType::DvsMacLearningPolicy => Ok(from.as_any_box().downcast::<DvsMacLearningPolicy>()?),
            StructType::DvsMacManagementPolicy => Ok(from.as_any_box().downcast::<DvsMacManagementPolicy>()?),
            StructType::DvsSecurityPolicy => Ok(from.as_any_box().downcast::<DvsSecurityPolicy>()?),
            StructType::VMwareUplinkLacpPolicy => Ok(from.as_any_box().downcast::<VMwareUplinkLacpPolicy>()?),
            StructType::VMwareUplinkPortOrderPolicy => Ok(from.as_any_box().downcast::<VMwareUplinkPortOrderPolicy>()?),
            StructType::VmwareUplinkPortTeamingPolicy => Ok(from.as_any_box().downcast::<VmwareUplinkPortTeamingPolicy>()?),
            StructType::VmwareDistributedVirtualSwitchVlanSpec => Ok(from.as_any_box().downcast::<VmwareDistributedVirtualSwitchVlanSpec>()?),
            StructType::VmwareDistributedVirtualSwitchPvlanSpec => Ok(from.as_any_box().downcast::<VmwareDistributedVirtualSwitchPvlanSpec>()?),
            StructType::VmwareDistributedVirtualSwitchTrunkVlanSpec => Ok(from.as_any_box().downcast::<VmwareDistributedVirtualSwitchTrunkVlanSpec>()?),
            StructType::VmwareDistributedVirtualSwitchVlanIdSpec => Ok(from.as_any_box().downcast::<VmwareDistributedVirtualSwitchVlanIdSpec>()?),
            StructType::IoFilterInfo => Ok(from.as_any_box().downcast::<IoFilterInfo>()?),
            StructType::ClusterIoFilterInfo => Ok(from.as_any_box().downcast::<ClusterIoFilterInfo>()?),
            StructType::HostIoFilterInfo => Ok(from.as_any_box().downcast::<HostIoFilterInfo>()?),
            StructType::IoFilterQueryIssueResult => Ok(from.as_any_box().downcast::<IoFilterQueryIssueResult>()?),
            StructType::IoFilterHostIssue => Ok(from.as_any_box().downcast::<IoFilterHostIssue>()?),
            StructType::IpPoolManagerIpAllocation => Ok(from.as_any_box().downcast::<IpPoolManagerIpAllocation>()?),
            StructType::KeyValue => Ok(from.as_any_box().downcast::<KeyValue>()?),
            StructType::LatencySensitivity => Ok(from.as_any_box().downcast::<LatencySensitivity>()?),
            StructType::LicenseAssignmentManagerLicenseAssignment => Ok(from.as_any_box().downcast::<LicenseAssignmentManagerLicenseAssignment>()?),
            StructType::LicenseAvailabilityInfo => Ok(from.as_any_box().downcast::<LicenseAvailabilityInfo>()?),
            StructType::LicenseDiagnostics => Ok(from.as_any_box().downcast::<LicenseDiagnostics>()?),
            StructType::LicenseManagerEvaluationInfo => Ok(from.as_any_box().downcast::<LicenseManagerEvaluationInfo>()?),
            StructType::LicenseFeatureInfo => Ok(from.as_any_box().downcast::<LicenseFeatureInfo>()?),
            StructType::HostLicensableResourceInfo => Ok(from.as_any_box().downcast::<HostLicensableResourceInfo>()?),
            StructType::LicenseManagerLicenseInfo => Ok(from.as_any_box().downcast::<LicenseManagerLicenseInfo>()?),
            StructType::LicenseSource => Ok(from.as_any_box().downcast::<LicenseSource>()?),
            StructType::EvaluationLicenseSource => Ok(from.as_any_box().downcast::<EvaluationLicenseSource>()?),
            StructType::LicenseServerSource => Ok(from.as_any_box().downcast::<LicenseServerSource>()?),
            StructType::LocalLicenseSource => Ok(from.as_any_box().downcast::<LocalLicenseSource>()?),
            StructType::LicenseUsageInfo => Ok(from.as_any_box().downcast::<LicenseUsageInfo>()?),
            StructType::LicenseReservationInfo => Ok(from.as_any_box().downcast::<LicenseReservationInfo>()?),
            StructType::LocalizationManagerMessageCatalog => Ok(from.as_any_box().downcast::<LocalizationManagerMessageCatalog>()?),
            StructType::NegatableExpression => Ok(from.as_any_box().downcast::<NegatableExpression>()?),
            StructType::IntExpression => Ok(from.as_any_box().downcast::<IntExpression>()?),
            StructType::IpAddress => Ok(from.as_any_box().downcast::<IpAddress>()?),
            StructType::IpRange => Ok(from.as_any_box().downcast::<IpRange>()?),
            StructType::SingleIp => Ok(from.as_any_box().downcast::<SingleIp>()?),
            StructType::MacAddress => Ok(from.as_any_box().downcast::<MacAddress>()?),
            StructType::MacRange => Ok(from.as_any_box().downcast::<MacRange>()?),
            StructType::SingleMac => Ok(from.as_any_box().downcast::<SingleMac>()?),
            StructType::StringExpression => Ok(from.as_any_box().downcast::<StringExpression>()?),
            StructType::DvsIpPort => Ok(from.as_any_box().downcast::<DvsIpPort>()?),
            StructType::DvsIpPortRange => Ok(from.as_any_box().downcast::<DvsIpPortRange>()?),
            StructType::DvsSingleIpPort => Ok(from.as_any_box().downcast::<DvsSingleIpPort>()?),
            StructType::NetworkSummary => Ok(from.as_any_box().downcast::<NetworkSummary>()?),
            StructType::OpaqueNetworkSummary => Ok(from.as_any_box().downcast::<OpaqueNetworkSummary>()?),
            StructType::NumericRange => Ok(from.as_any_box().downcast::<NumericRange>()?),
            StructType::OpaqueNetworkCapability => Ok(from.as_any_box().downcast::<OpaqueNetworkCapability>()?),
            StructType::OvfConsumerOstNode => Ok(from.as_any_box().downcast::<OvfConsumerOstNode>()?),
            StructType::OvfConsumerOvfSection => Ok(from.as_any_box().downcast::<OvfConsumerOvfSection>()?),
            StructType::OvfManagerCommonParams => Ok(from.as_any_box().downcast::<OvfManagerCommonParams>()?),
            StructType::OvfCreateImportSpecParams => Ok(from.as_any_box().downcast::<OvfCreateImportSpecParams>()?),
            StructType::OvfParseDescriptorParams => Ok(from.as_any_box().downcast::<OvfParseDescriptorParams>()?),
            StructType::OvfValidateHostParams => Ok(from.as_any_box().downcast::<OvfValidateHostParams>()?),
            StructType::OvfCreateDescriptorParams => Ok(from.as_any_box().downcast::<OvfCreateDescriptorParams>()?),
            StructType::OvfCreateDescriptorResult => Ok(from.as_any_box().downcast::<OvfCreateDescriptorResult>()?),
            StructType::OvfCreateImportSpecResult => Ok(from.as_any_box().downcast::<OvfCreateImportSpecResult>()?),
            StructType::OvfDeploymentOption => Ok(from.as_any_box().downcast::<OvfDeploymentOption>()?),
            StructType::OvfFileItem => Ok(from.as_any_box().downcast::<OvfFileItem>()?),
            StructType::OvfNetworkInfo => Ok(from.as_any_box().downcast::<OvfNetworkInfo>()?),
            StructType::OvfNetworkMapping => Ok(from.as_any_box().downcast::<OvfNetworkMapping>()?),
            StructType::OvfFile => Ok(from.as_any_box().downcast::<OvfFile>()?),
            StructType::OvfOptionInfo => Ok(from.as_any_box().downcast::<OvfOptionInfo>()?),
            StructType::OvfParseDescriptorResult => Ok(from.as_any_box().downcast::<OvfParseDescriptorResult>()?),
            StructType::OvfResourceMap => Ok(from.as_any_box().downcast::<OvfResourceMap>()?),
            StructType::OvfValidateHostResult => Ok(from.as_any_box().downcast::<OvfValidateHostResult>()?),
            StructType::PasswordField => Ok(from.as_any_box().downcast::<PasswordField>()?),
            StructType::PerformanceDescription => Ok(from.as_any_box().downcast::<PerformanceDescription>()?),
            StructType::PerfCompositeMetric => Ok(from.as_any_box().downcast::<PerfCompositeMetric>()?),
            StructType::PerfCounterInfo => Ok(from.as_any_box().downcast::<PerfCounterInfo>()?),
            StructType::PerformanceManagerCounterLevelMapping => Ok(from.as_any_box().downcast::<PerformanceManagerCounterLevelMapping>()?),
            StructType::PerfEntityMetricBase => Ok(from.as_any_box().downcast::<PerfEntityMetricBase>()?),
            StructType::PerfEntityMetric => Ok(from.as_any_box().downcast::<PerfEntityMetric>()?),
            StructType::PerfEntityMetricCsv => Ok(from.as_any_box().downcast::<PerfEntityMetricCsv>()?),
            StructType::PerfMetricId => Ok(from.as_any_box().downcast::<PerfMetricId>()?),
            StructType::PerfMetricSeries => Ok(from.as_any_box().downcast::<PerfMetricSeries>()?),
            StructType::PerfMetricIntSeries => Ok(from.as_any_box().downcast::<PerfMetricIntSeries>()?),
            StructType::PerfMetricSeriesCsv => Ok(from.as_any_box().downcast::<PerfMetricSeriesCsv>()?),
            StructType::PerfProviderSummary => Ok(from.as_any_box().downcast::<PerfProviderSummary>()?),
            StructType::PerfQuerySpec => Ok(from.as_any_box().downcast::<PerfQuerySpec>()?),
            StructType::PerfSampleInfo => Ok(from.as_any_box().downcast::<PerfSampleInfo>()?),
            StructType::PrivilegePolicyDef => Ok(from.as_any_box().downcast::<PrivilegePolicyDef>()?),
            StructType::ResourceAllocationInfo => Ok(from.as_any_box().downcast::<ResourceAllocationInfo>()?),
            StructType::ResourceAllocationOption => Ok(from.as_any_box().downcast::<ResourceAllocationOption>()?),
            StructType::ResourceConfigOption => Ok(from.as_any_box().downcast::<ResourceConfigOption>()?),
            StructType::ResourceConfigSpec => Ok(from.as_any_box().downcast::<ResourceConfigSpec>()?),
            StructType::DatabaseSizeEstimate => Ok(from.as_any_box().downcast::<DatabaseSizeEstimate>()?),
            StructType::DatabaseSizeParam => Ok(from.as_any_box().downcast::<DatabaseSizeParam>()?),
            StructType::InventoryDescription => Ok(from.as_any_box().downcast::<InventoryDescription>()?),
            StructType::PerformanceStatisticsDescription => Ok(from.as_any_box().downcast::<PerformanceStatisticsDescription>()?),
            StructType::ResourcePoolResourceUsage => Ok(from.as_any_box().downcast::<ResourcePoolResourceUsage>()?),
            StructType::ResourcePoolRuntimeInfo => Ok(from.as_any_box().downcast::<ResourcePoolRuntimeInfo>()?),
            StructType::ResourcePoolSummary => Ok(from.as_any_box().downcast::<ResourcePoolSummary>()?),
            StructType::VirtualAppSummary => Ok(from.as_any_box().downcast::<VirtualAppSummary>()?),
            StructType::ResourcePoolQuickStats => Ok(from.as_any_box().downcast::<ResourcePoolQuickStats>()?),
            StructType::SddcBase => Ok(from.as_any_box().downcast::<SddcBase>()?),
            StructType::SelectionSet => Ok(from.as_any_box().downcast::<SelectionSet>()?),
            StructType::DvPortgroupSelection => Ok(from.as_any_box().downcast::<DvPortgroupSelection>()?),
            StructType::DvsSelection => Ok(from.as_any_box().downcast::<DvsSelection>()?),
            StructType::HostVMotionCompatibility => Ok(from.as_any_box().downcast::<HostVMotionCompatibility>()?),
            StructType::ProductComponentInfo => Ok(from.as_any_box().downcast::<ProductComponentInfo>()?),
            StructType::ServiceContent => Ok(from.as_any_box().downcast::<ServiceContent>()?),
            StructType::ServiceLocator => Ok(from.as_any_box().downcast::<ServiceLocator>()?),
            StructType::ServiceLocatorCredential => Ok(from.as_any_box().downcast::<ServiceLocatorCredential>()?),
            StructType::ServiceLocatorNamePassword => Ok(from.as_any_box().downcast::<ServiceLocatorNamePassword>()?),
            StructType::ServiceLocatorSamlCredential => Ok(from.as_any_box().downcast::<ServiceLocatorSamlCredential>()?),
            StructType::ServiceManagerServiceInfo => Ok(from.as_any_box().downcast::<ServiceManagerServiceInfo>()?),
            StructType::SessionManagerGenericServiceTicket => Ok(from.as_any_box().downcast::<SessionManagerGenericServiceTicket>()?),
            StructType::SessionManagerLocalTicket => Ok(from.as_any_box().downcast::<SessionManagerLocalTicket>()?),
            StructType::SessionManagerServiceRequestSpec => Ok(from.as_any_box().downcast::<SessionManagerServiceRequestSpec>()?),
            StructType::SessionManagerHttpServiceRequestSpec => Ok(from.as_any_box().downcast::<SessionManagerHttpServiceRequestSpec>()?),
            StructType::SessionManagerVmomiServiceRequestSpec => Ok(from.as_any_box().downcast::<SessionManagerVmomiServiceRequestSpec>()?),
            StructType::SharesInfo => Ok(from.as_any_box().downcast::<SharesInfo>()?),
            StructType::SharesOption => Ok(from.as_any_box().downcast::<SharesOption>()?),
            StructType::SiteInfo => Ok(from.as_any_box().downcast::<SiteInfo>()?),
            StructType::StoragePodSummary => Ok(from.as_any_box().downcast::<StoragePodSummary>()?),
            StructType::StorageIoAllocationInfo => Ok(from.as_any_box().downcast::<StorageIoAllocationInfo>()?),
            StructType::StorageIoAllocationOption => Ok(from.as_any_box().downcast::<StorageIoAllocationOption>()?),
            StructType::StorageIormInfo => Ok(from.as_any_box().downcast::<StorageIormInfo>()?),
            StructType::StorageIormConfigOption => Ok(from.as_any_box().downcast::<StorageIormConfigOption>()?),
            StructType::StorageIormConfigSpec => Ok(from.as_any_box().downcast::<StorageIormConfigSpec>()?),
            StructType::PodStorageDrsEntry => Ok(from.as_any_box().downcast::<PodStorageDrsEntry>()?),
            StructType::StoragePerformanceSummary => Ok(from.as_any_box().downcast::<StoragePerformanceSummary>()?),
            StructType::StorageResourceManagerStorageProfileStatistics => Ok(from.as_any_box().downcast::<StorageResourceManagerStorageProfileStatistics>()?),
            StructType::Tag => Ok(from.as_any_box().downcast::<Tag>()?),
            StructType::TaskDescription => Ok(from.as_any_box().downcast::<TaskDescription>()?),
            StructType::TaskFilterSpec => Ok(from.as_any_box().downcast::<TaskFilterSpec>()?),
            StructType::TaskFilterSpecByEntity => Ok(from.as_any_box().downcast::<TaskFilterSpecByEntity>()?),
            StructType::TaskFilterSpecByTime => Ok(from.as_any_box().downcast::<TaskFilterSpecByTime>()?),
            StructType::TaskFilterSpecByUsername => Ok(from.as_any_box().downcast::<TaskFilterSpecByUsername>()?),
            StructType::TaskInfo => Ok(from.as_any_box().downcast::<TaskInfo>()?),
            StructType::TaskReason => Ok(from.as_any_box().downcast::<TaskReason>()?),
            StructType::TaskReasonAlarm => Ok(from.as_any_box().downcast::<TaskReasonAlarm>()?),
            StructType::TaskReasonSchedule => Ok(from.as_any_box().downcast::<TaskReasonSchedule>()?),
            StructType::TaskReasonSystem => Ok(from.as_any_box().downcast::<TaskReasonSystem>()?),
            StructType::TaskReasonUser => Ok(from.as_any_box().downcast::<TaskReasonUser>()?),
            StructType::UpdateVirtualMachineFilesResult => Ok(from.as_any_box().downcast::<UpdateVirtualMachineFilesResult>()?),
            StructType::UpdateVirtualMachineFilesResultFailedVmFileInfo => Ok(from.as_any_box().downcast::<UpdateVirtualMachineFilesResultFailedVmFileInfo>()?),
            StructType::UserSearchResult => Ok(from.as_any_box().downcast::<UserSearchResult>()?),
            StructType::PosixUserSearchResult => Ok(from.as_any_box().downcast::<PosixUserSearchResult>()?),
            StructType::UserSession => Ok(from.as_any_box().downcast::<UserSession>()?),
            StructType::VVolVmConfigFileUpdateResult => Ok(from.as_any_box().downcast::<VVolVmConfigFileUpdateResult>()?),
            StructType::VVolVmConfigFileUpdateResultFailedVmConfigFileInfo => Ok(from.as_any_box().downcast::<VVolVmConfigFileUpdateResultFailedVmConfigFileInfo>()?),
            StructType::VasaStorageArray => Ok(from.as_any_box().downcast::<VasaStorageArray>()?),
            StructType::VasaStorageArrayDiscoveryFcTransport => Ok(from.as_any_box().downcast::<VasaStorageArrayDiscoveryFcTransport>()?),
            StructType::VasaStorageArrayDiscoveryIpTransport => Ok(from.as_any_box().downcast::<VasaStorageArrayDiscoveryIpTransport>()?),
            StructType::VasaStorageArrayDiscoverySvcInfo => Ok(from.as_any_box().downcast::<VasaStorageArrayDiscoverySvcInfo>()?),
            StructType::VasaProviderContainerSpec => Ok(from.as_any_box().downcast::<VasaProviderContainerSpec>()?),
            StructType::VimVasaProvider => Ok(from.as_any_box().downcast::<VimVasaProvider>()?),
            StructType::VimVasaProviderStatePerArray => Ok(from.as_any_box().downcast::<VimVasaProviderStatePerArray>()?),
            StructType::VimVasaProviderVirtualHostConfig => Ok(from.as_any_box().downcast::<VimVasaProviderVirtualHostConfig>()?),
            StructType::VimVasaProviderInfo => Ok(from.as_any_box().downcast::<VimVasaProviderInfo>()?),
            StructType::VirtualAppLinkInfo => Ok(from.as_any_box().downcast::<VirtualAppLinkInfo>()?),
            StructType::VirtualDiskSpec => Ok(from.as_any_box().downcast::<VirtualDiskSpec>()?),
            StructType::DeviceBackedVirtualDiskSpec => Ok(from.as_any_box().downcast::<DeviceBackedVirtualDiskSpec>()?),
            StructType::FileBackedVirtualDiskSpec => Ok(from.as_any_box().downcast::<FileBackedVirtualDiskSpec>()?),
            StructType::SeSparseVirtualDiskSpec => Ok(from.as_any_box().downcast::<SeSparseVirtualDiskSpec>()?),
            StructType::VirtualMachineConnection => Ok(from.as_any_box().downcast::<VirtualMachineConnection>()?),
            StructType::VirtualMachineMksConnection => Ok(from.as_any_box().downcast::<VirtualMachineMksConnection>()?),
            StructType::DiskChangeInfo => Ok(from.as_any_box().downcast::<DiskChangeInfo>()?),
            StructType::DiskChangeExtent => Ok(from.as_any_box().downcast::<DiskChangeExtent>()?),
            StructType::VirtualMachineDisplayTopology => Ok(from.as_any_box().downcast::<VirtualMachineDisplayTopology>()?),
            StructType::VirtualMachineMksTicket => Ok(from.as_any_box().downcast::<VirtualMachineMksTicket>()?),
            StructType::StorageRequirement => Ok(from.as_any_box().downcast::<StorageRequirement>()?),
            StructType::VirtualMachineTicket => Ok(from.as_any_box().downcast::<VirtualMachineTicket>()?),
            StructType::VirtualMachineWipeResult => Ok(from.as_any_box().downcast::<VirtualMachineWipeResult>()?),
            StructType::VsanUpgradeSystemNetworkPartitionInfo => Ok(from.as_any_box().downcast::<VsanUpgradeSystemNetworkPartitionInfo>()?),
            StructType::VsanUpgradeSystemPreflightCheckIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemPreflightCheckIssue>()?),
            StructType::VsanUpgradeSystemApiBrokenIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemApiBrokenIssue>()?),
            StructType::VsanUpgradeSystemAutoClaimEnabledOnHostsIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemAutoClaimEnabledOnHostsIssue>()?),
            StructType::VsanUpgradeSystemHostsDisconnectedIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemHostsDisconnectedIssue>()?),
            StructType::VsanUpgradeSystemMissingHostsInClusterIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemMissingHostsInClusterIssue>()?),
            StructType::VsanUpgradeSystemNetworkPartitionIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemNetworkPartitionIssue>()?),
            StructType::VsanUpgradeSystemNotEnoughFreeCapacityIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemNotEnoughFreeCapacityIssue>()?),
            StructType::VsanUpgradeSystemRogueHostsInClusterIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemRogueHostsInClusterIssue>()?),
            StructType::VsanUpgradeSystemV2ObjectsPresentDuringDowngradeIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemV2ObjectsPresentDuringDowngradeIssue>()?),
            StructType::VsanUpgradeSystemWrongEsxVersionIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemWrongEsxVersionIssue>()?),
            StructType::VsanUpgradeSystemPreflightCheckResult => Ok(from.as_any_box().downcast::<VsanUpgradeSystemPreflightCheckResult>()?),
            StructType::VsanUpgradeSystemUpgradeHistoryItem => Ok(from.as_any_box().downcast::<VsanUpgradeSystemUpgradeHistoryItem>()?),
            StructType::VsanUpgradeSystemUpgradeHistoryDiskGroupOp => Ok(from.as_any_box().downcast::<VsanUpgradeSystemUpgradeHistoryDiskGroupOp>()?),
            StructType::VsanUpgradeSystemUpgradeHistoryPreflightFail => Ok(from.as_any_box().downcast::<VsanUpgradeSystemUpgradeHistoryPreflightFail>()?),
            StructType::VsanUpgradeSystemUpgradeStatus => Ok(from.as_any_box().downcast::<VsanUpgradeSystemUpgradeStatus>()?),
            StructType::Action => Ok(from.as_any_box().downcast::<Action>()?),
            StructType::CreateTaskAction => Ok(from.as_any_box().downcast::<CreateTaskAction>()?),
            StructType::MethodAction => Ok(from.as_any_box().downcast::<MethodAction>()?),
            StructType::RunScriptAction => Ok(from.as_any_box().downcast::<RunScriptAction>()?),
            StructType::SendEmailAction => Ok(from.as_any_box().downcast::<SendEmailAction>()?),
            StructType::SendSnmpAction => Ok(from.as_any_box().downcast::<SendSnmpAction>()?),
            StructType::MethodActionArgument => Ok(from.as_any_box().downcast::<MethodActionArgument>()?),
            StructType::AlarmAction => Ok(from.as_any_box().downcast::<AlarmAction>()?),
            StructType::AlarmTriggeringAction => Ok(from.as_any_box().downcast::<AlarmTriggeringAction>()?),
            StructType::GroupAlarmAction => Ok(from.as_any_box().downcast::<GroupAlarmAction>()?),
            StructType::AlarmDescription => Ok(from.as_any_box().downcast::<AlarmDescription>()?),
            StructType::AlarmExpression => Ok(from.as_any_box().downcast::<AlarmExpression>()?),
            StructType::AndAlarmExpression => Ok(from.as_any_box().downcast::<AndAlarmExpression>()?),
            StructType::EventAlarmExpression => Ok(from.as_any_box().downcast::<EventAlarmExpression>()?),
            StructType::MetricAlarmExpression => Ok(from.as_any_box().downcast::<MetricAlarmExpression>()?),
            StructType::OrAlarmExpression => Ok(from.as_any_box().downcast::<OrAlarmExpression>()?),
            StructType::StateAlarmExpression => Ok(from.as_any_box().downcast::<StateAlarmExpression>()?),
            StructType::AlarmFilterSpec => Ok(from.as_any_box().downcast::<AlarmFilterSpec>()?),
            StructType::AlarmSetting => Ok(from.as_any_box().downcast::<AlarmSetting>()?),
            StructType::AlarmSpec => Ok(from.as_any_box().downcast::<AlarmSpec>()?),
            StructType::AlarmInfo => Ok(from.as_any_box().downcast::<AlarmInfo>()?),
            StructType::AlarmState => Ok(from.as_any_box().downcast::<AlarmState>()?),
            StructType::AlarmTriggeringActionTransitionSpec => Ok(from.as_any_box().downcast::<AlarmTriggeringActionTransitionSpec>()?),
            StructType::EventAlarmExpressionComparison => Ok(from.as_any_box().downcast::<EventAlarmExpressionComparison>()?),
            StructType::ClusterAction => Ok(from.as_any_box().downcast::<ClusterAction>()?),
            StructType::ClusterClusterInitialPlacementAction => Ok(from.as_any_box().downcast::<ClusterClusterInitialPlacementAction>()?),
            StructType::ClusterHostInfraUpdateHaModeAction => Ok(from.as_any_box().downcast::<ClusterHostInfraUpdateHaModeAction>()?),
            StructType::ClusterHostPowerAction => Ok(from.as_any_box().downcast::<ClusterHostPowerAction>()?),
            StructType::ClusterInitialPlacementAction => Ok(from.as_any_box().downcast::<ClusterInitialPlacementAction>()?),
            StructType::ClusterMigrationAction => Ok(from.as_any_box().downcast::<ClusterMigrationAction>()?),
            StructType::PlacementAction => Ok(from.as_any_box().downcast::<PlacementAction>()?),
            StructType::HbrDiskMigrationAction => Ok(from.as_any_box().downcast::<HbrDiskMigrationAction>()?),
            StructType::StorageMigrationAction => Ok(from.as_any_box().downcast::<StorageMigrationAction>()?),
            StructType::StoragePlacementAction => Ok(from.as_any_box().downcast::<StoragePlacementAction>()?),
            StructType::ClusterActionHistory => Ok(from.as_any_box().downcast::<ClusterActionHistory>()?),
            StructType::ClusterAttemptedVmInfo => Ok(from.as_any_box().downcast::<ClusterAttemptedVmInfo>()?),
            StructType::ClusterConfigInfo => Ok(from.as_any_box().downcast::<ClusterConfigInfo>()?),
            StructType::ClusterConfigSpec => Ok(from.as_any_box().downcast::<ClusterConfigSpec>()?),
            StructType::ClusterCryptoConfigInfo => Ok(from.as_any_box().downcast::<ClusterCryptoConfigInfo>()?),
            StructType::ClusterDasAamNodeState => Ok(from.as_any_box().downcast::<ClusterDasAamNodeState>()?),
            StructType::ClusterDasAdmissionControlInfo => Ok(from.as_any_box().downcast::<ClusterDasAdmissionControlInfo>()?),
            StructType::ClusterFailoverHostAdmissionControlInfo => Ok(from.as_any_box().downcast::<ClusterFailoverHostAdmissionControlInfo>()?),
            StructType::ClusterFailoverLevelAdmissionControlInfo => Ok(from.as_any_box().downcast::<ClusterFailoverLevelAdmissionControlInfo>()?),
            StructType::ClusterFailoverResourcesAdmissionControlInfo => Ok(from.as_any_box().downcast::<ClusterFailoverResourcesAdmissionControlInfo>()?),
            StructType::ClusterDasAdmissionControlPolicy => Ok(from.as_any_box().downcast::<ClusterDasAdmissionControlPolicy>()?),
            StructType::ClusterFailoverHostAdmissionControlPolicy => Ok(from.as_any_box().downcast::<ClusterFailoverHostAdmissionControlPolicy>()?),
            StructType::ClusterFailoverLevelAdmissionControlPolicy => Ok(from.as_any_box().downcast::<ClusterFailoverLevelAdmissionControlPolicy>()?),
            StructType::ClusterFailoverResourcesAdmissionControlPolicy => Ok(from.as_any_box().downcast::<ClusterFailoverResourcesAdmissionControlPolicy>()?),
            StructType::ClusterDasAdvancedRuntimeInfo => Ok(from.as_any_box().downcast::<ClusterDasAdvancedRuntimeInfo>()?),
            StructType::ClusterDasFailoverLevelAdvancedRuntimeInfo => Ok(from.as_any_box().downcast::<ClusterDasFailoverLevelAdvancedRuntimeInfo>()?),
            StructType::DasHeartbeatDatastoreInfo => Ok(from.as_any_box().downcast::<DasHeartbeatDatastoreInfo>()?),
            StructType::ClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo => Ok(from.as_any_box().downcast::<ClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo>()?),
            StructType::ClusterDasConfigInfo => Ok(from.as_any_box().downcast::<ClusterDasConfigInfo>()?),
            StructType::ClusterDasData => Ok(from.as_any_box().downcast::<ClusterDasData>()?),
            StructType::ClusterDasDataSummary => Ok(from.as_any_box().downcast::<ClusterDasDataSummary>()?),
            StructType::ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots => Ok(from.as_any_box().downcast::<ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots>()?),
            StructType::ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo => Ok(from.as_any_box().downcast::<ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo>()?),
            StructType::ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots => Ok(from.as_any_box().downcast::<ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots>()?),
            StructType::ClusterDasFdmHostState => Ok(from.as_any_box().downcast::<ClusterDasFdmHostState>()?),
            StructType::ClusterDasHostInfo => Ok(from.as_any_box().downcast::<ClusterDasHostInfo>()?),
            StructType::ClusterDasAamHostInfo => Ok(from.as_any_box().downcast::<ClusterDasAamHostInfo>()?),
            StructType::ClusterDasHostRecommendation => Ok(from.as_any_box().downcast::<ClusterDasHostRecommendation>()?),
            StructType::ClusterDasVmConfigInfo => Ok(from.as_any_box().downcast::<ClusterDasVmConfigInfo>()?),
            StructType::ClusterDasVmSettings => Ok(from.as_any_box().downcast::<ClusterDasVmSettings>()?),
            StructType::ClusterDpmConfigInfo => Ok(from.as_any_box().downcast::<ClusterDpmConfigInfo>()?),
            StructType::ClusterDpmHostConfigInfo => Ok(from.as_any_box().downcast::<ClusterDpmHostConfigInfo>()?),
            StructType::ClusterDrsConfigInfo => Ok(from.as_any_box().downcast::<ClusterDrsConfigInfo>()?),
            StructType::ClusterDrsFaults => Ok(from.as_any_box().downcast::<ClusterDrsFaults>()?),
            StructType::ClusterDrsFaultsFaultsByVm => Ok(from.as_any_box().downcast::<ClusterDrsFaultsFaultsByVm>()?),
            StructType::ClusterDrsFaultsFaultsByVirtualDisk => Ok(from.as_any_box().downcast::<ClusterDrsFaultsFaultsByVirtualDisk>()?),
            StructType::ClusterDrsMigration => Ok(from.as_any_box().downcast::<ClusterDrsMigration>()?),
            StructType::ClusterDrsRecommendation => Ok(from.as_any_box().downcast::<ClusterDrsRecommendation>()?),
            StructType::ClusterDrsVmConfigInfo => Ok(from.as_any_box().downcast::<ClusterDrsVmConfigInfo>()?),
            StructType::ClusterEvcManagerCheckResult => Ok(from.as_any_box().downcast::<ClusterEvcManagerCheckResult>()?),
            StructType::ClusterEvcManagerEvcState => Ok(from.as_any_box().downcast::<ClusterEvcManagerEvcState>()?),
            StructType::ClusterEnterMaintenanceResult => Ok(from.as_any_box().downcast::<ClusterEnterMaintenanceResult>()?),
            StructType::ClusterFailoverHostAdmissionControlInfoHostStatus => Ok(from.as_any_box().downcast::<ClusterFailoverHostAdmissionControlInfoHostStatus>()?),
            StructType::ClusterGroupInfo => Ok(from.as_any_box().downcast::<ClusterGroupInfo>()?),
            StructType::ClusterHostGroup => Ok(from.as_any_box().downcast::<ClusterHostGroup>()?),
            StructType::ClusterVmGroup => Ok(from.as_any_box().downcast::<ClusterVmGroup>()?),
            StructType::ClusterHostRecommendation => Ok(from.as_any_box().downcast::<ClusterHostRecommendation>()?),
            StructType::ClusterInfraUpdateHaConfigInfo => Ok(from.as_any_box().downcast::<ClusterInfraUpdateHaConfigInfo>()?),
            StructType::ClusterNotAttemptedVmInfo => Ok(from.as_any_box().downcast::<ClusterNotAttemptedVmInfo>()?),
            StructType::ClusterOrchestrationInfo => Ok(from.as_any_box().downcast::<ClusterOrchestrationInfo>()?),
            StructType::PlacementResult => Ok(from.as_any_box().downcast::<PlacementResult>()?),
            StructType::PlacementSpec => Ok(from.as_any_box().downcast::<PlacementSpec>()?),
            StructType::ClusterPowerOnVmResult => Ok(from.as_any_box().downcast::<ClusterPowerOnVmResult>()?),
            StructType::ClusterPreemptibleVmPairInfo => Ok(from.as_any_box().downcast::<ClusterPreemptibleVmPairInfo>()?),
            StructType::ClusterProactiveDrsConfigInfo => Ok(from.as_any_box().downcast::<ClusterProactiveDrsConfigInfo>()?),
            StructType::ClusterRecommendation => Ok(from.as_any_box().downcast::<ClusterRecommendation>()?),
            StructType::ClusterResourceUsageSummary => Ok(from.as_any_box().downcast::<ClusterResourceUsageSummary>()?),
            StructType::ClusterRuleInfo => Ok(from.as_any_box().downcast::<ClusterRuleInfo>()?),
            StructType::ClusterAffinityRuleSpec => Ok(from.as_any_box().downcast::<ClusterAffinityRuleSpec>()?),
            StructType::ClusterAntiAffinityRuleSpec => Ok(from.as_any_box().downcast::<ClusterAntiAffinityRuleSpec>()?),
            StructType::ClusterDependencyRuleInfo => Ok(from.as_any_box().downcast::<ClusterDependencyRuleInfo>()?),
            StructType::ClusterVmHostRuleInfo => Ok(from.as_any_box().downcast::<ClusterVmHostRuleInfo>()?),
            StructType::VirtualDiskAntiAffinityRuleSpec => Ok(from.as_any_box().downcast::<VirtualDiskAntiAffinityRuleSpec>()?),
            StructType::VirtualDiskRuleSpec => Ok(from.as_any_box().downcast::<VirtualDiskRuleSpec>()?),
            StructType::ClusterSlotPolicy => Ok(from.as_any_box().downcast::<ClusterSlotPolicy>()?),
            StructType::ClusterFixedSizeSlotPolicy => Ok(from.as_any_box().downcast::<ClusterFixedSizeSlotPolicy>()?),
            StructType::ClusterSystemVMsConfigInfo => Ok(from.as_any_box().downcast::<ClusterSystemVMsConfigInfo>()?),
            StructType::ClusterSystemVMsConfigSpec => Ok(from.as_any_box().downcast::<ClusterSystemVMsConfigSpec>()?),
            StructType::ClusterUsageSummary => Ok(from.as_any_box().downcast::<ClusterUsageSummary>()?),
            StructType::ClusterVmComponentProtectionSettings => Ok(from.as_any_box().downcast::<ClusterVmComponentProtectionSettings>()?),
            StructType::ClusterVmOrchestrationInfo => Ok(from.as_any_box().downcast::<ClusterVmOrchestrationInfo>()?),
            StructType::ClusterVmReadiness => Ok(from.as_any_box().downcast::<ClusterVmReadiness>()?),
            StructType::ClusterVmToolsMonitoringSettings => Ok(from.as_any_box().downcast::<ClusterVmToolsMonitoringSettings>()?),
            StructType::DistributedVirtualPort => Ok(from.as_any_box().downcast::<DistributedVirtualPort>()?),
            StructType::DvPortConfigInfo => Ok(from.as_any_box().downcast::<DvPortConfigInfo>()?),
            StructType::DvPortConfigSpec => Ok(from.as_any_box().downcast::<DvPortConfigSpec>()?),
            StructType::DvsFilterParameter => Ok(from.as_any_box().downcast::<DvsFilterParameter>()?),
            StructType::DvsHostLocalPortInfo => Ok(from.as_any_box().downcast::<DvsHostLocalPortInfo>()?),
            StructType::DvPortStatus => Ok(from.as_any_box().downcast::<DvPortStatus>()?),
            StructType::DvPortSetting => Ok(from.as_any_box().downcast::<DvPortSetting>()?),
            StructType::VMwareDvsPortSetting => Ok(from.as_any_box().downcast::<VMwareDvsPortSetting>()?),
            StructType::DvPortState => Ok(from.as_any_box().downcast::<DvPortState>()?),
            StructType::DvPortgroupConfigInfo => Ok(from.as_any_box().downcast::<DvPortgroupConfigInfo>()?),
            StructType::DvPortgroupConfigSpec => Ok(from.as_any_box().downcast::<DvPortgroupConfigSpec>()?),
            StructType::DistributedVirtualPortgroupNsxPortgroupOperationResult => Ok(from.as_any_box().downcast::<DistributedVirtualPortgroupNsxPortgroupOperationResult>()?),
            StructType::DvPortgroupPolicy => Ok(from.as_any_box().downcast::<DvPortgroupPolicy>()?),
            StructType::VMwareDvsPortgroupPolicy => Ok(from.as_any_box().downcast::<VMwareDvsPortgroupPolicy>()?),
            StructType::DistributedVirtualPortgroupProblem => Ok(from.as_any_box().downcast::<DistributedVirtualPortgroupProblem>()?),
            StructType::DistributedVirtualPortgroupInfo => Ok(from.as_any_box().downcast::<DistributedVirtualPortgroupInfo>()?),
            StructType::DistributedVirtualSwitchInfo => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchInfo>()?),
            StructType::DistributedVirtualSwitchManagerCompatibilityResult => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchManagerCompatibilityResult>()?),
            StructType::DvsManagerDvsConfigTarget => Ok(from.as_any_box().downcast::<DvsManagerDvsConfigTarget>()?),
            StructType::DistributedVirtualSwitchManagerDvsProductSpec => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchManagerDvsProductSpec>()?),
            StructType::DistributedVirtualSwitchManagerHostContainer => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchManagerHostContainer>()?),
            StructType::DistributedVirtualSwitchManagerHostDvsFilterSpec => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchManagerHostDvsFilterSpec>()?),
            StructType::DistributedVirtualSwitchManagerHostArrayFilter => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchManagerHostArrayFilter>()?),
            StructType::DistributedVirtualSwitchManagerHostContainerFilter => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchManagerHostContainerFilter>()?),
            StructType::DistributedVirtualSwitchManagerHostDvsMembershipFilter => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchManagerHostDvsMembershipFilter>()?),
            StructType::DistributedVirtualSwitchManagerImportResult => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchManagerImportResult>()?),
            StructType::DvsManagerPhysicalNicsList => Ok(from.as_any_box().downcast::<DvsManagerPhysicalNicsList>()?),
            StructType::EntityBackup => Ok(from.as_any_box().downcast::<EntityBackup>()?),
            StructType::EntityBackupConfig => Ok(from.as_any_box().downcast::<EntityBackupConfig>()?),
            StructType::DistributedVirtualSwitchHostMember => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchHostMember>()?),
            StructType::DistributedVirtualSwitchHostMemberBacking => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchHostMemberBacking>()?),
            StructType::DistributedVirtualSwitchHostMemberPnicBacking => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchHostMemberPnicBacking>()?),
            StructType::DistributedVirtualSwitchHostMemberConfigInfo => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchHostMemberConfigInfo>()?),
            StructType::DistributedVirtualSwitchHostMemberConfigSpec => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchHostMemberConfigSpec>()?),
            StructType::HostMemberHealthCheckResult => Ok(from.as_any_box().downcast::<HostMemberHealthCheckResult>()?),
            StructType::HostMemberUplinkHealthCheckResult => Ok(from.as_any_box().downcast::<HostMemberUplinkHealthCheckResult>()?),
            StructType::VMwareDvsMtuHealthCheckResult => Ok(from.as_any_box().downcast::<VMwareDvsMtuHealthCheckResult>()?),
            StructType::VMwareDvsVlanHealthCheckResult => Ok(from.as_any_box().downcast::<VMwareDvsVlanHealthCheckResult>()?),
            StructType::VMwareDvsTeamingHealthCheckResult => Ok(from.as_any_box().downcast::<VMwareDvsTeamingHealthCheckResult>()?),
            StructType::DistributedVirtualSwitchHostMemberPnicSpec => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchHostMemberPnicSpec>()?),
            StructType::HostMemberRuntimeInfo => Ok(from.as_any_box().downcast::<HostMemberRuntimeInfo>()?),
            StructType::DistributedVirtualSwitchHostMemberRuntimeState => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchHostMemberRuntimeState>()?),
            StructType::DistributedVirtualSwitchHostMemberTransportZoneInfo => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchHostMemberTransportZoneInfo>()?),
            StructType::DistributedVirtualSwitchHostProductSpec => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchHostProductSpec>()?),
            StructType::DistributedVirtualSwitchKeyedOpaqueBlob => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchKeyedOpaqueBlob>()?),
            StructType::DistributedVirtualSwitchNetworkOffloadSpec => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchNetworkOffloadSpec>()?),
            StructType::DvsNetworkResourcePool => Ok(from.as_any_box().downcast::<DvsNetworkResourcePool>()?),
            StructType::DvsNetworkResourcePoolAllocationInfo => Ok(from.as_any_box().downcast::<DvsNetworkResourcePoolAllocationInfo>()?),
            StructType::DvsNetworkResourcePoolConfigSpec => Ok(from.as_any_box().downcast::<DvsNetworkResourcePoolConfigSpec>()?),
            StructType::DistributedVirtualSwitchPortConnectee => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchPortConnectee>()?),
            StructType::DistributedVirtualSwitchPortConnection => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchPortConnection>()?),
            StructType::DistributedVirtualSwitchPortCriteria => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchPortCriteria>()?),
            StructType::DistributedVirtualSwitchPortStatistics => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchPortStatistics>()?),
            StructType::DistributedVirtualSwitchProductSpec => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchProductSpec>()?),
            StructType::DvsTrafficRule => Ok(from.as_any_box().downcast::<DvsTrafficRule>()?),
            StructType::DvsNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsNetworkRuleAction>()?),
            StructType::DvsAcceptNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsAcceptNetworkRuleAction>()?),
            StructType::DvsCopyNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsCopyNetworkRuleAction>()?),
            StructType::DvsDropNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsDropNetworkRuleAction>()?),
            StructType::DvsGreEncapNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsGreEncapNetworkRuleAction>()?),
            StructType::DvsLogNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsLogNetworkRuleAction>()?),
            StructType::DvsMacRewriteNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsMacRewriteNetworkRuleAction>()?),
            StructType::DvsPuntNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsPuntNetworkRuleAction>()?),
            StructType::DvsRateLimitNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsRateLimitNetworkRuleAction>()?),
            StructType::DvsUpdateTagNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsUpdateTagNetworkRuleAction>()?),
            StructType::DvsNetworkRuleQualifier => Ok(from.as_any_box().downcast::<DvsNetworkRuleQualifier>()?),
            StructType::DvsIpNetworkRuleQualifier => Ok(from.as_any_box().downcast::<DvsIpNetworkRuleQualifier>()?),
            StructType::DvsMacNetworkRuleQualifier => Ok(from.as_any_box().downcast::<DvsMacNetworkRuleQualifier>()?),
            StructType::DvsSystemTrafficNetworkRuleQualifier => Ok(from.as_any_box().downcast::<DvsSystemTrafficNetworkRuleQualifier>()?),
            StructType::DvsTrafficRuleset => Ok(from.as_any_box().downcast::<DvsTrafficRuleset>()?),
            StructType::DvsVmVnicNetworkResourcePool => Ok(from.as_any_box().downcast::<DvsVmVnicNetworkResourcePool>()?),
            StructType::DvsVmVnicResourcePoolConfigSpec => Ok(from.as_any_box().downcast::<DvsVmVnicResourcePoolConfigSpec>()?),
            StructType::DvsVmVnicResourceAllocation => Ok(from.as_any_box().downcast::<DvsVmVnicResourceAllocation>()?),
            StructType::DvsVmVnicNetworkResourcePoolRuntimeInfo => Ok(from.as_any_box().downcast::<DvsVmVnicNetworkResourcePoolRuntimeInfo>()?),
            StructType::DvsVnicAllocatedResource => Ok(from.as_any_box().downcast::<DvsVnicAllocatedResource>()?),
            StructType::VMwareDvsDpuCapability => Ok(from.as_any_box().downcast::<VMwareDvsDpuCapability>()?),
            StructType::VMwareIpfixConfig => Ok(from.as_any_box().downcast::<VMwareIpfixConfig>()?),
            StructType::VMwareDvsIpfixCapability => Ok(from.as_any_box().downcast::<VMwareDvsIpfixCapability>()?),
            StructType::VMwareDvsLacpCapability => Ok(from.as_any_box().downcast::<VMwareDvsLacpCapability>()?),
            StructType::VMwareDvsLacpGroupConfig => Ok(from.as_any_box().downcast::<VMwareDvsLacpGroupConfig>()?),
            StructType::VMwareDvsLacpGroupSpec => Ok(from.as_any_box().downcast::<VMwareDvsLacpGroupSpec>()?),
            StructType::VMwareDvsLagIpfixConfig => Ok(from.as_any_box().downcast::<VMwareDvsLagIpfixConfig>()?),
            StructType::VMwareDvsLagVlanConfig => Ok(from.as_any_box().downcast::<VMwareDvsLagVlanConfig>()?),
            StructType::VMwareDvsMtuCapability => Ok(from.as_any_box().downcast::<VMwareDvsMtuCapability>()?),
            StructType::VMwareDvsPvlanConfigSpec => Ok(from.as_any_box().downcast::<VMwareDvsPvlanConfigSpec>()?),
            StructType::VMwareDvsPvlanMapEntry => Ok(from.as_any_box().downcast::<VMwareDvsPvlanMapEntry>()?),
            StructType::VMwareDvsVspanConfigSpec => Ok(from.as_any_box().downcast::<VMwareDvsVspanConfigSpec>()?),
            StructType::VMwareDvsVspanCapability => Ok(from.as_any_box().downcast::<VMwareDvsVspanCapability>()?),
            StructType::VMwareVspanPort => Ok(from.as_any_box().downcast::<VMwareVspanPort>()?),
            StructType::VMwareVspanSession => Ok(from.as_any_box().downcast::<VMwareVspanSession>()?),
            StructType::CryptoKeyId => Ok(from.as_any_box().downcast::<CryptoKeyId>()?),
            StructType::CryptoKeyPlain => Ok(from.as_any_box().downcast::<CryptoKeyPlain>()?),
            StructType::CryptoKeyResult => Ok(from.as_any_box().downcast::<CryptoKeyResult>()?),
            StructType::CryptoManagerHostKeyStatus => Ok(from.as_any_box().downcast::<CryptoManagerHostKeyStatus>()?),
            StructType::CryptoManagerKmipCertSignRequest => Ok(from.as_any_box().downcast::<CryptoManagerKmipCertSignRequest>()?),
            StructType::CryptoManagerKmipCertificateInfo => Ok(from.as_any_box().downcast::<CryptoManagerKmipCertificateInfo>()?),
            StructType::CryptoManagerKmipClusterStatus => Ok(from.as_any_box().downcast::<CryptoManagerKmipClusterStatus>()?),
            StructType::CryptoManagerKmipCryptoKeyStatus => Ok(from.as_any_box().downcast::<CryptoManagerKmipCryptoKeyStatus>()?),
            StructType::CryptoManagerKmipCustomAttributeSpec => Ok(from.as_any_box().downcast::<CryptoManagerKmipCustomAttributeSpec>()?),
            StructType::CryptoManagerKmipServerCertInfo => Ok(from.as_any_box().downcast::<CryptoManagerKmipServerCertInfo>()?),
            StructType::CryptoManagerKmipServerStatus => Ok(from.as_any_box().downcast::<CryptoManagerKmipServerStatus>()?),
            StructType::CryptoSpec => Ok(from.as_any_box().downcast::<CryptoSpec>()?),
            StructType::CryptoSpecDecrypt => Ok(from.as_any_box().downcast::<CryptoSpecDecrypt>()?),
            StructType::CryptoSpecDeepRecrypt => Ok(from.as_any_box().downcast::<CryptoSpecDeepRecrypt>()?),
            StructType::CryptoSpecEncrypt => Ok(from.as_any_box().downcast::<CryptoSpecEncrypt>()?),
            StructType::CryptoSpecNoOp => Ok(from.as_any_box().downcast::<CryptoSpecNoOp>()?),
            StructType::CryptoSpecRegister => Ok(from.as_any_box().downcast::<CryptoSpecRegister>()?),
            StructType::CryptoSpecShallowRecrypt => Ok(from.as_any_box().downcast::<CryptoSpecShallowRecrypt>()?),
            StructType::KeyProviderId => Ok(from.as_any_box().downcast::<KeyProviderId>()?),
            StructType::KmipClusterInfo => Ok(from.as_any_box().downcast::<KmipClusterInfo>()?),
            StructType::KmipServerInfo => Ok(from.as_any_box().downcast::<KmipServerInfo>()?),
            StructType::KmipServerSpec => Ok(from.as_any_box().downcast::<KmipServerSpec>()?),
            StructType::KmipServerStatus => Ok(from.as_any_box().downcast::<KmipServerStatus>()?),
            StructType::ChangesInfoEventArgument => Ok(from.as_any_box().downcast::<ChangesInfoEventArgument>()?),
            StructType::DvsOutOfSyncHostArgument => Ok(from.as_any_box().downcast::<DvsOutOfSyncHostArgument>()?),
            StructType::Event => Ok(from.as_any_box().downcast::<Event>()?),
            StructType::AlarmEvent => Ok(from.as_any_box().downcast::<AlarmEvent>()?),
            StructType::AlarmAcknowledgedEvent => Ok(from.as_any_box().downcast::<AlarmAcknowledgedEvent>()?),
            StructType::AlarmActionTriggeredEvent => Ok(from.as_any_box().downcast::<AlarmActionTriggeredEvent>()?),
            StructType::AlarmClearedEvent => Ok(from.as_any_box().downcast::<AlarmClearedEvent>()?),
            StructType::AlarmCreatedEvent => Ok(from.as_any_box().downcast::<AlarmCreatedEvent>()?),
            StructType::AlarmEmailCompletedEvent => Ok(from.as_any_box().downcast::<AlarmEmailCompletedEvent>()?),
            StructType::AlarmEmailFailedEvent => Ok(from.as_any_box().downcast::<AlarmEmailFailedEvent>()?),
            StructType::AlarmReconfiguredEvent => Ok(from.as_any_box().downcast::<AlarmReconfiguredEvent>()?),
            StructType::AlarmRemovedEvent => Ok(from.as_any_box().downcast::<AlarmRemovedEvent>()?),
            StructType::AlarmScriptCompleteEvent => Ok(from.as_any_box().downcast::<AlarmScriptCompleteEvent>()?),
            StructType::AlarmScriptFailedEvent => Ok(from.as_any_box().downcast::<AlarmScriptFailedEvent>()?),
            StructType::AlarmSnmpCompletedEvent => Ok(from.as_any_box().downcast::<AlarmSnmpCompletedEvent>()?),
            StructType::AlarmSnmpFailedEvent => Ok(from.as_any_box().downcast::<AlarmSnmpFailedEvent>()?),
            StructType::AlarmStatusChangedEvent => Ok(from.as_any_box().downcast::<AlarmStatusChangedEvent>()?),
            StructType::AuthorizationEvent => Ok(from.as_any_box().downcast::<AuthorizationEvent>()?),
            StructType::PermissionEvent => Ok(from.as_any_box().downcast::<PermissionEvent>()?),
            StructType::PermissionAddedEvent => Ok(from.as_any_box().downcast::<PermissionAddedEvent>()?),
            StructType::PermissionRemovedEvent => Ok(from.as_any_box().downcast::<PermissionRemovedEvent>()?),
            StructType::PermissionUpdatedEvent => Ok(from.as_any_box().downcast::<PermissionUpdatedEvent>()?),
            StructType::RoleEvent => Ok(from.as_any_box().downcast::<RoleEvent>()?),
            StructType::RoleAddedEvent => Ok(from.as_any_box().downcast::<RoleAddedEvent>()?),
            StructType::RoleRemovedEvent => Ok(from.as_any_box().downcast::<RoleRemovedEvent>()?),
            StructType::RoleUpdatedEvent => Ok(from.as_any_box().downcast::<RoleUpdatedEvent>()?),
            StructType::ClusterEvent => Ok(from.as_any_box().downcast::<ClusterEvent>()?),
            StructType::ClusterComplianceCheckedEvent => Ok(from.as_any_box().downcast::<ClusterComplianceCheckedEvent>()?),
            StructType::ClusterCreatedEvent => Ok(from.as_any_box().downcast::<ClusterCreatedEvent>()?),
            StructType::ClusterDestroyedEvent => Ok(from.as_any_box().downcast::<ClusterDestroyedEvent>()?),
            StructType::ClusterOvercommittedEvent => Ok(from.as_any_box().downcast::<ClusterOvercommittedEvent>()?),
            StructType::HostOvercommittedEvent => Ok(from.as_any_box().downcast::<HostOvercommittedEvent>()?),
            StructType::ClusterReconfiguredEvent => Ok(from.as_any_box().downcast::<ClusterReconfiguredEvent>()?),
            StructType::ClusterStatusChangedEvent => Ok(from.as_any_box().downcast::<ClusterStatusChangedEvent>()?),
            StructType::HostStatusChangedEvent => Ok(from.as_any_box().downcast::<HostStatusChangedEvent>()?),
            StructType::DasAdmissionControlDisabledEvent => Ok(from.as_any_box().downcast::<DasAdmissionControlDisabledEvent>()?),
            StructType::DasAdmissionControlEnabledEvent => Ok(from.as_any_box().downcast::<DasAdmissionControlEnabledEvent>()?),
            StructType::DasAgentFoundEvent => Ok(from.as_any_box().downcast::<DasAgentFoundEvent>()?),
            StructType::DasAgentUnavailableEvent => Ok(from.as_any_box().downcast::<DasAgentUnavailableEvent>()?),
            StructType::DasClusterIsolatedEvent => Ok(from.as_any_box().downcast::<DasClusterIsolatedEvent>()?),
            StructType::DasDisabledEvent => Ok(from.as_any_box().downcast::<DasDisabledEvent>()?),
            StructType::DasEnabledEvent => Ok(from.as_any_box().downcast::<DasEnabledEvent>()?),
            StructType::DasHostFailedEvent => Ok(from.as_any_box().downcast::<DasHostFailedEvent>()?),
            StructType::DasHostIsolatedEvent => Ok(from.as_any_box().downcast::<DasHostIsolatedEvent>()?),
            StructType::DrsDisabledEvent => Ok(from.as_any_box().downcast::<DrsDisabledEvent>()?),
            StructType::DrsEnabledEvent => Ok(from.as_any_box().downcast::<DrsEnabledEvent>()?),
            StructType::DrsInvocationFailedEvent => Ok(from.as_any_box().downcast::<DrsInvocationFailedEvent>()?),
            StructType::DrsRecoveredFromFailureEvent => Ok(from.as_any_box().downcast::<DrsRecoveredFromFailureEvent>()?),
            StructType::FailoverLevelRestored => Ok(from.as_any_box().downcast::<FailoverLevelRestored>()?),
            StructType::HostMonitoringStateChangedEvent => Ok(from.as_any_box().downcast::<HostMonitoringStateChangedEvent>()?),
            StructType::InsufficientFailoverResourcesEvent => Ok(from.as_any_box().downcast::<InsufficientFailoverResourcesEvent>()?),
            StructType::VmHealthMonitoringStateChangedEvent => Ok(from.as_any_box().downcast::<VmHealthMonitoringStateChangedEvent>()?),
            StructType::CustomFieldEvent => Ok(from.as_any_box().downcast::<CustomFieldEvent>()?),
            StructType::CustomFieldDefEvent => Ok(from.as_any_box().downcast::<CustomFieldDefEvent>()?),
            StructType::CustomFieldDefAddedEvent => Ok(from.as_any_box().downcast::<CustomFieldDefAddedEvent>()?),
            StructType::CustomFieldDefRemovedEvent => Ok(from.as_any_box().downcast::<CustomFieldDefRemovedEvent>()?),
            StructType::CustomFieldDefRenamedEvent => Ok(from.as_any_box().downcast::<CustomFieldDefRenamedEvent>()?),
            StructType::CustomFieldValueChangedEvent => Ok(from.as_any_box().downcast::<CustomFieldValueChangedEvent>()?),
            StructType::DvPortgroupEvent => Ok(from.as_any_box().downcast::<DvPortgroupEvent>()?),
            StructType::DvPortgroupCreatedEvent => Ok(from.as_any_box().downcast::<DvPortgroupCreatedEvent>()?),
            StructType::DvPortgroupDestroyedEvent => Ok(from.as_any_box().downcast::<DvPortgroupDestroyedEvent>()?),
            StructType::DvPortgroupReconfiguredEvent => Ok(from.as_any_box().downcast::<DvPortgroupReconfiguredEvent>()?),
            StructType::DvPortgroupRenamedEvent => Ok(from.as_any_box().downcast::<DvPortgroupRenamedEvent>()?),
            StructType::DvpgImportEvent => Ok(from.as_any_box().downcast::<DvpgImportEvent>()?),
            StructType::DvpgRestoreEvent => Ok(from.as_any_box().downcast::<DvpgRestoreEvent>()?),
            StructType::DatacenterEvent => Ok(from.as_any_box().downcast::<DatacenterEvent>()?),
            StructType::DatacenterCreatedEvent => Ok(from.as_any_box().downcast::<DatacenterCreatedEvent>()?),
            StructType::DatacenterRenamedEvent => Ok(from.as_any_box().downcast::<DatacenterRenamedEvent>()?),
            StructType::DatastoreEvent => Ok(from.as_any_box().downcast::<DatastoreEvent>()?),
            StructType::DatastoreCapacityIncreasedEvent => Ok(from.as_any_box().downcast::<DatastoreCapacityIncreasedEvent>()?),
            StructType::DatastoreDestroyedEvent => Ok(from.as_any_box().downcast::<DatastoreDestroyedEvent>()?),
            StructType::DatastoreDuplicatedEvent => Ok(from.as_any_box().downcast::<DatastoreDuplicatedEvent>()?),
            StructType::DatastoreFileEvent => Ok(from.as_any_box().downcast::<DatastoreFileEvent>()?),
            StructType::DatastoreFileCopiedEvent => Ok(from.as_any_box().downcast::<DatastoreFileCopiedEvent>()?),
            StructType::DatastoreFileDeletedEvent => Ok(from.as_any_box().downcast::<DatastoreFileDeletedEvent>()?),
            StructType::DatastoreFileMovedEvent => Ok(from.as_any_box().downcast::<DatastoreFileMovedEvent>()?),
            StructType::DatastoreIormReconfiguredEvent => Ok(from.as_any_box().downcast::<DatastoreIormReconfiguredEvent>()?),
            StructType::DatastoreRenamedEvent => Ok(from.as_any_box().downcast::<DatastoreRenamedEvent>()?),
            StructType::NonViWorkloadDetectedOnDatastoreEvent => Ok(from.as_any_box().downcast::<NonViWorkloadDetectedOnDatastoreEvent>()?),
            StructType::DvsEvent => Ok(from.as_any_box().downcast::<DvsEvent>()?),
            StructType::DvsCreatedEvent => Ok(from.as_any_box().downcast::<DvsCreatedEvent>()?),
            StructType::DvsDestroyedEvent => Ok(from.as_any_box().downcast::<DvsDestroyedEvent>()?),
            StructType::DvsHostBackInSyncEvent => Ok(from.as_any_box().downcast::<DvsHostBackInSyncEvent>()?),
            StructType::DvsHostJoinedEvent => Ok(from.as_any_box().downcast::<DvsHostJoinedEvent>()?),
            StructType::DvsHostLeftEvent => Ok(from.as_any_box().downcast::<DvsHostLeftEvent>()?),
            StructType::DvsHostStatusUpdated => Ok(from.as_any_box().downcast::<DvsHostStatusUpdated>()?),
            StructType::DvsHostWentOutOfSyncEvent => Ok(from.as_any_box().downcast::<DvsHostWentOutOfSyncEvent>()?),
            StructType::DvsImportEvent => Ok(from.as_any_box().downcast::<DvsImportEvent>()?),
            StructType::DvsMergedEvent => Ok(from.as_any_box().downcast::<DvsMergedEvent>()?),
            StructType::DvsPortBlockedEvent => Ok(from.as_any_box().downcast::<DvsPortBlockedEvent>()?),
            StructType::DvsPortConnectedEvent => Ok(from.as_any_box().downcast::<DvsPortConnectedEvent>()?),
            StructType::DvsPortCreatedEvent => Ok(from.as_any_box().downcast::<DvsPortCreatedEvent>()?),
            StructType::DvsPortDeletedEvent => Ok(from.as_any_box().downcast::<DvsPortDeletedEvent>()?),
            StructType::DvsPortDisconnectedEvent => Ok(from.as_any_box().downcast::<DvsPortDisconnectedEvent>()?),
            StructType::DvsPortEnteredPassthruEvent => Ok(from.as_any_box().downcast::<DvsPortEnteredPassthruEvent>()?),
            StructType::DvsPortExitedPassthruEvent => Ok(from.as_any_box().downcast::<DvsPortExitedPassthruEvent>()?),
            StructType::DvsPortJoinPortgroupEvent => Ok(from.as_any_box().downcast::<DvsPortJoinPortgroupEvent>()?),
            StructType::DvsPortLeavePortgroupEvent => Ok(from.as_any_box().downcast::<DvsPortLeavePortgroupEvent>()?),
            StructType::DvsPortLinkDownEvent => Ok(from.as_any_box().downcast::<DvsPortLinkDownEvent>()?),
            StructType::DvsPortLinkUpEvent => Ok(from.as_any_box().downcast::<DvsPortLinkUpEvent>()?),
            StructType::DvsPortReconfiguredEvent => Ok(from.as_any_box().downcast::<DvsPortReconfiguredEvent>()?),
            StructType::DvsPortRuntimeChangeEvent => Ok(from.as_any_box().downcast::<DvsPortRuntimeChangeEvent>()?),
            StructType::DvsPortUnblockedEvent => Ok(from.as_any_box().downcast::<DvsPortUnblockedEvent>()?),
            StructType::DvsPortVendorSpecificStateChangeEvent => Ok(from.as_any_box().downcast::<DvsPortVendorSpecificStateChangeEvent>()?),
            StructType::DvsReconfiguredEvent => Ok(from.as_any_box().downcast::<DvsReconfiguredEvent>()?),
            StructType::DvsRenamedEvent => Ok(from.as_any_box().downcast::<DvsRenamedEvent>()?),
            StructType::DvsRestoreEvent => Ok(from.as_any_box().downcast::<DvsRestoreEvent>()?),
            StructType::DvsUpgradeAvailableEvent => Ok(from.as_any_box().downcast::<DvsUpgradeAvailableEvent>()?),
            StructType::DvsUpgradeInProgressEvent => Ok(from.as_any_box().downcast::<DvsUpgradeInProgressEvent>()?),
            StructType::DvsUpgradeRejectedEvent => Ok(from.as_any_box().downcast::<DvsUpgradeRejectedEvent>()?),
            StructType::DvsUpgradedEvent => Ok(from.as_any_box().downcast::<DvsUpgradedEvent>()?),
            StructType::HostLocalPortCreatedEvent => Ok(from.as_any_box().downcast::<HostLocalPortCreatedEvent>()?),
            StructType::OutOfSyncDvsHost => Ok(from.as_any_box().downcast::<OutOfSyncDvsHost>()?),
            StructType::RecoveryEvent => Ok(from.as_any_box().downcast::<RecoveryEvent>()?),
            StructType::RollbackEvent => Ok(from.as_any_box().downcast::<RollbackEvent>()?),
            StructType::VmVnicPoolReservationViolationClearEvent => Ok(from.as_any_box().downcast::<VmVnicPoolReservationViolationClearEvent>()?),
            StructType::VmVnicPoolReservationViolationRaiseEvent => Ok(from.as_any_box().downcast::<VmVnicPoolReservationViolationRaiseEvent>()?),
            StructType::EventEx => Ok(from.as_any_box().downcast::<EventEx>()?),
            StructType::GeneralEvent => Ok(from.as_any_box().downcast::<GeneralEvent>()?),
            StructType::ExtendedEvent => Ok(from.as_any_box().downcast::<ExtendedEvent>()?),
            StructType::GeneralHostErrorEvent => Ok(from.as_any_box().downcast::<GeneralHostErrorEvent>()?),
            StructType::GeneralHostInfoEvent => Ok(from.as_any_box().downcast::<GeneralHostInfoEvent>()?),
            StructType::GeneralHostWarningEvent => Ok(from.as_any_box().downcast::<GeneralHostWarningEvent>()?),
            StructType::GeneralUserEvent => Ok(from.as_any_box().downcast::<GeneralUserEvent>()?),
            StructType::GeneralVmErrorEvent => Ok(from.as_any_box().downcast::<GeneralVmErrorEvent>()?),
            StructType::GeneralVmInfoEvent => Ok(from.as_any_box().downcast::<GeneralVmInfoEvent>()?),
            StructType::GeneralVmWarningEvent => Ok(from.as_any_box().downcast::<GeneralVmWarningEvent>()?),
            StructType::HealthStatusChangedEvent => Ok(from.as_any_box().downcast::<HealthStatusChangedEvent>()?),
            StructType::HostEvent => Ok(from.as_any_box().downcast::<HostEvent>()?),
            StructType::AccountCreatedEvent => Ok(from.as_any_box().downcast::<AccountCreatedEvent>()?),
            StructType::AccountRemovedEvent => Ok(from.as_any_box().downcast::<AccountRemovedEvent>()?),
            StructType::AccountUpdatedEvent => Ok(from.as_any_box().downcast::<AccountUpdatedEvent>()?),
            StructType::AdminPasswordNotChangedEvent => Ok(from.as_any_box().downcast::<AdminPasswordNotChangedEvent>()?),
            StructType::CanceledHostOperationEvent => Ok(from.as_any_box().downcast::<CanceledHostOperationEvent>()?),
            StructType::DatastoreDiscoveredEvent => Ok(from.as_any_box().downcast::<DatastoreDiscoveredEvent>()?),
            StructType::DatastorePrincipalConfigured => Ok(from.as_any_box().downcast::<DatastorePrincipalConfigured>()?),
            StructType::DatastoreRemovedOnHostEvent => Ok(from.as_any_box().downcast::<DatastoreRemovedOnHostEvent>()?),
            StructType::DatastoreRenamedOnHostEvent => Ok(from.as_any_box().downcast::<DatastoreRenamedOnHostEvent>()?),
            StructType::DrsResourceConfigureFailedEvent => Ok(from.as_any_box().downcast::<DrsResourceConfigureFailedEvent>()?),
            StructType::DrsResourceConfigureSyncedEvent => Ok(from.as_any_box().downcast::<DrsResourceConfigureSyncedEvent>()?),
            StructType::DuplicateIpDetectedEvent => Ok(from.as_any_box().downcast::<DuplicateIpDetectedEvent>()?),
            StructType::DvsHealthStatusChangeEvent => Ok(from.as_any_box().downcast::<DvsHealthStatusChangeEvent>()?),
            StructType::MtuMatchEvent => Ok(from.as_any_box().downcast::<MtuMatchEvent>()?),
            StructType::MtuMismatchEvent => Ok(from.as_any_box().downcast::<MtuMismatchEvent>()?),
            StructType::TeamingMatchEvent => Ok(from.as_any_box().downcast::<TeamingMatchEvent>()?),
            StructType::TeamingMisMatchEvent => Ok(from.as_any_box().downcast::<TeamingMisMatchEvent>()?),
            StructType::UplinkPortMtuNotSupportEvent => Ok(from.as_any_box().downcast::<UplinkPortMtuNotSupportEvent>()?),
            StructType::UplinkPortMtuSupportEvent => Ok(from.as_any_box().downcast::<UplinkPortMtuSupportEvent>()?),
            StructType::UplinkPortVlanTrunkedEvent => Ok(from.as_any_box().downcast::<UplinkPortVlanTrunkedEvent>()?),
            StructType::UplinkPortVlanUntrunkedEvent => Ok(from.as_any_box().downcast::<UplinkPortVlanUntrunkedEvent>()?),
            StructType::EnteredMaintenanceModeEvent => Ok(from.as_any_box().downcast::<EnteredMaintenanceModeEvent>()?),
            StructType::EnteredStandbyModeEvent => Ok(from.as_any_box().downcast::<EnteredStandbyModeEvent>()?),
            StructType::DrsEnteredStandbyModeEvent => Ok(from.as_any_box().downcast::<DrsEnteredStandbyModeEvent>()?),
            StructType::EnteringMaintenanceModeEvent => Ok(from.as_any_box().downcast::<EnteringMaintenanceModeEvent>()?),
            StructType::EnteringStandbyModeEvent => Ok(from.as_any_box().downcast::<EnteringStandbyModeEvent>()?),
            StructType::DrsEnteringStandbyModeEvent => Ok(from.as_any_box().downcast::<DrsEnteringStandbyModeEvent>()?),
            StructType::ExitMaintenanceModeEvent => Ok(from.as_any_box().downcast::<ExitMaintenanceModeEvent>()?),
            StructType::ExitStandbyModeFailedEvent => Ok(from.as_any_box().downcast::<ExitStandbyModeFailedEvent>()?),
            StructType::DrsExitStandbyModeFailedEvent => Ok(from.as_any_box().downcast::<DrsExitStandbyModeFailedEvent>()?),
            StructType::ExitedStandbyModeEvent => Ok(from.as_any_box().downcast::<ExitedStandbyModeEvent>()?),
            StructType::DrsExitedStandbyModeEvent => Ok(from.as_any_box().downcast::<DrsExitedStandbyModeEvent>()?),
            StructType::ExitingStandbyModeEvent => Ok(from.as_any_box().downcast::<ExitingStandbyModeEvent>()?),
            StructType::DrsExitingStandbyModeEvent => Ok(from.as_any_box().downcast::<DrsExitingStandbyModeEvent>()?),
            StructType::GhostDvsProxySwitchDetectedEvent => Ok(from.as_any_box().downcast::<GhostDvsProxySwitchDetectedEvent>()?),
            StructType::GhostDvsProxySwitchRemovedEvent => Ok(from.as_any_box().downcast::<GhostDvsProxySwitchRemovedEvent>()?),
            StructType::HostAddFailedEvent => Ok(from.as_any_box().downcast::<HostAddFailedEvent>()?),
            StructType::HostAddedEvent => Ok(from.as_any_box().downcast::<HostAddedEvent>()?),
            StructType::HostAdminDisableEvent => Ok(from.as_any_box().downcast::<HostAdminDisableEvent>()?),
            StructType::HostAdminEnableEvent => Ok(from.as_any_box().downcast::<HostAdminEnableEvent>()?),
            StructType::HostCnxFailedAccountFailedEvent => Ok(from.as_any_box().downcast::<HostCnxFailedAccountFailedEvent>()?),
            StructType::HostCnxFailedAlreadyManagedEvent => Ok(from.as_any_box().downcast::<HostCnxFailedAlreadyManagedEvent>()?),
            StructType::HostCnxFailedBadCcagentEvent => Ok(from.as_any_box().downcast::<HostCnxFailedBadCcagentEvent>()?),
            StructType::HostCnxFailedBadUsernameEvent => Ok(from.as_any_box().downcast::<HostCnxFailedBadUsernameEvent>()?),
            StructType::HostCnxFailedBadVersionEvent => Ok(from.as_any_box().downcast::<HostCnxFailedBadVersionEvent>()?),
            StructType::HostCnxFailedCcagentUpgradeEvent => Ok(from.as_any_box().downcast::<HostCnxFailedCcagentUpgradeEvent>()?),
            StructType::HostCnxFailedEvent => Ok(from.as_any_box().downcast::<HostCnxFailedEvent>()?),
            StructType::HostCnxFailedNetworkErrorEvent => Ok(from.as_any_box().downcast::<HostCnxFailedNetworkErrorEvent>()?),
            StructType::HostCnxFailedNoAccessEvent => Ok(from.as_any_box().downcast::<HostCnxFailedNoAccessEvent>()?),
            StructType::HostCnxFailedNoConnectionEvent => Ok(from.as_any_box().downcast::<HostCnxFailedNoConnectionEvent>()?),
            StructType::HostCnxFailedNoLicenseEvent => Ok(from.as_any_box().downcast::<HostCnxFailedNoLicenseEvent>()?),
            StructType::HostCnxFailedNotFoundEvent => Ok(from.as_any_box().downcast::<HostCnxFailedNotFoundEvent>()?),
            StructType::HostCnxFailedTimeoutEvent => Ok(from.as_any_box().downcast::<HostCnxFailedTimeoutEvent>()?),
            StructType::HostComplianceCheckedEvent => Ok(from.as_any_box().downcast::<HostComplianceCheckedEvent>()?),
            StructType::HostCompliantEvent => Ok(from.as_any_box().downcast::<HostCompliantEvent>()?),
            StructType::HostConfigAppliedEvent => Ok(from.as_any_box().downcast::<HostConfigAppliedEvent>()?),
            StructType::HostConnectedEvent => Ok(from.as_any_box().downcast::<HostConnectedEvent>()?),
            StructType::HostConnectionLostEvent => Ok(from.as_any_box().downcast::<HostConnectionLostEvent>()?),
            StructType::HostDasDisabledEvent => Ok(from.as_any_box().downcast::<HostDasDisabledEvent>()?),
            StructType::HostDasDisablingEvent => Ok(from.as_any_box().downcast::<HostDasDisablingEvent>()?),
            StructType::HostDasEnabledEvent => Ok(from.as_any_box().downcast::<HostDasEnabledEvent>()?),
            StructType::HostDasEnablingEvent => Ok(from.as_any_box().downcast::<HostDasEnablingEvent>()?),
            StructType::HostDasErrorEvent => Ok(from.as_any_box().downcast::<HostDasErrorEvent>()?),
            StructType::HostDasEvent => Ok(from.as_any_box().downcast::<HostDasEvent>()?),
            StructType::HostExtraNetworksEvent => Ok(from.as_any_box().downcast::<HostExtraNetworksEvent>()?),
            StructType::HostIsolationIpPingFailedEvent => Ok(from.as_any_box().downcast::<HostIsolationIpPingFailedEvent>()?),
            StructType::HostMissingNetworksEvent => Ok(from.as_any_box().downcast::<HostMissingNetworksEvent>()?),
            StructType::HostNoAvailableNetworksEvent => Ok(from.as_any_box().downcast::<HostNoAvailableNetworksEvent>()?),
            StructType::HostNoHaEnabledPortGroupsEvent => Ok(from.as_any_box().downcast::<HostNoHaEnabledPortGroupsEvent>()?),
            StructType::HostNoRedundantManagementNetworkEvent => Ok(from.as_any_box().downcast::<HostNoRedundantManagementNetworkEvent>()?),
            StructType::HostNotInClusterEvent => Ok(from.as_any_box().downcast::<HostNotInClusterEvent>()?),
            StructType::HostPrimaryAgentNotShortNameEvent => Ok(from.as_any_box().downcast::<HostPrimaryAgentNotShortNameEvent>()?),
            StructType::HostShortNameInconsistentEvent => Ok(from.as_any_box().downcast::<HostShortNameInconsistentEvent>()?),
            StructType::HostDasOkEvent => Ok(from.as_any_box().downcast::<HostDasOkEvent>()?),
            StructType::HostDisconnectedEvent => Ok(from.as_any_box().downcast::<HostDisconnectedEvent>()?),
            StructType::HostEnableAdminFailedEvent => Ok(from.as_any_box().downcast::<HostEnableAdminFailedEvent>()?),
            StructType::HostGetShortNameFailedEvent => Ok(from.as_any_box().downcast::<HostGetShortNameFailedEvent>()?),
            StructType::HostInAuditModeEvent => Ok(from.as_any_box().downcast::<HostInAuditModeEvent>()?),
            StructType::HostIpChangedEvent => Ok(from.as_any_box().downcast::<HostIpChangedEvent>()?),
            StructType::HostIpInconsistentEvent => Ok(from.as_any_box().downcast::<HostIpInconsistentEvent>()?),
            StructType::HostIpToShortNameFailedEvent => Ok(from.as_any_box().downcast::<HostIpToShortNameFailedEvent>()?),
            StructType::HostNonCompliantEvent => Ok(from.as_any_box().downcast::<HostNonCompliantEvent>()?),
            StructType::HostProfileAppliedEvent => Ok(from.as_any_box().downcast::<HostProfileAppliedEvent>()?),
            StructType::HostReconnectionFailedEvent => Ok(from.as_any_box().downcast::<HostReconnectionFailedEvent>()?),
            StructType::HostRemovedEvent => Ok(from.as_any_box().downcast::<HostRemovedEvent>()?),
            StructType::HostShortNameToIpFailedEvent => Ok(from.as_any_box().downcast::<HostShortNameToIpFailedEvent>()?),
            StructType::HostShutdownEvent => Ok(from.as_any_box().downcast::<HostShutdownEvent>()?),
            StructType::HostSpecificationChangedEvent => Ok(from.as_any_box().downcast::<HostSpecificationChangedEvent>()?),
            StructType::HostSpecificationRequireEvent => Ok(from.as_any_box().downcast::<HostSpecificationRequireEvent>()?),
            StructType::HostSpecificationUpdateEvent => Ok(from.as_any_box().downcast::<HostSpecificationUpdateEvent>()?),
            StructType::HostSubSpecificationDeleteEvent => Ok(from.as_any_box().downcast::<HostSubSpecificationDeleteEvent>()?),
            StructType::HostSubSpecificationUpdateEvent => Ok(from.as_any_box().downcast::<HostSubSpecificationUpdateEvent>()?),
            StructType::HostSyncFailedEvent => Ok(from.as_any_box().downcast::<HostSyncFailedEvent>()?),
            StructType::HostUpgradeFailedEvent => Ok(from.as_any_box().downcast::<HostUpgradeFailedEvent>()?),
            StructType::HostUserWorldSwapNotEnabledEvent => Ok(from.as_any_box().downcast::<HostUserWorldSwapNotEnabledEvent>()?),
            StructType::HostVnicConnectedToCustomizedDvPortEvent => Ok(from.as_any_box().downcast::<HostVnicConnectedToCustomizedDvPortEvent>()?),
            StructType::HostWwnChangedEvent => Ok(from.as_any_box().downcast::<HostWwnChangedEvent>()?),
            StructType::HostWwnConflictEvent => Ok(from.as_any_box().downcast::<HostWwnConflictEvent>()?),
            StructType::LocalDatastoreCreatedEvent => Ok(from.as_any_box().downcast::<LocalDatastoreCreatedEvent>()?),
            StructType::LocalTsmEnabledEvent => Ok(from.as_any_box().downcast::<LocalTsmEnabledEvent>()?),
            StructType::NasDatastoreCreatedEvent => Ok(from.as_any_box().downcast::<NasDatastoreCreatedEvent>()?),
            StructType::NoDatastoresConfiguredEvent => Ok(from.as_any_box().downcast::<NoDatastoresConfiguredEvent>()?),
            StructType::RemoteTsmEnabledEvent => Ok(from.as_any_box().downcast::<RemoteTsmEnabledEvent>()?),
            StructType::TimedOutHostOperationEvent => Ok(from.as_any_box().downcast::<TimedOutHostOperationEvent>()?),
            StructType::UpdatedAgentBeingRestartedEvent => Ok(from.as_any_box().downcast::<UpdatedAgentBeingRestartedEvent>()?),
            StructType::UserAssignedToGroup => Ok(from.as_any_box().downcast::<UserAssignedToGroup>()?),
            StructType::UserPasswordChanged => Ok(from.as_any_box().downcast::<UserPasswordChanged>()?),
            StructType::UserUnassignedFromGroup => Ok(from.as_any_box().downcast::<UserUnassignedFromGroup>()?),
            StructType::VmfsDatastoreCreatedEvent => Ok(from.as_any_box().downcast::<VmfsDatastoreCreatedEvent>()?),
            StructType::VmfsDatastoreExpandedEvent => Ok(from.as_any_box().downcast::<VmfsDatastoreExpandedEvent>()?),
            StructType::VmfsDatastoreExtendedEvent => Ok(from.as_any_box().downcast::<VmfsDatastoreExtendedEvent>()?),
            StructType::VcAgentUninstallFailedEvent => Ok(from.as_any_box().downcast::<VcAgentUninstallFailedEvent>()?),
            StructType::VcAgentUninstalledEvent => Ok(from.as_any_box().downcast::<VcAgentUninstalledEvent>()?),
            StructType::VcAgentUpgradeFailedEvent => Ok(from.as_any_box().downcast::<VcAgentUpgradeFailedEvent>()?),
            StructType::VcAgentUpgradedEvent => Ok(from.as_any_box().downcast::<VcAgentUpgradedEvent>()?),
            StructType::VimAccountPasswordChangedEvent => Ok(from.as_any_box().downcast::<VimAccountPasswordChangedEvent>()?),
            StructType::IScsiBootFailureEvent => Ok(from.as_any_box().downcast::<IScsiBootFailureEvent>()?),
            StructType::HostInventoryUnreadableEvent => Ok(from.as_any_box().downcast::<HostInventoryUnreadableEvent>()?),
            StructType::LicenseEvent => Ok(from.as_any_box().downcast::<LicenseEvent>()?),
            StructType::AllVirtualMachinesLicensedEvent => Ok(from.as_any_box().downcast::<AllVirtualMachinesLicensedEvent>()?),
            StructType::HostInventoryFullEvent => Ok(from.as_any_box().downcast::<HostInventoryFullEvent>()?),
            StructType::HostLicenseExpiredEvent => Ok(from.as_any_box().downcast::<HostLicenseExpiredEvent>()?),
            StructType::IncorrectHostInformationEvent => Ok(from.as_any_box().downcast::<IncorrectHostInformationEvent>()?),
            StructType::InvalidEditionEvent => Ok(from.as_any_box().downcast::<InvalidEditionEvent>()?),
            StructType::LicenseNonComplianceEvent => Ok(from.as_any_box().downcast::<LicenseNonComplianceEvent>()?),
            StructType::LicenseRestrictedEvent => Ok(from.as_any_box().downcast::<LicenseRestrictedEvent>()?),
            StructType::LicenseServerAvailableEvent => Ok(from.as_any_box().downcast::<LicenseServerAvailableEvent>()?),
            StructType::LicenseServerUnavailableEvent => Ok(from.as_any_box().downcast::<LicenseServerUnavailableEvent>()?),
            StructType::NoLicenseEvent => Ok(from.as_any_box().downcast::<NoLicenseEvent>()?),
            StructType::ServerLicenseExpiredEvent => Ok(from.as_any_box().downcast::<ServerLicenseExpiredEvent>()?),
            StructType::UnlicensedVirtualMachinesEvent => Ok(from.as_any_box().downcast::<UnlicensedVirtualMachinesEvent>()?),
            StructType::UnlicensedVirtualMachinesFoundEvent => Ok(from.as_any_box().downcast::<UnlicensedVirtualMachinesFoundEvent>()?),
            StructType::VMotionLicenseExpiredEvent => Ok(from.as_any_box().downcast::<VMotionLicenseExpiredEvent>()?),
            StructType::LicenseExpiredEvent => Ok(from.as_any_box().downcast::<LicenseExpiredEvent>()?),
            StructType::LockerMisconfiguredEvent => Ok(from.as_any_box().downcast::<LockerMisconfiguredEvent>()?),
            StructType::LockerReconfiguredEvent => Ok(from.as_any_box().downcast::<LockerReconfiguredEvent>()?),
            StructType::NetworkRollbackEvent => Ok(from.as_any_box().downcast::<NetworkRollbackEvent>()?),
            StructType::ProfileEvent => Ok(from.as_any_box().downcast::<ProfileEvent>()?),
            StructType::ProfileAssociatedEvent => Ok(from.as_any_box().downcast::<ProfileAssociatedEvent>()?),
            StructType::ProfileChangedEvent => Ok(from.as_any_box().downcast::<ProfileChangedEvent>()?),
            StructType::ProfileCreatedEvent => Ok(from.as_any_box().downcast::<ProfileCreatedEvent>()?),
            StructType::ProfileDissociatedEvent => Ok(from.as_any_box().downcast::<ProfileDissociatedEvent>()?),
            StructType::ProfileReferenceHostChangedEvent => Ok(from.as_any_box().downcast::<ProfileReferenceHostChangedEvent>()?),
            StructType::ProfileRemovedEvent => Ok(from.as_any_box().downcast::<ProfileRemovedEvent>()?),
            StructType::ResourcePoolEvent => Ok(from.as_any_box().downcast::<ResourcePoolEvent>()?),
            StructType::ResourcePoolCreatedEvent => Ok(from.as_any_box().downcast::<ResourcePoolCreatedEvent>()?),
            StructType::ResourcePoolDestroyedEvent => Ok(from.as_any_box().downcast::<ResourcePoolDestroyedEvent>()?),
            StructType::ResourcePoolMovedEvent => Ok(from.as_any_box().downcast::<ResourcePoolMovedEvent>()?),
            StructType::ResourcePoolReconfiguredEvent => Ok(from.as_any_box().downcast::<ResourcePoolReconfiguredEvent>()?),
            StructType::ResourceViolatedEvent => Ok(from.as_any_box().downcast::<ResourceViolatedEvent>()?),
            StructType::ScheduledTaskEvent => Ok(from.as_any_box().downcast::<ScheduledTaskEvent>()?),
            StructType::ScheduledTaskCompletedEvent => Ok(from.as_any_box().downcast::<ScheduledTaskCompletedEvent>()?),
            StructType::ScheduledTaskCreatedEvent => Ok(from.as_any_box().downcast::<ScheduledTaskCreatedEvent>()?),
            StructType::ScheduledTaskEmailCompletedEvent => Ok(from.as_any_box().downcast::<ScheduledTaskEmailCompletedEvent>()?),
            StructType::ScheduledTaskEmailFailedEvent => Ok(from.as_any_box().downcast::<ScheduledTaskEmailFailedEvent>()?),
            StructType::ScheduledTaskFailedEvent => Ok(from.as_any_box().downcast::<ScheduledTaskFailedEvent>()?),
            StructType::ScheduledTaskReconfiguredEvent => Ok(from.as_any_box().downcast::<ScheduledTaskReconfiguredEvent>()?),
            StructType::ScheduledTaskRemovedEvent => Ok(from.as_any_box().downcast::<ScheduledTaskRemovedEvent>()?),
            StructType::ScheduledTaskStartedEvent => Ok(from.as_any_box().downcast::<ScheduledTaskStartedEvent>()?),
            StructType::SessionEvent => Ok(from.as_any_box().downcast::<SessionEvent>()?),
            StructType::AlreadyAuthenticatedSessionEvent => Ok(from.as_any_box().downcast::<AlreadyAuthenticatedSessionEvent>()?),
            StructType::BadUsernameSessionEvent => Ok(from.as_any_box().downcast::<BadUsernameSessionEvent>()?),
            StructType::GlobalMessageChangedEvent => Ok(from.as_any_box().downcast::<GlobalMessageChangedEvent>()?),
            StructType::NoAccessUserEvent => Ok(from.as_any_box().downcast::<NoAccessUserEvent>()?),
            StructType::ServerStartedSessionEvent => Ok(from.as_any_box().downcast::<ServerStartedSessionEvent>()?),
            StructType::SessionTerminatedEvent => Ok(from.as_any_box().downcast::<SessionTerminatedEvent>()?),
            StructType::UserLoginSessionEvent => Ok(from.as_any_box().downcast::<UserLoginSessionEvent>()?),
            StructType::UserLogoutSessionEvent => Ok(from.as_any_box().downcast::<UserLogoutSessionEvent>()?),
            StructType::TaskEvent => Ok(from.as_any_box().downcast::<TaskEvent>()?),
            StructType::TaskTimeoutEvent => Ok(from.as_any_box().downcast::<TaskTimeoutEvent>()?),
            StructType::TemplateUpgradeEvent => Ok(from.as_any_box().downcast::<TemplateUpgradeEvent>()?),
            StructType::TemplateBeingUpgradedEvent => Ok(from.as_any_box().downcast::<TemplateBeingUpgradedEvent>()?),
            StructType::TemplateUpgradeFailedEvent => Ok(from.as_any_box().downcast::<TemplateUpgradeFailedEvent>()?),
            StructType::TemplateUpgradedEvent => Ok(from.as_any_box().downcast::<TemplateUpgradedEvent>()?),
            StructType::UpgradeEvent => Ok(from.as_any_box().downcast::<UpgradeEvent>()?),
            StructType::ErrorUpgradeEvent => Ok(from.as_any_box().downcast::<ErrorUpgradeEvent>()?),
            StructType::InfoUpgradeEvent => Ok(from.as_any_box().downcast::<InfoUpgradeEvent>()?),
            StructType::UserUpgradeEvent => Ok(from.as_any_box().downcast::<UserUpgradeEvent>()?),
            StructType::WarningUpgradeEvent => Ok(from.as_any_box().downcast::<WarningUpgradeEvent>()?),
            StructType::VmEvent => Ok(from.as_any_box().downcast::<VmEvent>()?),
            StructType::CustomizationEvent => Ok(from.as_any_box().downcast::<CustomizationEvent>()?),
            StructType::CustomizationFailed => Ok(from.as_any_box().downcast::<CustomizationFailed>()?),
            StructType::CustomizationLinuxIdentityFailed => Ok(from.as_any_box().downcast::<CustomizationLinuxIdentityFailed>()?),
            StructType::CustomizationNetworkSetupFailed => Ok(from.as_any_box().downcast::<CustomizationNetworkSetupFailed>()?),
            StructType::CustomizationSysprepFailed => Ok(from.as_any_box().downcast::<CustomizationSysprepFailed>()?),
            StructType::CustomizationUnknownFailure => Ok(from.as_any_box().downcast::<CustomizationUnknownFailure>()?),
            StructType::CustomizationStartedEvent => Ok(from.as_any_box().downcast::<CustomizationStartedEvent>()?),
            StructType::CustomizationSucceeded => Ok(from.as_any_box().downcast::<CustomizationSucceeded>()?),
            StructType::DrsRuleComplianceEvent => Ok(from.as_any_box().downcast::<DrsRuleComplianceEvent>()?),
            StructType::DrsRuleViolationEvent => Ok(from.as_any_box().downcast::<DrsRuleViolationEvent>()?),
            StructType::DrsSoftRuleViolationEvent => Ok(from.as_any_box().downcast::<DrsSoftRuleViolationEvent>()?),
            StructType::MigrationEvent => Ok(from.as_any_box().downcast::<MigrationEvent>()?),
            StructType::MigrationErrorEvent => Ok(from.as_any_box().downcast::<MigrationErrorEvent>()?),
            StructType::MigrationHostErrorEvent => Ok(from.as_any_box().downcast::<MigrationHostErrorEvent>()?),
            StructType::MigrationHostWarningEvent => Ok(from.as_any_box().downcast::<MigrationHostWarningEvent>()?),
            StructType::MigrationResourceErrorEvent => Ok(from.as_any_box().downcast::<MigrationResourceErrorEvent>()?),
            StructType::MigrationResourceWarningEvent => Ok(from.as_any_box().downcast::<MigrationResourceWarningEvent>()?),
            StructType::MigrationWarningEvent => Ok(from.as_any_box().downcast::<MigrationWarningEvent>()?),
            StructType::NoMaintenanceModeDrsRecommendationForVm => Ok(from.as_any_box().downcast::<NoMaintenanceModeDrsRecommendationForVm>()?),
            StructType::NotEnoughResourcesToStartVmEvent => Ok(from.as_any_box().downcast::<NotEnoughResourcesToStartVmEvent>()?),
            StructType::VmAcquiredMksTicketEvent => Ok(from.as_any_box().downcast::<VmAcquiredMksTicketEvent>()?),
            StructType::VmAcquiredTicketEvent => Ok(from.as_any_box().downcast::<VmAcquiredTicketEvent>()?),
            StructType::VmAutoRenameEvent => Ok(from.as_any_box().downcast::<VmAutoRenameEvent>()?),
            StructType::VmBeingCreatedEvent => Ok(from.as_any_box().downcast::<VmBeingCreatedEvent>()?),
            StructType::VmBeingDeployedEvent => Ok(from.as_any_box().downcast::<VmBeingDeployedEvent>()?),
            StructType::VmBeingHotMigratedEvent => Ok(from.as_any_box().downcast::<VmBeingHotMigratedEvent>()?),
            StructType::VmBeingMigratedEvent => Ok(from.as_any_box().downcast::<VmBeingMigratedEvent>()?),
            StructType::VmCloneEvent => Ok(from.as_any_box().downcast::<VmCloneEvent>()?),
            StructType::VmBeingClonedEvent => Ok(from.as_any_box().downcast::<VmBeingClonedEvent>()?),
            StructType::VmBeingClonedNoFolderEvent => Ok(from.as_any_box().downcast::<VmBeingClonedNoFolderEvent>()?),
            StructType::VmCloneFailedEvent => Ok(from.as_any_box().downcast::<VmCloneFailedEvent>()?),
            StructType::VmClonedEvent => Ok(from.as_any_box().downcast::<VmClonedEvent>()?),
            StructType::VmConfigMissingEvent => Ok(from.as_any_box().downcast::<VmConfigMissingEvent>()?),
            StructType::VmConnectedEvent => Ok(from.as_any_box().downcast::<VmConnectedEvent>()?),
            StructType::VmCreatedEvent => Ok(from.as_any_box().downcast::<VmCreatedEvent>()?),
            StructType::VmDasBeingResetEvent => Ok(from.as_any_box().downcast::<VmDasBeingResetEvent>()?),
            StructType::VmDasBeingResetWithScreenshotEvent => Ok(from.as_any_box().downcast::<VmDasBeingResetWithScreenshotEvent>()?),
            StructType::VmDasResetFailedEvent => Ok(from.as_any_box().downcast::<VmDasResetFailedEvent>()?),
            StructType::VmDasUpdateErrorEvent => Ok(from.as_any_box().downcast::<VmDasUpdateErrorEvent>()?),
            StructType::VmDasUpdateOkEvent => Ok(from.as_any_box().downcast::<VmDasUpdateOkEvent>()?),
            StructType::VmDateRolledBackEvent => Ok(from.as_any_box().downcast::<VmDateRolledBackEvent>()?),
            StructType::VmDeployFailedEvent => Ok(from.as_any_box().downcast::<VmDeployFailedEvent>()?),
            StructType::VmDeployedEvent => Ok(from.as_any_box().downcast::<VmDeployedEvent>()?),
            StructType::VmDisconnectedEvent => Ok(from.as_any_box().downcast::<VmDisconnectedEvent>()?),
            StructType::VmDiscoveredEvent => Ok(from.as_any_box().downcast::<VmDiscoveredEvent>()?),
            StructType::VmDiskFailedEvent => Ok(from.as_any_box().downcast::<VmDiskFailedEvent>()?),
            StructType::VmEmigratingEvent => Ok(from.as_any_box().downcast::<VmEmigratingEvent>()?),
            StructType::VmEndRecordingEvent => Ok(from.as_any_box().downcast::<VmEndRecordingEvent>()?),
            StructType::VmEndReplayingEvent => Ok(from.as_any_box().downcast::<VmEndReplayingEvent>()?),
            StructType::VmFailedMigrateEvent => Ok(from.as_any_box().downcast::<VmFailedMigrateEvent>()?),
            StructType::VmFailedRelayoutEvent => Ok(from.as_any_box().downcast::<VmFailedRelayoutEvent>()?),
            StructType::VmFailedRelayoutOnVmfs2DatastoreEvent => Ok(from.as_any_box().downcast::<VmFailedRelayoutOnVmfs2DatastoreEvent>()?),
            StructType::VmFailedStartingSecondaryEvent => Ok(from.as_any_box().downcast::<VmFailedStartingSecondaryEvent>()?),
            StructType::VmFailedToPowerOffEvent => Ok(from.as_any_box().downcast::<VmFailedToPowerOffEvent>()?),
            StructType::VmFailedToPowerOnEvent => Ok(from.as_any_box().downcast::<VmFailedToPowerOnEvent>()?),
            StructType::VmFailedToRebootGuestEvent => Ok(from.as_any_box().downcast::<VmFailedToRebootGuestEvent>()?),
            StructType::VmFailedToResetEvent => Ok(from.as_any_box().downcast::<VmFailedToResetEvent>()?),
            StructType::VmFailedToShutdownGuestEvent => Ok(from.as_any_box().downcast::<VmFailedToShutdownGuestEvent>()?),
            StructType::VmFailedToStandbyGuestEvent => Ok(from.as_any_box().downcast::<VmFailedToStandbyGuestEvent>()?),
            StructType::VmFailedToSuspendEvent => Ok(from.as_any_box().downcast::<VmFailedToSuspendEvent>()?),
            StructType::VmFailedUpdatingSecondaryConfig => Ok(from.as_any_box().downcast::<VmFailedUpdatingSecondaryConfig>()?),
            StructType::VmFailoverFailed => Ok(from.as_any_box().downcast::<VmFailoverFailed>()?),
            StructType::VmFaultToleranceStateChangedEvent => Ok(from.as_any_box().downcast::<VmFaultToleranceStateChangedEvent>()?),
            StructType::VmFaultToleranceTurnedOffEvent => Ok(from.as_any_box().downcast::<VmFaultToleranceTurnedOffEvent>()?),
            StructType::VmFaultToleranceVmTerminatedEvent => Ok(from.as_any_box().downcast::<VmFaultToleranceVmTerminatedEvent>()?),
            StructType::VmGuestOsCrashedEvent => Ok(from.as_any_box().downcast::<VmGuestOsCrashedEvent>()?),
            StructType::VmGuestRebootEvent => Ok(from.as_any_box().downcast::<VmGuestRebootEvent>()?),
            StructType::VmGuestShutdownEvent => Ok(from.as_any_box().downcast::<VmGuestShutdownEvent>()?),
            StructType::VmGuestStandbyEvent => Ok(from.as_any_box().downcast::<VmGuestStandbyEvent>()?),
            StructType::VmInstanceUuidAssignedEvent => Ok(from.as_any_box().downcast::<VmInstanceUuidAssignedEvent>()?),
            StructType::VmInstanceUuidChangedEvent => Ok(from.as_any_box().downcast::<VmInstanceUuidChangedEvent>()?),
            StructType::VmInstanceUuidConflictEvent => Ok(from.as_any_box().downcast::<VmInstanceUuidConflictEvent>()?),
            StructType::VmMacAssignedEvent => Ok(from.as_any_box().downcast::<VmMacAssignedEvent>()?),
            StructType::VmMacChangedEvent => Ok(from.as_any_box().downcast::<VmMacChangedEvent>()?),
            StructType::VmMacConflictEvent => Ok(from.as_any_box().downcast::<VmMacConflictEvent>()?),
            StructType::VmMaxFtRestartCountReached => Ok(from.as_any_box().downcast::<VmMaxFtRestartCountReached>()?),
            StructType::VmMaxRestartCountReached => Ok(from.as_any_box().downcast::<VmMaxRestartCountReached>()?),
            StructType::VmMessageErrorEvent => Ok(from.as_any_box().downcast::<VmMessageErrorEvent>()?),
            StructType::VmMessageEvent => Ok(from.as_any_box().downcast::<VmMessageEvent>()?),
            StructType::VmMessageWarningEvent => Ok(from.as_any_box().downcast::<VmMessageWarningEvent>()?),
            StructType::VmMigratedEvent => Ok(from.as_any_box().downcast::<VmMigratedEvent>()?),
            StructType::DrsVmMigratedEvent => Ok(from.as_any_box().downcast::<DrsVmMigratedEvent>()?),
            StructType::VmNoCompatibleHostForSecondaryEvent => Ok(from.as_any_box().downcast::<VmNoCompatibleHostForSecondaryEvent>()?),
            StructType::VmNoNetworkAccessEvent => Ok(from.as_any_box().downcast::<VmNoNetworkAccessEvent>()?),
            StructType::VmOrphanedEvent => Ok(from.as_any_box().downcast::<VmOrphanedEvent>()?),
            StructType::VmPoweredOffEvent => Ok(from.as_any_box().downcast::<VmPoweredOffEvent>()?),
            StructType::VmPowerOffOnIsolationEvent => Ok(from.as_any_box().downcast::<VmPowerOffOnIsolationEvent>()?),
            StructType::VmShutdownOnIsolationEvent => Ok(from.as_any_box().downcast::<VmShutdownOnIsolationEvent>()?),
            StructType::VmPoweredOnEvent => Ok(from.as_any_box().downcast::<VmPoweredOnEvent>()?),
            StructType::DrsVmPoweredOnEvent => Ok(from.as_any_box().downcast::<DrsVmPoweredOnEvent>()?),
            StructType::VmRestartedOnAlternateHostEvent => Ok(from.as_any_box().downcast::<VmRestartedOnAlternateHostEvent>()?),
            StructType::VmPoweringOnWithCustomizedDvPortEvent => Ok(from.as_any_box().downcast::<VmPoweringOnWithCustomizedDvPortEvent>()?),
            StructType::VmPrimaryFailoverEvent => Ok(from.as_any_box().downcast::<VmPrimaryFailoverEvent>()?),
            StructType::VmReconfiguredEvent => Ok(from.as_any_box().downcast::<VmReconfiguredEvent>()?),
            StructType::VmRegisteredEvent => Ok(from.as_any_box().downcast::<VmRegisteredEvent>()?),
            StructType::VmRelayoutSuccessfulEvent => Ok(from.as_any_box().downcast::<VmRelayoutSuccessfulEvent>()?),
            StructType::VmRelayoutUpToDateEvent => Ok(from.as_any_box().downcast::<VmRelayoutUpToDateEvent>()?),
            StructType::VmReloadFromPathEvent => Ok(from.as_any_box().downcast::<VmReloadFromPathEvent>()?),
            StructType::VmReloadFromPathFailedEvent => Ok(from.as_any_box().downcast::<VmReloadFromPathFailedEvent>()?),
            StructType::VmRelocateSpecEvent => Ok(from.as_any_box().downcast::<VmRelocateSpecEvent>()?),
            StructType::VmBeingRelocatedEvent => Ok(from.as_any_box().downcast::<VmBeingRelocatedEvent>()?),
            StructType::VmRelocateFailedEvent => Ok(from.as_any_box().downcast::<VmRelocateFailedEvent>()?),
            StructType::VmRelocatedEvent => Ok(from.as_any_box().downcast::<VmRelocatedEvent>()?),
            StructType::VmRemoteConsoleConnectedEvent => Ok(from.as_any_box().downcast::<VmRemoteConsoleConnectedEvent>()?),
            StructType::VmRemoteConsoleDisconnectedEvent => Ok(from.as_any_box().downcast::<VmRemoteConsoleDisconnectedEvent>()?),
            StructType::VmRemovedEvent => Ok(from.as_any_box().downcast::<VmRemovedEvent>()?),
            StructType::VmRenamedEvent => Ok(from.as_any_box().downcast::<VmRenamedEvent>()?),
            StructType::VmRequirementsExceedCurrentEvcModeEvent => Ok(from.as_any_box().downcast::<VmRequirementsExceedCurrentEvcModeEvent>()?),
            StructType::VmResettingEvent => Ok(from.as_any_box().downcast::<VmResettingEvent>()?),
            StructType::VmResourcePoolMovedEvent => Ok(from.as_any_box().downcast::<VmResourcePoolMovedEvent>()?),
            StructType::VmResourceReallocatedEvent => Ok(from.as_any_box().downcast::<VmResourceReallocatedEvent>()?),
            StructType::VmResumingEvent => Ok(from.as_any_box().downcast::<VmResumingEvent>()?),
            StructType::VmSecondaryAddedEvent => Ok(from.as_any_box().downcast::<VmSecondaryAddedEvent>()?),
            StructType::VmSecondaryDisabledBySystemEvent => Ok(from.as_any_box().downcast::<VmSecondaryDisabledBySystemEvent>()?),
            StructType::VmSecondaryDisabledEvent => Ok(from.as_any_box().downcast::<VmSecondaryDisabledEvent>()?),
            StructType::VmSecondaryEnabledEvent => Ok(from.as_any_box().downcast::<VmSecondaryEnabledEvent>()?),
            StructType::VmSecondaryStartedEvent => Ok(from.as_any_box().downcast::<VmSecondaryStartedEvent>()?),
            StructType::VmStartRecordingEvent => Ok(from.as_any_box().downcast::<VmStartRecordingEvent>()?),
            StructType::VmStartReplayingEvent => Ok(from.as_any_box().downcast::<VmStartReplayingEvent>()?),
            StructType::VmStartingEvent => Ok(from.as_any_box().downcast::<VmStartingEvent>()?),
            StructType::VmUnsupportedStartingEvent => Ok(from.as_any_box().downcast::<VmUnsupportedStartingEvent>()?),
            StructType::VmStartingSecondaryEvent => Ok(from.as_any_box().downcast::<VmStartingSecondaryEvent>()?),
            StructType::VmStaticMacConflictEvent => Ok(from.as_any_box().downcast::<VmStaticMacConflictEvent>()?),
            StructType::VmStoppingEvent => Ok(from.as_any_box().downcast::<VmStoppingEvent>()?),
            StructType::VmSuspendedEvent => Ok(from.as_any_box().downcast::<VmSuspendedEvent>()?),
            StructType::VmSuspendingEvent => Ok(from.as_any_box().downcast::<VmSuspendingEvent>()?),
            StructType::VmTimedoutStartingSecondaryEvent => Ok(from.as_any_box().downcast::<VmTimedoutStartingSecondaryEvent>()?),
            StructType::VmUpgradeCompleteEvent => Ok(from.as_any_box().downcast::<VmUpgradeCompleteEvent>()?),
            StructType::VmUpgradeFailedEvent => Ok(from.as_any_box().downcast::<VmUpgradeFailedEvent>()?),
            StructType::VmUpgradingEvent => Ok(from.as_any_box().downcast::<VmUpgradingEvent>()?),
            StructType::VmUuidAssignedEvent => Ok(from.as_any_box().downcast::<VmUuidAssignedEvent>()?),
            StructType::VmUuidChangedEvent => Ok(from.as_any_box().downcast::<VmUuidChangedEvent>()?),
            StructType::VmUuidConflictEvent => Ok(from.as_any_box().downcast::<VmUuidConflictEvent>()?),
            StructType::VmWwnAssignedEvent => Ok(from.as_any_box().downcast::<VmWwnAssignedEvent>()?),
            StructType::VmWwnChangedEvent => Ok(from.as_any_box().downcast::<VmWwnChangedEvent>()?),
            StructType::VmWwnConflictEvent => Ok(from.as_any_box().downcast::<VmWwnConflictEvent>()?),
            StructType::EventArgument => Ok(from.as_any_box().downcast::<EventArgument>()?),
            StructType::EntityEventArgument => Ok(from.as_any_box().downcast::<EntityEventArgument>()?),
            StructType::AlarmEventArgument => Ok(from.as_any_box().downcast::<AlarmEventArgument>()?),
            StructType::ComputeResourceEventArgument => Ok(from.as_any_box().downcast::<ComputeResourceEventArgument>()?),
            StructType::DatacenterEventArgument => Ok(from.as_any_box().downcast::<DatacenterEventArgument>()?),
            StructType::DatastoreEventArgument => Ok(from.as_any_box().downcast::<DatastoreEventArgument>()?),
            StructType::DvsEventArgument => Ok(from.as_any_box().downcast::<DvsEventArgument>()?),
            StructType::FolderEventArgument => Ok(from.as_any_box().downcast::<FolderEventArgument>()?),
            StructType::HostEventArgument => Ok(from.as_any_box().downcast::<HostEventArgument>()?),
            StructType::ManagedEntityEventArgument => Ok(from.as_any_box().downcast::<ManagedEntityEventArgument>()?),
            StructType::NetworkEventArgument => Ok(from.as_any_box().downcast::<NetworkEventArgument>()?),
            StructType::ResourcePoolEventArgument => Ok(from.as_any_box().downcast::<ResourcePoolEventArgument>()?),
            StructType::ScheduledTaskEventArgument => Ok(from.as_any_box().downcast::<ScheduledTaskEventArgument>()?),
            StructType::VmEventArgument => Ok(from.as_any_box().downcast::<VmEventArgument>()?),
            StructType::ProfileEventArgument => Ok(from.as_any_box().downcast::<ProfileEventArgument>()?),
            StructType::RoleEventArgument => Ok(from.as_any_box().downcast::<RoleEventArgument>()?),
            StructType::EventDescription => Ok(from.as_any_box().downcast::<EventDescription>()?),
            StructType::EventArgDesc => Ok(from.as_any_box().downcast::<EventArgDesc>()?),
            StructType::EventDescriptionEventDetail => Ok(from.as_any_box().downcast::<EventDescriptionEventDetail>()?),
            StructType::EventFilterSpec => Ok(from.as_any_box().downcast::<EventFilterSpec>()?),
            StructType::EventFilterSpecByEntity => Ok(from.as_any_box().downcast::<EventFilterSpecByEntity>()?),
            StructType::EventFilterSpecByTime => Ok(from.as_any_box().downcast::<EventFilterSpecByTime>()?),
            StructType::EventFilterSpecByUsername => Ok(from.as_any_box().downcast::<EventFilterSpecByUsername>()?),
            StructType::ExtendedEventPair => Ok(from.as_any_box().downcast::<ExtendedEventPair>()?),
            StructType::VnicPortArgument => Ok(from.as_any_box().downcast::<VnicPortArgument>()?),
            StructType::ExtExtendedProductInfo => Ok(from.as_any_box().downcast::<ExtExtendedProductInfo>()?),
            StructType::ManagedByInfo => Ok(from.as_any_box().downcast::<ManagedByInfo>()?),
            StructType::ExtManagedEntityInfo => Ok(from.as_any_box().downcast::<ExtManagedEntityInfo>()?),
            StructType::ExtSolutionManagerInfo => Ok(from.as_any_box().downcast::<ExtSolutionManagerInfo>()?),
            StructType::ExtSolutionManagerInfoTabInfo => Ok(from.as_any_box().downcast::<ExtSolutionManagerInfoTabInfo>()?),
            StructType::AnswerFileUpdateFailure => Ok(from.as_any_box().downcast::<AnswerFileUpdateFailure>()?),
            StructType::ConflictingConfigurationConfig => Ok(from.as_any_box().downcast::<ConflictingConfigurationConfig>()?),
            StructType::DatacenterMismatchArgument => Ok(from.as_any_box().downcast::<DatacenterMismatchArgument>()?),
            StructType::DvsApplyOperationFaultFaultOnObject => Ok(from.as_any_box().downcast::<DvsApplyOperationFaultFaultOnObject>()?),
            StructType::DvsOperationBulkFaultFaultOnHost => Ok(from.as_any_box().downcast::<DvsOperationBulkFaultFaultOnHost>()?),
            StructType::ImportOperationBulkFaultFaultOnImport => Ok(from.as_any_box().downcast::<ImportOperationBulkFaultFaultOnImport>()?),
            StructType::MultipleCertificatesVerifyFaultThumbprintData => Ok(from.as_any_box().downcast::<MultipleCertificatesVerifyFaultThumbprintData>()?),
            StructType::NoPermissionEntityPrivileges => Ok(from.as_any_box().downcast::<NoPermissionEntityPrivileges>()?),
            StructType::ProfileUpdateFailedUpdateFailure => Ok(from.as_any_box().downcast::<ProfileUpdateFailedUpdateFailure>()?),
            StructType::HostActiveDirectory => Ok(from.as_any_box().downcast::<HostActiveDirectory>()?),
            StructType::HostActiveDirectorySpec => Ok(from.as_any_box().downcast::<HostActiveDirectorySpec>()?),
            StructType::HostAssignableHardwareBinding => Ok(from.as_any_box().downcast::<HostAssignableHardwareBinding>()?),
            StructType::HostAssignableHardwareConfig => Ok(from.as_any_box().downcast::<HostAssignableHardwareConfig>()?),
            StructType::HostAssignableHardwareConfigAttributeOverride => Ok(from.as_any_box().downcast::<HostAssignableHardwareConfigAttributeOverride>()?),
            StructType::HostAuthenticationManagerInfo => Ok(from.as_any_box().downcast::<HostAuthenticationManagerInfo>()?),
            StructType::HostAuthenticationStoreInfo => Ok(from.as_any_box().downcast::<HostAuthenticationStoreInfo>()?),
            StructType::HostDirectoryStoreInfo => Ok(from.as_any_box().downcast::<HostDirectoryStoreInfo>()?),
            StructType::HostActiveDirectoryInfo => Ok(from.as_any_box().downcast::<HostActiveDirectoryInfo>()?),
            StructType::HostLocalAuthenticationInfo => Ok(from.as_any_box().downcast::<HostLocalAuthenticationInfo>()?),
            StructType::AutoStartPowerInfo => Ok(from.as_any_box().downcast::<AutoStartPowerInfo>()?),
            StructType::HostAutoStartManagerConfig => Ok(from.as_any_box().downcast::<HostAutoStartManagerConfig>()?),
            StructType::AutoStartDefaults => Ok(from.as_any_box().downcast::<AutoStartDefaults>()?),
            StructType::HostBiosInfo => Ok(from.as_any_box().downcast::<HostBiosInfo>()?),
            StructType::HostBootDeviceInfo => Ok(from.as_any_box().downcast::<HostBootDeviceInfo>()?),
            StructType::HostBootDevice => Ok(from.as_any_box().downcast::<HostBootDevice>()?),
            StructType::HostCacheConfigurationInfo => Ok(from.as_any_box().downcast::<HostCacheConfigurationInfo>()?),
            StructType::HostCacheConfigurationSpec => Ok(from.as_any_box().downcast::<HostCacheConfigurationSpec>()?),
            StructType::HostCapability => Ok(from.as_any_box().downcast::<HostCapability>()?),
            StructType::HostCertificateManagerCertificateInfo => Ok(from.as_any_box().downcast::<HostCertificateManagerCertificateInfo>()?),
            StructType::HostCertificateManagerCertificateSpec => Ok(from.as_any_box().downcast::<HostCertificateManagerCertificateSpec>()?),
            StructType::HostConfigChange => Ok(from.as_any_box().downcast::<HostConfigChange>()?),
            StructType::HostConfigInfo => Ok(from.as_any_box().downcast::<HostConfigInfo>()?),
            StructType::HostConfigManager => Ok(from.as_any_box().downcast::<HostConfigManager>()?),
            StructType::HostConfigSpec => Ok(from.as_any_box().downcast::<HostConfigSpec>()?),
            StructType::HostConnectInfo => Ok(from.as_any_box().downcast::<HostConnectInfo>()?),
            StructType::HostDatastoreConnectInfo => Ok(from.as_any_box().downcast::<HostDatastoreConnectInfo>()?),
            StructType::HostDatastoreExistsConnectInfo => Ok(from.as_any_box().downcast::<HostDatastoreExistsConnectInfo>()?),
            StructType::HostDatastoreNameConflictConnectInfo => Ok(from.as_any_box().downcast::<HostDatastoreNameConflictConnectInfo>()?),
            StructType::HostLicenseConnectInfo => Ok(from.as_any_box().downcast::<HostLicenseConnectInfo>()?),
            StructType::HostConnectInfoNetworkInfo => Ok(from.as_any_box().downcast::<HostConnectInfoNetworkInfo>()?),
            StructType::HostNewNetworkConnectInfo => Ok(from.as_any_box().downcast::<HostNewNetworkConnectInfo>()?),
            StructType::HostConnectSpec => Ok(from.as_any_box().downcast::<HostConnectSpec>()?),
            StructType::HostCpuIdInfo => Ok(from.as_any_box().downcast::<HostCpuIdInfo>()?),
            StructType::HostCpuInfo => Ok(from.as_any_box().downcast::<HostCpuInfo>()?),
            StructType::HostCpuPackage => Ok(from.as_any_box().downcast::<HostCpuPackage>()?),
            StructType::HostCpuPowerManagementInfo => Ok(from.as_any_box().downcast::<HostCpuPowerManagementInfo>()?),
            StructType::HostHyperThreadScheduleInfo => Ok(from.as_any_box().downcast::<HostHyperThreadScheduleInfo>()?),
            StructType::HostDataTransportConnectionInfo => Ok(from.as_any_box().downcast::<HostDataTransportConnectionInfo>()?),
            StructType::HostNfcConnectionInfo => Ok(from.as_any_box().downcast::<HostNfcConnectionInfo>()?),
            StructType::FileInfo => Ok(from.as_any_box().downcast::<FileInfo>()?),
            StructType::FloppyImageFileInfo => Ok(from.as_any_box().downcast::<FloppyImageFileInfo>()?),
            StructType::FolderFileInfo => Ok(from.as_any_box().downcast::<FolderFileInfo>()?),
            StructType::IsoImageFileInfo => Ok(from.as_any_box().downcast::<IsoImageFileInfo>()?),
            StructType::VmConfigFileInfo => Ok(from.as_any_box().downcast::<VmConfigFileInfo>()?),
            StructType::TemplateConfigFileInfo => Ok(from.as_any_box().downcast::<TemplateConfigFileInfo>()?),
            StructType::VmDiskFileInfo => Ok(from.as_any_box().downcast::<VmDiskFileInfo>()?),
            StructType::VmLogFileInfo => Ok(from.as_any_box().downcast::<VmLogFileInfo>()?),
            StructType::VmNvramFileInfo => Ok(from.as_any_box().downcast::<VmNvramFileInfo>()?),
            StructType::VmSnapshotFileInfo => Ok(from.as_any_box().downcast::<VmSnapshotFileInfo>()?),
            StructType::FileQueryFlags => Ok(from.as_any_box().downcast::<FileQueryFlags>()?),
            StructType::FileQuery => Ok(from.as_any_box().downcast::<FileQuery>()?),
            StructType::FloppyImageFileQuery => Ok(from.as_any_box().downcast::<FloppyImageFileQuery>()?),
            StructType::FolderFileQuery => Ok(from.as_any_box().downcast::<FolderFileQuery>()?),
            StructType::IsoImageFileQuery => Ok(from.as_any_box().downcast::<IsoImageFileQuery>()?),
            StructType::VmConfigFileQuery => Ok(from.as_any_box().downcast::<VmConfigFileQuery>()?),
            StructType::TemplateConfigFileQuery => Ok(from.as_any_box().downcast::<TemplateConfigFileQuery>()?),
            StructType::VmDiskFileQuery => Ok(from.as_any_box().downcast::<VmDiskFileQuery>()?),
            StructType::VmLogFileQuery => Ok(from.as_any_box().downcast::<VmLogFileQuery>()?),
            StructType::VmNvramFileQuery => Ok(from.as_any_box().downcast::<VmNvramFileQuery>()?),
            StructType::VmSnapshotFileQuery => Ok(from.as_any_box().downcast::<VmSnapshotFileQuery>()?),
            StructType::HostDatastoreBrowserSearchResults => Ok(from.as_any_box().downcast::<HostDatastoreBrowserSearchResults>()?),
            StructType::HostDatastoreBrowserSearchSpec => Ok(from.as_any_box().downcast::<HostDatastoreBrowserSearchSpec>()?),
            StructType::VmConfigFileEncryptionInfo => Ok(from.as_any_box().downcast::<VmConfigFileEncryptionInfo>()?),
            StructType::VmConfigFileQueryFlags => Ok(from.as_any_box().downcast::<VmConfigFileQueryFlags>()?),
            StructType::VmConfigFileQueryFilter => Ok(from.as_any_box().downcast::<VmConfigFileQueryFilter>()?),
            StructType::VmDiskFileEncryptionInfo => Ok(from.as_any_box().downcast::<VmDiskFileEncryptionInfo>()?),
            StructType::VmDiskFileQueryFlags => Ok(from.as_any_box().downcast::<VmDiskFileQueryFlags>()?),
            StructType::VmDiskFileQueryFilter => Ok(from.as_any_box().downcast::<VmDiskFileQueryFilter>()?),
            StructType::HostDatastoreSystemCapabilities => Ok(from.as_any_box().downcast::<HostDatastoreSystemCapabilities>()?),
            StructType::HostDatastoreSystemDatastoreResult => Ok(from.as_any_box().downcast::<HostDatastoreSystemDatastoreResult>()?),
            StructType::HostDatastoreSystemVvolDatastoreSpec => Ok(from.as_any_box().downcast::<HostDatastoreSystemVvolDatastoreSpec>()?),
            StructType::HostDateTimeConfig => Ok(from.as_any_box().downcast::<HostDateTimeConfig>()?),
            StructType::HostDateTimeInfo => Ok(from.as_any_box().downcast::<HostDateTimeInfo>()?),
            StructType::HostDateTimeSystemServiceTestResult => Ok(from.as_any_box().downcast::<HostDateTimeSystemServiceTestResult>()?),
            StructType::HostDateTimeSystemTimeZone => Ok(from.as_any_box().downcast::<HostDateTimeSystemTimeZone>()?),
            StructType::HostDeploymentInfo => Ok(from.as_any_box().downcast::<HostDeploymentInfo>()?),
            StructType::HostDevice => Ok(from.as_any_box().downcast::<HostDevice>()?),
            StructType::ScsiLun => Ok(from.as_any_box().downcast::<ScsiLun>()?),
            StructType::HostScsiDisk => Ok(from.as_any_box().downcast::<HostScsiDisk>()?),
            StructType::HostDhcpService => Ok(from.as_any_box().downcast::<HostDhcpService>()?),
            StructType::HostDhcpServiceConfig => Ok(from.as_any_box().downcast::<HostDhcpServiceConfig>()?),
            StructType::HostDhcpServiceSpec => Ok(from.as_any_box().downcast::<HostDhcpServiceSpec>()?),
            StructType::HostDiagnosticPartition => Ok(from.as_any_box().downcast::<HostDiagnosticPartition>()?),
            StructType::HostDiagnosticPartitionCreateDescription => Ok(from.as_any_box().downcast::<HostDiagnosticPartitionCreateDescription>()?),
            StructType::HostDiagnosticPartitionCreateOption => Ok(from.as_any_box().downcast::<HostDiagnosticPartitionCreateOption>()?),
            StructType::HostDiagnosticPartitionCreateSpec => Ok(from.as_any_box().downcast::<HostDiagnosticPartitionCreateSpec>()?),
            StructType::HostDigestInfo => Ok(from.as_any_box().downcast::<HostDigestInfo>()?),
            StructType::HostTpmDigestInfo => Ok(from.as_any_box().downcast::<HostTpmDigestInfo>()?),
            StructType::HostDiskConfigurationResult => Ok(from.as_any_box().downcast::<HostDiskConfigurationResult>()?),
            StructType::HostDiskDimensions => Ok(from.as_any_box().downcast::<HostDiskDimensions>()?),
            StructType::HostDiskDimensionsChs => Ok(from.as_any_box().downcast::<HostDiskDimensionsChs>()?),
            StructType::HostDiskDimensionsLba => Ok(from.as_any_box().downcast::<HostDiskDimensionsLba>()?),
            StructType::HostDiskPartitionInfo => Ok(from.as_any_box().downcast::<HostDiskPartitionInfo>()?),
            StructType::HostDiskPartitionBlockRange => Ok(from.as_any_box().downcast::<HostDiskPartitionBlockRange>()?),
            StructType::HostDiskPartitionLayout => Ok(from.as_any_box().downcast::<HostDiskPartitionLayout>()?),
            StructType::HostDiskPartitionAttributes => Ok(from.as_any_box().downcast::<HostDiskPartitionAttributes>()?),
            StructType::HostDiskPartitionSpec => Ok(from.as_any_box().downcast::<HostDiskPartitionSpec>()?),
            StructType::HostDnsConfig => Ok(from.as_any_box().downcast::<HostDnsConfig>()?),
            StructType::HostDnsConfigSpec => Ok(from.as_any_box().downcast::<HostDnsConfigSpec>()?),
            StructType::HostDvxClass => Ok(from.as_any_box().downcast::<HostDvxClass>()?),
            StructType::HostEnterMaintenanceResult => Ok(from.as_any_box().downcast::<HostEnterMaintenanceResult>()?),
            StructType::HostEsxAgentHostManagerConfigInfo => Ok(from.as_any_box().downcast::<HostEsxAgentHostManagerConfigInfo>()?),
            StructType::HostFaultToleranceManagerComponentHealthInfo => Ok(from.as_any_box().downcast::<HostFaultToleranceManagerComponentHealthInfo>()?),
            StructType::FcoeConfig => Ok(from.as_any_box().downcast::<FcoeConfig>()?),
            StructType::FcoeConfigFcoeCapabilities => Ok(from.as_any_box().downcast::<FcoeConfigFcoeCapabilities>()?),
            StructType::FcoeConfigFcoeSpecification => Ok(from.as_any_box().downcast::<FcoeConfigFcoeSpecification>()?),
            StructType::FcoeConfigVlanRange => Ok(from.as_any_box().downcast::<FcoeConfigVlanRange>()?),
            StructType::HostFeatureCapability => Ok(from.as_any_box().downcast::<HostFeatureCapability>()?),
            StructType::HostFeatureMask => Ok(from.as_any_box().downcast::<HostFeatureMask>()?),
            StructType::HostFeatureVersionInfo => Ok(from.as_any_box().downcast::<HostFeatureVersionInfo>()?),
            StructType::HostFibreChannelOverEthernetHbaLinkInfo => Ok(from.as_any_box().downcast::<HostFibreChannelOverEthernetHbaLinkInfo>()?),
            StructType::HostFileAccess => Ok(from.as_any_box().downcast::<HostFileAccess>()?),
            StructType::ModeInfo => Ok(from.as_any_box().downcast::<ModeInfo>()?),
            StructType::HostFileSystemMountInfo => Ok(from.as_any_box().downcast::<HostFileSystemMountInfo>()?),
            StructType::HostFileSystemVolume => Ok(from.as_any_box().downcast::<HostFileSystemVolume>()?),
            StructType::HostLocalFileSystemVolume => Ok(from.as_any_box().downcast::<HostLocalFileSystemVolume>()?),
            StructType::HostNasVolume => Ok(from.as_any_box().downcast::<HostNasVolume>()?),
            StructType::HostPMemVolume => Ok(from.as_any_box().downcast::<HostPMemVolume>()?),
            StructType::HostVfatVolume => Ok(from.as_any_box().downcast::<HostVfatVolume>()?),
            StructType::HostVffsVolume => Ok(from.as_any_box().downcast::<HostVffsVolume>()?),
            StructType::HostVmfsVolume => Ok(from.as_any_box().downcast::<HostVmfsVolume>()?),
            StructType::HostVvolVolume => Ok(from.as_any_box().downcast::<HostVvolVolume>()?),
            StructType::HostFileSystemVolumeInfo => Ok(from.as_any_box().downcast::<HostFileSystemVolumeInfo>()?),
            StructType::HostFirewallConfig => Ok(from.as_any_box().downcast::<HostFirewallConfig>()?),
            StructType::HostFirewallConfigRuleSetConfig => Ok(from.as_any_box().downcast::<HostFirewallConfigRuleSetConfig>()?),
            StructType::HostFirewallInfo => Ok(from.as_any_box().downcast::<HostFirewallInfo>()?),
            StructType::HostFirewallDefaultPolicy => Ok(from.as_any_box().downcast::<HostFirewallDefaultPolicy>()?),
            StructType::HostFlagInfo => Ok(from.as_any_box().downcast::<HostFlagInfo>()?),
            StructType::HostForceMountedInfo => Ok(from.as_any_box().downcast::<HostForceMountedInfo>()?),
            StructType::HostFru => Ok(from.as_any_box().downcast::<HostFru>()?),
            StructType::HostGatewaySpec => Ok(from.as_any_box().downcast::<HostGatewaySpec>()?),
            StructType::HostGraphicsConfig => Ok(from.as_any_box().downcast::<HostGraphicsConfig>()?),
            StructType::HostGraphicsConfigDeviceType => Ok(from.as_any_box().downcast::<HostGraphicsConfigDeviceType>()?),
            StructType::HostGraphicsInfo => Ok(from.as_any_box().downcast::<HostGraphicsInfo>()?),
            StructType::HostHardwareInfo => Ok(from.as_any_box().downcast::<HostHardwareInfo>()?),
            StructType::HostHardwareStatusInfo => Ok(from.as_any_box().downcast::<HostHardwareStatusInfo>()?),
            StructType::DpuStatusInfoOperationalInfo => Ok(from.as_any_box().downcast::<DpuStatusInfoOperationalInfo>()?),
            StructType::HostHardwareElementInfo => Ok(from.as_any_box().downcast::<HostHardwareElementInfo>()?),
            StructType::DpuStatusInfo => Ok(from.as_any_box().downcast::<DpuStatusInfo>()?),
            StructType::HostStorageElementInfo => Ok(from.as_any_box().downcast::<HostStorageElementInfo>()?),
            StructType::HostStorageOperationalInfo => Ok(from.as_any_box().downcast::<HostStorageOperationalInfo>()?),
            StructType::HostHbaCreateSpec => Ok(from.as_any_box().downcast::<HostHbaCreateSpec>()?),
            StructType::HostTcpHbaCreateSpec => Ok(from.as_any_box().downcast::<HostTcpHbaCreateSpec>()?),
            StructType::HealthSystemRuntime => Ok(from.as_any_box().downcast::<HealthSystemRuntime>()?),
            StructType::HostAccessControlEntry => Ok(from.as_any_box().downcast::<HostAccessControlEntry>()?),
            StructType::HostHostBusAdapter => Ok(from.as_any_box().downcast::<HostHostBusAdapter>()?),
            StructType::HostBlockHba => Ok(from.as_any_box().downcast::<HostBlockHba>()?),
            StructType::HostFibreChannelHba => Ok(from.as_any_box().downcast::<HostFibreChannelHba>()?),
            StructType::HostFibreChannelOverEthernetHba => Ok(from.as_any_box().downcast::<HostFibreChannelOverEthernetHba>()?),
            StructType::HostInternetScsiHba => Ok(from.as_any_box().downcast::<HostInternetScsiHba>()?),
            StructType::HostParallelScsiHba => Ok(from.as_any_box().downcast::<HostParallelScsiHba>()?),
            StructType::HostPcieHba => Ok(from.as_any_box().downcast::<HostPcieHba>()?),
            StructType::HostRdmaHba => Ok(from.as_any_box().downcast::<HostRdmaHba>()?),
            StructType::HostSerialAttachedHba => Ok(from.as_any_box().downcast::<HostSerialAttachedHba>()?),
            StructType::HostTcpHba => Ok(from.as_any_box().downcast::<HostTcpHba>()?),
            StructType::HostProxySwitch => Ok(from.as_any_box().downcast::<HostProxySwitch>()?),
            StructType::HostProxySwitchConfig => Ok(from.as_any_box().downcast::<HostProxySwitchConfig>()?),
            StructType::HostProxySwitchEnsInfo => Ok(from.as_any_box().downcast::<HostProxySwitchEnsInfo>()?),
            StructType::HostProxySwitchHostLagConfig => Ok(from.as_any_box().downcast::<HostProxySwitchHostLagConfig>()?),
            StructType::HostProxySwitchSpec => Ok(from.as_any_box().downcast::<HostProxySwitchSpec>()?),
            StructType::HostImageProfileSummary => Ok(from.as_any_box().downcast::<HostImageProfileSummary>()?),
            StructType::HostInternetScsiHbaAuthenticationCapabilities => Ok(from.as_any_box().downcast::<HostInternetScsiHbaAuthenticationCapabilities>()?),
            StructType::HostInternetScsiHbaAuthenticationProperties => Ok(from.as_any_box().downcast::<HostInternetScsiHbaAuthenticationProperties>()?),
            StructType::HostInternetScsiHbaDigestCapabilities => Ok(from.as_any_box().downcast::<HostInternetScsiHbaDigestCapabilities>()?),
            StructType::HostInternetScsiHbaDigestProperties => Ok(from.as_any_box().downcast::<HostInternetScsiHbaDigestProperties>()?),
            StructType::HostInternetScsiHbaDiscoveryCapabilities => Ok(from.as_any_box().downcast::<HostInternetScsiHbaDiscoveryCapabilities>()?),
            StructType::HostInternetScsiHbaDiscoveryProperties => Ok(from.as_any_box().downcast::<HostInternetScsiHbaDiscoveryProperties>()?),
            StructType::HostInternetScsiHbaIpCapabilities => Ok(from.as_any_box().downcast::<HostInternetScsiHbaIpCapabilities>()?),
            StructType::HostInternetScsiHbaIpProperties => Ok(from.as_any_box().downcast::<HostInternetScsiHbaIpProperties>()?),
            StructType::HostInternetScsiHbaIPv6Properties => Ok(from.as_any_box().downcast::<HostInternetScsiHbaIPv6Properties>()?),
            StructType::HostInternetScsiHbaIscsiIpv6Address => Ok(from.as_any_box().downcast::<HostInternetScsiHbaIscsiIpv6Address>()?),
            StructType::HostInternetScsiHbaSendTarget => Ok(from.as_any_box().downcast::<HostInternetScsiHbaSendTarget>()?),
            StructType::HostInternetScsiHbaStaticTarget => Ok(from.as_any_box().downcast::<HostInternetScsiHbaStaticTarget>()?),
            StructType::HostInternetScsiHbaTargetSet => Ok(from.as_any_box().downcast::<HostInternetScsiHbaTargetSet>()?),
            StructType::HostIpConfig => Ok(from.as_any_box().downcast::<HostIpConfig>()?),
            StructType::HostIpConfigIpV6Address => Ok(from.as_any_box().downcast::<HostIpConfigIpV6Address>()?),
            StructType::HostIpConfigIpV6AddressConfiguration => Ok(from.as_any_box().downcast::<HostIpConfigIpV6AddressConfiguration>()?),
            StructType::HostIpRouteConfig => Ok(from.as_any_box().downcast::<HostIpRouteConfig>()?),
            StructType::HostIpRouteConfigSpec => Ok(from.as_any_box().downcast::<HostIpRouteConfigSpec>()?),
            StructType::HostIpRouteEntry => Ok(from.as_any_box().downcast::<HostIpRouteEntry>()?),
            StructType::HostIpRouteOp => Ok(from.as_any_box().downcast::<HostIpRouteOp>()?),
            StructType::HostIpRouteTableConfig => Ok(from.as_any_box().downcast::<HostIpRouteTableConfig>()?),
            StructType::HostIpRouteTableInfo => Ok(from.as_any_box().downcast::<HostIpRouteTableInfo>()?),
            StructType::HostIpmiInfo => Ok(from.as_any_box().downcast::<HostIpmiInfo>()?),
            StructType::IscsiDependencyEntity => Ok(from.as_any_box().downcast::<IscsiDependencyEntity>()?),
            StructType::IscsiMigrationDependency => Ok(from.as_any_box().downcast::<IscsiMigrationDependency>()?),
            StructType::IscsiPortInfo => Ok(from.as_any_box().downcast::<IscsiPortInfo>()?),
            StructType::IscsiStatus => Ok(from.as_any_box().downcast::<IscsiStatus>()?),
            StructType::KernelModuleInfo => Ok(from.as_any_box().downcast::<KernelModuleInfo>()?),
            StructType::KernelModuleSectionInfo => Ok(from.as_any_box().downcast::<KernelModuleSectionInfo>()?),
            StructType::HostLicenseSpec => Ok(from.as_any_box().downcast::<HostLicenseSpec>()?),
            StructType::LinkDiscoveryProtocolConfig => Ok(from.as_any_box().downcast::<LinkDiscoveryProtocolConfig>()?),
            StructType::HostAccountSpec => Ok(from.as_any_box().downcast::<HostAccountSpec>()?),
            StructType::HostPosixAccountSpec => Ok(from.as_any_box().downcast::<HostPosixAccountSpec>()?),
            StructType::HostLocalFileSystemVolumeSpec => Ok(from.as_any_box().downcast::<HostLocalFileSystemVolumeSpec>()?),
            StructType::HostLowLevelProvisioningManagerDiskLayoutSpec => Ok(from.as_any_box().downcast::<HostLowLevelProvisioningManagerDiskLayoutSpec>()?),
            StructType::HostLowLevelProvisioningManagerFileDeleteResult => Ok(from.as_any_box().downcast::<HostLowLevelProvisioningManagerFileDeleteResult>()?),
            StructType::HostLowLevelProvisioningManagerFileDeleteSpec => Ok(from.as_any_box().downcast::<HostLowLevelProvisioningManagerFileDeleteSpec>()?),
            StructType::HostLowLevelProvisioningManagerFileReserveResult => Ok(from.as_any_box().downcast::<HostLowLevelProvisioningManagerFileReserveResult>()?),
            StructType::HostLowLevelProvisioningManagerFileReserveSpec => Ok(from.as_any_box().downcast::<HostLowLevelProvisioningManagerFileReserveSpec>()?),
            StructType::HostLowLevelProvisioningManagerSnapshotLayoutSpec => Ok(from.as_any_box().downcast::<HostLowLevelProvisioningManagerSnapshotLayoutSpec>()?),
            StructType::HostLowLevelProvisioningManagerVmMigrationStatus => Ok(from.as_any_box().downcast::<HostLowLevelProvisioningManagerVmMigrationStatus>()?),
            StructType::HostLowLevelProvisioningManagerVmRecoveryInfo => Ok(from.as_any_box().downcast::<HostLowLevelProvisioningManagerVmRecoveryInfo>()?),
            StructType::HostMaintenanceSpec => Ok(from.as_any_box().downcast::<HostMaintenanceSpec>()?),
            StructType::ServiceConsoleReservationInfo => Ok(from.as_any_box().downcast::<ServiceConsoleReservationInfo>()?),
            StructType::VirtualMachineMemoryReservationInfo => Ok(from.as_any_box().downcast::<VirtualMachineMemoryReservationInfo>()?),
            StructType::VirtualMachineMemoryReservationSpec => Ok(from.as_any_box().downcast::<VirtualMachineMemoryReservationSpec>()?),
            StructType::HostMemorySpec => Ok(from.as_any_box().downcast::<HostMemorySpec>()?),
            StructType::HostMemoryTierInfo => Ok(from.as_any_box().downcast::<HostMemoryTierInfo>()?),
            StructType::HostMountInfo => Ok(from.as_any_box().downcast::<HostMountInfo>()?),
            StructType::HostMultipathInfo => Ok(from.as_any_box().downcast::<HostMultipathInfo>()?),
            StructType::HostMultipathInfoLogicalUnit => Ok(from.as_any_box().downcast::<HostMultipathInfoLogicalUnit>()?),
            StructType::HostMultipathInfoLogicalUnitPolicy => Ok(from.as_any_box().downcast::<HostMultipathInfoLogicalUnitPolicy>()?),
            StructType::HostMultipathInfoFixedLogicalUnitPolicy => Ok(from.as_any_box().downcast::<HostMultipathInfoFixedLogicalUnitPolicy>()?),
            StructType::HostMultipathInfoHppLogicalUnitPolicy => Ok(from.as_any_box().downcast::<HostMultipathInfoHppLogicalUnitPolicy>()?),
            StructType::HostMultipathInfoLogicalUnitStorageArrayTypePolicy => Ok(from.as_any_box().downcast::<HostMultipathInfoLogicalUnitStorageArrayTypePolicy>()?),
            StructType::HostMultipathInfoPath => Ok(from.as_any_box().downcast::<HostMultipathInfoPath>()?),
            StructType::HostMultipathStateInfo => Ok(from.as_any_box().downcast::<HostMultipathStateInfo>()?),
            StructType::HostMultipathStateInfoPath => Ok(from.as_any_box().downcast::<HostMultipathStateInfoPath>()?),
            StructType::HostNasVolumeConfig => Ok(from.as_any_box().downcast::<HostNasVolumeConfig>()?),
            StructType::HostNasVolumeSpec => Ok(from.as_any_box().downcast::<HostNasVolumeSpec>()?),
            StructType::HostNasVolumeUserInfo => Ok(from.as_any_box().downcast::<HostNasVolumeUserInfo>()?),
            StructType::HostNatService => Ok(from.as_any_box().downcast::<HostNatService>()?),
            StructType::HostNatServiceConfig => Ok(from.as_any_box().downcast::<HostNatServiceConfig>()?),
            StructType::HostNatServiceNameServiceSpec => Ok(from.as_any_box().downcast::<HostNatServiceNameServiceSpec>()?),
            StructType::HostNatServicePortForwardSpec => Ok(from.as_any_box().downcast::<HostNatServicePortForwardSpec>()?),
            StructType::HostNatServiceSpec => Ok(from.as_any_box().downcast::<HostNatServiceSpec>()?),
            StructType::HostNetCapabilities => Ok(from.as_any_box().downcast::<HostNetCapabilities>()?),
            StructType::HostNetOffloadCapabilities => Ok(from.as_any_box().downcast::<HostNetOffloadCapabilities>()?),
            StructType::HostNetStackInstance => Ok(from.as_any_box().downcast::<HostNetStackInstance>()?),
            StructType::HostNetworkConfig => Ok(from.as_any_box().downcast::<HostNetworkConfig>()?),
            StructType::HostNetworkConfigNetStackSpec => Ok(from.as_any_box().downcast::<HostNetworkConfigNetStackSpec>()?),
            StructType::HostNetworkConfigResult => Ok(from.as_any_box().downcast::<HostNetworkConfigResult>()?),
            StructType::HostNetworkInfo => Ok(from.as_any_box().downcast::<HostNetworkInfo>()?),
            StructType::HostNetworkPolicy => Ok(from.as_any_box().downcast::<HostNetworkPolicy>()?),
            StructType::HostNicFailureCriteria => Ok(from.as_any_box().downcast::<HostNicFailureCriteria>()?),
            StructType::HostNicOrderPolicy => Ok(from.as_any_box().downcast::<HostNicOrderPolicy>()?),
            StructType::HostNicTeamingPolicy => Ok(from.as_any_box().downcast::<HostNicTeamingPolicy>()?),
            StructType::HostNetworkSecurityPolicy => Ok(from.as_any_box().downcast::<HostNetworkSecurityPolicy>()?),
            StructType::HostNetworkTrafficShapingPolicy => Ok(from.as_any_box().downcast::<HostNetworkTrafficShapingPolicy>()?),
            StructType::HostNtpConfig => Ok(from.as_any_box().downcast::<HostNtpConfig>()?),
            StructType::HostNumaInfo => Ok(from.as_any_box().downcast::<HostNumaInfo>()?),
            StructType::HostNumaNode => Ok(from.as_any_box().downcast::<HostNumaNode>()?),
            StructType::HostNumericSensorInfo => Ok(from.as_any_box().downcast::<HostNumericSensorInfo>()?),
            StructType::NvdimmDimmInfo => Ok(from.as_any_box().downcast::<NvdimmDimmInfo>()?),
            StructType::NvdimmGuid => Ok(from.as_any_box().downcast::<NvdimmGuid>()?),
            StructType::NvdimmHealthInfo => Ok(from.as_any_box().downcast::<NvdimmHealthInfo>()?),
            StructType::NvdimmInterleaveSetInfo => Ok(from.as_any_box().downcast::<NvdimmInterleaveSetInfo>()?),
            StructType::NvdimmNamespaceCreateSpec => Ok(from.as_any_box().downcast::<NvdimmNamespaceCreateSpec>()?),
            StructType::NvdimmNamespaceDeleteSpec => Ok(from.as_any_box().downcast::<NvdimmNamespaceDeleteSpec>()?),
            StructType::NvdimmNamespaceDetails => Ok(from.as_any_box().downcast::<NvdimmNamespaceDetails>()?),
            StructType::NvdimmNamespaceInfo => Ok(from.as_any_box().downcast::<NvdimmNamespaceInfo>()?),
            StructType::NvdimmSystemInfo => Ok(from.as_any_box().downcast::<NvdimmSystemInfo>()?),
            StructType::NvdimmPMemNamespaceCreateSpec => Ok(from.as_any_box().downcast::<NvdimmPMemNamespaceCreateSpec>()?),
            StructType::NvdimmRegionInfo => Ok(from.as_any_box().downcast::<NvdimmRegionInfo>()?),
            StructType::NvdimmSummary => Ok(from.as_any_box().downcast::<NvdimmSummary>()?),
            StructType::HostNvmeController => Ok(from.as_any_box().downcast::<HostNvmeController>()?),
            StructType::HostNvmeDisconnectSpec => Ok(from.as_any_box().downcast::<HostNvmeDisconnectSpec>()?),
            StructType::HostNvmeDiscoveryLog => Ok(from.as_any_box().downcast::<HostNvmeDiscoveryLog>()?),
            StructType::HostNvmeDiscoveryLogEntry => Ok(from.as_any_box().downcast::<HostNvmeDiscoveryLogEntry>()?),
            StructType::HostNvmeNamespace => Ok(from.as_any_box().downcast::<HostNvmeNamespace>()?),
            StructType::HostNvmeSpec => Ok(from.as_any_box().downcast::<HostNvmeSpec>()?),
            StructType::HostNvmeConnectSpec => Ok(from.as_any_box().downcast::<HostNvmeConnectSpec>()?),
            StructType::HostNvmeDiscoverSpec => Ok(from.as_any_box().downcast::<HostNvmeDiscoverSpec>()?),
            StructType::HostNvmeTopology => Ok(from.as_any_box().downcast::<HostNvmeTopology>()?),
            StructType::HostNvmeTopologyInterface => Ok(from.as_any_box().downcast::<HostNvmeTopologyInterface>()?),
            StructType::HostNvmeTransportParameters => Ok(from.as_any_box().downcast::<HostNvmeTransportParameters>()?),
            StructType::HostNvmeOpaqueTransportParameters => Ok(from.as_any_box().downcast::<HostNvmeOpaqueTransportParameters>()?),
            StructType::HostNvmeOverFibreChannelParameters => Ok(from.as_any_box().downcast::<HostNvmeOverFibreChannelParameters>()?),
            StructType::HostNvmeOverRdmaParameters => Ok(from.as_any_box().downcast::<HostNvmeOverRdmaParameters>()?),
            StructType::HostNvmeOverTcpParameters => Ok(from.as_any_box().downcast::<HostNvmeOverTcpParameters>()?),
            StructType::HostOpaqueNetworkInfo => Ok(from.as_any_box().downcast::<HostOpaqueNetworkInfo>()?),
            StructType::HostOpaqueSwitch => Ok(from.as_any_box().downcast::<HostOpaqueSwitch>()?),
            StructType::HostOpaqueSwitchPhysicalNicZone => Ok(from.as_any_box().downcast::<HostOpaqueSwitchPhysicalNicZone>()?),
            StructType::HostPatchManagerLocator => Ok(from.as_any_box().downcast::<HostPatchManagerLocator>()?),
            StructType::HostPatchManagerPatchManagerOperationSpec => Ok(from.as_any_box().downcast::<HostPatchManagerPatchManagerOperationSpec>()?),
            StructType::HostPatchManagerResult => Ok(from.as_any_box().downcast::<HostPatchManagerResult>()?),
            StructType::HostPatchManagerStatus => Ok(from.as_any_box().downcast::<HostPatchManagerStatus>()?),
            StructType::HostPatchManagerStatusPrerequisitePatch => Ok(from.as_any_box().downcast::<HostPatchManagerStatusPrerequisitePatch>()?),
            StructType::HostPathSelectionPolicyOption => Ok(from.as_any_box().downcast::<HostPathSelectionPolicyOption>()?),
            StructType::HostPciDevice => Ok(from.as_any_box().downcast::<HostPciDevice>()?),
            StructType::HostPciPassthruConfig => Ok(from.as_any_box().downcast::<HostPciPassthruConfig>()?),
            StructType::HostSriovConfig => Ok(from.as_any_box().downcast::<HostSriovConfig>()?),
            StructType::HostPciPassthruInfo => Ok(from.as_any_box().downcast::<HostPciPassthruInfo>()?),
            StructType::HostSriovInfo => Ok(from.as_any_box().downcast::<HostSriovInfo>()?),
            StructType::HostPersistentMemoryInfo => Ok(from.as_any_box().downcast::<HostPersistentMemoryInfo>()?),
            StructType::PhysicalNic => Ok(from.as_any_box().downcast::<PhysicalNic>()?),
            StructType::PhysicalNicCdpDeviceCapability => Ok(from.as_any_box().downcast::<PhysicalNicCdpDeviceCapability>()?),
            StructType::PhysicalNicCdpInfo => Ok(from.as_any_box().downcast::<PhysicalNicCdpInfo>()?),
            StructType::PhysicalNicConfig => Ok(from.as_any_box().downcast::<PhysicalNicConfig>()?),
            StructType::PhysicalNicLinkInfo => Ok(from.as_any_box().downcast::<PhysicalNicLinkInfo>()?),
            StructType::LinkLayerDiscoveryProtocolInfo => Ok(from.as_any_box().downcast::<LinkLayerDiscoveryProtocolInfo>()?),
            StructType::PhysicalNicHintInfo => Ok(from.as_any_box().downcast::<PhysicalNicHintInfo>()?),
            StructType::PhysicalNicHint => Ok(from.as_any_box().downcast::<PhysicalNicHint>()?),
            StructType::PhysicalNicIpHint => Ok(from.as_any_box().downcast::<PhysicalNicIpHint>()?),
            StructType::PhysicalNicNameHint => Ok(from.as_any_box().downcast::<PhysicalNicNameHint>()?),
            StructType::PhysicalNicSpec => Ok(from.as_any_box().downcast::<PhysicalNicSpec>()?),
            StructType::HostPlugStoreTopology => Ok(from.as_any_box().downcast::<HostPlugStoreTopology>()?),
            StructType::HostPlugStoreTopologyAdapter => Ok(from.as_any_box().downcast::<HostPlugStoreTopologyAdapter>()?),
            StructType::HostPlugStoreTopologyDevice => Ok(from.as_any_box().downcast::<HostPlugStoreTopologyDevice>()?),
            StructType::HostPlugStoreTopologyPath => Ok(from.as_any_box().downcast::<HostPlugStoreTopologyPath>()?),
            StructType::HostPlugStoreTopologyPlugin => Ok(from.as_any_box().downcast::<HostPlugStoreTopologyPlugin>()?),
            StructType::HostPlugStoreTopologyTarget => Ok(from.as_any_box().downcast::<HostPlugStoreTopologyTarget>()?),
            StructType::HostPortGroup => Ok(from.as_any_box().downcast::<HostPortGroup>()?),
            StructType::HostPortGroupConfig => Ok(from.as_any_box().downcast::<HostPortGroupConfig>()?),
            StructType::HostPortGroupPort => Ok(from.as_any_box().downcast::<HostPortGroupPort>()?),
            StructType::HostPortGroupSpec => Ok(from.as_any_box().downcast::<HostPortGroupSpec>()?),
            StructType::PowerSystemCapability => Ok(from.as_any_box().downcast::<PowerSystemCapability>()?),
            StructType::PowerSystemInfo => Ok(from.as_any_box().downcast::<PowerSystemInfo>()?),
            StructType::HostPowerPolicy => Ok(from.as_any_box().downcast::<HostPowerPolicy>()?),
            StructType::HostProtocolEndpoint => Ok(from.as_any_box().downcast::<HostProtocolEndpoint>()?),
            StructType::HostPtpConfig => Ok(from.as_any_box().downcast::<HostPtpConfig>()?),
            StructType::HostPtpConfigPtpPort => Ok(from.as_any_box().downcast::<HostPtpConfigPtpPort>()?),
            StructType::HostQualifiedName => Ok(from.as_any_box().downcast::<HostQualifiedName>()?),
            StructType::HostRdmaDevice => Ok(from.as_any_box().downcast::<HostRdmaDevice>()?),
            StructType::HostRdmaDeviceBacking => Ok(from.as_any_box().downcast::<HostRdmaDeviceBacking>()?),
            StructType::HostRdmaDevicePnicBacking => Ok(from.as_any_box().downcast::<HostRdmaDevicePnicBacking>()?),
            StructType::HostRdmaDeviceCapability => Ok(from.as_any_box().downcast::<HostRdmaDeviceCapability>()?),
            StructType::HostRdmaDeviceConnectionInfo => Ok(from.as_any_box().downcast::<HostRdmaDeviceConnectionInfo>()?),
            StructType::HostReliableMemoryInfo => Ok(from.as_any_box().downcast::<HostReliableMemoryInfo>()?),
            StructType::HostResignatureRescanResult => Ok(from.as_any_box().downcast::<HostResignatureRescanResult>()?),
            StructType::HostFirewallRuleset => Ok(from.as_any_box().downcast::<HostFirewallRuleset>()?),
            StructType::HostFirewallRulesetIpList => Ok(from.as_any_box().downcast::<HostFirewallRulesetIpList>()?),
            StructType::HostFirewallRulesetIpNetwork => Ok(from.as_any_box().downcast::<HostFirewallRulesetIpNetwork>()?),
            StructType::HostFirewallRule => Ok(from.as_any_box().downcast::<HostFirewallRule>()?),
            StructType::HostFirewallRulesetRulesetSpec => Ok(from.as_any_box().downcast::<HostFirewallRulesetRulesetSpec>()?),
            StructType::HostRuntimeInfo => Ok(from.as_any_box().downcast::<HostRuntimeInfo>()?),
            StructType::HostRuntimeInfoNetStackInstanceRuntimeInfo => Ok(from.as_any_box().downcast::<HostRuntimeInfoNetStackInstanceRuntimeInfo>()?),
            StructType::HostNetworkResourceRuntime => Ok(from.as_any_box().downcast::<HostNetworkResourceRuntime>()?),
            StructType::HostRuntimeInfoNetworkRuntimeInfo => Ok(from.as_any_box().downcast::<HostRuntimeInfoNetworkRuntimeInfo>()?),
            StructType::HostPlacedVirtualNicIdentifier => Ok(from.as_any_box().downcast::<HostPlacedVirtualNicIdentifier>()?),
            StructType::HostPnicNetworkResourceInfo => Ok(from.as_any_box().downcast::<HostPnicNetworkResourceInfo>()?),
            StructType::HostRuntimeInfoStateEncryptionInfo => Ok(from.as_any_box().downcast::<HostRuntimeInfoStateEncryptionInfo>()?),
            StructType::HostScsiDiskPartition => Ok(from.as_any_box().downcast::<HostScsiDiskPartition>()?),
            StructType::ScsiLunCapabilities => Ok(from.as_any_box().downcast::<ScsiLunCapabilities>()?),
            StructType::ScsiLunDescriptor => Ok(from.as_any_box().downcast::<ScsiLunDescriptor>()?),
            StructType::ScsiLunDurableName => Ok(from.as_any_box().downcast::<ScsiLunDurableName>()?),
            StructType::HostScsiTopology => Ok(from.as_any_box().downcast::<HostScsiTopology>()?),
            StructType::HostScsiTopologyInterface => Ok(from.as_any_box().downcast::<HostScsiTopologyInterface>()?),
            StructType::HostScsiTopologyLun => Ok(from.as_any_box().downcast::<HostScsiTopologyLun>()?),
            StructType::HostScsiTopologyTarget => Ok(from.as_any_box().downcast::<HostScsiTopologyTarget>()?),
            StructType::HostSecuritySpec => Ok(from.as_any_box().downcast::<HostSecuritySpec>()?),
            StructType::HostService => Ok(from.as_any_box().downcast::<HostService>()?),
            StructType::HostServiceSourcePackage => Ok(from.as_any_box().downcast::<HostServiceSourcePackage>()?),
            StructType::HostServiceConfig => Ok(from.as_any_box().downcast::<HostServiceConfig>()?),
            StructType::HostServiceInfo => Ok(from.as_any_box().downcast::<HostServiceInfo>()?),
            StructType::HostSevInfo => Ok(from.as_any_box().downcast::<HostSevInfo>()?),
            StructType::HostSgxInfo => Ok(from.as_any_box().downcast::<HostSgxInfo>()?),
            StructType::HostSgxRegistrationInfo => Ok(from.as_any_box().downcast::<HostSgxRegistrationInfo>()?),
            StructType::HostSharedGpuCapabilities => Ok(from.as_any_box().downcast::<HostSharedGpuCapabilities>()?),
            StructType::HostSnmpSystemAgentLimits => Ok(from.as_any_box().downcast::<HostSnmpSystemAgentLimits>()?),
            StructType::HostSnmpConfigSpec => Ok(from.as_any_box().downcast::<HostSnmpConfigSpec>()?),
            StructType::HostSnmpDestination => Ok(from.as_any_box().downcast::<HostSnmpDestination>()?),
            StructType::SoftwarePackage => Ok(from.as_any_box().downcast::<SoftwarePackage>()?),
            StructType::SoftwarePackageCapability => Ok(from.as_any_box().downcast::<SoftwarePackageCapability>()?),
            StructType::Relation => Ok(from.as_any_box().downcast::<Relation>()?),
            StructType::HostSriovDevicePoolInfo => Ok(from.as_any_box().downcast::<HostSriovDevicePoolInfo>()?),
            StructType::HostSriovNetworkDevicePoolInfo => Ok(from.as_any_box().downcast::<HostSriovNetworkDevicePoolInfo>()?),
            StructType::HostSslThumbprintInfo => Ok(from.as_any_box().downcast::<HostSslThumbprintInfo>()?),
            StructType::HostStorageArrayTypePolicyOption => Ok(from.as_any_box().downcast::<HostStorageArrayTypePolicyOption>()?),
            StructType::HostStorageDeviceInfo => Ok(from.as_any_box().downcast::<HostStorageDeviceInfo>()?),
            StructType::HostStorageSystemDiskLocatorLedResult => Ok(from.as_any_box().downcast::<HostStorageSystemDiskLocatorLedResult>()?),
            StructType::HostStorageSystemScsiLunResult => Ok(from.as_any_box().downcast::<HostStorageSystemScsiLunResult>()?),
            StructType::HostStorageSystemVmfsVolumeResult => Ok(from.as_any_box().downcast::<HostStorageSystemVmfsVolumeResult>()?),
            StructType::HostListSummary => Ok(from.as_any_box().downcast::<HostListSummary>()?),
            StructType::HostConfigSummary => Ok(from.as_any_box().downcast::<HostConfigSummary>()?),
            StructType::HostListSummaryGatewaySummary => Ok(from.as_any_box().downcast::<HostListSummaryGatewaySummary>()?),
            StructType::HostHardwareSummary => Ok(from.as_any_box().downcast::<HostHardwareSummary>()?),
            StructType::HostListSummaryQuickStats => Ok(from.as_any_box().downcast::<HostListSummaryQuickStats>()?),
            StructType::SystemEventInfo => Ok(from.as_any_box().downcast::<SystemEventInfo>()?),
            StructType::HostSystemHealthInfo => Ok(from.as_any_box().downcast::<HostSystemHealthInfo>()?),
            StructType::HostSystemIdentificationInfo => Ok(from.as_any_box().downcast::<HostSystemIdentificationInfo>()?),
            StructType::HostSystemInfo => Ok(from.as_any_box().downcast::<HostSystemInfo>()?),
            StructType::HostSystemResourceInfo => Ok(from.as_any_box().downcast::<HostSystemResourceInfo>()?),
            StructType::HostSystemSwapConfiguration => Ok(from.as_any_box().downcast::<HostSystemSwapConfiguration>()?),
            StructType::HostSystemSwapConfigurationSystemSwapOption => Ok(from.as_any_box().downcast::<HostSystemSwapConfigurationSystemSwapOption>()?),
            StructType::HostSystemSwapConfigurationDatastoreOption => Ok(from.as_any_box().downcast::<HostSystemSwapConfigurationDatastoreOption>()?),
            StructType::HostSystemSwapConfigurationDisabledOption => Ok(from.as_any_box().downcast::<HostSystemSwapConfigurationDisabledOption>()?),
            StructType::HostSystemSwapConfigurationHostCacheOption => Ok(from.as_any_box().downcast::<HostSystemSwapConfigurationHostCacheOption>()?),
            StructType::HostSystemSwapConfigurationHostLocalSwapOption => Ok(from.as_any_box().downcast::<HostSystemSwapConfigurationHostLocalSwapOption>()?),
            StructType::HostTargetTransport => Ok(from.as_any_box().downcast::<HostTargetTransport>()?),
            StructType::HostBlockAdapterTargetTransport => Ok(from.as_any_box().downcast::<HostBlockAdapterTargetTransport>()?),
            StructType::HostFibreChannelTargetTransport => Ok(from.as_any_box().downcast::<HostFibreChannelTargetTransport>()?),
            StructType::HostFibreChannelOverEthernetTargetTransport => Ok(from.as_any_box().downcast::<HostFibreChannelOverEthernetTargetTransport>()?),
            StructType::HostInternetScsiTargetTransport => Ok(from.as_any_box().downcast::<HostInternetScsiTargetTransport>()?),
            StructType::HostParallelScsiTargetTransport => Ok(from.as_any_box().downcast::<HostParallelScsiTargetTransport>()?),
            StructType::HostPcieTargetTransport => Ok(from.as_any_box().downcast::<HostPcieTargetTransport>()?),
            StructType::HostRdmaTargetTransport => Ok(from.as_any_box().downcast::<HostRdmaTargetTransport>()?),
            StructType::HostSerialAttachedTargetTransport => Ok(from.as_any_box().downcast::<HostSerialAttachedTargetTransport>()?),
            StructType::HostTcpTargetTransport => Ok(from.as_any_box().downcast::<HostTcpTargetTransport>()?),
            StructType::HostTpmAttestationInfo => Ok(from.as_any_box().downcast::<HostTpmAttestationInfo>()?),
            StructType::HostTpmAttestationReport => Ok(from.as_any_box().downcast::<HostTpmAttestationReport>()?),
            StructType::HostTpmEventDetails => Ok(from.as_any_box().downcast::<HostTpmEventDetails>()?),
            StructType::HostTpmBootCompleteEventDetails => Ok(from.as_any_box().downcast::<HostTpmBootCompleteEventDetails>()?),
            StructType::HostTpmBootSecurityOptionEventDetails => Ok(from.as_any_box().downcast::<HostTpmBootSecurityOptionEventDetails>()?),
            StructType::HostTpmNvTagEventDetails => Ok(from.as_any_box().downcast::<HostTpmNvTagEventDetails>()?),
            StructType::HostTpmSignerEventDetails => Ok(from.as_any_box().downcast::<HostTpmSignerEventDetails>()?),
            StructType::HostTpmCommandEventDetails => Ok(from.as_any_box().downcast::<HostTpmCommandEventDetails>()?),
            StructType::HostTpmOptionEventDetails => Ok(from.as_any_box().downcast::<HostTpmOptionEventDetails>()?),
            StructType::HostTpmSoftwareComponentEventDetails => Ok(from.as_any_box().downcast::<HostTpmSoftwareComponentEventDetails>()?),
            StructType::HostTpmVersionEventDetails => Ok(from.as_any_box().downcast::<HostTpmVersionEventDetails>()?),
            StructType::HostTpmEventLogEntry => Ok(from.as_any_box().downcast::<HostTpmEventLogEntry>()?),
            StructType::HostTrustAuthorityAttestationInfo => Ok(from.as_any_box().downcast::<HostTrustAuthorityAttestationInfo>()?),
            StructType::HostUnresolvedVmfsExtent => Ok(from.as_any_box().downcast::<HostUnresolvedVmfsExtent>()?),
            StructType::HostUnresolvedVmfsResignatureSpec => Ok(from.as_any_box().downcast::<HostUnresolvedVmfsResignatureSpec>()?),
            StructType::HostUnresolvedVmfsResolutionResult => Ok(from.as_any_box().downcast::<HostUnresolvedVmfsResolutionResult>()?),
            StructType::HostUnresolvedVmfsResolutionSpec => Ok(from.as_any_box().downcast::<HostUnresolvedVmfsResolutionSpec>()?),
            StructType::HostUnresolvedVmfsVolume => Ok(from.as_any_box().downcast::<HostUnresolvedVmfsVolume>()?),
            StructType::HostUnresolvedVmfsVolumeResolveStatus => Ok(from.as_any_box().downcast::<HostUnresolvedVmfsVolumeResolveStatus>()?),
            StructType::HostVFlashManagerVFlashCacheConfigInfo => Ok(from.as_any_box().downcast::<HostVFlashManagerVFlashCacheConfigInfo>()?),
            StructType::HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption => Ok(from.as_any_box().downcast::<HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption>()?),
            StructType::HostVFlashManagerVFlashCacheConfigSpec => Ok(from.as_any_box().downcast::<HostVFlashManagerVFlashCacheConfigSpec>()?),
            StructType::HostVFlashManagerVFlashConfigInfo => Ok(from.as_any_box().downcast::<HostVFlashManagerVFlashConfigInfo>()?),
            StructType::HostVFlashManagerVFlashResourceConfigInfo => Ok(from.as_any_box().downcast::<HostVFlashManagerVFlashResourceConfigInfo>()?),
            StructType::HostVFlashManagerVFlashResourceConfigSpec => Ok(from.as_any_box().downcast::<HostVFlashManagerVFlashResourceConfigSpec>()?),
            StructType::HostVFlashManagerVFlashResourceRunTimeInfo => Ok(from.as_any_box().downcast::<HostVFlashManagerVFlashResourceRunTimeInfo>()?),
            StructType::HostVFlashResourceConfigurationResult => Ok(from.as_any_box().downcast::<HostVFlashResourceConfigurationResult>()?),
            StructType::HostVMotionConfig => Ok(from.as_any_box().downcast::<HostVMotionConfig>()?),
            StructType::HostVMotionInfo => Ok(from.as_any_box().downcast::<HostVMotionInfo>()?),
            StructType::HostVMotionManagerDstInstantCloneResult => Ok(from.as_any_box().downcast::<HostVMotionManagerDstInstantCloneResult>()?),
            StructType::HostVMotionManagerSrcInstantCloneResult => Ok(from.as_any_box().downcast::<HostVMotionManagerSrcInstantCloneResult>()?),
            StructType::HostVMotionNetConfig => Ok(from.as_any_box().downcast::<HostVMotionNetConfig>()?),
            StructType::HostVffsSpec => Ok(from.as_any_box().downcast::<HostVffsSpec>()?),
            StructType::HostVirtualNic => Ok(from.as_any_box().downcast::<HostVirtualNic>()?),
            StructType::HostVirtualNicConfig => Ok(from.as_any_box().downcast::<HostVirtualNicConfig>()?),
            StructType::HostVirtualNicIpRouteSpec => Ok(from.as_any_box().downcast::<HostVirtualNicIpRouteSpec>()?),
            StructType::HostVirtualNicOpaqueNetworkSpec => Ok(from.as_any_box().downcast::<HostVirtualNicOpaqueNetworkSpec>()?),
            StructType::HostVirtualNicSpec => Ok(from.as_any_box().downcast::<HostVirtualNicSpec>()?),
            StructType::HostVirtualNicConnection => Ok(from.as_any_box().downcast::<HostVirtualNicConnection>()?),
            StructType::VirtualNicManagerNetConfig => Ok(from.as_any_box().downcast::<VirtualNicManagerNetConfig>()?),
            StructType::HostVirtualNicManagerNicTypeSelection => Ok(from.as_any_box().downcast::<HostVirtualNicManagerNicTypeSelection>()?),
            StructType::HostVirtualNicManagerInfo => Ok(from.as_any_box().downcast::<HostVirtualNicManagerInfo>()?),
            StructType::HostVirtualSwitch => Ok(from.as_any_box().downcast::<HostVirtualSwitch>()?),
            StructType::HostVirtualSwitchBeaconConfig => Ok(from.as_any_box().downcast::<HostVirtualSwitchBeaconConfig>()?),
            StructType::HostVirtualSwitchBridge => Ok(from.as_any_box().downcast::<HostVirtualSwitchBridge>()?),
            StructType::HostVirtualSwitchAutoBridge => Ok(from.as_any_box().downcast::<HostVirtualSwitchAutoBridge>()?),
            StructType::HostVirtualSwitchBondBridge => Ok(from.as_any_box().downcast::<HostVirtualSwitchBondBridge>()?),
            StructType::HostVirtualSwitchSimpleBridge => Ok(from.as_any_box().downcast::<HostVirtualSwitchSimpleBridge>()?),
            StructType::HostVirtualSwitchConfig => Ok(from.as_any_box().downcast::<HostVirtualSwitchConfig>()?),
            StructType::HostVirtualSwitchSpec => Ok(from.as_any_box().downcast::<HostVirtualSwitchSpec>()?),
            StructType::HostVmciAccessManagerAccessSpec => Ok(from.as_any_box().downcast::<HostVmciAccessManagerAccessSpec>()?),
            StructType::VmfsDatastoreOption => Ok(from.as_any_box().downcast::<VmfsDatastoreOption>()?),
            StructType::VmfsDatastoreBaseOption => Ok(from.as_any_box().downcast::<VmfsDatastoreBaseOption>()?),
            StructType::VmfsDatastoreMultipleExtentOption => Ok(from.as_any_box().downcast::<VmfsDatastoreMultipleExtentOption>()?),
            StructType::VmfsDatastoreSingleExtentOption => Ok(from.as_any_box().downcast::<VmfsDatastoreSingleExtentOption>()?),
            StructType::VmfsDatastoreAllExtentOption => Ok(from.as_any_box().downcast::<VmfsDatastoreAllExtentOption>()?),
            StructType::VmfsDatastoreSpec => Ok(from.as_any_box().downcast::<VmfsDatastoreSpec>()?),
            StructType::VmfsDatastoreCreateSpec => Ok(from.as_any_box().downcast::<VmfsDatastoreCreateSpec>()?),
            StructType::VmfsDatastoreExpandSpec => Ok(from.as_any_box().downcast::<VmfsDatastoreExpandSpec>()?),
            StructType::VmfsDatastoreExtendSpec => Ok(from.as_any_box().downcast::<VmfsDatastoreExtendSpec>()?),
            StructType::HostVmfsRescanResult => Ok(from.as_any_box().downcast::<HostVmfsRescanResult>()?),
            StructType::VmfsConfigOption => Ok(from.as_any_box().downcast::<VmfsConfigOption>()?),
            StructType::HostVmfsSpec => Ok(from.as_any_box().downcast::<HostVmfsSpec>()?),
            StructType::VmfsUnmapBandwidthSpec => Ok(from.as_any_box().downcast::<VmfsUnmapBandwidthSpec>()?),
            StructType::HostVsanInternalSystemCmmdsQuery => Ok(from.as_any_box().downcast::<HostVsanInternalSystemCmmdsQuery>()?),
            StructType::HostVsanInternalSystemDeleteVsanObjectsResult => Ok(from.as_any_box().downcast::<HostVsanInternalSystemDeleteVsanObjectsResult>()?),
            StructType::VsanNewPolicyBatch => Ok(from.as_any_box().downcast::<VsanNewPolicyBatch>()?),
            StructType::VsanPolicyChangeBatch => Ok(from.as_any_box().downcast::<VsanPolicyChangeBatch>()?),
            StructType::VsanPolicyCost => Ok(from.as_any_box().downcast::<VsanPolicyCost>()?),
            StructType::VsanPolicySatisfiability => Ok(from.as_any_box().downcast::<VsanPolicySatisfiability>()?),
            StructType::HostVsanInternalSystemVsanObjectOperationResult => Ok(from.as_any_box().downcast::<HostVsanInternalSystemVsanObjectOperationResult>()?),
            StructType::HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult => Ok(from.as_any_box().downcast::<HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult>()?),
            StructType::HostVvolNqn => Ok(from.as_any_box().downcast::<HostVvolNqn>()?),
            StructType::VVolHostPe => Ok(from.as_any_box().downcast::<VVolHostPe>()?),
            StructType::HostVvolVolumeHostVvolNqn => Ok(from.as_any_box().downcast::<HostVvolVolumeHostVvolNqn>()?),
            StructType::HostVvolVolumeSpecification => Ok(from.as_any_box().downcast::<HostVvolVolumeSpecification>()?),
            StructType::NetDhcpConfigInfo => Ok(from.as_any_box().downcast::<NetDhcpConfigInfo>()?),
            StructType::NetDhcpConfigInfoDhcpOptions => Ok(from.as_any_box().downcast::<NetDhcpConfigInfoDhcpOptions>()?),
            StructType::NetDhcpConfigSpec => Ok(from.as_any_box().downcast::<NetDhcpConfigSpec>()?),
            StructType::NetDhcpConfigSpecDhcpOptionsSpec => Ok(from.as_any_box().downcast::<NetDhcpConfigSpecDhcpOptionsSpec>()?),
            StructType::NetDnsConfigInfo => Ok(from.as_any_box().downcast::<NetDnsConfigInfo>()?),
            StructType::NetDnsConfigSpec => Ok(from.as_any_box().downcast::<NetDnsConfigSpec>()?),
            StructType::NetIpConfigInfo => Ok(from.as_any_box().downcast::<NetIpConfigInfo>()?),
            StructType::NetIpConfigInfoIpAddress => Ok(from.as_any_box().downcast::<NetIpConfigInfoIpAddress>()?),
            StructType::NetIpConfigSpec => Ok(from.as_any_box().downcast::<NetIpConfigSpec>()?),
            StructType::NetIpConfigSpecIpAddressSpec => Ok(from.as_any_box().downcast::<NetIpConfigSpecIpAddressSpec>()?),
            StructType::NetIpRouteConfigInfo => Ok(from.as_any_box().downcast::<NetIpRouteConfigInfo>()?),
            StructType::NetIpRouteConfigInfoGateway => Ok(from.as_any_box().downcast::<NetIpRouteConfigInfoGateway>()?),
            StructType::NetIpRouteConfigInfoIpRoute => Ok(from.as_any_box().downcast::<NetIpRouteConfigInfoIpRoute>()?),
            StructType::NetIpRouteConfigSpec => Ok(from.as_any_box().downcast::<NetIpRouteConfigSpec>()?),
            StructType::NetIpRouteConfigSpecGatewaySpec => Ok(from.as_any_box().downcast::<NetIpRouteConfigSpecGatewaySpec>()?),
            StructType::NetIpRouteConfigSpecIpRouteSpec => Ok(from.as_any_box().downcast::<NetIpRouteConfigSpecIpRouteSpec>()?),
            StructType::NetIpStackInfo => Ok(from.as_any_box().downcast::<NetIpStackInfo>()?),
            StructType::NetIpStackInfoDefaultRouter => Ok(from.as_any_box().downcast::<NetIpStackInfoDefaultRouter>()?),
            StructType::NetIpStackInfoNetToMedia => Ok(from.as_any_box().downcast::<NetIpStackInfoNetToMedia>()?),
            StructType::NetBiosConfigInfo => Ok(from.as_any_box().downcast::<NetBiosConfigInfo>()?),
            StructType::WinNetBiosConfigInfo => Ok(from.as_any_box().downcast::<WinNetBiosConfigInfo>()?),
            StructType::ArrayUpdateSpec => Ok(from.as_any_box().downcast::<ArrayUpdateSpec>()?),
            StructType::ClusterDasVmConfigSpec => Ok(from.as_any_box().downcast::<ClusterDasVmConfigSpec>()?),
            StructType::ClusterDatastoreUpdateSpec => Ok(from.as_any_box().downcast::<ClusterDatastoreUpdateSpec>()?),
            StructType::ClusterDpmHostConfigSpec => Ok(from.as_any_box().downcast::<ClusterDpmHostConfigSpec>()?),
            StructType::ClusterDrsVmConfigSpec => Ok(from.as_any_box().downcast::<ClusterDrsVmConfigSpec>()?),
            StructType::ClusterGroupSpec => Ok(from.as_any_box().downcast::<ClusterGroupSpec>()?),
            StructType::ClusterPreemptibleVmPairSpec => Ok(from.as_any_box().downcast::<ClusterPreemptibleVmPairSpec>()?),
            StructType::ClusterRuleSpec => Ok(from.as_any_box().downcast::<ClusterRuleSpec>()?),
            StructType::ClusterTagCategoryUpdateSpec => Ok(from.as_any_box().downcast::<ClusterTagCategoryUpdateSpec>()?),
            StructType::ClusterVmOrchestrationSpec => Ok(from.as_any_box().downcast::<ClusterVmOrchestrationSpec>()?),
            StructType::StorageDrsOptionSpec => Ok(from.as_any_box().downcast::<StorageDrsOptionSpec>()?),
            StructType::StorageDrsVmConfigSpec => Ok(from.as_any_box().downcast::<StorageDrsVmConfigSpec>()?),
            StructType::VAppOvfSectionSpec => Ok(from.as_any_box().downcast::<VAppOvfSectionSpec>()?),
            StructType::VAppProductSpec => Ok(from.as_any_box().downcast::<VAppProductSpec>()?),
            StructType::VAppPropertySpec => Ok(from.as_any_box().downcast::<VAppPropertySpec>()?),
            StructType::VirtualMachineCpuIdInfoSpec => Ok(from.as_any_box().downcast::<VirtualMachineCpuIdInfoSpec>()?),
            StructType::OptionType => Ok(from.as_any_box().downcast::<OptionType>()?),
            StructType::BoolOption => Ok(from.as_any_box().downcast::<BoolOption>()?),
            StructType::ChoiceOption => Ok(from.as_any_box().downcast::<ChoiceOption>()?),
            StructType::FloatOption => Ok(from.as_any_box().downcast::<FloatOption>()?),
            StructType::IntOption => Ok(from.as_any_box().downcast::<IntOption>()?),
            StructType::LongOption => Ok(from.as_any_box().downcast::<LongOption>()?),
            StructType::StringOption => Ok(from.as_any_box().downcast::<StringOption>()?),
            StructType::OptionValue => Ok(from.as_any_box().downcast::<OptionValue>()?),
            StructType::HostInternetScsiHbaParamValue => Ok(from.as_any_box().downcast::<HostInternetScsiHbaParamValue>()?),
            StructType::ApplyProfile => Ok(from.as_any_box().downcast::<ApplyProfile>()?),
            StructType::ProfileApplyProfileElement => Ok(from.as_any_box().downcast::<ProfileApplyProfileElement>()?),
            StructType::ActiveDirectoryProfile => Ok(from.as_any_box().downcast::<ActiveDirectoryProfile>()?),
            StructType::AuthenticationProfile => Ok(from.as_any_box().downcast::<AuthenticationProfile>()?),
            StructType::DateTimeProfile => Ok(from.as_any_box().downcast::<DateTimeProfile>()?),
            StructType::DvsProfile => Ok(from.as_any_box().downcast::<DvsProfile>()?),
            StructType::DvsVNicProfile => Ok(from.as_any_box().downcast::<DvsVNicProfile>()?),
            StructType::DvsHostVNicProfile => Ok(from.as_any_box().downcast::<DvsHostVNicProfile>()?),
            StructType::DvsServiceConsoleVNicProfile => Ok(from.as_any_box().downcast::<DvsServiceConsoleVNicProfile>()?),
            StructType::FirewallProfile => Ok(from.as_any_box().downcast::<FirewallProfile>()?),
            StructType::FirewallProfileRulesetProfile => Ok(from.as_any_box().downcast::<FirewallProfileRulesetProfile>()?),
            StructType::HostApplyProfile => Ok(from.as_any_box().downcast::<HostApplyProfile>()?),
            StructType::HostMemoryProfile => Ok(from.as_any_box().downcast::<HostMemoryProfile>()?),
            StructType::IpAddressProfile => Ok(from.as_any_box().downcast::<IpAddressProfile>()?),
            StructType::IpRouteProfile => Ok(from.as_any_box().downcast::<IpRouteProfile>()?),
            StructType::NasStorageProfile => Ok(from.as_any_box().downcast::<NasStorageProfile>()?),
            StructType::NetStackInstanceProfile => Ok(from.as_any_box().downcast::<NetStackInstanceProfile>()?),
            StructType::NetworkPolicyProfile => Ok(from.as_any_box().downcast::<NetworkPolicyProfile>()?),
            StructType::NetworkProfile => Ok(from.as_any_box().downcast::<NetworkProfile>()?),
            StructType::NetworkProfileDnsConfigProfile => Ok(from.as_any_box().downcast::<NetworkProfileDnsConfigProfile>()?),
            StructType::NsxHostVNicProfile => Ok(from.as_any_box().downcast::<NsxHostVNicProfile>()?),
            StructType::OpaqueSwitchProfile => Ok(from.as_any_box().downcast::<OpaqueSwitchProfile>()?),
            StructType::OptionProfile => Ok(from.as_any_box().downcast::<OptionProfile>()?),
            StructType::PermissionProfile => Ok(from.as_any_box().downcast::<PermissionProfile>()?),
            StructType::PhysicalNicProfile => Ok(from.as_any_box().downcast::<PhysicalNicProfile>()?),
            StructType::PnicUplinkProfile => Ok(from.as_any_box().downcast::<PnicUplinkProfile>()?),
            StructType::PortGroupProfile => Ok(from.as_any_box().downcast::<PortGroupProfile>()?),
            StructType::HostPortGroupProfile => Ok(from.as_any_box().downcast::<HostPortGroupProfile>()?),
            StructType::ServiceConsolePortGroupProfile => Ok(from.as_any_box().downcast::<ServiceConsolePortGroupProfile>()?),
            StructType::VmPortGroupProfile => Ok(from.as_any_box().downcast::<VmPortGroupProfile>()?),
            StructType::VirtualSwitchSelectionProfile => Ok(from.as_any_box().downcast::<VirtualSwitchSelectionProfile>()?),
            StructType::VlanProfile => Ok(from.as_any_box().downcast::<VlanProfile>()?),
            StructType::SecurityProfile => Ok(from.as_any_box().downcast::<SecurityProfile>()?),
            StructType::ServiceProfile => Ok(from.as_any_box().downcast::<ServiceProfile>()?),
            StructType::StaticRouteProfile => Ok(from.as_any_box().downcast::<StaticRouteProfile>()?),
            StructType::StorageProfile => Ok(from.as_any_box().downcast::<StorageProfile>()?),
            StructType::UserGroupProfile => Ok(from.as_any_box().downcast::<UserGroupProfile>()?),
            StructType::UserProfile => Ok(from.as_any_box().downcast::<UserProfile>()?),
            StructType::VirtualSwitchProfile => Ok(from.as_any_box().downcast::<VirtualSwitchProfile>()?),
            StructType::LinkProfile => Ok(from.as_any_box().downcast::<LinkProfile>()?),
            StructType::NumPortsProfile => Ok(from.as_any_box().downcast::<NumPortsProfile>()?),
            StructType::ProfileApplyProfileProperty => Ok(from.as_any_box().downcast::<ProfileApplyProfileProperty>()?),
            StructType::ComplianceLocator => Ok(from.as_any_box().downcast::<ComplianceLocator>()?),
            StructType::ComplianceProfile => Ok(from.as_any_box().downcast::<ComplianceProfile>()?),
            StructType::ComplianceResult => Ok(from.as_any_box().downcast::<ComplianceResult>()?),
            StructType::ComplianceFailure => Ok(from.as_any_box().downcast::<ComplianceFailure>()?),
            StructType::ComplianceFailureComplianceFailureValues => Ok(from.as_any_box().downcast::<ComplianceFailureComplianceFailureValues>()?),
            StructType::ProfileDeferredPolicyOptionParameter => Ok(from.as_any_box().downcast::<ProfileDeferredPolicyOptionParameter>()?),
            StructType::ProfileExpression => Ok(from.as_any_box().downcast::<ProfileExpression>()?),
            StructType::ProfileCompositeExpression => Ok(from.as_any_box().downcast::<ProfileCompositeExpression>()?),
            StructType::ProfileSimpleExpression => Ok(from.as_any_box().downcast::<ProfileSimpleExpression>()?),
            StructType::ProfileExpressionMetadata => Ok(from.as_any_box().downcast::<ProfileExpressionMetadata>()?),
            StructType::ProfileParameterMetadata => Ok(from.as_any_box().downcast::<ProfileParameterMetadata>()?),
            StructType::ProfileParameterMetadataParameterRelationMetadata => Ok(from.as_any_box().downcast::<ProfileParameterMetadataParameterRelationMetadata>()?),
            StructType::ProfilePolicy => Ok(from.as_any_box().downcast::<ProfilePolicy>()?),
            StructType::ProfilePolicyMetadata => Ok(from.as_any_box().downcast::<ProfilePolicyMetadata>()?),
            StructType::PolicyOption => Ok(from.as_any_box().downcast::<PolicyOption>()?),
            StructType::CompositePolicyOption => Ok(from.as_any_box().downcast::<CompositePolicyOption>()?),
            StructType::ProfilePolicyOptionMetadata => Ok(from.as_any_box().downcast::<ProfilePolicyOptionMetadata>()?),
            StructType::ProfileCompositePolicyOptionMetadata => Ok(from.as_any_box().downcast::<ProfileCompositePolicyOptionMetadata>()?),
            StructType::UserInputRequiredParameterMetadata => Ok(from.as_any_box().downcast::<UserInputRequiredParameterMetadata>()?),
            StructType::ProfileConfigInfo => Ok(from.as_any_box().downcast::<ProfileConfigInfo>()?),
            StructType::ClusterProfileConfigInfo => Ok(from.as_any_box().downcast::<ClusterProfileConfigInfo>()?),
            StructType::HostProfileConfigInfo => Ok(from.as_any_box().downcast::<HostProfileConfigInfo>()?),
            StructType::ProfileCreateSpec => Ok(from.as_any_box().downcast::<ProfileCreateSpec>()?),
            StructType::ProfileSerializedCreateSpec => Ok(from.as_any_box().downcast::<ProfileSerializedCreateSpec>()?),
            StructType::HostProfileSerializedHostProfileSpec => Ok(from.as_any_box().downcast::<HostProfileSerializedHostProfileSpec>()?),
            StructType::ClusterProfileCreateSpec => Ok(from.as_any_box().downcast::<ClusterProfileCreateSpec>()?),
            StructType::ClusterProfileConfigSpec => Ok(from.as_any_box().downcast::<ClusterProfileConfigSpec>()?),
            StructType::ClusterProfileCompleteConfigSpec => Ok(from.as_any_box().downcast::<ClusterProfileCompleteConfigSpec>()?),
            StructType::ClusterProfileConfigServiceCreateSpec => Ok(from.as_any_box().downcast::<ClusterProfileConfigServiceCreateSpec>()?),
            StructType::HostProfileConfigSpec => Ok(from.as_any_box().downcast::<HostProfileConfigSpec>()?),
            StructType::HostProfileCompleteConfigSpec => Ok(from.as_any_box().downcast::<HostProfileCompleteConfigSpec>()?),
            StructType::HostProfileHostBasedConfigSpec => Ok(from.as_any_box().downcast::<HostProfileHostBasedConfigSpec>()?),
            StructType::ProfileDescription => Ok(from.as_any_box().downcast::<ProfileDescription>()?),
            StructType::ProfileDescriptionSection => Ok(from.as_any_box().downcast::<ProfileDescriptionSection>()?),
            StructType::ProfileMetadata => Ok(from.as_any_box().downcast::<ProfileMetadata>()?),
            StructType::ProfileMetadataProfileOperationMessage => Ok(from.as_any_box().downcast::<ProfileMetadataProfileOperationMessage>()?),
            StructType::ProfileMetadataProfileSortSpec => Ok(from.as_any_box().downcast::<ProfileMetadataProfileSortSpec>()?),
            StructType::ProfilePropertyPath => Ok(from.as_any_box().downcast::<ProfilePropertyPath>()?),
            StructType::ProfileProfileStructure => Ok(from.as_any_box().downcast::<ProfileProfileStructure>()?),
            StructType::ProfileProfileStructureProperty => Ok(from.as_any_box().downcast::<ProfileProfileStructureProperty>()?),
            StructType::AnswerFile => Ok(from.as_any_box().downcast::<AnswerFile>()?),
            StructType::AnswerFileStatusResult => Ok(from.as_any_box().downcast::<AnswerFileStatusResult>()?),
            StructType::AnswerFileStatusError => Ok(from.as_any_box().downcast::<AnswerFileStatusError>()?),
            StructType::ProfileExecuteResult => Ok(from.as_any_box().downcast::<ProfileExecuteResult>()?),
            StructType::ApplyHostProfileConfigurationSpec => Ok(from.as_any_box().downcast::<ApplyHostProfileConfigurationSpec>()?),
            StructType::ProfileExecuteError => Ok(from.as_any_box().downcast::<ProfileExecuteError>()?),
            StructType::HostProfileValidationFailureInfo => Ok(from.as_any_box().downcast::<HostProfileValidationFailureInfo>()?),
            StructType::HostSpecification => Ok(from.as_any_box().downcast::<HostSpecification>()?),
            StructType::HostSubSpecification => Ok(from.as_any_box().downcast::<HostSubSpecification>()?),
            StructType::AnswerFileCreateSpec => Ok(from.as_any_box().downcast::<AnswerFileCreateSpec>()?),
            StructType::AnswerFileOptionsCreateSpec => Ok(from.as_any_box().downcast::<AnswerFileOptionsCreateSpec>()?),
            StructType::AnswerFileSerializedCreateSpec => Ok(from.as_any_box().downcast::<AnswerFileSerializedCreateSpec>()?),
            StructType::ApplyHostProfileConfigurationResult => Ok(from.as_any_box().downcast::<ApplyHostProfileConfigurationResult>()?),
            StructType::HostProfileManagerCompositionResult => Ok(from.as_any_box().downcast::<HostProfileManagerCompositionResult>()?),
            StructType::HostProfileManagerCompositionResultResultElement => Ok(from.as_any_box().downcast::<HostProfileManagerCompositionResultResultElement>()?),
            StructType::HostProfileManagerCompositionValidationResult => Ok(from.as_any_box().downcast::<HostProfileManagerCompositionValidationResult>()?),
            StructType::HostProfileManagerCompositionValidationResultResultElement => Ok(from.as_any_box().downcast::<HostProfileManagerCompositionValidationResultResultElement>()?),
            StructType::HostProfileManagerConfigTaskList => Ok(from.as_any_box().downcast::<HostProfileManagerConfigTaskList>()?),
            StructType::HostProfilesEntityCustomizations => Ok(from.as_any_box().downcast::<HostProfilesEntityCustomizations>()?),
            StructType::StructuredCustomizations => Ok(from.as_any_box().downcast::<StructuredCustomizations>()?),
            StructType::HostProfileManagerHostToConfigSpecMap => Ok(from.as_any_box().downcast::<HostProfileManagerHostToConfigSpecMap>()?),
            StructType::ScheduledTaskDescription => Ok(from.as_any_box().downcast::<ScheduledTaskDescription>()?),
            StructType::ScheduledTaskSpec => Ok(from.as_any_box().downcast::<ScheduledTaskSpec>()?),
            StructType::ScheduledTaskInfo => Ok(from.as_any_box().downcast::<ScheduledTaskInfo>()?),
            StructType::TaskScheduler => Ok(from.as_any_box().downcast::<TaskScheduler>()?),
            StructType::AfterStartupTaskScheduler => Ok(from.as_any_box().downcast::<AfterStartupTaskScheduler>()?),
            StructType::OnceTaskScheduler => Ok(from.as_any_box().downcast::<OnceTaskScheduler>()?),
            StructType::RecurrentTaskScheduler => Ok(from.as_any_box().downcast::<RecurrentTaskScheduler>()?),
            StructType::HourlyTaskScheduler => Ok(from.as_any_box().downcast::<HourlyTaskScheduler>()?),
            StructType::DailyTaskScheduler => Ok(from.as_any_box().downcast::<DailyTaskScheduler>()?),
            StructType::MonthlyTaskScheduler => Ok(from.as_any_box().downcast::<MonthlyTaskScheduler>()?),
            StructType::MonthlyByDayTaskScheduler => Ok(from.as_any_box().downcast::<MonthlyByDayTaskScheduler>()?),
            StructType::MonthlyByWeekdayTaskScheduler => Ok(from.as_any_box().downcast::<MonthlyByWeekdayTaskScheduler>()?),
            StructType::WeeklyTaskScheduler => Ok(from.as_any_box().downcast::<WeeklyTaskScheduler>()?),
            StructType::ApplyStorageRecommendationResult => Ok(from.as_any_box().downcast::<ApplyStorageRecommendationResult>()?),
            StructType::StorageDrsAutomationConfig => Ok(from.as_any_box().downcast::<StorageDrsAutomationConfig>()?),
            StructType::StorageDrsConfigInfo => Ok(from.as_any_box().downcast::<StorageDrsConfigInfo>()?),
            StructType::StorageDrsConfigSpec => Ok(from.as_any_box().downcast::<StorageDrsConfigSpec>()?),
            StructType::StorageDrsIoLoadBalanceConfig => Ok(from.as_any_box().downcast::<StorageDrsIoLoadBalanceConfig>()?),
            StructType::PlacementAffinityRule => Ok(from.as_any_box().downcast::<PlacementAffinityRule>()?),
            StructType::PlacementRankResult => Ok(from.as_any_box().downcast::<PlacementRankResult>()?),
            StructType::PlacementRankSpec => Ok(from.as_any_box().downcast::<PlacementRankSpec>()?),
            StructType::StorageDrsPlacementRankVmSpec => Ok(from.as_any_box().downcast::<StorageDrsPlacementRankVmSpec>()?),
            StructType::StorageDrsPodConfigInfo => Ok(from.as_any_box().downcast::<StorageDrsPodConfigInfo>()?),
            StructType::StorageDrsPodConfigSpec => Ok(from.as_any_box().downcast::<StorageDrsPodConfigSpec>()?),
            StructType::StorageDrsPodSelectionSpec => Ok(from.as_any_box().downcast::<StorageDrsPodSelectionSpec>()?),
            StructType::PodDiskLocator => Ok(from.as_any_box().downcast::<PodDiskLocator>()?),
            StructType::VmPodConfigForPlacement => Ok(from.as_any_box().downcast::<VmPodConfigForPlacement>()?),
            StructType::StorageDrsSpaceLoadBalanceConfig => Ok(from.as_any_box().downcast::<StorageDrsSpaceLoadBalanceConfig>()?),
            StructType::StoragePlacementResult => Ok(from.as_any_box().downcast::<StoragePlacementResult>()?),
            StructType::StoragePlacementSpec => Ok(from.as_any_box().downcast::<StoragePlacementSpec>()?),
            StructType::StorageDrsVmConfigInfo => Ok(from.as_any_box().downcast::<StorageDrsVmConfigInfo>()?),
            StructType::VAppCloneSpec => Ok(from.as_any_box().downcast::<VAppCloneSpec>()?),
            StructType::VAppCloneSpecNetworkMappingPair => Ok(from.as_any_box().downcast::<VAppCloneSpecNetworkMappingPair>()?),
            StructType::VAppCloneSpecResourceMap => Ok(from.as_any_box().downcast::<VAppCloneSpecResourceMap>()?),
            StructType::VAppEntityConfigInfo => Ok(from.as_any_box().downcast::<VAppEntityConfigInfo>()?),
            StructType::VAppIpAssignmentInfo => Ok(from.as_any_box().downcast::<VAppIpAssignmentInfo>()?),
            StructType::IpPool => Ok(from.as_any_box().downcast::<IpPool>()?),
            StructType::IpPoolAssociation => Ok(from.as_any_box().downcast::<IpPoolAssociation>()?),
            StructType::IpPoolIpPoolConfigInfo => Ok(from.as_any_box().downcast::<IpPoolIpPoolConfigInfo>()?),
            StructType::VAppOvfSectionInfo => Ok(from.as_any_box().downcast::<VAppOvfSectionInfo>()?),
            StructType::VAppProductInfo => Ok(from.as_any_box().downcast::<VAppProductInfo>()?),
            StructType::VAppPropertyInfo => Ok(from.as_any_box().downcast::<VAppPropertyInfo>()?),
            StructType::VmConfigInfo => Ok(from.as_any_box().downcast::<VmConfigInfo>()?),
            StructType::VAppConfigInfo => Ok(from.as_any_box().downcast::<VAppConfigInfo>()?),
            StructType::VmConfigSpec => Ok(from.as_any_box().downcast::<VmConfigSpec>()?),
            StructType::VAppConfigSpec => Ok(from.as_any_box().downcast::<VAppConfigSpec>()?),
            StructType::ClusterNetworkConfigSpec => Ok(from.as_any_box().downcast::<ClusterNetworkConfigSpec>()?),
            StructType::FailoverNodeInfo => Ok(from.as_any_box().downcast::<FailoverNodeInfo>()?),
            StructType::NodeDeploymentSpec => Ok(from.as_any_box().downcast::<NodeDeploymentSpec>()?),
            StructType::PassiveNodeDeploymentSpec => Ok(from.as_any_box().downcast::<PassiveNodeDeploymentSpec>()?),
            StructType::NodeNetworkSpec => Ok(from.as_any_box().downcast::<NodeNetworkSpec>()?),
            StructType::PassiveNodeNetworkSpec => Ok(from.as_any_box().downcast::<PassiveNodeNetworkSpec>()?),
            StructType::SourceNodeSpec => Ok(from.as_any_box().downcast::<SourceNodeSpec>()?),
            StructType::VchaClusterConfigInfo => Ok(from.as_any_box().downcast::<VchaClusterConfigInfo>()?),
            StructType::VchaClusterConfigSpec => Ok(from.as_any_box().downcast::<VchaClusterConfigSpec>()?),
            StructType::VchaClusterDeploymentSpec => Ok(from.as_any_box().downcast::<VchaClusterDeploymentSpec>()?),
            StructType::VchaClusterNetworkSpec => Ok(from.as_any_box().downcast::<VchaClusterNetworkSpec>()?),
            StructType::WitnessNodeInfo => Ok(from.as_any_box().downcast::<WitnessNodeInfo>()?),
            StructType::VchaClusterHealth => Ok(from.as_any_box().downcast::<VchaClusterHealth>()?),
            StructType::VchaClusterRuntimeInfo => Ok(from.as_any_box().downcast::<VchaClusterRuntimeInfo>()?),
            StructType::VchaNodeRuntimeInfo => Ok(from.as_any_box().downcast::<VchaNodeRuntimeInfo>()?),
            StructType::VirtualMachineAffinityInfo => Ok(from.as_any_box().downcast::<VirtualMachineAffinityInfo>()?),
            StructType::VirtualMachineBaseIndependentFilterSpec => Ok(from.as_any_box().downcast::<VirtualMachineBaseIndependentFilterSpec>()?),
            StructType::VirtualMachineEmptyIndependentFilterSpec => Ok(from.as_any_box().downcast::<VirtualMachineEmptyIndependentFilterSpec>()?),
            StructType::VirtualMachineIndependentFilterSpec => Ok(from.as_any_box().downcast::<VirtualMachineIndependentFilterSpec>()?),
            StructType::VirtualMachineBootOptions => Ok(from.as_any_box().downcast::<VirtualMachineBootOptions>()?),
            StructType::VirtualMachineBootOptionsBootableDevice => Ok(from.as_any_box().downcast::<VirtualMachineBootOptionsBootableDevice>()?),
            StructType::VirtualMachineBootOptionsBootableCdromDevice => Ok(from.as_any_box().downcast::<VirtualMachineBootOptionsBootableCdromDevice>()?),
            StructType::VirtualMachineBootOptionsBootableDiskDevice => Ok(from.as_any_box().downcast::<VirtualMachineBootOptionsBootableDiskDevice>()?),
            StructType::VirtualMachineBootOptionsBootableEthernetDevice => Ok(from.as_any_box().downcast::<VirtualMachineBootOptionsBootableEthernetDevice>()?),
            StructType::VirtualMachineBootOptionsBootableFloppyDevice => Ok(from.as_any_box().downcast::<VirtualMachineBootOptionsBootableFloppyDevice>()?),
            StructType::VirtualMachineCapability => Ok(from.as_any_box().downcast::<VirtualMachineCapability>()?),
            StructType::VirtualMachineCertThumbprint => Ok(from.as_any_box().downcast::<VirtualMachineCertThumbprint>()?),
            StructType::VirtualMachineCloneSpec => Ok(from.as_any_box().downcast::<VirtualMachineCloneSpec>()?),
            StructType::VirtualMachineConfigInfo => Ok(from.as_any_box().downcast::<VirtualMachineConfigInfo>()?),
            StructType::VirtualMachineConfigInfoDatastoreUrlPair => Ok(from.as_any_box().downcast::<VirtualMachineConfigInfoDatastoreUrlPair>()?),
            StructType::VirtualMachineConfigInfoOverheadInfo => Ok(from.as_any_box().downcast::<VirtualMachineConfigInfoOverheadInfo>()?),
            StructType::VirtualMachineConfigOption => Ok(from.as_any_box().downcast::<VirtualMachineConfigOption>()?),
            StructType::VirtualMachineConfigOptionDescriptor => Ok(from.as_any_box().downcast::<VirtualMachineConfigOptionDescriptor>()?),
            StructType::VirtualMachineConfigSpec => Ok(from.as_any_box().downcast::<VirtualMachineConfigSpec>()?),
            StructType::ConfigTarget => Ok(from.as_any_box().downcast::<ConfigTarget>()?),
            StructType::VirtualMachineConsolePreferences => Ok(from.as_any_box().downcast::<VirtualMachineConsolePreferences>()?),
            StructType::VirtualMachineContentLibraryItemInfo => Ok(from.as_any_box().downcast::<VirtualMachineContentLibraryItemInfo>()?),
            StructType::DatastoreOption => Ok(from.as_any_box().downcast::<DatastoreOption>()?),
            StructType::VirtualMachineDatastoreVolumeOption => Ok(from.as_any_box().downcast::<VirtualMachineDatastoreVolumeOption>()?),
            StructType::VirtualMachineDefaultPowerOpInfo => Ok(from.as_any_box().downcast::<VirtualMachineDefaultPowerOpInfo>()?),
            StructType::VirtualMachineDeviceRuntimeInfo => Ok(from.as_any_box().downcast::<VirtualMachineDeviceRuntimeInfo>()?),
            StructType::VirtualMachineDeviceRuntimeInfoDeviceRuntimeState => Ok(from.as_any_box().downcast::<VirtualMachineDeviceRuntimeInfoDeviceRuntimeState>()?),
            StructType::VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState => Ok(from.as_any_box().downcast::<VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState>()?),
            StructType::VirtualMachineDvxClassInfo => Ok(from.as_any_box().downcast::<VirtualMachineDvxClassInfo>()?),
            StructType::FaultToleranceConfigInfo => Ok(from.as_any_box().downcast::<FaultToleranceConfigInfo>()?),
            StructType::FaultTolerancePrimaryConfigInfo => Ok(from.as_any_box().downcast::<FaultTolerancePrimaryConfigInfo>()?),
            StructType::FaultToleranceSecondaryConfigInfo => Ok(from.as_any_box().downcast::<FaultToleranceSecondaryConfigInfo>()?),
            StructType::FaultToleranceConfigSpec => Ok(from.as_any_box().downcast::<FaultToleranceConfigSpec>()?),
            StructType::FaultToleranceMetaSpec => Ok(from.as_any_box().downcast::<FaultToleranceMetaSpec>()?),
            StructType::FaultToleranceSecondaryOpResult => Ok(from.as_any_box().downcast::<FaultToleranceSecondaryOpResult>()?),
            StructType::FaultToleranceVmConfigSpec => Ok(from.as_any_box().downcast::<FaultToleranceVmConfigSpec>()?),
            StructType::FaultToleranceDiskSpec => Ok(from.as_any_box().downcast::<FaultToleranceDiskSpec>()?),
            StructType::VirtualMachineFeatureRequirement => Ok(from.as_any_box().downcast::<VirtualMachineFeatureRequirement>()?),
            StructType::VirtualMachineFileInfo => Ok(from.as_any_box().downcast::<VirtualMachineFileInfo>()?),
            StructType::VirtualMachineFileLayout => Ok(from.as_any_box().downcast::<VirtualMachineFileLayout>()?),
            StructType::VirtualMachineFileLayoutDiskLayout => Ok(from.as_any_box().downcast::<VirtualMachineFileLayoutDiskLayout>()?),
            StructType::VirtualMachineFileLayoutSnapshotLayout => Ok(from.as_any_box().downcast::<VirtualMachineFileLayoutSnapshotLayout>()?),
            StructType::VirtualMachineFileLayoutEx => Ok(from.as_any_box().downcast::<VirtualMachineFileLayoutEx>()?),
            StructType::VirtualMachineFileLayoutExDiskLayout => Ok(from.as_any_box().downcast::<VirtualMachineFileLayoutExDiskLayout>()?),
            StructType::VirtualMachineFileLayoutExDiskUnit => Ok(from.as_any_box().downcast::<VirtualMachineFileLayoutExDiskUnit>()?),
            StructType::VirtualMachineFileLayoutExFileInfo => Ok(from.as_any_box().downcast::<VirtualMachineFileLayoutExFileInfo>()?),
            StructType::VirtualMachineFileLayoutExSnapshotLayout => Ok(from.as_any_box().downcast::<VirtualMachineFileLayoutExSnapshotLayout>()?),
            StructType::VirtualMachineFlagInfo => Ok(from.as_any_box().downcast::<VirtualMachineFlagInfo>()?),
            StructType::VirtualMachineForkConfigInfo => Ok(from.as_any_box().downcast::<VirtualMachineForkConfigInfo>()?),
            StructType::GuestInfo => Ok(from.as_any_box().downcast::<GuestInfo>()?),
            StructType::GuestInfoCustomizationInfo => Ok(from.as_any_box().downcast::<GuestInfoCustomizationInfo>()?),
            StructType::GuestDiskInfo => Ok(from.as_any_box().downcast::<GuestDiskInfo>()?),
            StructType::GuestInfoNamespaceGenerationInfo => Ok(from.as_any_box().downcast::<GuestInfoNamespaceGenerationInfo>()?),
            StructType::GuestNicInfo => Ok(from.as_any_box().downcast::<GuestNicInfo>()?),
            StructType::GuestScreenInfo => Ok(from.as_any_box().downcast::<GuestScreenInfo>()?),
            StructType::GuestStackInfo => Ok(from.as_any_box().downcast::<GuestStackInfo>()?),
            StructType::GuestInfoVirtualDiskMapping => Ok(from.as_any_box().downcast::<GuestInfoVirtualDiskMapping>()?),
            StructType::VirtualMachineGuestIntegrityInfo => Ok(from.as_any_box().downcast::<VirtualMachineGuestIntegrityInfo>()?),
            StructType::VirtualMachineGuestMonitoringModeInfo => Ok(from.as_any_box().downcast::<VirtualMachineGuestMonitoringModeInfo>()?),
            StructType::GuestOsDescriptor => Ok(from.as_any_box().downcast::<GuestOsDescriptor>()?),
            StructType::VirtualMachineGuestQuiesceSpec => Ok(from.as_any_box().downcast::<VirtualMachineGuestQuiesceSpec>()?),
            StructType::VirtualMachineWindowsQuiesceSpec => Ok(from.as_any_box().downcast::<VirtualMachineWindowsQuiesceSpec>()?),
            StructType::VirtualMachineIdeDiskDevicePartitionInfo => Ok(from.as_any_box().downcast::<VirtualMachineIdeDiskDevicePartitionInfo>()?),
            StructType::VirtualMachineInstantCloneSpec => Ok(from.as_any_box().downcast::<VirtualMachineInstantCloneSpec>()?),
            StructType::VirtualMachineLegacyNetworkSwitchInfo => Ok(from.as_any_box().downcast::<VirtualMachineLegacyNetworkSwitchInfo>()?),
            StructType::VirtualMachineMessage => Ok(from.as_any_box().downcast::<VirtualMachineMessage>()?),
            StructType::VirtualMachineMetadataManagerVmMetadata => Ok(from.as_any_box().downcast::<VirtualMachineMetadataManagerVmMetadata>()?),
            StructType::VirtualMachineMetadataManagerVmMetadataInput => Ok(from.as_any_box().downcast::<VirtualMachineMetadataManagerVmMetadataInput>()?),
            StructType::VirtualMachineMetadataManagerVmMetadataOwner => Ok(from.as_any_box().downcast::<VirtualMachineMetadataManagerVmMetadataOwner>()?),
            StructType::VirtualMachineMetadataManagerVmMetadataResult => Ok(from.as_any_box().downcast::<VirtualMachineMetadataManagerVmMetadataResult>()?),
            StructType::VirtualMachineNetworkShaperInfo => Ok(from.as_any_box().downcast::<VirtualMachineNetworkShaperInfo>()?),
            StructType::VirtualMachineProfileDetails => Ok(from.as_any_box().downcast::<VirtualMachineProfileDetails>()?),
            StructType::VirtualMachineProfileDetailsDiskProfileDetails => Ok(from.as_any_box().downcast::<VirtualMachineProfileDetailsDiskProfileDetails>()?),
            StructType::VirtualMachineProfileRawData => Ok(from.as_any_box().downcast::<VirtualMachineProfileRawData>()?),
            StructType::VirtualMachineProfileSpec => Ok(from.as_any_box().downcast::<VirtualMachineProfileSpec>()?),
            StructType::VirtualMachineDefaultProfileSpec => Ok(from.as_any_box().downcast::<VirtualMachineDefaultProfileSpec>()?),
            StructType::VirtualMachineDefinedProfileSpec => Ok(from.as_any_box().downcast::<VirtualMachineDefinedProfileSpec>()?),
            StructType::VirtualMachineEmptyProfileSpec => Ok(from.as_any_box().downcast::<VirtualMachineEmptyProfileSpec>()?),
            StructType::VirtualMachinePropertyRelation => Ok(from.as_any_box().downcast::<VirtualMachinePropertyRelation>()?),
            StructType::VirtualMachineQuestionInfo => Ok(from.as_any_box().downcast::<VirtualMachineQuestionInfo>()?),
            StructType::VirtualMachineRelocateSpec => Ok(from.as_any_box().downcast::<VirtualMachineRelocateSpec>()?),
            StructType::VirtualMachineRelocateSpecDiskLocator => Ok(from.as_any_box().downcast::<VirtualMachineRelocateSpecDiskLocator>()?),
            StructType::VirtualMachineRelocateSpecDiskLocatorBackingSpec => Ok(from.as_any_box().downcast::<VirtualMachineRelocateSpecDiskLocatorBackingSpec>()?),
            StructType::ReplicationConfigSpec => Ok(from.as_any_box().downcast::<ReplicationConfigSpec>()?),
            StructType::ReplicationInfoDiskSettings => Ok(from.as_any_box().downcast::<ReplicationInfoDiskSettings>()?),
            StructType::VirtualMachineRuntimeInfo => Ok(from.as_any_box().downcast::<VirtualMachineRuntimeInfo>()?),
            StructType::VirtualMachineRuntimeInfoDasProtectionState => Ok(from.as_any_box().downcast::<VirtualMachineRuntimeInfoDasProtectionState>()?),
            StructType::ScheduledHardwareUpgradeInfo => Ok(from.as_any_box().downcast::<ScheduledHardwareUpgradeInfo>()?),
            StructType::VirtualMachineSgxInfo => Ok(from.as_any_box().downcast::<VirtualMachineSgxInfo>()?),
            StructType::VirtualMachineSnapshotInfo => Ok(from.as_any_box().downcast::<VirtualMachineSnapshotInfo>()?),
            StructType::VirtualMachineSnapshotTree => Ok(from.as_any_box().downcast::<VirtualMachineSnapshotTree>()?),
            StructType::VirtualMachineSriovDevicePoolInfo => Ok(from.as_any_box().downcast::<VirtualMachineSriovDevicePoolInfo>()?),
            StructType::VirtualMachineSriovNetworkDevicePoolInfo => Ok(from.as_any_box().downcast::<VirtualMachineSriovNetworkDevicePoolInfo>()?),
            StructType::VirtualMachineStorageInfo => Ok(from.as_any_box().downcast::<VirtualMachineStorageInfo>()?),
            StructType::VirtualMachineUsageOnDatastore => Ok(from.as_any_box().downcast::<VirtualMachineUsageOnDatastore>()?),
            StructType::VirtualMachineSummary => Ok(from.as_any_box().downcast::<VirtualMachineSummary>()?),
            StructType::VirtualMachineConfigSummary => Ok(from.as_any_box().downcast::<VirtualMachineConfigSummary>()?),
            StructType::VirtualMachineGuestSummary => Ok(from.as_any_box().downcast::<VirtualMachineGuestSummary>()?),
            StructType::VirtualMachineQuickStats => Ok(from.as_any_box().downcast::<VirtualMachineQuickStats>()?),
            StructType::VirtualMachineQuickStatsMemoryTierStats => Ok(from.as_any_box().downcast::<VirtualMachineQuickStatsMemoryTierStats>()?),
            StructType::VirtualMachineStorageSummary => Ok(from.as_any_box().downcast::<VirtualMachineStorageSummary>()?),
            StructType::VirtualMachineTargetInfo => Ok(from.as_any_box().downcast::<VirtualMachineTargetInfo>()?),
            StructType::VirtualMachineCdromInfo => Ok(from.as_any_box().downcast::<VirtualMachineCdromInfo>()?),
            StructType::VirtualMachineDatastoreInfo => Ok(from.as_any_box().downcast::<VirtualMachineDatastoreInfo>()?),
            StructType::VirtualMachineDiskDeviceInfo => Ok(from.as_any_box().downcast::<VirtualMachineDiskDeviceInfo>()?),
            StructType::VirtualMachineIdeDiskDeviceInfo => Ok(from.as_any_box().downcast::<VirtualMachineIdeDiskDeviceInfo>()?),
            StructType::VirtualMachineScsiDiskDeviceInfo => Ok(from.as_any_box().downcast::<VirtualMachineScsiDiskDeviceInfo>()?),
            StructType::VirtualMachineDynamicPassthroughInfo => Ok(from.as_any_box().downcast::<VirtualMachineDynamicPassthroughInfo>()?),
            StructType::VirtualMachineFloppyInfo => Ok(from.as_any_box().downcast::<VirtualMachineFloppyInfo>()?),
            StructType::VirtualMachineNetworkInfo => Ok(from.as_any_box().downcast::<VirtualMachineNetworkInfo>()?),
            StructType::OpaqueNetworkTargetInfo => Ok(from.as_any_box().downcast::<OpaqueNetworkTargetInfo>()?),
            StructType::VirtualMachineParallelInfo => Ok(from.as_any_box().downcast::<VirtualMachineParallelInfo>()?),
            StructType::VirtualMachinePciPassthroughInfo => Ok(from.as_any_box().downcast::<VirtualMachinePciPassthroughInfo>()?),
            StructType::VirtualMachineSriovInfo => Ok(from.as_any_box().downcast::<VirtualMachineSriovInfo>()?),
            StructType::VirtualMachinePciSharedGpuPassthroughInfo => Ok(from.as_any_box().downcast::<VirtualMachinePciSharedGpuPassthroughInfo>()?),
            StructType::VirtualMachinePrecisionClockInfo => Ok(from.as_any_box().downcast::<VirtualMachinePrecisionClockInfo>()?),
            StructType::VirtualMachineScsiPassthroughInfo => Ok(from.as_any_box().downcast::<VirtualMachineScsiPassthroughInfo>()?),
            StructType::VirtualMachineSerialInfo => Ok(from.as_any_box().downcast::<VirtualMachineSerialInfo>()?),
            StructType::VirtualMachineSgxTargetInfo => Ok(from.as_any_box().downcast::<VirtualMachineSgxTargetInfo>()?),
            StructType::VirtualMachineSoundInfo => Ok(from.as_any_box().downcast::<VirtualMachineSoundInfo>()?),
            StructType::VirtualMachineUsbInfo => Ok(from.as_any_box().downcast::<VirtualMachineUsbInfo>()?),
            StructType::VirtualMachineVFlashModuleInfo => Ok(from.as_any_box().downcast::<VirtualMachineVFlashModuleInfo>()?),
            StructType::VirtualMachineVMotionStunTimeInfo => Ok(from.as_any_box().downcast::<VirtualMachineVMotionStunTimeInfo>()?),
            StructType::VirtualMachineVendorDeviceGroupInfo => Ok(from.as_any_box().downcast::<VirtualMachineVendorDeviceGroupInfo>()?),
            StructType::VirtualMachineVgpuDeviceInfo => Ok(from.as_any_box().downcast::<VirtualMachineVgpuDeviceInfo>()?),
            StructType::VirtualMachineVgpuProfileInfo => Ok(from.as_any_box().downcast::<VirtualMachineVgpuProfileInfo>()?),
            StructType::ToolsConfigInfo => Ok(from.as_any_box().downcast::<ToolsConfigInfo>()?),
            StructType::ToolsConfigInfoToolsLastInstallInfo => Ok(from.as_any_box().downcast::<ToolsConfigInfoToolsLastInstallInfo>()?),
            StructType::UsbScanCodeSpec => Ok(from.as_any_box().downcast::<UsbScanCodeSpec>()?),
            StructType::UsbScanCodeSpecKeyEvent => Ok(from.as_any_box().downcast::<UsbScanCodeSpecKeyEvent>()?),
            StructType::UsbScanCodeSpecModifierType => Ok(from.as_any_box().downcast::<UsbScanCodeSpecModifierType>()?),
            StructType::VirtualMachineVcpuConfig => Ok(from.as_any_box().downcast::<VirtualMachineVcpuConfig>()?),
            StructType::VirtualMachineVendorDeviceGroupInfoComponentDeviceInfo => Ok(from.as_any_box().downcast::<VirtualMachineVendorDeviceGroupInfoComponentDeviceInfo>()?),
            StructType::VirtualMachineVirtualDeviceGroups => Ok(from.as_any_box().downcast::<VirtualMachineVirtualDeviceGroups>()?),
            StructType::VirtualMachineVirtualDeviceGroupsDeviceGroup => Ok(from.as_any_box().downcast::<VirtualMachineVirtualDeviceGroupsDeviceGroup>()?),
            StructType::VirtualMachineVirtualDeviceGroupsVendorDeviceGroup => Ok(from.as_any_box().downcast::<VirtualMachineVirtualDeviceGroupsVendorDeviceGroup>()?),
            StructType::VirtualMachineVirtualDeviceSwap => Ok(from.as_any_box().downcast::<VirtualMachineVirtualDeviceSwap>()?),
            StructType::VirtualMachineVirtualDeviceSwapDeviceSwapInfo => Ok(from.as_any_box().downcast::<VirtualMachineVirtualDeviceSwapDeviceSwapInfo>()?),
            StructType::VirtualHardware => Ok(from.as_any_box().downcast::<VirtualHardware>()?),
            StructType::VirtualHardwareOption => Ok(from.as_any_box().downcast::<VirtualHardwareOption>()?),
            StructType::VirtualMachineVirtualNuma => Ok(from.as_any_box().downcast::<VirtualMachineVirtualNuma>()?),
            StructType::VirtualMachineVirtualNumaInfo => Ok(from.as_any_box().downcast::<VirtualMachineVirtualNumaInfo>()?),
            StructType::VirtualMachineVirtualPMem => Ok(from.as_any_box().downcast::<VirtualMachineVirtualPMem>()?),
            StructType::CheckResult => Ok(from.as_any_box().downcast::<CheckResult>()?),
            StructType::CustomizationAdapterMapping => Ok(from.as_any_box().downcast::<CustomizationAdapterMapping>()?),
            StructType::CustomizationGlobalIpSettings => Ok(from.as_any_box().downcast::<CustomizationGlobalIpSettings>()?),
            StructType::CustomizationGuiRunOnce => Ok(from.as_any_box().downcast::<CustomizationGuiRunOnce>()?),
            StructType::CustomizationGuiUnattended => Ok(from.as_any_box().downcast::<CustomizationGuiUnattended>()?),
            StructType::CustomizationIpSettings => Ok(from.as_any_box().downcast::<CustomizationIpSettings>()?),
            StructType::CustomizationIpSettingsIpV6AddressSpec => Ok(from.as_any_box().downcast::<CustomizationIpSettingsIpV6AddressSpec>()?),
            StructType::CustomizationIdentification => Ok(from.as_any_box().downcast::<CustomizationIdentification>()?),
            StructType::CustomizationIdentitySettings => Ok(from.as_any_box().downcast::<CustomizationIdentitySettings>()?),
            StructType::CustomizationCloudinitPrep => Ok(from.as_any_box().downcast::<CustomizationCloudinitPrep>()?),
            StructType::CustomizationLinuxPrep => Ok(from.as_any_box().downcast::<CustomizationLinuxPrep>()?),
            StructType::CustomizationSysprep => Ok(from.as_any_box().downcast::<CustomizationSysprep>()?),
            StructType::CustomizationSysprepText => Ok(from.as_any_box().downcast::<CustomizationSysprepText>()?),
            StructType::CustomizationIpGenerator => Ok(from.as_any_box().downcast::<CustomizationIpGenerator>()?),
            StructType::CustomizationCustomIpGenerator => Ok(from.as_any_box().downcast::<CustomizationCustomIpGenerator>()?),
            StructType::CustomizationDhcpIpGenerator => Ok(from.as_any_box().downcast::<CustomizationDhcpIpGenerator>()?),
            StructType::CustomizationFixedIp => Ok(from.as_any_box().downcast::<CustomizationFixedIp>()?),
            StructType::CustomizationUnknownIpGenerator => Ok(from.as_any_box().downcast::<CustomizationUnknownIpGenerator>()?),
            StructType::CustomizationIpV6Generator => Ok(from.as_any_box().downcast::<CustomizationIpV6Generator>()?),
            StructType::CustomizationAutoIpV6Generator => Ok(from.as_any_box().downcast::<CustomizationAutoIpV6Generator>()?),
            StructType::CustomizationCustomIpV6Generator => Ok(from.as_any_box().downcast::<CustomizationCustomIpV6Generator>()?),
            StructType::CustomizationDhcpIpV6Generator => Ok(from.as_any_box().downcast::<CustomizationDhcpIpV6Generator>()?),
            StructType::CustomizationFixedIpV6 => Ok(from.as_any_box().downcast::<CustomizationFixedIpV6>()?),
            StructType::CustomizationStatelessIpV6Generator => Ok(from.as_any_box().downcast::<CustomizationStatelessIpV6Generator>()?),
            StructType::CustomizationUnknownIpV6Generator => Ok(from.as_any_box().downcast::<CustomizationUnknownIpV6Generator>()?),
            StructType::CustomizationLicenseFilePrintData => Ok(from.as_any_box().downcast::<CustomizationLicenseFilePrintData>()?),
            StructType::CustomizationName => Ok(from.as_any_box().downcast::<CustomizationName>()?),
            StructType::CustomizationCustomName => Ok(from.as_any_box().downcast::<CustomizationCustomName>()?),
            StructType::CustomizationFixedName => Ok(from.as_any_box().downcast::<CustomizationFixedName>()?),
            StructType::CustomizationPrefixName => Ok(from.as_any_box().downcast::<CustomizationPrefixName>()?),
            StructType::CustomizationUnknownName => Ok(from.as_any_box().downcast::<CustomizationUnknownName>()?),
            StructType::CustomizationVirtualMachineName => Ok(from.as_any_box().downcast::<CustomizationVirtualMachineName>()?),
            StructType::CustomizationOptions => Ok(from.as_any_box().downcast::<CustomizationOptions>()?),
            StructType::CustomizationLinuxOptions => Ok(from.as_any_box().downcast::<CustomizationLinuxOptions>()?),
            StructType::CustomizationWinOptions => Ok(from.as_any_box().downcast::<CustomizationWinOptions>()?),
            StructType::CustomizationPassword => Ok(from.as_any_box().downcast::<CustomizationPassword>()?),
            StructType::CustomizationSpec => Ok(from.as_any_box().downcast::<CustomizationSpec>()?),
            StructType::CustomizationUserData => Ok(from.as_any_box().downcast::<CustomizationUserData>()?),
            StructType::HostDiskMappingInfo => Ok(from.as_any_box().downcast::<HostDiskMappingInfo>()?),
            StructType::HostDiskMappingPartitionInfo => Ok(from.as_any_box().downcast::<HostDiskMappingPartitionInfo>()?),
            StructType::HostDiskMappingOption => Ok(from.as_any_box().downcast::<HostDiskMappingOption>()?),
            StructType::HostDiskMappingPartitionOption => Ok(from.as_any_box().downcast::<HostDiskMappingPartitionOption>()?),
            StructType::VirtualDevice => Ok(from.as_any_box().downcast::<VirtualDevice>()?),
            StructType::VirtualCdrom => Ok(from.as_any_box().downcast::<VirtualCdrom>()?),
            StructType::VirtualController => Ok(from.as_any_box().downcast::<VirtualController>()?),
            StructType::VirtualIdeController => Ok(from.as_any_box().downcast::<VirtualIdeController>()?),
            StructType::VirtualNvdimmController => Ok(from.as_any_box().downcast::<VirtualNvdimmController>()?),
            StructType::VirtualNvmeController => Ok(from.as_any_box().downcast::<VirtualNvmeController>()?),
            StructType::VirtualPciController => Ok(from.as_any_box().downcast::<VirtualPciController>()?),
            StructType::VirtualPs2Controller => Ok(from.as_any_box().downcast::<VirtualPs2Controller>()?),
            StructType::VirtualSataController => Ok(from.as_any_box().downcast::<VirtualSataController>()?),
            StructType::VirtualAhciController => Ok(from.as_any_box().downcast::<VirtualAhciController>()?),
            StructType::VirtualScsiController => Ok(from.as_any_box().downcast::<VirtualScsiController>()?),
            StructType::ParaVirtualScsiController => Ok(from.as_any_box().downcast::<ParaVirtualScsiController>()?),
            StructType::VirtualBusLogicController => Ok(from.as_any_box().downcast::<VirtualBusLogicController>()?),
            StructType::VirtualLsiLogicController => Ok(from.as_any_box().downcast::<VirtualLsiLogicController>()?),
            StructType::VirtualLsiLogicSasController => Ok(from.as_any_box().downcast::<VirtualLsiLogicSasController>()?),
            StructType::VirtualSioController => Ok(from.as_any_box().downcast::<VirtualSioController>()?),
            StructType::VirtualUsbController => Ok(from.as_any_box().downcast::<VirtualUsbController>()?),
            StructType::VirtualUsbxhciController => Ok(from.as_any_box().downcast::<VirtualUsbxhciController>()?),
            StructType::VirtualDisk => Ok(from.as_any_box().downcast::<VirtualDisk>()?),
            StructType::VirtualEthernetCard => Ok(from.as_any_box().downcast::<VirtualEthernetCard>()?),
            StructType::VirtualE1000 => Ok(from.as_any_box().downcast::<VirtualE1000>()?),
            StructType::VirtualE1000E => Ok(from.as_any_box().downcast::<VirtualE1000E>()?),
            StructType::VirtualPcNet32 => Ok(from.as_any_box().downcast::<VirtualPcNet32>()?),
            StructType::VirtualSriovEthernetCard => Ok(from.as_any_box().downcast::<VirtualSriovEthernetCard>()?),
            StructType::VirtualVmxnet => Ok(from.as_any_box().downcast::<VirtualVmxnet>()?),
            StructType::VirtualVmxnet2 => Ok(from.as_any_box().downcast::<VirtualVmxnet2>()?),
            StructType::VirtualVmxnet3 => Ok(from.as_any_box().downcast::<VirtualVmxnet3>()?),
            StructType::VirtualVmxnet3Vrdma => Ok(from.as_any_box().downcast::<VirtualVmxnet3Vrdma>()?),
            StructType::VirtualFloppy => Ok(from.as_any_box().downcast::<VirtualFloppy>()?),
            StructType::VirtualKeyboard => Ok(from.as_any_box().downcast::<VirtualKeyboard>()?),
            StructType::VirtualNvdimm => Ok(from.as_any_box().downcast::<VirtualNvdimm>()?),
            StructType::VirtualPciPassthrough => Ok(from.as_any_box().downcast::<VirtualPciPassthrough>()?),
            StructType::VirtualParallelPort => Ok(from.as_any_box().downcast::<VirtualParallelPort>()?),
            StructType::VirtualPointingDevice => Ok(from.as_any_box().downcast::<VirtualPointingDevice>()?),
            StructType::VirtualPrecisionClock => Ok(from.as_any_box().downcast::<VirtualPrecisionClock>()?),
            StructType::VirtualScsiPassthrough => Ok(from.as_any_box().downcast::<VirtualScsiPassthrough>()?),
            StructType::VirtualSerialPort => Ok(from.as_any_box().downcast::<VirtualSerialPort>()?),
            StructType::VirtualSoundCard => Ok(from.as_any_box().downcast::<VirtualSoundCard>()?),
            StructType::VirtualEnsoniq1371 => Ok(from.as_any_box().downcast::<VirtualEnsoniq1371>()?),
            StructType::VirtualHdAudioCard => Ok(from.as_any_box().downcast::<VirtualHdAudioCard>()?),
            StructType::VirtualSoundBlaster16 => Ok(from.as_any_box().downcast::<VirtualSoundBlaster16>()?),
            StructType::VirtualTpm => Ok(from.as_any_box().downcast::<VirtualTpm>()?),
            StructType::VirtualUsb => Ok(from.as_any_box().downcast::<VirtualUsb>()?),
            StructType::VirtualMachineVmciDevice => Ok(from.as_any_box().downcast::<VirtualMachineVmciDevice>()?),
            StructType::VirtualMachineVmirom => Ok(from.as_any_box().downcast::<VirtualMachineVmirom>()?),
            StructType::VirtualMachineVideoCard => Ok(from.as_any_box().downcast::<VirtualMachineVideoCard>()?),
            StructType::VirtualWdt => Ok(from.as_any_box().downcast::<VirtualWdt>()?),
            StructType::VirtualDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualDeviceBackingInfo>()?),
            StructType::VirtualDeviceDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualDeviceDeviceBackingInfo>()?),
            StructType::VirtualCdromAtapiBackingInfo => Ok(from.as_any_box().downcast::<VirtualCdromAtapiBackingInfo>()?),
            StructType::VirtualCdromPassthroughBackingInfo => Ok(from.as_any_box().downcast::<VirtualCdromPassthroughBackingInfo>()?),
            StructType::VirtualDiskRawDiskVer2BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskRawDiskVer2BackingInfo>()?),
            StructType::VirtualDiskPartitionedRawDiskVer2BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskPartitionedRawDiskVer2BackingInfo>()?),
            StructType::VirtualEthernetCardLegacyNetworkBackingInfo => Ok(from.as_any_box().downcast::<VirtualEthernetCardLegacyNetworkBackingInfo>()?),
            StructType::VirtualEthernetCardNetworkBackingInfo => Ok(from.as_any_box().downcast::<VirtualEthernetCardNetworkBackingInfo>()?),
            StructType::VirtualFloppyDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualFloppyDeviceBackingInfo>()?),
            StructType::VirtualPciPassthroughDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualPciPassthroughDeviceBackingInfo>()?),
            StructType::VirtualPciPassthroughDynamicBackingInfo => Ok(from.as_any_box().downcast::<VirtualPciPassthroughDynamicBackingInfo>()?),
            StructType::VirtualParallelPortDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualParallelPortDeviceBackingInfo>()?),
            StructType::VirtualPointingDeviceDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualPointingDeviceDeviceBackingInfo>()?),
            StructType::VirtualScsiPassthroughDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualScsiPassthroughDeviceBackingInfo>()?),
            StructType::VirtualSerialPortDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualSerialPortDeviceBackingInfo>()?),
            StructType::VirtualSoundCardDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualSoundCardDeviceBackingInfo>()?),
            StructType::VirtualUsbRemoteHostBackingInfo => Ok(from.as_any_box().downcast::<VirtualUsbRemoteHostBackingInfo>()?),
            StructType::VirtualUsbusbBackingInfo => Ok(from.as_any_box().downcast::<VirtualUsbusbBackingInfo>()?),
            StructType::VirtualDeviceFileBackingInfo => Ok(from.as_any_box().downcast::<VirtualDeviceFileBackingInfo>()?),
            StructType::VirtualCdromIsoBackingInfo => Ok(from.as_any_box().downcast::<VirtualCdromIsoBackingInfo>()?),
            StructType::VirtualDiskFlatVer1BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskFlatVer1BackingInfo>()?),
            StructType::VirtualDiskFlatVer2BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskFlatVer2BackingInfo>()?),
            StructType::VirtualDiskLocalPMemBackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskLocalPMemBackingInfo>()?),
            StructType::VirtualDiskRawDiskMappingVer1BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskRawDiskMappingVer1BackingInfo>()?),
            StructType::VirtualDiskSeSparseBackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskSeSparseBackingInfo>()?),
            StructType::VirtualDiskSparseVer1BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskSparseVer1BackingInfo>()?),
            StructType::VirtualDiskSparseVer2BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskSparseVer2BackingInfo>()?),
            StructType::VirtualFloppyImageBackingInfo => Ok(from.as_any_box().downcast::<VirtualFloppyImageBackingInfo>()?),
            StructType::VirtualNvdimmBackingInfo => Ok(from.as_any_box().downcast::<VirtualNvdimmBackingInfo>()?),
            StructType::VirtualParallelPortFileBackingInfo => Ok(from.as_any_box().downcast::<VirtualParallelPortFileBackingInfo>()?),
            StructType::VirtualSerialPortFileBackingInfo => Ok(from.as_any_box().downcast::<VirtualSerialPortFileBackingInfo>()?),
            StructType::VirtualDevicePipeBackingInfo => Ok(from.as_any_box().downcast::<VirtualDevicePipeBackingInfo>()?),
            StructType::VirtualSerialPortPipeBackingInfo => Ok(from.as_any_box().downcast::<VirtualSerialPortPipeBackingInfo>()?),
            StructType::VirtualDeviceRemoteDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualDeviceRemoteDeviceBackingInfo>()?),
            StructType::VirtualCdromRemoteAtapiBackingInfo => Ok(from.as_any_box().downcast::<VirtualCdromRemoteAtapiBackingInfo>()?),
            StructType::VirtualCdromRemotePassthroughBackingInfo => Ok(from.as_any_box().downcast::<VirtualCdromRemotePassthroughBackingInfo>()?),
            StructType::VirtualFloppyRemoteDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualFloppyRemoteDeviceBackingInfo>()?),
            StructType::VirtualUsbRemoteClientBackingInfo => Ok(from.as_any_box().downcast::<VirtualUsbRemoteClientBackingInfo>()?),
            StructType::VirtualDeviceUriBackingInfo => Ok(from.as_any_box().downcast::<VirtualDeviceUriBackingInfo>()?),
            StructType::VirtualSerialPortUriBackingInfo => Ok(from.as_any_box().downcast::<VirtualSerialPortUriBackingInfo>()?),
            StructType::VirtualEthernetCardDistributedVirtualPortBackingInfo => Ok(from.as_any_box().downcast::<VirtualEthernetCardDistributedVirtualPortBackingInfo>()?),
            StructType::VirtualEthernetCardOpaqueNetworkBackingInfo => Ok(from.as_any_box().downcast::<VirtualEthernetCardOpaqueNetworkBackingInfo>()?),
            StructType::VirtualPciPassthroughDvxBackingInfo => Ok(from.as_any_box().downcast::<VirtualPciPassthroughDvxBackingInfo>()?),
            StructType::VirtualPciPassthroughPluginBackingInfo => Ok(from.as_any_box().downcast::<VirtualPciPassthroughPluginBackingInfo>()?),
            StructType::VirtualPciPassthroughVmiopBackingInfo => Ok(from.as_any_box().downcast::<VirtualPciPassthroughVmiopBackingInfo>()?),
            StructType::VirtualPrecisionClockSystemClockBackingInfo => Ok(from.as_any_box().downcast::<VirtualPrecisionClockSystemClockBackingInfo>()?),
            StructType::VirtualSerialPortThinPrintBackingInfo => Ok(from.as_any_box().downcast::<VirtualSerialPortThinPrintBackingInfo>()?),
            StructType::VirtualSriovEthernetCardSriovBackingInfo => Ok(from.as_any_box().downcast::<VirtualSriovEthernetCardSriovBackingInfo>()?),
            StructType::VirtualDeviceBusSlotInfo => Ok(from.as_any_box().downcast::<VirtualDeviceBusSlotInfo>()?),
            StructType::VirtualDevicePciBusSlotInfo => Ok(from.as_any_box().downcast::<VirtualDevicePciBusSlotInfo>()?),
            StructType::VirtualUsbControllerPciBusSlotInfo => Ok(from.as_any_box().downcast::<VirtualUsbControllerPciBusSlotInfo>()?),
            StructType::VirtualDeviceConnectInfo => Ok(from.as_any_box().downcast::<VirtualDeviceConnectInfo>()?),
            StructType::VirtualDeviceDeviceGroupInfo => Ok(from.as_any_box().downcast::<VirtualDeviceDeviceGroupInfo>()?),
            StructType::VirtualDeviceOption => Ok(from.as_any_box().downcast::<VirtualDeviceOption>()?),
            StructType::VirtualCdromOption => Ok(from.as_any_box().downcast::<VirtualCdromOption>()?),
            StructType::VirtualControllerOption => Ok(from.as_any_box().downcast::<VirtualControllerOption>()?),
            StructType::VirtualIdeControllerOption => Ok(from.as_any_box().downcast::<VirtualIdeControllerOption>()?),
            StructType::VirtualNvdimmControllerOption => Ok(from.as_any_box().downcast::<VirtualNvdimmControllerOption>()?),
            StructType::VirtualNvmeControllerOption => Ok(from.as_any_box().downcast::<VirtualNvmeControllerOption>()?),
            StructType::VirtualPciControllerOption => Ok(from.as_any_box().downcast::<VirtualPciControllerOption>()?),
            StructType::VirtualPs2ControllerOption => Ok(from.as_any_box().downcast::<VirtualPs2ControllerOption>()?),
            StructType::VirtualSataControllerOption => Ok(from.as_any_box().downcast::<VirtualSataControllerOption>()?),
            StructType::VirtualAhciControllerOption => Ok(from.as_any_box().downcast::<VirtualAhciControllerOption>()?),
            StructType::VirtualScsiControllerOption => Ok(from.as_any_box().downcast::<VirtualScsiControllerOption>()?),
            StructType::ParaVirtualScsiControllerOption => Ok(from.as_any_box().downcast::<ParaVirtualScsiControllerOption>()?),
            StructType::VirtualBusLogicControllerOption => Ok(from.as_any_box().downcast::<VirtualBusLogicControllerOption>()?),
            StructType::VirtualLsiLogicControllerOption => Ok(from.as_any_box().downcast::<VirtualLsiLogicControllerOption>()?),
            StructType::VirtualLsiLogicSasControllerOption => Ok(from.as_any_box().downcast::<VirtualLsiLogicSasControllerOption>()?),
            StructType::VirtualSioControllerOption => Ok(from.as_any_box().downcast::<VirtualSioControllerOption>()?),
            StructType::VirtualUsbControllerOption => Ok(from.as_any_box().downcast::<VirtualUsbControllerOption>()?),
            StructType::VirtualUsbxhciControllerOption => Ok(from.as_any_box().downcast::<VirtualUsbxhciControllerOption>()?),
            StructType::VirtualDiskOption => Ok(from.as_any_box().downcast::<VirtualDiskOption>()?),
            StructType::VirtualEthernetCardOption => Ok(from.as_any_box().downcast::<VirtualEthernetCardOption>()?),
            StructType::VirtualE1000Option => Ok(from.as_any_box().downcast::<VirtualE1000Option>()?),
            StructType::VirtualE1000EOption => Ok(from.as_any_box().downcast::<VirtualE1000EOption>()?),
            StructType::VirtualPcNet32Option => Ok(from.as_any_box().downcast::<VirtualPcNet32Option>()?),
            StructType::VirtualSriovEthernetCardOption => Ok(from.as_any_box().downcast::<VirtualSriovEthernetCardOption>()?),
            StructType::VirtualVmxnetOption => Ok(from.as_any_box().downcast::<VirtualVmxnetOption>()?),
            StructType::VirtualVmxnet2Option => Ok(from.as_any_box().downcast::<VirtualVmxnet2Option>()?),
            StructType::VirtualVmxnet3Option => Ok(from.as_any_box().downcast::<VirtualVmxnet3Option>()?),
            StructType::VirtualVmxnet3VrdmaOption => Ok(from.as_any_box().downcast::<VirtualVmxnet3VrdmaOption>()?),
            StructType::VirtualFloppyOption => Ok(from.as_any_box().downcast::<VirtualFloppyOption>()?),
            StructType::VirtualKeyboardOption => Ok(from.as_any_box().downcast::<VirtualKeyboardOption>()?),
            StructType::VirtualNvdimmOption => Ok(from.as_any_box().downcast::<VirtualNvdimmOption>()?),
            StructType::VirtualPciPassthroughOption => Ok(from.as_any_box().downcast::<VirtualPciPassthroughOption>()?),
            StructType::VirtualParallelPortOption => Ok(from.as_any_box().downcast::<VirtualParallelPortOption>()?),
            StructType::VirtualPointingDeviceOption => Ok(from.as_any_box().downcast::<VirtualPointingDeviceOption>()?),
            StructType::VirtualPrecisionClockOption => Ok(from.as_any_box().downcast::<VirtualPrecisionClockOption>()?),
            StructType::VirtualScsiPassthroughOption => Ok(from.as_any_box().downcast::<VirtualScsiPassthroughOption>()?),
            StructType::VirtualSerialPortOption => Ok(from.as_any_box().downcast::<VirtualSerialPortOption>()?),
            StructType::VirtualSoundCardOption => Ok(from.as_any_box().downcast::<VirtualSoundCardOption>()?),
            StructType::VirtualEnsoniq1371Option => Ok(from.as_any_box().downcast::<VirtualEnsoniq1371Option>()?),
            StructType::VirtualHdAudioCardOption => Ok(from.as_any_box().downcast::<VirtualHdAudioCardOption>()?),
            StructType::VirtualSoundBlaster16Option => Ok(from.as_any_box().downcast::<VirtualSoundBlaster16Option>()?),
            StructType::VirtualTpmOption => Ok(from.as_any_box().downcast::<VirtualTpmOption>()?),
            StructType::VirtualUsbOption => Ok(from.as_any_box().downcast::<VirtualUsbOption>()?),
            StructType::VirtualMachineVmciDeviceOption => Ok(from.as_any_box().downcast::<VirtualMachineVmciDeviceOption>()?),
            StructType::VirtualVmiromOption => Ok(from.as_any_box().downcast::<VirtualVmiromOption>()?),
            StructType::VirtualVideoCardOption => Ok(from.as_any_box().downcast::<VirtualVideoCardOption>()?),
            StructType::VirtualWdtOption => Ok(from.as_any_box().downcast::<VirtualWdtOption>()?),
            StructType::VirtualDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualDeviceBackingOption>()?),
            StructType::VirtualDeviceDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualDeviceDeviceBackingOption>()?),
            StructType::VirtualCdromAtapiBackingOption => Ok(from.as_any_box().downcast::<VirtualCdromAtapiBackingOption>()?),
            StructType::VirtualCdromPassthroughBackingOption => Ok(from.as_any_box().downcast::<VirtualCdromPassthroughBackingOption>()?),
            StructType::VirtualCdromRemoteAtapiBackingOption => Ok(from.as_any_box().downcast::<VirtualCdromRemoteAtapiBackingOption>()?),
            StructType::VirtualDiskRawDiskMappingVer1BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskRawDiskMappingVer1BackingOption>()?),
            StructType::VirtualDiskRawDiskVer2BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskRawDiskVer2BackingOption>()?),
            StructType::VirtualDiskPartitionedRawDiskVer2BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskPartitionedRawDiskVer2BackingOption>()?),
            StructType::VirtualEthernetCardLegacyNetworkBackingOption => Ok(from.as_any_box().downcast::<VirtualEthernetCardLegacyNetworkBackingOption>()?),
            StructType::VirtualEthernetCardNetworkBackingOption => Ok(from.as_any_box().downcast::<VirtualEthernetCardNetworkBackingOption>()?),
            StructType::VirtualFloppyDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualFloppyDeviceBackingOption>()?),
            StructType::VirtualPciPassthroughDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualPciPassthroughDeviceBackingOption>()?),
            StructType::VirtualPciPassthroughDynamicBackingOption => Ok(from.as_any_box().downcast::<VirtualPciPassthroughDynamicBackingOption>()?),
            StructType::VirtualParallelPortDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualParallelPortDeviceBackingOption>()?),
            StructType::VirtualPointingDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualPointingDeviceBackingOption>()?),
            StructType::VirtualScsiPassthroughDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualScsiPassthroughDeviceBackingOption>()?),
            StructType::VirtualSerialPortDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualSerialPortDeviceBackingOption>()?),
            StructType::VirtualSoundCardDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualSoundCardDeviceBackingOption>()?),
            StructType::VirtualUsbRemoteHostBackingOption => Ok(from.as_any_box().downcast::<VirtualUsbRemoteHostBackingOption>()?),
            StructType::VirtualUsbusbBackingOption => Ok(from.as_any_box().downcast::<VirtualUsbusbBackingOption>()?),
            StructType::VirtualDeviceFileBackingOption => Ok(from.as_any_box().downcast::<VirtualDeviceFileBackingOption>()?),
            StructType::VirtualCdromIsoBackingOption => Ok(from.as_any_box().downcast::<VirtualCdromIsoBackingOption>()?),
            StructType::VirtualDiskFlatVer1BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskFlatVer1BackingOption>()?),
            StructType::VirtualDiskFlatVer2BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskFlatVer2BackingOption>()?),
            StructType::VirtualDiskLocalPMemBackingOption => Ok(from.as_any_box().downcast::<VirtualDiskLocalPMemBackingOption>()?),
            StructType::VirtualDiskSeSparseBackingOption => Ok(from.as_any_box().downcast::<VirtualDiskSeSparseBackingOption>()?),
            StructType::VirtualDiskSparseVer1BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskSparseVer1BackingOption>()?),
            StructType::VirtualDiskSparseVer2BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskSparseVer2BackingOption>()?),
            StructType::VirtualFloppyImageBackingOption => Ok(from.as_any_box().downcast::<VirtualFloppyImageBackingOption>()?),
            StructType::VirtualParallelPortFileBackingOption => Ok(from.as_any_box().downcast::<VirtualParallelPortFileBackingOption>()?),
            StructType::VirtualSerialPortFileBackingOption => Ok(from.as_any_box().downcast::<VirtualSerialPortFileBackingOption>()?),
            StructType::VirtualDevicePipeBackingOption => Ok(from.as_any_box().downcast::<VirtualDevicePipeBackingOption>()?),
            StructType::VirtualSerialPortPipeBackingOption => Ok(from.as_any_box().downcast::<VirtualSerialPortPipeBackingOption>()?),
            StructType::VirtualDeviceRemoteDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualDeviceRemoteDeviceBackingOption>()?),
            StructType::VirtualCdromRemotePassthroughBackingOption => Ok(from.as_any_box().downcast::<VirtualCdromRemotePassthroughBackingOption>()?),
            StructType::VirtualFloppyRemoteDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualFloppyRemoteDeviceBackingOption>()?),
            StructType::VirtualUsbRemoteClientBackingOption => Ok(from.as_any_box().downcast::<VirtualUsbRemoteClientBackingOption>()?),
            StructType::VirtualDeviceUriBackingOption => Ok(from.as_any_box().downcast::<VirtualDeviceUriBackingOption>()?),
            StructType::VirtualSerialPortUriBackingOption => Ok(from.as_any_box().downcast::<VirtualSerialPortUriBackingOption>()?),
            StructType::VirtualEthernetCardDvPortBackingOption => Ok(from.as_any_box().downcast::<VirtualEthernetCardDvPortBackingOption>()?),
            StructType::VirtualEthernetCardOpaqueNetworkBackingOption => Ok(from.as_any_box().downcast::<VirtualEthernetCardOpaqueNetworkBackingOption>()?),
            StructType::VirtualPciPassthroughDvxBackingOption => Ok(from.as_any_box().downcast::<VirtualPciPassthroughDvxBackingOption>()?),
            StructType::VirtualPciPassthroughPluginBackingOption => Ok(from.as_any_box().downcast::<VirtualPciPassthroughPluginBackingOption>()?),
            StructType::VirtualPciPassthroughVmiopBackingOption => Ok(from.as_any_box().downcast::<VirtualPciPassthroughVmiopBackingOption>()?),
            StructType::VirtualPrecisionClockSystemClockBackingOption => Ok(from.as_any_box().downcast::<VirtualPrecisionClockSystemClockBackingOption>()?),
            StructType::VirtualSerialPortThinPrintBackingOption => Ok(from.as_any_box().downcast::<VirtualSerialPortThinPrintBackingOption>()?),
            StructType::VirtualSriovEthernetCardSriovBackingOption => Ok(from.as_any_box().downcast::<VirtualSriovEthernetCardSriovBackingOption>()?),
            StructType::VirtualDeviceBusSlotOption => Ok(from.as_any_box().downcast::<VirtualDeviceBusSlotOption>()?),
            StructType::VirtualDeviceConnectOption => Ok(from.as_any_box().downcast::<VirtualDeviceConnectOption>()?),
            StructType::VirtualDeviceConfigSpec => Ok(from.as_any_box().downcast::<VirtualDeviceConfigSpec>()?),
            StructType::VirtualDiskConfigSpec => Ok(from.as_any_box().downcast::<VirtualDiskConfigSpec>()?),
            StructType::VirtualDeviceConfigSpecBackingSpec => Ok(from.as_any_box().downcast::<VirtualDeviceConfigSpecBackingSpec>()?),
            StructType::VirtualDiskVFlashCacheConfigInfo => Ok(from.as_any_box().downcast::<VirtualDiskVFlashCacheConfigInfo>()?),
            StructType::VirtualDiskId => Ok(from.as_any_box().downcast::<VirtualDiskId>()?),
            StructType::VirtualDiskDeltaDiskFormatsSupported => Ok(from.as_any_box().downcast::<VirtualDiskDeltaDiskFormatsSupported>()?),
            StructType::VirtualDiskOptionVFlashCacheConfigOption => Ok(from.as_any_box().downcast::<VirtualDiskOptionVFlashCacheConfigOption>()?),
            StructType::VirtualEthernetCardResourceAllocation => Ok(from.as_any_box().downcast::<VirtualEthernetCardResourceAllocation>()?),
            StructType::VirtualPciPassthroughAllowedDevice => Ok(from.as_any_box().downcast::<VirtualPciPassthroughAllowedDevice>()?),
            StructType::VirtualMachineVmciDeviceFilterInfo => Ok(from.as_any_box().downcast::<VirtualMachineVmciDeviceFilterInfo>()?),
            StructType::VirtualMachineVmciDeviceFilterSpec => Ok(from.as_any_box().downcast::<VirtualMachineVmciDeviceFilterSpec>()?),
            StructType::VirtualMachineVmciDeviceOptionFilterSpecOption => Ok(from.as_any_box().downcast::<VirtualMachineVmciDeviceOptionFilterSpecOption>()?),
            StructType::GuestAliases => Ok(from.as_any_box().downcast::<GuestAliases>()?),
            StructType::GuestAuthAliasInfo => Ok(from.as_any_box().downcast::<GuestAuthAliasInfo>()?),
            StructType::GuestAuthSubject => Ok(from.as_any_box().downcast::<GuestAuthSubject>()?),
            StructType::GuestAuthAnySubject => Ok(from.as_any_box().downcast::<GuestAuthAnySubject>()?),
            StructType::GuestAuthNamedSubject => Ok(from.as_any_box().downcast::<GuestAuthNamedSubject>()?),
            StructType::GuestMappedAliases => Ok(from.as_any_box().downcast::<GuestMappedAliases>()?),
            StructType::GuestFileAttributes => Ok(from.as_any_box().downcast::<GuestFileAttributes>()?),
            StructType::GuestPosixFileAttributes => Ok(from.as_any_box().downcast::<GuestPosixFileAttributes>()?),
            StructType::GuestWindowsFileAttributes => Ok(from.as_any_box().downcast::<GuestWindowsFileAttributes>()?),
            StructType::GuestFileInfo => Ok(from.as_any_box().downcast::<GuestFileInfo>()?),
            StructType::FileTransferInformation => Ok(from.as_any_box().downcast::<FileTransferInformation>()?),
            StructType::GuestListFileInfo => Ok(from.as_any_box().downcast::<GuestListFileInfo>()?),
            StructType::GuestAuthentication => Ok(from.as_any_box().downcast::<GuestAuthentication>()?),
            StructType::NamePasswordAuthentication => Ok(from.as_any_box().downcast::<NamePasswordAuthentication>()?),
            StructType::SamlTokenAuthentication => Ok(from.as_any_box().downcast::<SamlTokenAuthentication>()?),
            StructType::SspiAuthentication => Ok(from.as_any_box().downcast::<SspiAuthentication>()?),
            StructType::TicketedSessionAuthentication => Ok(from.as_any_box().downcast::<TicketedSessionAuthentication>()?),
            StructType::GuestProcessInfo => Ok(from.as_any_box().downcast::<GuestProcessInfo>()?),
            StructType::GuestProgramSpec => Ok(from.as_any_box().downcast::<GuestProgramSpec>()?),
            StructType::GuestWindowsProgramSpec => Ok(from.as_any_box().downcast::<GuestWindowsProgramSpec>()?),
            StructType::GuestRegKeySpec => Ok(from.as_any_box().downcast::<GuestRegKeySpec>()?),
            StructType::GuestRegKeyNameSpec => Ok(from.as_any_box().downcast::<GuestRegKeyNameSpec>()?),
            StructType::GuestRegKeyRecordSpec => Ok(from.as_any_box().downcast::<GuestRegKeyRecordSpec>()?),
            StructType::GuestRegValueSpec => Ok(from.as_any_box().downcast::<GuestRegValueSpec>()?),
            StructType::GuestRegValueDataSpec => Ok(from.as_any_box().downcast::<GuestRegValueDataSpec>()?),
            StructType::GuestRegValueBinarySpec => Ok(from.as_any_box().downcast::<GuestRegValueBinarySpec>()?),
            StructType::GuestRegValueDwordSpec => Ok(from.as_any_box().downcast::<GuestRegValueDwordSpec>()?),
            StructType::GuestRegValueExpandStringSpec => Ok(from.as_any_box().downcast::<GuestRegValueExpandStringSpec>()?),
            StructType::GuestRegValueMultiStringSpec => Ok(from.as_any_box().downcast::<GuestRegValueMultiStringSpec>()?),
            StructType::GuestRegValueQwordSpec => Ok(from.as_any_box().downcast::<GuestRegValueQwordSpec>()?),
            StructType::GuestRegValueStringSpec => Ok(from.as_any_box().downcast::<GuestRegValueStringSpec>()?),
            StructType::GuestRegValueNameSpec => Ok(from.as_any_box().downcast::<GuestRegValueNameSpec>()?),
            StructType::DeviceGroupId => Ok(from.as_any_box().downcast::<DeviceGroupId>()?),
            StructType::FaultDomainId => Ok(from.as_any_box().downcast::<FaultDomainId>()?),
            StructType::ReplicationGroupId => Ok(from.as_any_box().downcast::<ReplicationGroupId>()?),
            StructType::ReplicationSpec => Ok(from.as_any_box().downcast::<ReplicationSpec>()?),
            StructType::VsanClusterConfigInfo => Ok(from.as_any_box().downcast::<VsanClusterConfigInfo>()?),
            StructType::VsanClusterConfigInfoHostDefaultInfo => Ok(from.as_any_box().downcast::<VsanClusterConfigInfoHostDefaultInfo>()?),
            StructType::VsanHostClusterStatus => Ok(from.as_any_box().downcast::<VsanHostClusterStatus>()?),
            StructType::VsanHostClusterStatusState => Ok(from.as_any_box().downcast::<VsanHostClusterStatusState>()?),
            StructType::VsanHostClusterStatusStateCompletionEstimate => Ok(from.as_any_box().downcast::<VsanHostClusterStatusStateCompletionEstimate>()?),
            StructType::VsanHostConfigInfo => Ok(from.as_any_box().downcast::<VsanHostConfigInfo>()?),
            StructType::VsanHostConfigInfoClusterInfo => Ok(from.as_any_box().downcast::<VsanHostConfigInfoClusterInfo>()?),
            StructType::VsanHostFaultDomainInfo => Ok(from.as_any_box().downcast::<VsanHostFaultDomainInfo>()?),
            StructType::VsanHostConfigInfoNetworkInfo => Ok(from.as_any_box().downcast::<VsanHostConfigInfoNetworkInfo>()?),
            StructType::VsanHostConfigInfoNetworkInfoPortConfig => Ok(from.as_any_box().downcast::<VsanHostConfigInfoNetworkInfoPortConfig>()?),
            StructType::VsanHostConfigInfoStorageInfo => Ok(from.as_any_box().downcast::<VsanHostConfigInfoStorageInfo>()?),
            StructType::VsanHostDecommissionMode => Ok(from.as_any_box().downcast::<VsanHostDecommissionMode>()?),
            StructType::VsanHostDiskMapInfo => Ok(from.as_any_box().downcast::<VsanHostDiskMapInfo>()?),
            StructType::VsanHostDiskMapResult => Ok(from.as_any_box().downcast::<VsanHostDiskMapResult>()?),
            StructType::VsanHostDiskMapping => Ok(from.as_any_box().downcast::<VsanHostDiskMapping>()?),
            StructType::VsanHostDiskResult => Ok(from.as_any_box().downcast::<VsanHostDiskResult>()?),
            StructType::VsanHostIpConfig => Ok(from.as_any_box().downcast::<VsanHostIpConfig>()?),
            StructType::VsanHostMembershipInfo => Ok(from.as_any_box().downcast::<VsanHostMembershipInfo>()?),
            StructType::VsanHostVsanDiskInfo => Ok(from.as_any_box().downcast::<VsanHostVsanDiskInfo>()?),
            StructType::VsanHostRuntimeInfo => Ok(from.as_any_box().downcast::<VsanHostRuntimeInfo>()?),
            StructType::VsanHostRuntimeInfoDiskIssue => Ok(from.as_any_box().downcast::<VsanHostRuntimeInfoDiskIssue>()?),
            StructType::BaseConfigInfo => Ok(from.as_any_box().downcast::<BaseConfigInfo>()?),
            StructType::VStorageObjectConfigInfo => Ok(from.as_any_box().downcast::<VStorageObjectConfigInfo>()?),
            StructType::BaseConfigInfoBackingInfo => Ok(from.as_any_box().downcast::<BaseConfigInfoBackingInfo>()?),
            StructType::BaseConfigInfoFileBackingInfo => Ok(from.as_any_box().downcast::<BaseConfigInfoFileBackingInfo>()?),
            StructType::BaseConfigInfoDiskFileBackingInfo => Ok(from.as_any_box().downcast::<BaseConfigInfoDiskFileBackingInfo>()?),
            StructType::BaseConfigInfoRawDiskMappingBackingInfo => Ok(from.as_any_box().downcast::<BaseConfigInfoRawDiskMappingBackingInfo>()?),
            StructType::VslmCreateSpec => Ok(from.as_any_box().downcast::<VslmCreateSpec>()?),
            StructType::VslmCreateSpecBackingSpec => Ok(from.as_any_box().downcast::<VslmCreateSpecBackingSpec>()?),
            StructType::VslmCreateSpecDiskFileBackingSpec => Ok(from.as_any_box().downcast::<VslmCreateSpecDiskFileBackingSpec>()?),
            StructType::VslmCreateSpecRawDiskMappingBackingSpec => Ok(from.as_any_box().downcast::<VslmCreateSpecRawDiskMappingBackingSpec>()?),
            StructType::DiskCryptoSpec => Ok(from.as_any_box().downcast::<DiskCryptoSpec>()?),
            StructType::Id => Ok(from.as_any_box().downcast::<Id>()?),
            StructType::VslmInfrastructureObjectPolicy => Ok(from.as_any_box().downcast::<VslmInfrastructureObjectPolicy>()?),
            StructType::VslmInfrastructureObjectPolicySpec => Ok(from.as_any_box().downcast::<VslmInfrastructureObjectPolicySpec>()?),
            StructType::VslmMigrateSpec => Ok(from.as_any_box().downcast::<VslmMigrateSpec>()?),
            StructType::VslmCloneSpec => Ok(from.as_any_box().downcast::<VslmCloneSpec>()?),
            StructType::VslmRelocateSpec => Ok(from.as_any_box().downcast::<VslmRelocateSpec>()?),
            StructType::VStorageObjectStateInfo => Ok(from.as_any_box().downcast::<VStorageObjectStateInfo>()?),
            StructType::VslmTagEntry => Ok(from.as_any_box().downcast::<VslmTagEntry>()?),
            StructType::VslmVClockInfo => Ok(from.as_any_box().downcast::<VslmVClockInfo>()?),
            StructType::VStorageObject => Ok(from.as_any_box().downcast::<VStorageObject>()?),
            StructType::VStorageObjectSnapshot => Ok(from.as_any_box().downcast::<VStorageObjectSnapshot>()?),
            StructType::VStorageObjectSnapshotDetails => Ok(from.as_any_box().downcast::<VStorageObjectSnapshotDetails>()?),
            StructType::VStorageObjectSnapshotInfo => Ok(from.as_any_box().downcast::<VStorageObjectSnapshotInfo>()?),
            StructType::VStorageObjectSnapshotInfoVStorageObjectSnapshot => Ok(from.as_any_box().downcast::<VStorageObjectSnapshotInfoVStorageObjectSnapshot>()?),
            StructType::RetrieveVStorageObjSpec => Ok(from.as_any_box().downcast::<RetrieveVStorageObjSpec>()?),
            StructType::VStorageObjectAssociations => Ok(from.as_any_box().downcast::<VStorageObjectAssociations>()?),
            StructType::VStorageObjectAssociationsVmDiskAssociations => Ok(from.as_any_box().downcast::<VStorageObjectAssociationsVmDiskAssociations>()?),
            StructType::DynamicArray => Ok(from.as_any_box().downcast::<DynamicArray>()?),
            StructType::DynamicProperty => Ok(from.as_any_box().downcast::<DynamicProperty>()?),
            StructType::KeyAnyValue => Ok(from.as_any_box().downcast::<KeyAnyValue>()?),
            StructType::LocalizableMessage => Ok(from.as_any_box().downcast::<LocalizableMessage>()?),
            StructType::LocalizedMethodFault => Ok(from.as_any_box().downcast::<LocalizedMethodFault>()?),
            StructType::PropertyChange => Ok(from.as_any_box().downcast::<PropertyChange>()?),
            StructType::PropertyFilterSpec => Ok(from.as_any_box().downcast::<PropertyFilterSpec>()?),
            StructType::PropertyFilterUpdate => Ok(from.as_any_box().downcast::<PropertyFilterUpdate>()?),
            StructType::MissingObject => Ok(from.as_any_box().downcast::<MissingObject>()?),
            StructType::MissingProperty => Ok(from.as_any_box().downcast::<MissingProperty>()?),
            StructType::ObjectContent => Ok(from.as_any_box().downcast::<ObjectContent>()?),
            StructType::ObjectSpec => Ok(from.as_any_box().downcast::<ObjectSpec>()?),
            StructType::ObjectUpdate => Ok(from.as_any_box().downcast::<ObjectUpdate>()?),
            StructType::PropertySpec => Ok(from.as_any_box().downcast::<PropertySpec>()?),
            StructType::RetrieveOptions => Ok(from.as_any_box().downcast::<RetrieveOptions>()?),
            StructType::RetrieveResult => Ok(from.as_any_box().downcast::<RetrieveResult>()?),
            StructType::SelectionSpec => Ok(from.as_any_box().downcast::<SelectionSpec>()?),
            StructType::TraversalSpec => Ok(from.as_any_box().downcast::<TraversalSpec>()?),
            StructType::UpdateSet => Ok(from.as_any_box().downcast::<UpdateSet>()?),
            StructType::WaitOptions => Ok(from.as_any_box().downcast::<WaitOptions>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Describes the validation results.
pub trait ClusterComputeResourceValidationResultBaseTrait : super::traits::DataObjectTrait {
    /// Describes the messages relevant to the validation result
    fn get_info(&self) -> &Option<Vec<LocalizableMessage>>;
}
impl<'s> serde::Serialize for dyn ClusterComputeResourceValidationResultBaseTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ClusterComputeResourceValidationResultBaseTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ClusterComputeResourceValidationResultBaseVisitor)
            }
        }

struct ClusterComputeResourceValidationResultBaseVisitor;

impl<'de> de::Visitor<'de> for ClusterComputeResourceValidationResultBaseVisitor {
    type Value = Box<dyn ClusterComputeResourceValidationResultBaseTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ClusterComputeResourceValidationResultBaseTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ClusterComputeResourceValidationResultBaseTrait for ClusterComputeResourceValidationResultBase {
    fn get_info(&self) -> &Option<Vec<LocalizableMessage>> { &self.info }
}
impl ClusterComputeResourceValidationResultBaseTrait for ClusterComputeResourceDvsConfigurationValidation {
    fn get_info(&self) -> &Option<Vec<LocalizableMessage>> { &self.info }
}
impl ClusterComputeResourceValidationResultBaseTrait for ClusterComputeResourceHostConfigurationValidation {
    fn get_info(&self) -> &Option<Vec<LocalizableMessage>> { &self.info }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ClusterComputeResourceValidationResultBaseTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterComputeResourceValidationResultBase => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceValidationResultBase>()?),
            StructType::ClusterComputeResourceDvsConfigurationValidation => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceDvsConfigurationValidation>()?),
            StructType::ClusterComputeResourceHostConfigurationValidation => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceHostConfigurationValidation>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterComputeResourceValidationResultBase => Ok(from.as_any_box().downcast::<ClusterComputeResourceValidationResultBase>()?),
            StructType::ClusterComputeResourceDvsConfigurationValidation => Ok(from.as_any_box().downcast::<ClusterComputeResourceDvsConfigurationValidation>()?),
            StructType::ClusterComputeResourceHostConfigurationValidation => Ok(from.as_any_box().downcast::<ClusterComputeResourceHostConfigurationValidation>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Configuration of the compute resource; applies to both standalone hosts
/// and clusters.
pub trait ComputeResourceConfigInfoTrait : super::traits::DataObjectTrait {
    /// Swapfile placement policy for virtual machines within this compute
    /// resource.
    /// 
    /// Any policy except for "inherit" is a valid value for this
    /// property; the default is "vmDirectory". This setting will be honored
    /// for each virtual machine within the compute resource for which the
    /// following is true:
    /// - The virtual machine is executing on a host that has the
    ///   *perVmSwapFiles* capability.
    /// - The virtual machine configuration's
    ///   *swapPlacement* property is set
    ///   to "inherit".
    ///   
    /// See also *VirtualMachineConfigInfoSwapPlacementType_enum*.
    fn get_vm_swap_placement(&self) -> &str;
    /// Flag indicating whether or not the SPBM(Storage Policy Based Management)
    /// feature is enabled on this compute resource
    fn get_spbm_enabled(&self) -> Option<bool>;
    /// Key for Default Hardware Version used on this compute resource
    /// in the format of *VirtualMachineConfigOptionDescriptor.key*.
    /// 
    /// This field affects
    /// *VirtualMachineConfigOptionDescriptor.defaultConfigOption* returned
    /// by *ComputeResource.environmentBrowser* of this object and all its children
    /// with this field unset.
    fn get_default_hardware_version_key(&self) -> &Option<String>;
    /// Key for Maximum Hardware Version used on this compute resource
    /// in the format of *VirtualMachineConfigOptionDescriptor.key*.
    /// 
    /// This field affects
    /// *VirtualMachineConfigOptionDescriptor.defaultConfigOption* returned
    /// by *ComputeResource.environmentBrowser* of this object and all its children
    /// with this field unset.
    /// 
    /// ***Since:*** vSphere API Release 7.0.2.0
    fn get_maximum_hardware_version_key(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn ComputeResourceConfigInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ComputeResourceConfigInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ComputeResourceConfigInfoVisitor)
            }
        }

struct ComputeResourceConfigInfoVisitor;

impl<'de> de::Visitor<'de> for ComputeResourceConfigInfoVisitor {
    type Value = Box<dyn ComputeResourceConfigInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ComputeResourceConfigInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ComputeResourceConfigInfoTrait for ComputeResourceConfigInfo {
    fn get_vm_swap_placement(&self) -> &str { &self.vm_swap_placement }
    fn get_spbm_enabled(&self) -> Option<bool> { self.spbm_enabled }
    fn get_default_hardware_version_key(&self) -> &Option<String> { &self.default_hardware_version_key }
    fn get_maximum_hardware_version_key(&self) -> &Option<String> { &self.maximum_hardware_version_key }
}
impl ComputeResourceConfigInfoTrait for ClusterConfigInfoEx {
    fn get_vm_swap_placement(&self) -> &str { &self.vm_swap_placement }
    fn get_spbm_enabled(&self) -> Option<bool> { self.spbm_enabled }
    fn get_default_hardware_version_key(&self) -> &Option<String> { &self.default_hardware_version_key }
    fn get_maximum_hardware_version_key(&self) -> &Option<String> { &self.maximum_hardware_version_key }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ComputeResourceConfigInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ComputeResourceConfigInfo => Some(from.as_any_ref().downcast_ref::<ComputeResourceConfigInfo>()?),
            StructType::ClusterConfigInfoEx => Some(from.as_any_ref().downcast_ref::<ClusterConfigInfoEx>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ComputeResourceConfigInfo => Ok(from.as_any_box().downcast::<ComputeResourceConfigInfo>()?),
            StructType::ClusterConfigInfoEx => Ok(from.as_any_box().downcast::<ClusterConfigInfoEx>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Changes to apply to the compute resource configuration.
pub trait ComputeResourceConfigSpecTrait : super::traits::DataObjectTrait {
    /// New setting for the swapfile placement policy.
    /// 
    /// Any change to this
    /// policy will affect virtual machines that subsequently power on or
    /// resume from a suspended state in this compute resource, or that
    /// migrate to a host in this compute resource while powered on; virtual
    /// machines that are currently powered on in this compute resource will
    /// not yet be affected.
    /// 
    /// See also *VirtualMachineConfigInfoSwapPlacementType_enum*.
    fn get_vm_swap_placement(&self) -> &Option<String>;
    /// Flag indicating whether or not the SPBM(Storage Policy Based Management)
    /// feature is enabled on this compute resource
    fn get_spbm_enabled(&self) -> Option<bool>;
    /// Key for Default Hardware Version to be used on this compute resource
    /// in the format of *VirtualMachineConfigOptionDescriptor.key*.
    /// 
    /// Setting this field affects
    /// *VirtualMachineConfigOptionDescriptor.defaultConfigOption* returned
    /// by *ComputeResource.environmentBrowser* of this object and all its children
    /// with this field unset.
    fn get_default_hardware_version_key(&self) -> &Option<String>;
    /// Desired software spec for the set of physical compute resources.
    /// 
    /// This
    /// parameter is only supported in vim.Folder#createClusterEx operation.
    fn get_desired_software_spec(&self) -> &Option<DesiredSoftwareSpec>;
    /// Key for Maximum Hardware Version to be used on this compute resource
    /// in the format of *VirtualMachineConfigOptionDescriptor.key*.
    /// 
    /// Setting this field affects
    /// *VirtualMachineConfigOptionDescriptor.defaultConfigOption* returned
    /// by *ComputeResource.environmentBrowser* of this object and all its children
    /// with this field unset.
    /// 
    /// ***Since:*** vSphere API Release 7.0.2.0
    fn get_maximum_hardware_version_key(&self) -> &Option<String>;
    /// Flag indicating whether or not the vLCM (vSphere Lifecycle Manager)
    /// Config Manager feature is enabled on this compute resource.
    /// 
    /// If the
    /// flag is not set, the Config Manager feature will be disabled by
    /// default. This parameter is only supported in *Folder.CreateClusterEx*
    /// operation.
    /// 
    /// ***Since:*** vSphere API Release 7.0.3.1
    fn get_enable_config_manager(&self) -> Option<bool>;
}
impl<'s> serde::Serialize for dyn ComputeResourceConfigSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ComputeResourceConfigSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ComputeResourceConfigSpecVisitor)
            }
        }

struct ComputeResourceConfigSpecVisitor;

impl<'de> de::Visitor<'de> for ComputeResourceConfigSpecVisitor {
    type Value = Box<dyn ComputeResourceConfigSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ComputeResourceConfigSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ComputeResourceConfigSpecTrait for ComputeResourceConfigSpec {
    fn get_vm_swap_placement(&self) -> &Option<String> { &self.vm_swap_placement }
    fn get_spbm_enabled(&self) -> Option<bool> { self.spbm_enabled }
    fn get_default_hardware_version_key(&self) -> &Option<String> { &self.default_hardware_version_key }
    fn get_desired_software_spec(&self) -> &Option<DesiredSoftwareSpec> { &self.desired_software_spec }
    fn get_maximum_hardware_version_key(&self) -> &Option<String> { &self.maximum_hardware_version_key }
    fn get_enable_config_manager(&self) -> Option<bool> { self.enable_config_manager }
}
impl ComputeResourceConfigSpecTrait for ClusterConfigSpecEx {
    fn get_vm_swap_placement(&self) -> &Option<String> { &self.vm_swap_placement }
    fn get_spbm_enabled(&self) -> Option<bool> { self.spbm_enabled }
    fn get_default_hardware_version_key(&self) -> &Option<String> { &self.default_hardware_version_key }
    fn get_desired_software_spec(&self) -> &Option<DesiredSoftwareSpec> { &self.desired_software_spec }
    fn get_maximum_hardware_version_key(&self) -> &Option<String> { &self.maximum_hardware_version_key }
    fn get_enable_config_manager(&self) -> Option<bool> { self.enable_config_manager }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ComputeResourceConfigSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ComputeResourceConfigSpec => Some(from.as_any_ref().downcast_ref::<ComputeResourceConfigSpec>()?),
            StructType::ClusterConfigSpecEx => Some(from.as_any_ref().downcast_ref::<ClusterConfigSpecEx>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ComputeResourceConfigSpec => Ok(from.as_any_box().downcast::<ComputeResourceConfigSpec>()?),
            StructType::ClusterConfigSpecEx => Ok(from.as_any_box().downcast::<ClusterConfigSpecEx>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type encapsulates a typical set of ComputeResource information
/// that is useful for list views and summary pages.
pub trait ComputeResourceSummaryTrait : super::traits::DataObjectTrait {
    /// Aggregated CPU resources of all hosts, in MHz.
    fn get_total_cpu(&self) -> i32;
    /// Aggregated memory resources of all hosts, in bytes.
    fn get_total_memory(&self) -> i64;
    /// Number of physical CPU cores.
    /// 
    /// Physical CPU cores are the processors contained
    /// by a CPU package.
    fn get_num_cpu_cores(&self) -> i16;
    /// Aggregated number of CPU threads.
    fn get_num_cpu_threads(&self) -> i16;
    /// Effective CPU resources (in MHz) available to run virtual machines.
    /// 
    /// This is the
    /// aggregated effective resource level from all running hosts. Hosts that are in
    /// maintenance mode or are unresponsive are not counted. Resources used by the
    /// VMware Service Console are not included in the aggregate. This value represents
    /// the amount of resources available for the root resource pool for running
    /// virtual machines.
    fn get_effective_cpu(&self) -> i32;
    /// Effective memory resources (in MB) available to run virtual machines.
    /// 
    /// This is the aggregated effective resource level from all running hosts. Hosts
    /// that are in maintenance mode or are unresponsive are not counted.
    /// Resources used by the VMware Service Console are not included in the aggregate.
    /// This value represents the amount of resources available for the root
    /// resource pool for running virtual machines.
    fn get_effective_memory(&self) -> i64;
    /// Total number of hosts.
    fn get_num_hosts(&self) -> i32;
    /// Total number of effective hosts.
    fn get_num_effective_hosts(&self) -> i32;
    /// Overall alarm status.
    /// 
    /// In releases after vSphere API 5.0, vSphere Servers might not
    /// generate property collector update notifications for this property.
    /// To obtain the latest value of the property, you can use
    /// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
    /// If you use the PropertyCollector.WaitForUpdatesEx method, specify
    /// an empty string for the version parameter.
    /// Since this property is on a DataObject, an update returned by WaitForUpdatesEx may
    /// contain values for this property when some other property on the DataObject changes.
    /// If this update is a result of a call to WaitForUpdatesEx with a non-empty
    /// version parameter, the value for this property may not be current.
    fn get_overall_status(&self) -> &super::enums::ManagedEntityStatusEnum;
}
impl<'s> serde::Serialize for dyn ComputeResourceSummaryTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ComputeResourceSummaryTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ComputeResourceSummaryVisitor)
            }
        }

struct ComputeResourceSummaryVisitor;

impl<'de> de::Visitor<'de> for ComputeResourceSummaryVisitor {
    type Value = Box<dyn ComputeResourceSummaryTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ComputeResourceSummaryTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ComputeResourceSummaryTrait for ComputeResourceSummary {
    fn get_total_cpu(&self) -> i32 { self.total_cpu }
    fn get_total_memory(&self) -> i64 { self.total_memory }
    fn get_num_cpu_cores(&self) -> i16 { self.num_cpu_cores }
    fn get_num_cpu_threads(&self) -> i16 { self.num_cpu_threads }
    fn get_effective_cpu(&self) -> i32 { self.effective_cpu }
    fn get_effective_memory(&self) -> i64 { self.effective_memory }
    fn get_num_hosts(&self) -> i32 { self.num_hosts }
    fn get_num_effective_hosts(&self) -> i32 { self.num_effective_hosts }
    fn get_overall_status(&self) -> &super::enums::ManagedEntityStatusEnum { &self.overall_status }
}
impl ComputeResourceSummaryTrait for ClusterComputeResourceSummary {
    fn get_total_cpu(&self) -> i32 { self.total_cpu }
    fn get_total_memory(&self) -> i64 { self.total_memory }
    fn get_num_cpu_cores(&self) -> i16 { self.num_cpu_cores }
    fn get_num_cpu_threads(&self) -> i16 { self.num_cpu_threads }
    fn get_effective_cpu(&self) -> i32 { self.effective_cpu }
    fn get_effective_memory(&self) -> i64 { self.effective_memory }
    fn get_num_hosts(&self) -> i32 { self.num_hosts }
    fn get_num_effective_hosts(&self) -> i32 { self.num_effective_hosts }
    fn get_overall_status(&self) -> &super::enums::ManagedEntityStatusEnum { &self.overall_status }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ComputeResourceSummaryTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ComputeResourceSummary => Some(from.as_any_ref().downcast_ref::<ComputeResourceSummary>()?),
            StructType::ClusterComputeResourceSummary => Some(from.as_any_ref().downcast_ref::<ClusterComputeResourceSummary>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ComputeResourceSummary => Ok(from.as_any_box().downcast::<ComputeResourceSummary>()?),
            StructType::ClusterComputeResourceSummary => Ok(from.as_any_box().downcast::<ClusterComputeResourceSummary>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base type for storing values.
pub trait CustomFieldValueTrait : super::traits::DataObjectTrait {
    /// The ID of the field to which this value belongs.
    fn get_key(&self) -> i32;
}
impl<'s> serde::Serialize for dyn CustomFieldValueTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn CustomFieldValueTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(CustomFieldValueVisitor)
            }
        }

struct CustomFieldValueVisitor;

impl<'de> de::Visitor<'de> for CustomFieldValueVisitor {
    type Value = Box<dyn CustomFieldValueTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid CustomFieldValueTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl CustomFieldValueTrait for CustomFieldValue {
    fn get_key(&self) -> i32 { self.key }
}
impl CustomFieldValueTrait for CustomFieldStringValue {
    fn get_key(&self) -> i32 { self.key }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn CustomFieldValueTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::CustomFieldValue => Some(from.as_any_ref().downcast_ref::<CustomFieldValue>()?),
            StructType::CustomFieldStringValue => Some(from.as_any_ref().downcast_ref::<CustomFieldStringValue>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::CustomFieldValue => Ok(from.as_any_box().downcast::<CustomFieldValue>()?),
            StructType::CustomFieldStringValue => Ok(from.as_any_box().downcast::<CustomFieldStringValue>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Detailed information about a datastore.
/// 
/// This is a base type for derived types
/// that have more specific details about a datastore.
/// 
/// See also *HostVmfsVolume*, *HostNasVolume*, *HostLocalFileSystemVolume*.
pub trait DatastoreInfoTrait : super::traits::DataObjectTrait {
    /// The name of the datastore.
    fn get_name(&self) -> &str;
    /// The unique locator for the datastore.
    fn get_url(&self) -> &str;
    /// Free space of this datastore, in bytes.
    /// 
    /// The server periodically updates this
    /// value. It can be explicitly refreshed with the Refresh operation.
    fn get_free_space(&self) -> i64;
    /// The maximum size of a file that can reside on this file system volume.
    fn get_max_file_size(&self) -> i64;
    /// The maximum capacity of a virtual disk which can be created on this volume.
    fn get_max_virtual_disk_capacity(&self) -> Option<i64>;
    /// The maximum size of a snapshot or a swap file that can reside on this file system volume.
    fn get_max_memory_file_size(&self) -> i64;
    /// Time when the free-space and capacity values in *DatastoreInfo* and
    /// *DatastoreSummary* were updated.
    fn get_timestamp(&self) -> &Option<String>;
    /// The unique container ID of the datastore, if applicable.
    fn get_container_id(&self) -> &Option<String>;
    /// vSAN datastore container that this datastore is alias of.
    /// 
    /// If this
    /// field is unset then this datastore is not alias of any other vSAN
    /// datastore.
    /// See *DatastoreInfo.containerId*.
    fn get_alias_of(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn DatastoreInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DatastoreInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DatastoreInfoVisitor)
            }
        }

struct DatastoreInfoVisitor;

impl<'de> de::Visitor<'de> for DatastoreInfoVisitor {
    type Value = Box<dyn DatastoreInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DatastoreInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DatastoreInfoTrait for DatastoreInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_url(&self) -> &str { &self.url }
    fn get_free_space(&self) -> i64 { self.free_space }
    fn get_max_file_size(&self) -> i64 { self.max_file_size }
    fn get_max_virtual_disk_capacity(&self) -> Option<i64> { self.max_virtual_disk_capacity }
    fn get_max_memory_file_size(&self) -> i64 { self.max_memory_file_size }
    fn get_timestamp(&self) -> &Option<String> { &self.timestamp }
    fn get_container_id(&self) -> &Option<String> { &self.container_id }
    fn get_alias_of(&self) -> &Option<String> { &self.alias_of }
}
impl DatastoreInfoTrait for LocalDatastoreInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_url(&self) -> &str { &self.url }
    fn get_free_space(&self) -> i64 { self.free_space }
    fn get_max_file_size(&self) -> i64 { self.max_file_size }
    fn get_max_virtual_disk_capacity(&self) -> Option<i64> { self.max_virtual_disk_capacity }
    fn get_max_memory_file_size(&self) -> i64 { self.max_memory_file_size }
    fn get_timestamp(&self) -> &Option<String> { &self.timestamp }
    fn get_container_id(&self) -> &Option<String> { &self.container_id }
    fn get_alias_of(&self) -> &Option<String> { &self.alias_of }
}
impl DatastoreInfoTrait for NasDatastoreInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_url(&self) -> &str { &self.url }
    fn get_free_space(&self) -> i64 { self.free_space }
    fn get_max_file_size(&self) -> i64 { self.max_file_size }
    fn get_max_virtual_disk_capacity(&self) -> Option<i64> { self.max_virtual_disk_capacity }
    fn get_max_memory_file_size(&self) -> i64 { self.max_memory_file_size }
    fn get_timestamp(&self) -> &Option<String> { &self.timestamp }
    fn get_container_id(&self) -> &Option<String> { &self.container_id }
    fn get_alias_of(&self) -> &Option<String> { &self.alias_of }
}
impl DatastoreInfoTrait for PMemDatastoreInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_url(&self) -> &str { &self.url }
    fn get_free_space(&self) -> i64 { self.free_space }
    fn get_max_file_size(&self) -> i64 { self.max_file_size }
    fn get_max_virtual_disk_capacity(&self) -> Option<i64> { self.max_virtual_disk_capacity }
    fn get_max_memory_file_size(&self) -> i64 { self.max_memory_file_size }
    fn get_timestamp(&self) -> &Option<String> { &self.timestamp }
    fn get_container_id(&self) -> &Option<String> { &self.container_id }
    fn get_alias_of(&self) -> &Option<String> { &self.alias_of }
}
impl DatastoreInfoTrait for VmfsDatastoreInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_url(&self) -> &str { &self.url }
    fn get_free_space(&self) -> i64 { self.free_space }
    fn get_max_file_size(&self) -> i64 { self.max_file_size }
    fn get_max_virtual_disk_capacity(&self) -> Option<i64> { self.max_virtual_disk_capacity }
    fn get_max_memory_file_size(&self) -> i64 { self.max_memory_file_size }
    fn get_timestamp(&self) -> &Option<String> { &self.timestamp }
    fn get_container_id(&self) -> &Option<String> { &self.container_id }
    fn get_alias_of(&self) -> &Option<String> { &self.alias_of }
}
impl DatastoreInfoTrait for VsanDatastoreInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_url(&self) -> &str { &self.url }
    fn get_free_space(&self) -> i64 { self.free_space }
    fn get_max_file_size(&self) -> i64 { self.max_file_size }
    fn get_max_virtual_disk_capacity(&self) -> Option<i64> { self.max_virtual_disk_capacity }
    fn get_max_memory_file_size(&self) -> i64 { self.max_memory_file_size }
    fn get_timestamp(&self) -> &Option<String> { &self.timestamp }
    fn get_container_id(&self) -> &Option<String> { &self.container_id }
    fn get_alias_of(&self) -> &Option<String> { &self.alias_of }
}
impl DatastoreInfoTrait for VvolDatastoreInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_url(&self) -> &str { &self.url }
    fn get_free_space(&self) -> i64 { self.free_space }
    fn get_max_file_size(&self) -> i64 { self.max_file_size }
    fn get_max_virtual_disk_capacity(&self) -> Option<i64> { self.max_virtual_disk_capacity }
    fn get_max_memory_file_size(&self) -> i64 { self.max_memory_file_size }
    fn get_timestamp(&self) -> &Option<String> { &self.timestamp }
    fn get_container_id(&self) -> &Option<String> { &self.container_id }
    fn get_alias_of(&self) -> &Option<String> { &self.alias_of }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DatastoreInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DatastoreInfo => Some(from.as_any_ref().downcast_ref::<DatastoreInfo>()?),
            StructType::LocalDatastoreInfo => Some(from.as_any_ref().downcast_ref::<LocalDatastoreInfo>()?),
            StructType::NasDatastoreInfo => Some(from.as_any_ref().downcast_ref::<NasDatastoreInfo>()?),
            StructType::PMemDatastoreInfo => Some(from.as_any_ref().downcast_ref::<PMemDatastoreInfo>()?),
            StructType::VmfsDatastoreInfo => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreInfo>()?),
            StructType::VsanDatastoreInfo => Some(from.as_any_ref().downcast_ref::<VsanDatastoreInfo>()?),
            StructType::VvolDatastoreInfo => Some(from.as_any_ref().downcast_ref::<VvolDatastoreInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DatastoreInfo => Ok(from.as_any_box().downcast::<DatastoreInfo>()?),
            StructType::LocalDatastoreInfo => Ok(from.as_any_box().downcast::<LocalDatastoreInfo>()?),
            StructType::NasDatastoreInfo => Ok(from.as_any_box().downcast::<NasDatastoreInfo>()?),
            StructType::PMemDatastoreInfo => Ok(from.as_any_box().downcast::<PMemDatastoreInfo>()?),
            StructType::VmfsDatastoreInfo => Ok(from.as_any_box().downcast::<VmfsDatastoreInfo>()?),
            StructType::VsanDatastoreInfo => Ok(from.as_any_box().downcast::<VsanDatastoreInfo>()?),
            StructType::VvolDatastoreInfo => Ok(from.as_any_box().downcast::<VvolDatastoreInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Static strings used for describing an object or property.
pub trait DescriptionTrait : super::traits::DataObjectTrait {
    /// Display label.
    fn get_label(&self) -> &str;
    /// Summary description.
    fn get_summary(&self) -> &str;
}
impl<'s> serde::Serialize for dyn DescriptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DescriptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DescriptionVisitor)
            }
        }

struct DescriptionVisitor;

impl<'de> de::Visitor<'de> for DescriptionVisitor {
    type Value = Box<dyn DescriptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DescriptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DescriptionTrait for Description {
    fn get_label(&self) -> &str { &self.label }
    fn get_summary(&self) -> &str { &self.summary }
}
impl DescriptionTrait for ElementDescription {
    fn get_label(&self) -> &str { &self.label }
    fn get_summary(&self) -> &str { &self.summary }
}
impl DescriptionTrait for EvcMode {
    fn get_label(&self) -> &str { &self.label }
    fn get_summary(&self) -> &str { &self.summary }
}
impl DescriptionTrait for ExtendedElementDescription {
    fn get_label(&self) -> &str { &self.label }
    fn get_summary(&self) -> &str { &self.summary }
}
impl DescriptionTrait for FeatureEvcMode {
    fn get_label(&self) -> &str { &self.label }
    fn get_summary(&self) -> &str { &self.summary }
}
impl DescriptionTrait for OptionDef {
    fn get_label(&self) -> &str { &self.label }
    fn get_summary(&self) -> &str { &self.summary }
}
impl DescriptionTrait for ExtendedDescription {
    fn get_label(&self) -> &str { &self.label }
    fn get_summary(&self) -> &str { &self.summary }
}
impl DescriptionTrait for MethodDescription {
    fn get_label(&self) -> &str { &self.label }
    fn get_summary(&self) -> &str { &self.summary }
}
impl DescriptionTrait for TypeDescription {
    fn get_label(&self) -> &str { &self.label }
    fn get_summary(&self) -> &str { &self.summary }
}
impl DescriptionTrait for ScheduledTaskDetail {
    fn get_label(&self) -> &str { &self.label }
    fn get_summary(&self) -> &str { &self.summary }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DescriptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::Description => Some(from.as_any_ref().downcast_ref::<Description>()?),
            StructType::ElementDescription => Some(from.as_any_ref().downcast_ref::<ElementDescription>()?),
            StructType::EvcMode => Some(from.as_any_ref().downcast_ref::<EvcMode>()?),
            StructType::ExtendedElementDescription => Some(from.as_any_ref().downcast_ref::<ExtendedElementDescription>()?),
            StructType::FeatureEvcMode => Some(from.as_any_ref().downcast_ref::<FeatureEvcMode>()?),
            StructType::OptionDef => Some(from.as_any_ref().downcast_ref::<OptionDef>()?),
            StructType::ExtendedDescription => Some(from.as_any_ref().downcast_ref::<ExtendedDescription>()?),
            StructType::MethodDescription => Some(from.as_any_ref().downcast_ref::<MethodDescription>()?),
            StructType::TypeDescription => Some(from.as_any_ref().downcast_ref::<TypeDescription>()?),
            StructType::ScheduledTaskDetail => Some(from.as_any_ref().downcast_ref::<ScheduledTaskDetail>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::Description => Ok(from.as_any_box().downcast::<Description>()?),
            StructType::ElementDescription => Ok(from.as_any_box().downcast::<ElementDescription>()?),
            StructType::EvcMode => Ok(from.as_any_box().downcast::<EvcMode>()?),
            StructType::ExtendedElementDescription => Ok(from.as_any_box().downcast::<ExtendedElementDescription>()?),
            StructType::FeatureEvcMode => Ok(from.as_any_box().downcast::<FeatureEvcMode>()?),
            StructType::OptionDef => Ok(from.as_any_box().downcast::<OptionDef>()?),
            StructType::ExtendedDescription => Ok(from.as_any_box().downcast::<ExtendedDescription>()?),
            StructType::MethodDescription => Ok(from.as_any_box().downcast::<MethodDescription>()?),
            StructType::TypeDescription => Ok(from.as_any_box().downcast::<TypeDescription>()?),
            StructType::ScheduledTaskDetail => Ok(from.as_any_box().downcast::<ScheduledTaskDetail>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Static strings used for describing an object model string or enumeration.
pub trait ElementDescriptionTrait : super::traits::DescriptionTrait {
    /// Enumeration or literal ID being described.
    fn get_key(&self) -> &str;
}
impl<'s> serde::Serialize for dyn ElementDescriptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ElementDescriptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ElementDescriptionVisitor)
            }
        }

struct ElementDescriptionVisitor;

impl<'de> de::Visitor<'de> for ElementDescriptionVisitor {
    type Value = Box<dyn ElementDescriptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ElementDescriptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ElementDescriptionTrait for ElementDescription {
    fn get_key(&self) -> &str { &self.key }
}
impl ElementDescriptionTrait for EvcMode {
    fn get_key(&self) -> &str { &self.key }
}
impl ElementDescriptionTrait for ExtendedElementDescription {
    fn get_key(&self) -> &str { &self.key }
}
impl ElementDescriptionTrait for FeatureEvcMode {
    fn get_key(&self) -> &str { &self.key }
}
impl ElementDescriptionTrait for OptionDef {
    fn get_key(&self) -> &str { &self.key }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ElementDescriptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ElementDescription => Some(from.as_any_ref().downcast_ref::<ElementDescription>()?),
            StructType::EvcMode => Some(from.as_any_ref().downcast_ref::<EvcMode>()?),
            StructType::ExtendedElementDescription => Some(from.as_any_ref().downcast_ref::<ExtendedElementDescription>()?),
            StructType::FeatureEvcMode => Some(from.as_any_ref().downcast_ref::<FeatureEvcMode>()?),
            StructType::OptionDef => Some(from.as_any_ref().downcast_ref::<OptionDef>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ElementDescription => Ok(from.as_any_box().downcast::<ElementDescription>()?),
            StructType::EvcMode => Ok(from.as_any_box().downcast::<EvcMode>()?),
            StructType::ExtendedElementDescription => Ok(from.as_any_box().downcast::<ExtendedElementDescription>()?),
            StructType::FeatureEvcMode => Ok(from.as_any_box().downcast::<FeatureEvcMode>()?),
            StructType::OptionDef => Ok(from.as_any_box().downcast::<OptionDef>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Static strings used for describing an object type.
pub trait TypeDescriptionTrait : super::traits::DescriptionTrait {
    /// Type being described
    fn get_key(&self) -> &str;
}
impl<'s> serde::Serialize for dyn TypeDescriptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn TypeDescriptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(TypeDescriptionVisitor)
            }
        }

struct TypeDescriptionVisitor;

impl<'de> de::Visitor<'de> for TypeDescriptionVisitor {
    type Value = Box<dyn TypeDescriptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid TypeDescriptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl TypeDescriptionTrait for TypeDescription {
    fn get_key(&self) -> &str { &self.key }
}
impl TypeDescriptionTrait for ScheduledTaskDetail {
    fn get_key(&self) -> &str { &self.key }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn TypeDescriptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::TypeDescription => Some(from.as_any_ref().downcast_ref::<TypeDescription>()?),
            StructType::ScheduledTaskDetail => Some(from.as_any_ref().downcast_ref::<ScheduledTaskDetail>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::TypeDescription => Ok(from.as_any_box().downcast::<TypeDescription>()?),
            StructType::ScheduledTaskDetail => Ok(from.as_any_box().downcast::<ScheduledTaskDetail>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Configuration of a *DistributedVirtualSwitch*.
pub trait DvsConfigInfoTrait : super::traits::DataObjectTrait {
    /// Generated UUID of the switch.
    /// 
    /// Unique across vCenter Server
    /// inventory and instances.
    fn get_uuid(&self) -> &str;
    /// Name of the switch.
    fn get_name(&self) -> &str;
    /// Number of standalone ports in the switch.
    /// 
    /// Standalone ports are
    /// ports that do not belong to any portgroup.
    fn get_num_standalone_ports(&self) -> i32;
    /// Current number of ports, not including conflict ports.
    fn get_num_ports(&self) -> i32;
    /// Maximum number of ports allowed in the switch,
    /// not including conflict ports.
    fn get_max_ports(&self) -> i32;
    /// Uplink port policy.
    fn get_uplink_port_policy(&self) -> &Box<dyn super::traits::DvsUplinkPortPolicyTrait>;
    /// List of uplink portgroups.
    /// 
    /// When adding host members, the server
    /// uses the *DVSConfigInfo.uplinkPortPolicy* to create a number of
    /// uplink ports for the host. If portgroups are shown here,
    /// those uplink ports will be added to the portgroups, with uplink ports
    /// evenly spread among the portgroups.
    /// 
    /// Refers instances of *DistributedVirtualPortgroup*.
    fn get_uplink_portgroup(&self) -> &Option<Vec<ManagedObjectReference>>;
    /// Default configuration for the ports in the switch, if the port
    /// does not inherit configuration from the parent portgroup or has
    /// its own configuration.
    fn get_default_port_config(&self) -> &Box<dyn super::traits::DvPortSettingTrait>;
    /// Hosts that join the switch.
    fn get_host(&self) -> &Option<Vec<DistributedVirtualSwitchHostMember>>;
    /// Vendor, product, and version information for the implementation
    /// module of the switch.
    fn get_product_info(&self) -> &DistributedVirtualSwitchProductSpec;
    /// Intended vendor, product, and version information for the
    /// implementation module of the switch.
    fn get_target_info(&self) -> &Option<DistributedVirtualSwitchProductSpec>;
    /// Key of the extension registered by the remote server that
    /// controls the switch.
    fn get_extension_key(&self) -> &Option<String>;
    /// Opaque binary blob that stores vendor specific configuration.
    fn get_vendor_specific_config(&self) -> &Option<Vec<DistributedVirtualSwitchKeyedOpaqueBlob>>;
    /// Usage policy of the switch.
    fn get_policy(&self) -> &Option<DvsPolicy>;
    /// Description string for the switch.
    fn get_description(&self) -> &Option<String>;
    /// Version string of the configuration.
    fn get_config_version(&self) -> &str;
    /// Human operator contact information.
    fn get_contact(&self) -> &DvsContactInfo;
    /// IP address for the switch, specified using IPv4 dot notation.
    /// 
    /// The
    /// utility of this address is defined by other switch features.
    fn get_switch_ip_address(&self) -> &Option<String>;
    /// Create time of the switch.
    fn get_create_time(&self) -> &str;
    /// Boolean to indicate if network I/O control is enabled on the
    /// switch.
    fn get_network_resource_management_enabled(&self) -> bool;
    /// Default host proxy switch maximum port number
    fn get_default_proxy_switch_max_num_ports(&self) -> Option<i32>;
    /// VDS health check configuration.
    fn get_health_check_config(&self) -> &Option<Vec<Box<dyn super::traits::DvsHealthCheckConfigTrait>>>;
    /// Host infrastructure traffic class resource configuration.
    fn get_infrastructure_traffic_resource_config(&self) -> &Option<Vec<DvsHostInfrastructureTrafficResource>>;
    /// Dynamic Host infrastructure traffic class resource configuration.
    fn get_net_resource_pool_traffic_resource_config(&self) -> &Option<Vec<DvsHostInfrastructureTrafficResource>>;
    /// Network resource control version of the switch.
    /// 
    /// Possible value can be of
    /// *DistributedVirtualSwitchNetworkResourceControlVersion_enum*.
    fn get_network_resource_control_version(&self) -> &Option<String>;
    /// The Virtual NIC network resource pool information for the switch.
    fn get_vm_vnic_network_resource_pool(&self) -> &Option<Vec<DvsVmVnicNetworkResourcePool>>;
    /// The percentage of physical nic link speed
    /// *PhysicalNicLinkInfo.speedMb*
    /// available for infrastructure traffic reservation.
    /// 
    /// If this value is 75, then for a 1Gbps physical nic, only
    /// 750Mbps is allowed for all infrastructure traffic reservations.
    fn get_pnic_capacity_ratio_for_reservation(&self) -> Option<i32>;
}
impl<'s> serde::Serialize for dyn DvsConfigInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DvsConfigInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DvsConfigInfoVisitor)
            }
        }

struct DvsConfigInfoVisitor;

impl<'de> de::Visitor<'de> for DvsConfigInfoVisitor {
    type Value = Box<dyn DvsConfigInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DvsConfigInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DvsConfigInfoTrait for DvsConfigInfo {
    fn get_uuid(&self) -> &str { &self.uuid }
    fn get_name(&self) -> &str { &self.name }
    fn get_num_standalone_ports(&self) -> i32 { self.num_standalone_ports }
    fn get_num_ports(&self) -> i32 { self.num_ports }
    fn get_max_ports(&self) -> i32 { self.max_ports }
    fn get_uplink_port_policy(&self) -> &Box<dyn super::traits::DvsUplinkPortPolicyTrait> { &self.uplink_port_policy }
    fn get_uplink_portgroup(&self) -> &Option<Vec<ManagedObjectReference>> { &self.uplink_portgroup }
    fn get_default_port_config(&self) -> &Box<dyn super::traits::DvPortSettingTrait> { &self.default_port_config }
    fn get_host(&self) -> &Option<Vec<DistributedVirtualSwitchHostMember>> { &self.host }
    fn get_product_info(&self) -> &DistributedVirtualSwitchProductSpec { &self.product_info }
    fn get_target_info(&self) -> &Option<DistributedVirtualSwitchProductSpec> { &self.target_info }
    fn get_extension_key(&self) -> &Option<String> { &self.extension_key }
    fn get_vendor_specific_config(&self) -> &Option<Vec<DistributedVirtualSwitchKeyedOpaqueBlob>> { &self.vendor_specific_config }
    fn get_policy(&self) -> &Option<DvsPolicy> { &self.policy }
    fn get_description(&self) -> &Option<String> { &self.description }
    fn get_config_version(&self) -> &str { &self.config_version }
    fn get_contact(&self) -> &DvsContactInfo { &self.contact }
    fn get_switch_ip_address(&self) -> &Option<String> { &self.switch_ip_address }
    fn get_create_time(&self) -> &str { &self.create_time }
    fn get_network_resource_management_enabled(&self) -> bool { self.network_resource_management_enabled }
    fn get_default_proxy_switch_max_num_ports(&self) -> Option<i32> { self.default_proxy_switch_max_num_ports }
    fn get_health_check_config(&self) -> &Option<Vec<Box<dyn super::traits::DvsHealthCheckConfigTrait>>> { &self.health_check_config }
    fn get_infrastructure_traffic_resource_config(&self) -> &Option<Vec<DvsHostInfrastructureTrafficResource>> { &self.infrastructure_traffic_resource_config }
    fn get_net_resource_pool_traffic_resource_config(&self) -> &Option<Vec<DvsHostInfrastructureTrafficResource>> { &self.net_resource_pool_traffic_resource_config }
    fn get_network_resource_control_version(&self) -> &Option<String> { &self.network_resource_control_version }
    fn get_vm_vnic_network_resource_pool(&self) -> &Option<Vec<DvsVmVnicNetworkResourcePool>> { &self.vm_vnic_network_resource_pool }
    fn get_pnic_capacity_ratio_for_reservation(&self) -> Option<i32> { self.pnic_capacity_ratio_for_reservation }
}
impl DvsConfigInfoTrait for VMwareDvsConfigInfo {
    fn get_uuid(&self) -> &str { &self.uuid }
    fn get_name(&self) -> &str { &self.name }
    fn get_num_standalone_ports(&self) -> i32 { self.num_standalone_ports }
    fn get_num_ports(&self) -> i32 { self.num_ports }
    fn get_max_ports(&self) -> i32 { self.max_ports }
    fn get_uplink_port_policy(&self) -> &Box<dyn super::traits::DvsUplinkPortPolicyTrait> { &self.uplink_port_policy }
    fn get_uplink_portgroup(&self) -> &Option<Vec<ManagedObjectReference>> { &self.uplink_portgroup }
    fn get_default_port_config(&self) -> &Box<dyn super::traits::DvPortSettingTrait> { &self.default_port_config }
    fn get_host(&self) -> &Option<Vec<DistributedVirtualSwitchHostMember>> { &self.host }
    fn get_product_info(&self) -> &DistributedVirtualSwitchProductSpec { &self.product_info }
    fn get_target_info(&self) -> &Option<DistributedVirtualSwitchProductSpec> { &self.target_info }
    fn get_extension_key(&self) -> &Option<String> { &self.extension_key }
    fn get_vendor_specific_config(&self) -> &Option<Vec<DistributedVirtualSwitchKeyedOpaqueBlob>> { &self.vendor_specific_config }
    fn get_policy(&self) -> &Option<DvsPolicy> { &self.policy }
    fn get_description(&self) -> &Option<String> { &self.description }
    fn get_config_version(&self) -> &str { &self.config_version }
    fn get_contact(&self) -> &DvsContactInfo { &self.contact }
    fn get_switch_ip_address(&self) -> &Option<String> { &self.switch_ip_address }
    fn get_create_time(&self) -> &str { &self.create_time }
    fn get_network_resource_management_enabled(&self) -> bool { self.network_resource_management_enabled }
    fn get_default_proxy_switch_max_num_ports(&self) -> Option<i32> { self.default_proxy_switch_max_num_ports }
    fn get_health_check_config(&self) -> &Option<Vec<Box<dyn super::traits::DvsHealthCheckConfigTrait>>> { &self.health_check_config }
    fn get_infrastructure_traffic_resource_config(&self) -> &Option<Vec<DvsHostInfrastructureTrafficResource>> { &self.infrastructure_traffic_resource_config }
    fn get_net_resource_pool_traffic_resource_config(&self) -> &Option<Vec<DvsHostInfrastructureTrafficResource>> { &self.net_resource_pool_traffic_resource_config }
    fn get_network_resource_control_version(&self) -> &Option<String> { &self.network_resource_control_version }
    fn get_vm_vnic_network_resource_pool(&self) -> &Option<Vec<DvsVmVnicNetworkResourcePool>> { &self.vm_vnic_network_resource_pool }
    fn get_pnic_capacity_ratio_for_reservation(&self) -> Option<i32> { self.pnic_capacity_ratio_for_reservation }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DvsConfigInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsConfigInfo => Some(from.as_any_ref().downcast_ref::<DvsConfigInfo>()?),
            StructType::VMwareDvsConfigInfo => Some(from.as_any_ref().downcast_ref::<VMwareDvsConfigInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsConfigInfo => Ok(from.as_any_box().downcast::<DvsConfigInfo>()?),
            StructType::VMwareDvsConfigInfo => Ok(from.as_any_box().downcast::<VMwareDvsConfigInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *DVSConfigSpec*
/// data object contains configuration data for a
/// *DistributedVirtualSwitch*.
/// 
/// Use the *DistributedVirtualSwitch.ReconfigureDvs_Task*
/// method to apply the configuration to the
/// switch.
pub trait DvsConfigSpecTrait : super::traits::DataObjectTrait {
    /// Set of dynamic properties.
    /// 
    /// This property is optional because only the
    /// properties of an object that are unknown to a client will be part of this set.
    /// This property is not readonly just in case we want to send such properties
    /// from a client in the future.
    fn get_dynamic_property(&self) -> &Option<Vec<DynamicProperty>>;
    /// The version string of the configuration that this spec is trying to
    /// change.
    /// 
    /// This property is required in reconfiguring a switch
    /// and should be set to the same value as
    /// *DVSConfigInfo.configVersion*.
    /// This property is ignored during switch creation.
    fn get_config_version(&self) -> &Option<String>;
    /// The name of the switch.
    /// 
    /// Must be unique in the parent folder.
    fn get_name(&self) -> &Option<String>;
    /// The number of standalone ports in the switch.
    /// 
    /// Standalone ports are
    /// ports that do not belong to any portgroup. If set to a number larger
    /// than number of existing standalone ports in the switch, new ports get
    /// created to meet the number. If set to a number smaller than the number
    /// of existing standalone ports, free ports (uplink ports excluded) are
    /// deleted to meet the number. If the set number cannot be met by
    /// deleting free standalone ports, a fault is raised.
    fn get_num_standalone_ports(&self) -> Option<i32>;
    /// Deprecated as of vSphere API 5.0
    /// The default value of this propoerty is maxint and there is no reason
    /// for users to change it to a lower value.
    /// 
    /// The maximum number of DistributedVirtualPorts allowed in the switch.
    /// 
    /// If specified in a reconfigure operation, this number cannot be smaller
    /// than the number of existing DistributedVirtualPorts.
    fn get_max_ports(&self) -> Option<i32>;
    /// The uplink port policy.
    fn get_uplink_port_policy(&self) -> &Option<Box<dyn super::traits::DvsUplinkPortPolicyTrait>>;
    /// The uplink portgroups.
    /// 
    /// Refers instances of *DistributedVirtualPortgroup*.
    fn get_uplink_portgroup(&self) -> &Option<Vec<ManagedObjectReference>>;
    /// The default configuration for ports.
    fn get_default_port_config(&self) -> &Option<Box<dyn super::traits::DvPortSettingTrait>>;
    /// The host member specification.
    /// 
    /// A particular host should have only one entry
    /// in this array. Duplicate entries for the same host will raise a fault.
    /// The host version should be compatible with the version of
    /// *DistributedVirtualSwitch*. Use
    /// *DistributedVirtualSwitchManager.QueryDvsCheckCompatibility*
    /// to check for compatibility.
    fn get_host(&self) -> &Option<Vec<DistributedVirtualSwitchHostMemberConfigSpec>>;
    /// The key of the extension registered by a remote server that
    /// controls the switch.
    fn get_extension_key(&self) -> &Option<String>;
    /// Set the description string of the switch.
    fn get_description(&self) -> &Option<String>;
    /// The usage policy of the switch.
    fn get_policy(&self) -> &Option<DvsPolicy>;
    /// Set the opaque blob that stores vendor specific configuration.
    fn get_vendor_specific_config(&self) -> &Option<Vec<DistributedVirtualSwitchKeyedOpaqueBlob>>;
    /// Set the human operator contact information.
    fn get_contact(&self) -> &Option<DvsContactInfo>;
    /// IP address for the switch, specified using IPv4 dot notation.
    /// 
    /// IPv6 address is not supported for this property.
    /// The utility of this address is defined by other switch features.
    /// switchIpAddress would be ignored when IPFIX collector uses IPv6.
    fn get_switch_ip_address(&self) -> &Option<String>;
    /// The default host proxy switch maximum port number
    fn get_default_proxy_switch_max_num_ports(&self) -> Option<i32>;
    /// The host infrastructure traffic resource allocation specification.
    /// 
    /// Only the traffic class resource allocations identified in the list
    /// will be updated. The other traffic class resource allocations that are not
    /// specified will not change.
    fn get_infrastructure_traffic_resource_config(&self) -> &Option<Vec<DvsHostInfrastructureTrafficResource>>;
    /// The dynamic host infrastructure traffic resource allocation
    /// specification.
    fn get_net_resource_pool_traffic_resource_config(&self) -> &Option<Vec<DvsHostInfrastructureTrafficResource>>;
    /// Indicates the Network Resource Control APIs that are supported on the switch.
    /// 
    /// Possible value can be of
    /// *DistributedVirtualSwitchNetworkResourceControlVersion_enum*.
    fn get_network_resource_control_version(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn DvsConfigSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DvsConfigSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DvsConfigSpecVisitor)
            }
        }

struct DvsConfigSpecVisitor;

impl<'de> de::Visitor<'de> for DvsConfigSpecVisitor {
    type Value = Box<dyn DvsConfigSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DvsConfigSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DvsConfigSpecTrait for DvsConfigSpec {
    fn get_dynamic_property(&self) -> &Option<Vec<DynamicProperty>> { &self.dynamic_property }
    fn get_config_version(&self) -> &Option<String> { &self.config_version }
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_num_standalone_ports(&self) -> Option<i32> { self.num_standalone_ports }
    fn get_max_ports(&self) -> Option<i32> { self.max_ports }
    fn get_uplink_port_policy(&self) -> &Option<Box<dyn super::traits::DvsUplinkPortPolicyTrait>> { &self.uplink_port_policy }
    fn get_uplink_portgroup(&self) -> &Option<Vec<ManagedObjectReference>> { &self.uplink_portgroup }
    fn get_default_port_config(&self) -> &Option<Box<dyn super::traits::DvPortSettingTrait>> { &self.default_port_config }
    fn get_host(&self) -> &Option<Vec<DistributedVirtualSwitchHostMemberConfigSpec>> { &self.host }
    fn get_extension_key(&self) -> &Option<String> { &self.extension_key }
    fn get_description(&self) -> &Option<String> { &self.description }
    fn get_policy(&self) -> &Option<DvsPolicy> { &self.policy }
    fn get_vendor_specific_config(&self) -> &Option<Vec<DistributedVirtualSwitchKeyedOpaqueBlob>> { &self.vendor_specific_config }
    fn get_contact(&self) -> &Option<DvsContactInfo> { &self.contact }
    fn get_switch_ip_address(&self) -> &Option<String> { &self.switch_ip_address }
    fn get_default_proxy_switch_max_num_ports(&self) -> Option<i32> { self.default_proxy_switch_max_num_ports }
    fn get_infrastructure_traffic_resource_config(&self) -> &Option<Vec<DvsHostInfrastructureTrafficResource>> { &self.infrastructure_traffic_resource_config }
    fn get_net_resource_pool_traffic_resource_config(&self) -> &Option<Vec<DvsHostInfrastructureTrafficResource>> { &self.net_resource_pool_traffic_resource_config }
    fn get_network_resource_control_version(&self) -> &Option<String> { &self.network_resource_control_version }
}
impl DvsConfigSpecTrait for VMwareDvsConfigSpec {
    fn get_dynamic_property(&self) -> &Option<Vec<DynamicProperty>> { &self.dynamic_property }
    fn get_config_version(&self) -> &Option<String> { &self.config_version }
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_num_standalone_ports(&self) -> Option<i32> { self.num_standalone_ports }
    fn get_max_ports(&self) -> Option<i32> { self.max_ports }
    fn get_uplink_port_policy(&self) -> &Option<Box<dyn super::traits::DvsUplinkPortPolicyTrait>> { &self.uplink_port_policy }
    fn get_uplink_portgroup(&self) -> &Option<Vec<ManagedObjectReference>> { &self.uplink_portgroup }
    fn get_default_port_config(&self) -> &Option<Box<dyn super::traits::DvPortSettingTrait>> { &self.default_port_config }
    fn get_host(&self) -> &Option<Vec<DistributedVirtualSwitchHostMemberConfigSpec>> { &self.host }
    fn get_extension_key(&self) -> &Option<String> { &self.extension_key }
    fn get_description(&self) -> &Option<String> { &self.description }
    fn get_policy(&self) -> &Option<DvsPolicy> { &self.policy }
    fn get_vendor_specific_config(&self) -> &Option<Vec<DistributedVirtualSwitchKeyedOpaqueBlob>> { &self.vendor_specific_config }
    fn get_contact(&self) -> &Option<DvsContactInfo> { &self.contact }
    fn get_switch_ip_address(&self) -> &Option<String> { &self.switch_ip_address }
    fn get_default_proxy_switch_max_num_ports(&self) -> Option<i32> { self.default_proxy_switch_max_num_ports }
    fn get_infrastructure_traffic_resource_config(&self) -> &Option<Vec<DvsHostInfrastructureTrafficResource>> { &self.infrastructure_traffic_resource_config }
    fn get_net_resource_pool_traffic_resource_config(&self) -> &Option<Vec<DvsHostInfrastructureTrafficResource>> { &self.net_resource_pool_traffic_resource_config }
    fn get_network_resource_control_version(&self) -> &Option<String> { &self.network_resource_control_version }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DvsConfigSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsConfigSpec => Some(from.as_any_ref().downcast_ref::<DvsConfigSpec>()?),
            StructType::VMwareDvsConfigSpec => Some(from.as_any_ref().downcast_ref::<VMwareDvsConfigSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsConfigSpec => Ok(from.as_any_box().downcast::<DvsConfigSpec>()?),
            StructType::VMwareDvsConfigSpec => Ok(from.as_any_box().downcast::<VMwareDvsConfigSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *DVSFeatureCapability* data object
/// represents the capabilities supported by a
/// *DistributedVirtualSwitch*.
/// 
/// These properties are read-only with
/// the exception of
/// *DVSFeatureCapability.vmDirectPathGen2Supported*.
pub trait DvsFeatureCapabilityTrait : super::traits::DataObjectTrait {
    /// Deprecated as of vSphere API 5.0, use
    /// <code>networkResourceManagementCapability</code>.*DVSNetworkResourceManagementCapability.networkResourceManagementSupported*.
    /// 
    /// Indicates whether network I/O control is
    /// supported on the vSphere Distributed Switch.
    fn get_network_resource_management_supported(&self) -> bool;
    /// Deprecated as of vSphere API 8.0. VMDirectPath Gen 2 is no longer supported and
    /// there is no replacement.
    /// 
    /// Indicates whether VMDirectPath Gen 2 is supported on the
    /// distributed virtual switch.
    /// 
    /// See
    /// *HostCapability*.*HostCapability.vmDirectPathGen2Supported*
    /// and *PhysicalNic*.*PhysicalNic.vmDirectPathGen2Supported*.
    /// 
    /// For a third-party distributed switch implementation, you can
    /// specify this property during switch creation or when you call the
    /// *DistributedVirtualSwitch.UpdateDvsCapability* method.
    /// 
    /// VMDirectPath Gen 2 is supported in
    /// vSphere Distributed Switch Version 4.1 or later.
    fn get_vm_direct_path_gen_2_supported(&self) -> Option<bool>;
    /// The available teaming modes for the vSphere Distributed Switch.
    /// 
    /// The
    /// value can be one or more of
    /// *DistributedVirtualSwitchNicTeamingPolicyMode_enum*.
    fn get_nic_teaming_policy(&self) -> &Option<Vec<String>>;
    /// Deprecated as of vSphere API 5.0, use
    /// <code>networkResourceManagementCapability</code>.*DVSNetworkResourceManagementCapability.networkResourcePoolHighShareValue*.
    /// 
    /// This is the value for *high*
    /// in *DVSNetworkResourcePoolAllocationInfo.shares*.
    /// 
    /// This
    /// implicitly defines the legal range of share values to be between 1 and this.
    /// This also defines values for other level types, such as
    /// *normal* being one half of this value and
    /// *low* being one fourth of this value.
    fn get_network_resource_pool_high_share_value(&self) -> Option<i32>;
    /// Network resource management capabilities supported by a
    /// distributed virtual switch.
    fn get_network_resource_management_capability(&self) -> &Option<DvsNetworkResourceManagementCapability>;
    /// Health check capabilities supported by a *VmwareDistributedVirtualSwitch*.
    fn get_health_check_capability(&self) -> &Option<Box<dyn super::traits::DvsHealthCheckCapabilityTrait>>;
    /// Host rollback capability.
    /// 
    /// If <code>rollbackCapability</code>.*DVSRollbackCapability.rollbackSupported*
    /// is true, network operations that disconnect the the host are rolled back.
    fn get_rollback_capability(&self) -> &Option<DvsRollbackCapability>;
    /// Backup, restore, and rollback capabilities.
    /// 
    /// Backup and restore
    /// are supported only for *VmwareDistributedVirtualSwitch*.
    /// Rollback is supported for *VmwareDistributedVirtualSwitch*
    /// and *DistributedVirtualPortgroup*.
    /// For information about backup and restore, see the
    /// *DistributedVirtualSwitchManager* methods
    /// *DistributedVirtualSwitchManager.DVSManagerExportEntity_Task* and
    /// *DistributedVirtualSwitchManager.DVSManagerImportEntity_Task*.
    /// For information about rollback, see the
    /// *DistributedVirtualSwitch*.*DistributedVirtualSwitch.DVSRollback_Task*
    /// and *DistributedVirtualPortgroup*.*DistributedVirtualPortgroup.DVPortgroupRollback_Task*
    /// methods.
    fn get_backup_restore_capability(&self) -> &Option<DvsBackupRestoreCapability>;
    /// Indicates whether Network Filter feature is
    /// supported in vSphere Distributed Switch.
    fn get_network_filter_supported(&self) -> Option<bool>;
    /// Indicates whether MAC learning feature is
    /// supported in vSphere Distributed Switch.
    fn get_mac_learning_supported(&self) -> Option<bool>;
}
impl<'s> serde::Serialize for dyn DvsFeatureCapabilityTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DvsFeatureCapabilityTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DvsFeatureCapabilityVisitor)
            }
        }

struct DvsFeatureCapabilityVisitor;

impl<'de> de::Visitor<'de> for DvsFeatureCapabilityVisitor {
    type Value = Box<dyn DvsFeatureCapabilityTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DvsFeatureCapabilityTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DvsFeatureCapabilityTrait for DvsFeatureCapability {
    fn get_network_resource_management_supported(&self) -> bool { self.network_resource_management_supported }
    fn get_vm_direct_path_gen_2_supported(&self) -> Option<bool> { self.vm_direct_path_gen_2_supported }
    fn get_nic_teaming_policy(&self) -> &Option<Vec<String>> { &self.nic_teaming_policy }
    fn get_network_resource_pool_high_share_value(&self) -> Option<i32> { self.network_resource_pool_high_share_value }
    fn get_network_resource_management_capability(&self) -> &Option<DvsNetworkResourceManagementCapability> { &self.network_resource_management_capability }
    fn get_health_check_capability(&self) -> &Option<Box<dyn super::traits::DvsHealthCheckCapabilityTrait>> { &self.health_check_capability }
    fn get_rollback_capability(&self) -> &Option<DvsRollbackCapability> { &self.rollback_capability }
    fn get_backup_restore_capability(&self) -> &Option<DvsBackupRestoreCapability> { &self.backup_restore_capability }
    fn get_network_filter_supported(&self) -> Option<bool> { self.network_filter_supported }
    fn get_mac_learning_supported(&self) -> Option<bool> { self.mac_learning_supported }
}
impl DvsFeatureCapabilityTrait for VMwareDvsFeatureCapability {
    fn get_network_resource_management_supported(&self) -> bool { self.network_resource_management_supported }
    fn get_vm_direct_path_gen_2_supported(&self) -> Option<bool> { self.vm_direct_path_gen_2_supported }
    fn get_nic_teaming_policy(&self) -> &Option<Vec<String>> { &self.nic_teaming_policy }
    fn get_network_resource_pool_high_share_value(&self) -> Option<i32> { self.network_resource_pool_high_share_value }
    fn get_network_resource_management_capability(&self) -> &Option<DvsNetworkResourceManagementCapability> { &self.network_resource_management_capability }
    fn get_health_check_capability(&self) -> &Option<Box<dyn super::traits::DvsHealthCheckCapabilityTrait>> { &self.health_check_capability }
    fn get_rollback_capability(&self) -> &Option<DvsRollbackCapability> { &self.rollback_capability }
    fn get_backup_restore_capability(&self) -> &Option<DvsBackupRestoreCapability> { &self.backup_restore_capability }
    fn get_network_filter_supported(&self) -> Option<bool> { self.network_filter_supported }
    fn get_mac_learning_supported(&self) -> Option<bool> { self.mac_learning_supported }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DvsFeatureCapabilityTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsFeatureCapability => Some(from.as_any_ref().downcast_ref::<DvsFeatureCapability>()?),
            StructType::VMwareDvsFeatureCapability => Some(from.as_any_ref().downcast_ref::<VMwareDvsFeatureCapability>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsFeatureCapability => Ok(from.as_any_box().downcast::<DvsFeatureCapability>()?),
            StructType::VMwareDvsFeatureCapability => Ok(from.as_any_box().downcast::<VMwareDvsFeatureCapability>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *DVSHealthCheckConfig* data object
/// defines vSphere Distributed Switch health check configuration.
pub trait DvsHealthCheckConfigTrait : super::traits::DataObjectTrait {
    /// True if enable health check.
    fn get_enable(&self) -> Option<bool>;
    /// Interval of health check, in minutes.
    fn get_interval(&self) -> Option<i32>;
}
impl<'s> serde::Serialize for dyn DvsHealthCheckConfigTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DvsHealthCheckConfigTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DvsHealthCheckConfigVisitor)
            }
        }

struct DvsHealthCheckConfigVisitor;

impl<'de> de::Visitor<'de> for DvsHealthCheckConfigVisitor {
    type Value = Box<dyn DvsHealthCheckConfigTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DvsHealthCheckConfigTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DvsHealthCheckConfigTrait for DvsHealthCheckConfig {
    fn get_enable(&self) -> Option<bool> { self.enable }
    fn get_interval(&self) -> Option<i32> { self.interval }
}
impl DvsHealthCheckConfigTrait for VMwareDvsHealthCheckConfig {
    fn get_enable(&self) -> Option<bool> { self.enable }
    fn get_interval(&self) -> Option<i32> { self.interval }
}
impl DvsHealthCheckConfigTrait for VMwareDvsTeamingHealthCheckConfig {
    fn get_enable(&self) -> Option<bool> { self.enable }
    fn get_interval(&self) -> Option<i32> { self.interval }
}
impl DvsHealthCheckConfigTrait for VMwareDvsVlanMtuHealthCheckConfig {
    fn get_enable(&self) -> Option<bool> { self.enable }
    fn get_interval(&self) -> Option<i32> { self.interval }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DvsHealthCheckConfigTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsHealthCheckConfig => Some(from.as_any_ref().downcast_ref::<DvsHealthCheckConfig>()?),
            StructType::VMwareDvsHealthCheckConfig => Some(from.as_any_ref().downcast_ref::<VMwareDvsHealthCheckConfig>()?),
            StructType::VMwareDvsTeamingHealthCheckConfig => Some(from.as_any_ref().downcast_ref::<VMwareDvsTeamingHealthCheckConfig>()?),
            StructType::VMwareDvsVlanMtuHealthCheckConfig => Some(from.as_any_ref().downcast_ref::<VMwareDvsVlanMtuHealthCheckConfig>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsHealthCheckConfig => Ok(from.as_any_box().downcast::<DvsHealthCheckConfig>()?),
            StructType::VMwareDvsHealthCheckConfig => Ok(from.as_any_box().downcast::<VMwareDvsHealthCheckConfig>()?),
            StructType::VMwareDvsTeamingHealthCheckConfig => Ok(from.as_any_box().downcast::<VMwareDvsTeamingHealthCheckConfig>()?),
            StructType::VMwareDvsVlanMtuHealthCheckConfig => Ok(from.as_any_box().downcast::<VMwareDvsVlanMtuHealthCheckConfig>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This class defines health check configuration for
/// VMware vSphere Distributed Switch.
pub trait VMwareDvsHealthCheckConfigTrait : super::traits::DvsHealthCheckConfigTrait {
}
impl<'s> serde::Serialize for dyn VMwareDvsHealthCheckConfigTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VMwareDvsHealthCheckConfigTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VMwareDvsHealthCheckConfigVisitor)
            }
        }

struct VMwareDvsHealthCheckConfigVisitor;

impl<'de> de::Visitor<'de> for VMwareDvsHealthCheckConfigVisitor {
    type Value = Box<dyn VMwareDvsHealthCheckConfigTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VMwareDvsHealthCheckConfigTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VMwareDvsHealthCheckConfigTrait for VMwareDvsHealthCheckConfig {
}
impl VMwareDvsHealthCheckConfigTrait for VMwareDvsTeamingHealthCheckConfig {
}
impl VMwareDvsHealthCheckConfigTrait for VMwareDvsVlanMtuHealthCheckConfig {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VMwareDvsHealthCheckConfigTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VMwareDvsHealthCheckConfig => Some(from.as_any_ref().downcast_ref::<VMwareDvsHealthCheckConfig>()?),
            StructType::VMwareDvsTeamingHealthCheckConfig => Some(from.as_any_ref().downcast_ref::<VMwareDvsTeamingHealthCheckConfig>()?),
            StructType::VMwareDvsVlanMtuHealthCheckConfig => Some(from.as_any_ref().downcast_ref::<VMwareDvsVlanMtuHealthCheckConfig>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VMwareDvsHealthCheckConfig => Ok(from.as_any_box().downcast::<VMwareDvsHealthCheckConfig>()?),
            StructType::VMwareDvsTeamingHealthCheckConfig => Ok(from.as_any_box().downcast::<VMwareDvsTeamingHealthCheckConfig>()?),
            StructType::VMwareDvsVlanMtuHealthCheckConfig => Ok(from.as_any_box().downcast::<VMwareDvsVlanMtuHealthCheckConfig>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Health check capabilities of health check supported by the
/// vSphere Distributed Switch
pub trait DvsHealthCheckCapabilityTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn DvsHealthCheckCapabilityTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DvsHealthCheckCapabilityTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DvsHealthCheckCapabilityVisitor)
            }
        }

struct DvsHealthCheckCapabilityVisitor;

impl<'de> de::Visitor<'de> for DvsHealthCheckCapabilityVisitor {
    type Value = Box<dyn DvsHealthCheckCapabilityTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DvsHealthCheckCapabilityTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DvsHealthCheckCapabilityTrait for DvsHealthCheckCapability {
}
impl DvsHealthCheckCapabilityTrait for VMwareDvsHealthCheckCapability {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DvsHealthCheckCapabilityTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsHealthCheckCapability => Some(from.as_any_ref().downcast_ref::<DvsHealthCheckCapability>()?),
            StructType::VMwareDvsHealthCheckCapability => Some(from.as_any_ref().downcast_ref::<VMwareDvsHealthCheckCapability>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsHealthCheckCapability => Ok(from.as_any_box().downcast::<DvsHealthCheckCapability>()?),
            StructType::VMwareDvsHealthCheckCapability => Ok(from.as_any_box().downcast::<VMwareDvsHealthCheckCapability>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The base class for uplink port policy.
pub trait DvsUplinkPortPolicyTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn DvsUplinkPortPolicyTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DvsUplinkPortPolicyTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DvsUplinkPortPolicyVisitor)
            }
        }

struct DvsUplinkPortPolicyVisitor;

impl<'de> de::Visitor<'de> for DvsUplinkPortPolicyVisitor {
    type Value = Box<dyn DvsUplinkPortPolicyTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DvsUplinkPortPolicyTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DvsUplinkPortPolicyTrait for DvsUplinkPortPolicy {
}
impl DvsUplinkPortPolicyTrait for DvsNameArrayUplinkPortPolicy {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DvsUplinkPortPolicyTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsUplinkPortPolicy => Some(from.as_any_ref().downcast_ref::<DvsUplinkPortPolicy>()?),
            StructType::DvsNameArrayUplinkPortPolicy => Some(from.as_any_ref().downcast_ref::<DvsNameArrayUplinkPortPolicy>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsUplinkPortPolicy => Ok(from.as_any_box().downcast::<DvsUplinkPortPolicy>()?),
            StructType::DvsNameArrayUplinkPortPolicy => Ok(from.as_any_box().downcast::<DvsNameArrayUplinkPortPolicy>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// An ImportSpec is used when importing VMs or vApps.
/// 
/// It can be built from scratch, or it can be generated from an OVF descriptor using the
/// service interface *OvfManager*.
/// 
/// This class is the abstract base for *VirtualMachineImportSpec* and
/// *VirtualAppImportSpec*. These three classes form a composite structure
/// that allows us to contain arbitrarily complex entitites in a single ImportSpec.
pub trait ImportSpecTrait : super::traits::DataObjectTrait {
    /// Configuration of sub-entities (virtual machine or vApp).
    /// 
    /// This is used for
    /// sub-entities of a vApp that could be a virtual machine or a vApp.
    fn get_entity_config(&self) -> &Option<VAppEntityConfigInfo>;
    /// The instantiation OST (see *OvfConsumer* ) to be consumed by OVF
    /// consumers.
    fn get_instantiation_ost(&self) -> &Option<OvfConsumerOstNode>;
}
impl<'s> serde::Serialize for dyn ImportSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ImportSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ImportSpecVisitor)
            }
        }

struct ImportSpecVisitor;

impl<'de> de::Visitor<'de> for ImportSpecVisitor {
    type Value = Box<dyn ImportSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ImportSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ImportSpecTrait for ImportSpec {
    fn get_entity_config(&self) -> &Option<VAppEntityConfigInfo> { &self.entity_config }
    fn get_instantiation_ost(&self) -> &Option<OvfConsumerOstNode> { &self.instantiation_ost }
}
impl ImportSpecTrait for VirtualAppImportSpec {
    fn get_entity_config(&self) -> &Option<VAppEntityConfigInfo> { &self.entity_config }
    fn get_instantiation_ost(&self) -> &Option<OvfConsumerOstNode> { &self.instantiation_ost }
}
impl ImportSpecTrait for VirtualMachineImportSpec {
    fn get_entity_config(&self) -> &Option<VAppEntityConfigInfo> { &self.entity_config }
    fn get_instantiation_ost(&self) -> &Option<OvfConsumerOstNode> { &self.instantiation_ost }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ImportSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ImportSpec => Some(from.as_any_ref().downcast_ref::<ImportSpec>()?),
            StructType::VirtualAppImportSpec => Some(from.as_any_ref().downcast_ref::<VirtualAppImportSpec>()?),
            StructType::VirtualMachineImportSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineImportSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ImportSpec => Ok(from.as_any_box().downcast::<ImportSpec>()?),
            StructType::VirtualAppImportSpec => Ok(from.as_any_box().downcast::<VirtualAppImportSpec>()?),
            StructType::VirtualMachineImportSpec => Ok(from.as_any_box().downcast::<VirtualMachineImportSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The base class for any type of setting or configuration that may get a
/// inherited value.
/// 
/// When used in a reconfigure operation specification, if *InheritablePolicy.inherited* is true,
/// it specifies the intention to change the values of subclass's properties to the
/// inherited values from the level above. In this case, users don't need to specify
/// the values and any set property in the subclass will be ignored.
/// if *InheritablePolicy.inherited* is false, it specifies the intention to explicitly set
/// subclass's properties to user specified values. Users should set the properties in
/// the subclass with the desired values.
/// 
/// When used in a configuration information object, The values of the properties in
/// the subclass are the effective values. if *InheritablePolicy.inherited* is true, the object
/// is getting the effective values from upper level. If false, the values are
/// explicitly set by a user.
pub trait InheritablePolicyTrait : super::traits::DataObjectTrait {
    /// Whether the configuration is set to inherited value.
    fn get_inherited(&self) -> bool;
}
impl<'s> serde::Serialize for dyn InheritablePolicyTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn InheritablePolicyTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(InheritablePolicyVisitor)
            }
        }

struct InheritablePolicyVisitor;

impl<'de> de::Visitor<'de> for InheritablePolicyVisitor {
    type Value = Box<dyn InheritablePolicyTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid InheritablePolicyTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl InheritablePolicyTrait for InheritablePolicy {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for BoolPolicy {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for IntPolicy {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for LongPolicy {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for StringPolicy {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for DvsFilterConfig {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for DvsFilterConfigSpec {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for DvsTrafficFilterConfig {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for DvsTrafficFilterConfigSpec {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for DvsFilterPolicy {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for DvsTrafficShapingPolicy {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for DvsVendorSpecificConfig {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for DvsFailureCriteria {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for DvsMacLearningPolicy {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for DvsMacManagementPolicy {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for DvsSecurityPolicy {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for VMwareUplinkLacpPolicy {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for VMwareUplinkPortOrderPolicy {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for VmwareUplinkPortTeamingPolicy {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for VmwareDistributedVirtualSwitchVlanSpec {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for VmwareDistributedVirtualSwitchPvlanSpec {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for VmwareDistributedVirtualSwitchTrunkVlanSpec {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl InheritablePolicyTrait for VmwareDistributedVirtualSwitchVlanIdSpec {
    fn get_inherited(&self) -> bool { self.inherited }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn InheritablePolicyTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::InheritablePolicy => Some(from.as_any_ref().downcast_ref::<InheritablePolicy>()?),
            StructType::BoolPolicy => Some(from.as_any_ref().downcast_ref::<BoolPolicy>()?),
            StructType::IntPolicy => Some(from.as_any_ref().downcast_ref::<IntPolicy>()?),
            StructType::LongPolicy => Some(from.as_any_ref().downcast_ref::<LongPolicy>()?),
            StructType::StringPolicy => Some(from.as_any_ref().downcast_ref::<StringPolicy>()?),
            StructType::DvsFilterConfig => Some(from.as_any_ref().downcast_ref::<DvsFilterConfig>()?),
            StructType::DvsFilterConfigSpec => Some(from.as_any_ref().downcast_ref::<DvsFilterConfigSpec>()?),
            StructType::DvsTrafficFilterConfig => Some(from.as_any_ref().downcast_ref::<DvsTrafficFilterConfig>()?),
            StructType::DvsTrafficFilterConfigSpec => Some(from.as_any_ref().downcast_ref::<DvsTrafficFilterConfigSpec>()?),
            StructType::DvsFilterPolicy => Some(from.as_any_ref().downcast_ref::<DvsFilterPolicy>()?),
            StructType::DvsTrafficShapingPolicy => Some(from.as_any_ref().downcast_ref::<DvsTrafficShapingPolicy>()?),
            StructType::DvsVendorSpecificConfig => Some(from.as_any_ref().downcast_ref::<DvsVendorSpecificConfig>()?),
            StructType::DvsFailureCriteria => Some(from.as_any_ref().downcast_ref::<DvsFailureCriteria>()?),
            StructType::DvsMacLearningPolicy => Some(from.as_any_ref().downcast_ref::<DvsMacLearningPolicy>()?),
            StructType::DvsMacManagementPolicy => Some(from.as_any_ref().downcast_ref::<DvsMacManagementPolicy>()?),
            StructType::DvsSecurityPolicy => Some(from.as_any_ref().downcast_ref::<DvsSecurityPolicy>()?),
            StructType::VMwareUplinkLacpPolicy => Some(from.as_any_ref().downcast_ref::<VMwareUplinkLacpPolicy>()?),
            StructType::VMwareUplinkPortOrderPolicy => Some(from.as_any_ref().downcast_ref::<VMwareUplinkPortOrderPolicy>()?),
            StructType::VmwareUplinkPortTeamingPolicy => Some(from.as_any_ref().downcast_ref::<VmwareUplinkPortTeamingPolicy>()?),
            StructType::VmwareDistributedVirtualSwitchVlanSpec => Some(from.as_any_ref().downcast_ref::<VmwareDistributedVirtualSwitchVlanSpec>()?),
            StructType::VmwareDistributedVirtualSwitchPvlanSpec => Some(from.as_any_ref().downcast_ref::<VmwareDistributedVirtualSwitchPvlanSpec>()?),
            StructType::VmwareDistributedVirtualSwitchTrunkVlanSpec => Some(from.as_any_ref().downcast_ref::<VmwareDistributedVirtualSwitchTrunkVlanSpec>()?),
            StructType::VmwareDistributedVirtualSwitchVlanIdSpec => Some(from.as_any_ref().downcast_ref::<VmwareDistributedVirtualSwitchVlanIdSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::InheritablePolicy => Ok(from.as_any_box().downcast::<InheritablePolicy>()?),
            StructType::BoolPolicy => Ok(from.as_any_box().downcast::<BoolPolicy>()?),
            StructType::IntPolicy => Ok(from.as_any_box().downcast::<IntPolicy>()?),
            StructType::LongPolicy => Ok(from.as_any_box().downcast::<LongPolicy>()?),
            StructType::StringPolicy => Ok(from.as_any_box().downcast::<StringPolicy>()?),
            StructType::DvsFilterConfig => Ok(from.as_any_box().downcast::<DvsFilterConfig>()?),
            StructType::DvsFilterConfigSpec => Ok(from.as_any_box().downcast::<DvsFilterConfigSpec>()?),
            StructType::DvsTrafficFilterConfig => Ok(from.as_any_box().downcast::<DvsTrafficFilterConfig>()?),
            StructType::DvsTrafficFilterConfigSpec => Ok(from.as_any_box().downcast::<DvsTrafficFilterConfigSpec>()?),
            StructType::DvsFilterPolicy => Ok(from.as_any_box().downcast::<DvsFilterPolicy>()?),
            StructType::DvsTrafficShapingPolicy => Ok(from.as_any_box().downcast::<DvsTrafficShapingPolicy>()?),
            StructType::DvsVendorSpecificConfig => Ok(from.as_any_box().downcast::<DvsVendorSpecificConfig>()?),
            StructType::DvsFailureCriteria => Ok(from.as_any_box().downcast::<DvsFailureCriteria>()?),
            StructType::DvsMacLearningPolicy => Ok(from.as_any_box().downcast::<DvsMacLearningPolicy>()?),
            StructType::DvsMacManagementPolicy => Ok(from.as_any_box().downcast::<DvsMacManagementPolicy>()?),
            StructType::DvsSecurityPolicy => Ok(from.as_any_box().downcast::<DvsSecurityPolicy>()?),
            StructType::VMwareUplinkLacpPolicy => Ok(from.as_any_box().downcast::<VMwareUplinkLacpPolicy>()?),
            StructType::VMwareUplinkPortOrderPolicy => Ok(from.as_any_box().downcast::<VMwareUplinkPortOrderPolicy>()?),
            StructType::VmwareUplinkPortTeamingPolicy => Ok(from.as_any_box().downcast::<VmwareUplinkPortTeamingPolicy>()?),
            StructType::VmwareDistributedVirtualSwitchVlanSpec => Ok(from.as_any_box().downcast::<VmwareDistributedVirtualSwitchVlanSpec>()?),
            StructType::VmwareDistributedVirtualSwitchPvlanSpec => Ok(from.as_any_box().downcast::<VmwareDistributedVirtualSwitchPvlanSpec>()?),
            StructType::VmwareDistributedVirtualSwitchTrunkVlanSpec => Ok(from.as_any_box().downcast::<VmwareDistributedVirtualSwitchTrunkVlanSpec>()?),
            StructType::VmwareDistributedVirtualSwitchVlanIdSpec => Ok(from.as_any_box().downcast::<VmwareDistributedVirtualSwitchVlanIdSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This class defines Network Filter configuration.
/// 
/// ** Supported Qualifier and Actions **
/// <table border="1"width="100%">
/// <tr>
/// <th>Network Filter Config</th>
/// <th>Supported classes</th>
/// </tr>
/// <tr>
/// <td>Qualifiers supported</td>
/// <td>*SingleIp*, *IpRange*,
/// *SingleMac*, *MacRange*,
/// *DvsSingleIpPort*,
/// *DvsSystemTrafficNetworkRuleQualifier*
/// </td>
/// </tr>
/// <tr>
/// <td>Actions Supported</td>
/// <td>*DvsDropNetworkRuleAction*,
/// *DvsAcceptNetworkRuleAction*,
/// *DvsPuntNetworkRuleAction*,
/// *DvsCopyNetworkRuleAction*,
/// *DvsMacRewriteNetworkRuleAction*,
/// *DvsGreEncapNetworkRuleAction*,
/// *DvsLogNetworkRuleAction*,
/// *DvsUpdateTagNetworkRuleAction*,
/// *DvsRateLimitNetworkRuleAction*
/// </td>
/// </tr>
pub trait DvsFilterConfigTrait : super::traits::InheritablePolicyTrait {
    /// The key of Network Filter Config.
    fn get_key(&self) -> &Option<String>;
    /// The name of the network traffic filter agent.
    fn get_agent_name(&self) -> &Option<String>;
    /// The slot number of the network filter agent.
    fn get_slot_number(&self) -> &Option<String>;
    /// Network Filter Parameter
    fn get_parameters(&self) -> &Option<DvsFilterParameter>;
    /// This property specifies whether to allow all traffic or to deny all
    /// traffic when a Network Filter fails to configure.
    /// 
    /// Please see *DvsFilterOnFailure_enum*
    /// for more details.
    fn get_on_failure(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn DvsFilterConfigTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DvsFilterConfigTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DvsFilterConfigVisitor)
            }
        }

struct DvsFilterConfigVisitor;

impl<'de> de::Visitor<'de> for DvsFilterConfigVisitor {
    type Value = Box<dyn DvsFilterConfigTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DvsFilterConfigTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DvsFilterConfigTrait for DvsFilterConfig {
    fn get_key(&self) -> &Option<String> { &self.key }
    fn get_agent_name(&self) -> &Option<String> { &self.agent_name }
    fn get_slot_number(&self) -> &Option<String> { &self.slot_number }
    fn get_parameters(&self) -> &Option<DvsFilterParameter> { &self.parameters }
    fn get_on_failure(&self) -> &Option<String> { &self.on_failure }
}
impl DvsFilterConfigTrait for DvsFilterConfigSpec {
    fn get_key(&self) -> &Option<String> { &self.key }
    fn get_agent_name(&self) -> &Option<String> { &self.agent_name }
    fn get_slot_number(&self) -> &Option<String> { &self.slot_number }
    fn get_parameters(&self) -> &Option<DvsFilterParameter> { &self.parameters }
    fn get_on_failure(&self) -> &Option<String> { &self.on_failure }
}
impl DvsFilterConfigTrait for DvsTrafficFilterConfig {
    fn get_key(&self) -> &Option<String> { &self.key }
    fn get_agent_name(&self) -> &Option<String> { &self.agent_name }
    fn get_slot_number(&self) -> &Option<String> { &self.slot_number }
    fn get_parameters(&self) -> &Option<DvsFilterParameter> { &self.parameters }
    fn get_on_failure(&self) -> &Option<String> { &self.on_failure }
}
impl DvsFilterConfigTrait for DvsTrafficFilterConfigSpec {
    fn get_key(&self) -> &Option<String> { &self.key }
    fn get_agent_name(&self) -> &Option<String> { &self.agent_name }
    fn get_slot_number(&self) -> &Option<String> { &self.slot_number }
    fn get_parameters(&self) -> &Option<DvsFilterParameter> { &self.parameters }
    fn get_on_failure(&self) -> &Option<String> { &self.on_failure }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DvsFilterConfigTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsFilterConfig => Some(from.as_any_ref().downcast_ref::<DvsFilterConfig>()?),
            StructType::DvsFilterConfigSpec => Some(from.as_any_ref().downcast_ref::<DvsFilterConfigSpec>()?),
            StructType::DvsTrafficFilterConfig => Some(from.as_any_ref().downcast_ref::<DvsTrafficFilterConfig>()?),
            StructType::DvsTrafficFilterConfigSpec => Some(from.as_any_ref().downcast_ref::<DvsTrafficFilterConfigSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsFilterConfig => Ok(from.as_any_box().downcast::<DvsFilterConfig>()?),
            StructType::DvsFilterConfigSpec => Ok(from.as_any_box().downcast::<DvsFilterConfigSpec>()?),
            StructType::DvsTrafficFilterConfig => Ok(from.as_any_box().downcast::<DvsTrafficFilterConfig>()?),
            StructType::DvsTrafficFilterConfigSpec => Ok(from.as_any_box().downcast::<DvsTrafficFilterConfigSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This class defines Traffic Filter configuration.
/// 
/// ** Supported Qualifier and Actions **
/// <table border="1"width="100%">
/// <tr>
/// <th>Traffic Filter Config</th>
/// <th>Supported classes</th>
/// </tr>
/// <tr>
/// <td>Qualifiers supported</td>
/// <td>*SingleIp*, *IpRange*,
/// *SingleMac*, *MacRange*,
/// *DvsSingleIpPort*,
/// *DvsSystemTrafficNetworkRuleQualifier*
/// </td>
/// </tr>
/// <tr>
/// <td>Actions Supported</td>
/// <td>*DvsDropNetworkRuleAction*,
/// *DvsAcceptNetworkRuleAction*,
/// *DvsPuntNetworkRuleAction*,
/// *DvsCopyNetworkRuleAction*,
/// *DvsMacRewriteNetworkRuleAction*,
/// *DvsGreEncapNetworkRuleAction*,
/// *DvsLogNetworkRuleAction*,
/// *DvsUpdateTagNetworkRuleAction*,
/// *DvsRateLimitNetworkRuleAction*
/// </td>
/// </tr>
pub trait DvsTrafficFilterConfigTrait : super::traits::DvsFilterConfigTrait {
    /// Network Traffic Ruleset
    fn get_traffic_ruleset(&self) -> &Option<DvsTrafficRuleset>;
}
impl<'s> serde::Serialize for dyn DvsTrafficFilterConfigTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DvsTrafficFilterConfigTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DvsTrafficFilterConfigVisitor)
            }
        }

struct DvsTrafficFilterConfigVisitor;

impl<'de> de::Visitor<'de> for DvsTrafficFilterConfigVisitor {
    type Value = Box<dyn DvsTrafficFilterConfigTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DvsTrafficFilterConfigTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DvsTrafficFilterConfigTrait for DvsTrafficFilterConfig {
    fn get_traffic_ruleset(&self) -> &Option<DvsTrafficRuleset> { &self.traffic_ruleset }
}
impl DvsTrafficFilterConfigTrait for DvsTrafficFilterConfigSpec {
    fn get_traffic_ruleset(&self) -> &Option<DvsTrafficRuleset> { &self.traffic_ruleset }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DvsTrafficFilterConfigTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsTrafficFilterConfig => Some(from.as_any_ref().downcast_ref::<DvsTrafficFilterConfig>()?),
            StructType::DvsTrafficFilterConfigSpec => Some(from.as_any_ref().downcast_ref::<DvsTrafficFilterConfigSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsTrafficFilterConfig => Ok(from.as_any_box().downcast::<DvsTrafficFilterConfig>()?),
            StructType::DvsTrafficFilterConfigSpec => Ok(from.as_any_box().downcast::<DvsTrafficFilterConfigSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class for Vlan Specifiation for ports.
pub trait VmwareDistributedVirtualSwitchVlanSpecTrait : super::traits::InheritablePolicyTrait {
}
impl<'s> serde::Serialize for dyn VmwareDistributedVirtualSwitchVlanSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VmwareDistributedVirtualSwitchVlanSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VmwareDistributedVirtualSwitchVlanSpecVisitor)
            }
        }

struct VmwareDistributedVirtualSwitchVlanSpecVisitor;

impl<'de> de::Visitor<'de> for VmwareDistributedVirtualSwitchVlanSpecVisitor {
    type Value = Box<dyn VmwareDistributedVirtualSwitchVlanSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VmwareDistributedVirtualSwitchVlanSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VmwareDistributedVirtualSwitchVlanSpecTrait for VmwareDistributedVirtualSwitchVlanSpec {
}
impl VmwareDistributedVirtualSwitchVlanSpecTrait for VmwareDistributedVirtualSwitchPvlanSpec {
}
impl VmwareDistributedVirtualSwitchVlanSpecTrait for VmwareDistributedVirtualSwitchTrunkVlanSpec {
}
impl VmwareDistributedVirtualSwitchVlanSpecTrait for VmwareDistributedVirtualSwitchVlanIdSpec {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VmwareDistributedVirtualSwitchVlanSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmwareDistributedVirtualSwitchVlanSpec => Some(from.as_any_ref().downcast_ref::<VmwareDistributedVirtualSwitchVlanSpec>()?),
            StructType::VmwareDistributedVirtualSwitchPvlanSpec => Some(from.as_any_ref().downcast_ref::<VmwareDistributedVirtualSwitchPvlanSpec>()?),
            StructType::VmwareDistributedVirtualSwitchTrunkVlanSpec => Some(from.as_any_ref().downcast_ref::<VmwareDistributedVirtualSwitchTrunkVlanSpec>()?),
            StructType::VmwareDistributedVirtualSwitchVlanIdSpec => Some(from.as_any_ref().downcast_ref::<VmwareDistributedVirtualSwitchVlanIdSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmwareDistributedVirtualSwitchVlanSpec => Ok(from.as_any_box().downcast::<VmwareDistributedVirtualSwitchVlanSpec>()?),
            StructType::VmwareDistributedVirtualSwitchPvlanSpec => Ok(from.as_any_box().downcast::<VmwareDistributedVirtualSwitchPvlanSpec>()?),
            StructType::VmwareDistributedVirtualSwitchTrunkVlanSpec => Ok(from.as_any_box().downcast::<VmwareDistributedVirtualSwitchTrunkVlanSpec>()?),
            StructType::VmwareDistributedVirtualSwitchVlanIdSpec => Ok(from.as_any_box().downcast::<VmwareDistributedVirtualSwitchVlanIdSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Information about an IO Filter.
pub trait IoFilterInfoTrait : super::traits::DataObjectTrait {
    /// IO Filter identifier.
    fn get_id(&self) -> &str;
    /// Name of the IO Filter.
    fn get_name(&self) -> &str;
    /// Vendor of the IO Filter.
    fn get_vendor(&self) -> &str;
    /// Version of the IO Filter.
    fn get_version(&self) -> &str;
    /// Type of the IO Filter.
    /// 
    /// The set of possible values are listed in
    /// *IoFilterType_enum*.
    /// The property is unset if the information is not available.
    fn get_type(&self) -> &Option<String>;
    /// Short description of the IO Filter.
    /// 
    /// The property is unset if the information is not available.
    fn get_summary(&self) -> &Option<String>;
    /// Release date of the IO Filter.
    /// 
    /// The property is unset if the information is not available.
    fn get_release_date(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn IoFilterInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn IoFilterInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(IoFilterInfoVisitor)
            }
        }

struct IoFilterInfoVisitor;

impl<'de> de::Visitor<'de> for IoFilterInfoVisitor {
    type Value = Box<dyn IoFilterInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid IoFilterInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl IoFilterInfoTrait for IoFilterInfo {
    fn get_id(&self) -> &str { &self.id }
    fn get_name(&self) -> &str { &self.name }
    fn get_vendor(&self) -> &str { &self.vendor }
    fn get_version(&self) -> &str { &self.version }
    fn get_type(&self) -> &Option<String> { &self.r#type }
    fn get_summary(&self) -> &Option<String> { &self.summary }
    fn get_release_date(&self) -> &Option<String> { &self.release_date }
}
impl IoFilterInfoTrait for ClusterIoFilterInfo {
    fn get_id(&self) -> &str { &self.id }
    fn get_name(&self) -> &str { &self.name }
    fn get_vendor(&self) -> &str { &self.vendor }
    fn get_version(&self) -> &str { &self.version }
    fn get_type(&self) -> &Option<String> { &self.r#type }
    fn get_summary(&self) -> &Option<String> { &self.summary }
    fn get_release_date(&self) -> &Option<String> { &self.release_date }
}
impl IoFilterInfoTrait for HostIoFilterInfo {
    fn get_id(&self) -> &str { &self.id }
    fn get_name(&self) -> &str { &self.name }
    fn get_vendor(&self) -> &str { &self.vendor }
    fn get_version(&self) -> &str { &self.version }
    fn get_type(&self) -> &Option<String> { &self.r#type }
    fn get_summary(&self) -> &Option<String> { &self.summary }
    fn get_release_date(&self) -> &Option<String> { &self.release_date }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn IoFilterInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::IoFilterInfo => Some(from.as_any_ref().downcast_ref::<IoFilterInfo>()?),
            StructType::ClusterIoFilterInfo => Some(from.as_any_ref().downcast_ref::<ClusterIoFilterInfo>()?),
            StructType::HostIoFilterInfo => Some(from.as_any_ref().downcast_ref::<HostIoFilterInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::IoFilterInfo => Ok(from.as_any_box().downcast::<IoFilterInfo>()?),
            StructType::ClusterIoFilterInfo => Ok(from.as_any_box().downcast::<ClusterIoFilterInfo>()?),
            StructType::HostIoFilterInfo => Ok(from.as_any_box().downcast::<HostIoFilterInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Deprecated as of vSphere API 4.0, this is not used by the system.
/// 
/// This data object type is used to communicate configuration about
/// where to find licenses to use for this system.
pub trait LicenseSourceTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn LicenseSourceTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn LicenseSourceTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(LicenseSourceVisitor)
            }
        }

struct LicenseSourceVisitor;

impl<'de> de::Visitor<'de> for LicenseSourceVisitor {
    type Value = Box<dyn LicenseSourceTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid LicenseSourceTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl LicenseSourceTrait for LicenseSource {
}
impl LicenseSourceTrait for EvaluationLicenseSource {
}
impl LicenseSourceTrait for LicenseServerSource {
}
impl LicenseSourceTrait for LocalLicenseSource {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn LicenseSourceTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::LicenseSource => Some(from.as_any_ref().downcast_ref::<LicenseSource>()?),
            StructType::EvaluationLicenseSource => Some(from.as_any_ref().downcast_ref::<EvaluationLicenseSource>()?),
            StructType::LicenseServerSource => Some(from.as_any_ref().downcast_ref::<LicenseServerSource>()?),
            StructType::LocalLicenseSource => Some(from.as_any_ref().downcast_ref::<LocalLicenseSource>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::LicenseSource => Ok(from.as_any_box().downcast::<LicenseSource>()?),
            StructType::EvaluationLicenseSource => Ok(from.as_any_box().downcast::<EvaluationLicenseSource>()?),
            StructType::LicenseServerSource => Ok(from.as_any_box().downcast::<LicenseServerSource>()?),
            StructType::LocalLicenseSource => Ok(from.as_any_box().downcast::<LocalLicenseSource>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The base class for any type of setting or configuration to which negation
/// can be applied.
/// 
/// When used in a configuration information object:
/// if *NegatableExpression.negate* is true, then ~(objectValue) will be used for the
/// configuration. If false, then objectValue will be used as it is.
pub trait NegatableExpressionTrait : super::traits::DataObjectTrait {
    /// Whether the configuration needs to be negated or not.
    fn get_negate(&self) -> Option<bool>;
}
impl<'s> serde::Serialize for dyn NegatableExpressionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn NegatableExpressionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(NegatableExpressionVisitor)
            }
        }

struct NegatableExpressionVisitor;

impl<'de> de::Visitor<'de> for NegatableExpressionVisitor {
    type Value = Box<dyn NegatableExpressionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid NegatableExpressionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl NegatableExpressionTrait for NegatableExpression {
    fn get_negate(&self) -> Option<bool> { self.negate }
}
impl NegatableExpressionTrait for IntExpression {
    fn get_negate(&self) -> Option<bool> { self.negate }
}
impl NegatableExpressionTrait for IpAddress {
    fn get_negate(&self) -> Option<bool> { self.negate }
}
impl NegatableExpressionTrait for IpRange {
    fn get_negate(&self) -> Option<bool> { self.negate }
}
impl NegatableExpressionTrait for SingleIp {
    fn get_negate(&self) -> Option<bool> { self.negate }
}
impl NegatableExpressionTrait for MacAddress {
    fn get_negate(&self) -> Option<bool> { self.negate }
}
impl NegatableExpressionTrait for MacRange {
    fn get_negate(&self) -> Option<bool> { self.negate }
}
impl NegatableExpressionTrait for SingleMac {
    fn get_negate(&self) -> Option<bool> { self.negate }
}
impl NegatableExpressionTrait for StringExpression {
    fn get_negate(&self) -> Option<bool> { self.negate }
}
impl NegatableExpressionTrait for DvsIpPort {
    fn get_negate(&self) -> Option<bool> { self.negate }
}
impl NegatableExpressionTrait for DvsIpPortRange {
    fn get_negate(&self) -> Option<bool> { self.negate }
}
impl NegatableExpressionTrait for DvsSingleIpPort {
    fn get_negate(&self) -> Option<bool> { self.negate }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn NegatableExpressionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::NegatableExpression => Some(from.as_any_ref().downcast_ref::<NegatableExpression>()?),
            StructType::IntExpression => Some(from.as_any_ref().downcast_ref::<IntExpression>()?),
            StructType::IpAddress => Some(from.as_any_ref().downcast_ref::<IpAddress>()?),
            StructType::IpRange => Some(from.as_any_ref().downcast_ref::<IpRange>()?),
            StructType::SingleIp => Some(from.as_any_ref().downcast_ref::<SingleIp>()?),
            StructType::MacAddress => Some(from.as_any_ref().downcast_ref::<MacAddress>()?),
            StructType::MacRange => Some(from.as_any_ref().downcast_ref::<MacRange>()?),
            StructType::SingleMac => Some(from.as_any_ref().downcast_ref::<SingleMac>()?),
            StructType::StringExpression => Some(from.as_any_ref().downcast_ref::<StringExpression>()?),
            StructType::DvsIpPort => Some(from.as_any_ref().downcast_ref::<DvsIpPort>()?),
            StructType::DvsIpPortRange => Some(from.as_any_ref().downcast_ref::<DvsIpPortRange>()?),
            StructType::DvsSingleIpPort => Some(from.as_any_ref().downcast_ref::<DvsSingleIpPort>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::NegatableExpression => Ok(from.as_any_box().downcast::<NegatableExpression>()?),
            StructType::IntExpression => Ok(from.as_any_box().downcast::<IntExpression>()?),
            StructType::IpAddress => Ok(from.as_any_box().downcast::<IpAddress>()?),
            StructType::IpRange => Ok(from.as_any_box().downcast::<IpRange>()?),
            StructType::SingleIp => Ok(from.as_any_box().downcast::<SingleIp>()?),
            StructType::MacAddress => Ok(from.as_any_box().downcast::<MacAddress>()?),
            StructType::MacRange => Ok(from.as_any_box().downcast::<MacRange>()?),
            StructType::SingleMac => Ok(from.as_any_box().downcast::<SingleMac>()?),
            StructType::StringExpression => Ok(from.as_any_box().downcast::<StringExpression>()?),
            StructType::DvsIpPort => Ok(from.as_any_box().downcast::<DvsIpPort>()?),
            StructType::DvsIpPortRange => Ok(from.as_any_box().downcast::<DvsIpPortRange>()?),
            StructType::DvsSingleIpPort => Ok(from.as_any_box().downcast::<DvsSingleIpPort>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This is the abstract base class for IP address.
pub trait IpAddressTrait : super::traits::NegatableExpressionTrait {
}
impl<'s> serde::Serialize for dyn IpAddressTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn IpAddressTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(IpAddressVisitor)
            }
        }

struct IpAddressVisitor;

impl<'de> de::Visitor<'de> for IpAddressVisitor {
    type Value = Box<dyn IpAddressTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid IpAddressTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl IpAddressTrait for IpAddress {
}
impl IpAddressTrait for IpRange {
}
impl IpAddressTrait for SingleIp {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn IpAddressTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::IpAddress => Some(from.as_any_ref().downcast_ref::<IpAddress>()?),
            StructType::IpRange => Some(from.as_any_ref().downcast_ref::<IpRange>()?),
            StructType::SingleIp => Some(from.as_any_ref().downcast_ref::<SingleIp>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::IpAddress => Ok(from.as_any_box().downcast::<IpAddress>()?),
            StructType::IpRange => Ok(from.as_any_box().downcast::<IpRange>()?),
            StructType::SingleIp => Ok(from.as_any_box().downcast::<SingleIp>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class for specifying MAC addresses.
pub trait MacAddressTrait : super::traits::NegatableExpressionTrait {
}
impl<'s> serde::Serialize for dyn MacAddressTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn MacAddressTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(MacAddressVisitor)
            }
        }

struct MacAddressVisitor;

impl<'de> de::Visitor<'de> for MacAddressVisitor {
    type Value = Box<dyn MacAddressTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid MacAddressTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl MacAddressTrait for MacAddress {
}
impl MacAddressTrait for MacRange {
}
impl MacAddressTrait for SingleMac {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn MacAddressTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::MacAddress => Some(from.as_any_ref().downcast_ref::<MacAddress>()?),
            StructType::MacRange => Some(from.as_any_ref().downcast_ref::<MacRange>()?),
            StructType::SingleMac => Some(from.as_any_ref().downcast_ref::<SingleMac>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::MacAddress => Ok(from.as_any_box().downcast::<MacAddress>()?),
            StructType::MacRange => Ok(from.as_any_box().downcast::<MacRange>()?),
            StructType::SingleMac => Ok(from.as_any_box().downcast::<SingleMac>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class for specifying Ports.
/// 
/// Objects of the base class represent any port (single/range/list).
pub trait DvsIpPortTrait : super::traits::NegatableExpressionTrait {
}
impl<'s> serde::Serialize for dyn DvsIpPortTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DvsIpPortTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DvsIpPortVisitor)
            }
        }

struct DvsIpPortVisitor;

impl<'de> de::Visitor<'de> for DvsIpPortVisitor {
    type Value = Box<dyn DvsIpPortTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DvsIpPortTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DvsIpPortTrait for DvsIpPort {
}
impl DvsIpPortTrait for DvsIpPortRange {
}
impl DvsIpPortTrait for DvsSingleIpPort {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DvsIpPortTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsIpPort => Some(from.as_any_ref().downcast_ref::<DvsIpPort>()?),
            StructType::DvsIpPortRange => Some(from.as_any_ref().downcast_ref::<DvsIpPortRange>()?),
            StructType::DvsSingleIpPort => Some(from.as_any_ref().downcast_ref::<DvsSingleIpPort>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsIpPort => Ok(from.as_any_box().downcast::<DvsIpPort>()?),
            StructType::DvsIpPortRange => Ok(from.as_any_box().downcast::<DvsIpPortRange>()?),
            StructType::DvsSingleIpPort => Ok(from.as_any_box().downcast::<DvsSingleIpPort>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// General information about a network.
pub trait NetworkSummaryTrait : super::traits::DataObjectTrait {
    /// Reference to the associated managed object.
    /// 
    /// Refers instance of *Network*.
    fn get_network(&self) -> &Option<ManagedObjectReference>;
    /// Name of the network.
    fn get_name(&self) -> &str;
    /// At least one host is configured to provide this network.
    fn get_accessible(&self) -> bool;
    /// Name of the associated IP pool.
    /// 
    /// Empty if the network is not associated with an
    /// IP pool.
    fn get_ip_pool_name(&self) -> &str;
    /// Identifier of the associated IP pool.
    /// 
    /// Zero if the network is not associated
    /// with an IP pool.
    fn get_ip_pool_id(&self) -> Option<i32>;
}
impl<'s> serde::Serialize for dyn NetworkSummaryTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn NetworkSummaryTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(NetworkSummaryVisitor)
            }
        }

struct NetworkSummaryVisitor;

impl<'de> de::Visitor<'de> for NetworkSummaryVisitor {
    type Value = Box<dyn NetworkSummaryTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid NetworkSummaryTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl NetworkSummaryTrait for NetworkSummary {
    fn get_network(&self) -> &Option<ManagedObjectReference> { &self.network }
    fn get_name(&self) -> &str { &self.name }
    fn get_accessible(&self) -> bool { self.accessible }
    fn get_ip_pool_name(&self) -> &str { &self.ip_pool_name }
    fn get_ip_pool_id(&self) -> Option<i32> { self.ip_pool_id }
}
impl NetworkSummaryTrait for OpaqueNetworkSummary {
    fn get_network(&self) -> &Option<ManagedObjectReference> { &self.network }
    fn get_name(&self) -> &str { &self.name }
    fn get_accessible(&self) -> bool { self.accessible }
    fn get_ip_pool_name(&self) -> &str { &self.ip_pool_name }
    fn get_ip_pool_id(&self) -> Option<i32> { self.ip_pool_id }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn NetworkSummaryTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::NetworkSummary => Some(from.as_any_ref().downcast_ref::<NetworkSummary>()?),
            StructType::OpaqueNetworkSummary => Some(from.as_any_ref().downcast_ref::<OpaqueNetworkSummary>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::NetworkSummary => Ok(from.as_any_box().downcast::<NetworkSummary>()?),
            StructType::OpaqueNetworkSummary => Ok(from.as_any_box().downcast::<OpaqueNetworkSummary>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// A common super-class for basic OVF descriptor parameters
pub trait OvfManagerCommonParamsTrait : super::traits::DataObjectTrait {
    /// The locale-identifier to choose from the descriptor.
    /// 
    /// If empty, the
    /// default locale on the server is used.
    fn get_locale(&self) -> &str;
    /// The key of the chosen deployment option.
    /// 
    /// If empty, the default option is
    /// chosen. The list of possible deployment options is returned in the result of
    /// parseDescriptor.
    fn get_deployment_option(&self) -> &str;
    /// An optional set of localization strings to be used.
    /// 
    /// The server will use
    /// these message strings to localize information in the result and in
    /// error and warning messages.
    /// 
    /// This argument allows a client to pass messages from external
    /// string bundles. The client is responsible for selecting the right string
    /// bundle (based on locale) and parsing the external string bundle. The
    /// passed in key/value pairs are looked up before any messages
    /// included in the OVF descriptor itself.
    fn get_msg_bundle(&self) -> &Option<Vec<KeyValue>>;
    /// An optional argument for modifing the OVF parsing.
    /// 
    /// When the server parses an OVF
    /// descriptor a set of options can be used to modify the parsing. The argument is a list
    /// of keywords.
    /// 
    /// To get a list of supported keywords see *OvfManager.ovfImportOption*. Unknown
    /// options will be ignored by the server.
    fn get_import_option(&self) -> &Option<Vec<String>>;
}
impl<'s> serde::Serialize for dyn OvfManagerCommonParamsTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn OvfManagerCommonParamsTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(OvfManagerCommonParamsVisitor)
            }
        }

struct OvfManagerCommonParamsVisitor;

impl<'de> de::Visitor<'de> for OvfManagerCommonParamsVisitor {
    type Value = Box<dyn OvfManagerCommonParamsTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid OvfManagerCommonParamsTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl OvfManagerCommonParamsTrait for OvfManagerCommonParams {
    fn get_locale(&self) -> &str { &self.locale }
    fn get_deployment_option(&self) -> &str { &self.deployment_option }
    fn get_msg_bundle(&self) -> &Option<Vec<KeyValue>> { &self.msg_bundle }
    fn get_import_option(&self) -> &Option<Vec<String>> { &self.import_option }
}
impl OvfManagerCommonParamsTrait for OvfCreateImportSpecParams {
    fn get_locale(&self) -> &str { &self.locale }
    fn get_deployment_option(&self) -> &str { &self.deployment_option }
    fn get_msg_bundle(&self) -> &Option<Vec<KeyValue>> { &self.msg_bundle }
    fn get_import_option(&self) -> &Option<Vec<String>> { &self.import_option }
}
impl OvfManagerCommonParamsTrait for OvfParseDescriptorParams {
    fn get_locale(&self) -> &str { &self.locale }
    fn get_deployment_option(&self) -> &str { &self.deployment_option }
    fn get_msg_bundle(&self) -> &Option<Vec<KeyValue>> { &self.msg_bundle }
    fn get_import_option(&self) -> &Option<Vec<String>> { &self.import_option }
}
impl OvfManagerCommonParamsTrait for OvfValidateHostParams {
    fn get_locale(&self) -> &str { &self.locale }
    fn get_deployment_option(&self) -> &str { &self.deployment_option }
    fn get_msg_bundle(&self) -> &Option<Vec<KeyValue>> { &self.msg_bundle }
    fn get_import_option(&self) -> &Option<Vec<String>> { &self.import_option }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn OvfManagerCommonParamsTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfManagerCommonParams => Some(from.as_any_ref().downcast_ref::<OvfManagerCommonParams>()?),
            StructType::OvfCreateImportSpecParams => Some(from.as_any_ref().downcast_ref::<OvfCreateImportSpecParams>()?),
            StructType::OvfParseDescriptorParams => Some(from.as_any_ref().downcast_ref::<OvfParseDescriptorParams>()?),
            StructType::OvfValidateHostParams => Some(from.as_any_ref().downcast_ref::<OvfValidateHostParams>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfManagerCommonParams => Ok(from.as_any_box().downcast::<OvfManagerCommonParams>()?),
            StructType::OvfCreateImportSpecParams => Ok(from.as_any_box().downcast::<OvfCreateImportSpecParams>()?),
            StructType::OvfParseDescriptorParams => Ok(from.as_any_box().downcast::<OvfParseDescriptorParams>()?),
            StructType::OvfValidateHostParams => Ok(from.as_any_box().downcast::<OvfValidateHostParams>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base type for the various *PerfEntityMetric*
/// encodings.
pub trait PerfEntityMetricBaseTrait : super::traits::DataObjectTrait {
    /// Performance provider ID.
    fn get_entity(&self) -> &ManagedObjectReference;
}
impl<'s> serde::Serialize for dyn PerfEntityMetricBaseTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn PerfEntityMetricBaseTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(PerfEntityMetricBaseVisitor)
            }
        }

struct PerfEntityMetricBaseVisitor;

impl<'de> de::Visitor<'de> for PerfEntityMetricBaseVisitor {
    type Value = Box<dyn PerfEntityMetricBaseTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid PerfEntityMetricBaseTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl PerfEntityMetricBaseTrait for PerfEntityMetricBase {
    fn get_entity(&self) -> &ManagedObjectReference { &self.entity }
}
impl PerfEntityMetricBaseTrait for PerfEntityMetric {
    fn get_entity(&self) -> &ManagedObjectReference { &self.entity }
}
impl PerfEntityMetricBaseTrait for PerfEntityMetricCsv {
    fn get_entity(&self) -> &ManagedObjectReference { &self.entity }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn PerfEntityMetricBaseTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::PerfEntityMetricBase => Some(from.as_any_ref().downcast_ref::<PerfEntityMetricBase>()?),
            StructType::PerfEntityMetric => Some(from.as_any_ref().downcast_ref::<PerfEntityMetric>()?),
            StructType::PerfEntityMetricCsv => Some(from.as_any_ref().downcast_ref::<PerfEntityMetricCsv>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::PerfEntityMetricBase => Ok(from.as_any_box().downcast::<PerfEntityMetricBase>()?),
            StructType::PerfEntityMetric => Ok(from.as_any_box().downcast::<PerfEntityMetric>()?),
            StructType::PerfEntityMetricCsv => Ok(from.as_any_box().downcast::<PerfEntityMetricCsv>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This is a generic data object type that stores values for a specific
/// performance metric.
/// 
/// Useful data objects that store actual metric values
/// extend this data object (see *PerfMetricIntSeries*).
pub trait PerfMetricSeriesTrait : super::traits::DataObjectTrait {
    /// An identifier for the performance metric.
    fn get_id(&self) -> &PerfMetricId;
}
impl<'s> serde::Serialize for dyn PerfMetricSeriesTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn PerfMetricSeriesTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(PerfMetricSeriesVisitor)
            }
        }

struct PerfMetricSeriesVisitor;

impl<'de> de::Visitor<'de> for PerfMetricSeriesVisitor {
    type Value = Box<dyn PerfMetricSeriesTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid PerfMetricSeriesTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl PerfMetricSeriesTrait for PerfMetricSeries {
    fn get_id(&self) -> &PerfMetricId { &self.id }
}
impl PerfMetricSeriesTrait for PerfMetricIntSeries {
    fn get_id(&self) -> &PerfMetricId { &self.id }
}
impl PerfMetricSeriesTrait for PerfMetricSeriesCsv {
    fn get_id(&self) -> &PerfMetricId { &self.id }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn PerfMetricSeriesTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::PerfMetricSeries => Some(from.as_any_ref().downcast_ref::<PerfMetricSeries>()?),
            StructType::PerfMetricIntSeries => Some(from.as_any_ref().downcast_ref::<PerfMetricIntSeries>()?),
            StructType::PerfMetricSeriesCsv => Some(from.as_any_ref().downcast_ref::<PerfMetricSeriesCsv>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::PerfMetricSeries => Ok(from.as_any_box().downcast::<PerfMetricSeries>()?),
            StructType::PerfMetricIntSeries => Ok(from.as_any_box().downcast::<PerfMetricIntSeries>()?),
            StructType::PerfMetricSeriesCsv => Ok(from.as_any_box().downcast::<PerfMetricSeriesCsv>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type encapsulates a typical set of resource
/// pool information that is useful for list views and summary pages.
pub trait ResourcePoolSummaryTrait : super::traits::DataObjectTrait {
    /// Name of resource pool.
    fn get_name(&self) -> &str;
    /// Current configuration of the resource pool.
    fn get_config(&self) -> &ResourceConfigSpec;
    /// Current runtime state of the resource pool.
    fn get_runtime(&self) -> &ResourcePoolRuntimeInfo;
    /// A set of statistics that are typically updated with near real-time regularity.
    /// 
    /// This data object type does not support notification, for scalability reasons.
    /// Therefore, changes in QuickStats do not generate property collector updates.
    /// To monitor statistics values, use the statistics and alarms modules instead.
    fn get_quick_stats(&self) -> &Option<ResourcePoolQuickStats>;
    /// Total configured memory of all virtual machines in the resource pool, in MB.
    fn get_configured_memory_mb(&self) -> Option<i32>;
}
impl<'s> serde::Serialize for dyn ResourcePoolSummaryTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ResourcePoolSummaryTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ResourcePoolSummaryVisitor)
            }
        }

struct ResourcePoolSummaryVisitor;

impl<'de> de::Visitor<'de> for ResourcePoolSummaryVisitor {
    type Value = Box<dyn ResourcePoolSummaryTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ResourcePoolSummaryTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ResourcePoolSummaryTrait for ResourcePoolSummary {
    fn get_name(&self) -> &str { &self.name }
    fn get_config(&self) -> &ResourceConfigSpec { &self.config }
    fn get_runtime(&self) -> &ResourcePoolRuntimeInfo { &self.runtime }
    fn get_quick_stats(&self) -> &Option<ResourcePoolQuickStats> { &self.quick_stats }
    fn get_configured_memory_mb(&self) -> Option<i32> { self.configured_memory_mb }
}
impl ResourcePoolSummaryTrait for VirtualAppSummary {
    fn get_name(&self) -> &str { &self.name }
    fn get_config(&self) -> &ResourceConfigSpec { &self.config }
    fn get_runtime(&self) -> &ResourcePoolRuntimeInfo { &self.runtime }
    fn get_quick_stats(&self) -> &Option<ResourcePoolQuickStats> { &self.quick_stats }
    fn get_configured_memory_mb(&self) -> Option<i32> { self.configured_memory_mb }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ResourcePoolSummaryTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ResourcePoolSummary => Some(from.as_any_ref().downcast_ref::<ResourcePoolSummary>()?),
            StructType::VirtualAppSummary => Some(from.as_any_ref().downcast_ref::<VirtualAppSummary>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ResourcePoolSummary => Ok(from.as_any_box().downcast::<ResourcePoolSummary>()?),
            StructType::VirtualAppSummary => Ok(from.as_any_box().downcast::<VirtualAppSummary>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class for selecting entities
pub trait SelectionSetTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn SelectionSetTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn SelectionSetTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(SelectionSetVisitor)
            }
        }

struct SelectionSetVisitor;

impl<'de> de::Visitor<'de> for SelectionSetVisitor {
    type Value = Box<dyn SelectionSetTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid SelectionSetTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl SelectionSetTrait for SelectionSet {
}
impl SelectionSetTrait for DvPortgroupSelection {
}
impl SelectionSetTrait for DvsSelection {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn SelectionSetTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::SelectionSet => Some(from.as_any_ref().downcast_ref::<SelectionSet>()?),
            StructType::DvPortgroupSelection => Some(from.as_any_ref().downcast_ref::<DvPortgroupSelection>()?),
            StructType::DvsSelection => Some(from.as_any_ref().downcast_ref::<DvsSelection>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::SelectionSet => Ok(from.as_any_box().downcast::<SelectionSet>()?),
            StructType::DvPortgroupSelection => Ok(from.as_any_box().downcast::<DvPortgroupSelection>()?),
            StructType::DvsSelection => Ok(from.as_any_box().downcast::<DvsSelection>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The data object type is a base type of credential for authentication such
/// as username/password or SAML token.
pub trait ServiceLocatorCredentialTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn ServiceLocatorCredentialTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ServiceLocatorCredentialTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ServiceLocatorCredentialVisitor)
            }
        }

struct ServiceLocatorCredentialVisitor;

impl<'de> de::Visitor<'de> for ServiceLocatorCredentialVisitor {
    type Value = Box<dyn ServiceLocatorCredentialTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ServiceLocatorCredentialTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ServiceLocatorCredentialTrait for ServiceLocatorCredential {
}
impl ServiceLocatorCredentialTrait for ServiceLocatorNamePassword {
}
impl ServiceLocatorCredentialTrait for ServiceLocatorSamlCredential {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ServiceLocatorCredentialTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ServiceLocatorCredential => Some(from.as_any_ref().downcast_ref::<ServiceLocatorCredential>()?),
            StructType::ServiceLocatorNamePassword => Some(from.as_any_ref().downcast_ref::<ServiceLocatorNamePassword>()?),
            StructType::ServiceLocatorSamlCredential => Some(from.as_any_ref().downcast_ref::<ServiceLocatorSamlCredential>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ServiceLocatorCredential => Ok(from.as_any_box().downcast::<ServiceLocatorCredential>()?),
            StructType::ServiceLocatorNamePassword => Ok(from.as_any_box().downcast::<ServiceLocatorNamePassword>()?),
            StructType::ServiceLocatorSamlCredential => Ok(from.as_any_box().downcast::<ServiceLocatorSamlCredential>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type describes a request to a service.
/// 
/// It is used as argument to
/// *SessionManager.AcquireGenericServiceTicket*.
/// This is the base class for more specific service request specifications.
/// E.g. for HTTP services the derived class will provide a URL property.
pub trait SessionManagerServiceRequestSpecTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn SessionManagerServiceRequestSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn SessionManagerServiceRequestSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(SessionManagerServiceRequestSpecVisitor)
            }
        }

struct SessionManagerServiceRequestSpecVisitor;

impl<'de> de::Visitor<'de> for SessionManagerServiceRequestSpecVisitor {
    type Value = Box<dyn SessionManagerServiceRequestSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid SessionManagerServiceRequestSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl SessionManagerServiceRequestSpecTrait for SessionManagerServiceRequestSpec {
}
impl SessionManagerServiceRequestSpecTrait for SessionManagerHttpServiceRequestSpec {
}
impl SessionManagerServiceRequestSpecTrait for SessionManagerVmomiServiceRequestSpec {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn SessionManagerServiceRequestSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::SessionManagerServiceRequestSpec => Some(from.as_any_ref().downcast_ref::<SessionManagerServiceRequestSpec>()?),
            StructType::SessionManagerHttpServiceRequestSpec => Some(from.as_any_ref().downcast_ref::<SessionManagerHttpServiceRequestSpec>()?),
            StructType::SessionManagerVmomiServiceRequestSpec => Some(from.as_any_ref().downcast_ref::<SessionManagerVmomiServiceRequestSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::SessionManagerServiceRequestSpec => Ok(from.as_any_box().downcast::<SessionManagerServiceRequestSpec>()?),
            StructType::SessionManagerHttpServiceRequestSpec => Ok(from.as_any_box().downcast::<SessionManagerHttpServiceRequestSpec>()?),
            StructType::SessionManagerVmomiServiceRequestSpec => Ok(from.as_any_box().downcast::<SessionManagerVmomiServiceRequestSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base type for all task reasons.
/// 
/// Task reasons represent the kind of entity responsible for a task's creation.
pub trait TaskReasonTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn TaskReasonTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn TaskReasonTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(TaskReasonVisitor)
            }
        }

struct TaskReasonVisitor;

impl<'de> de::Visitor<'de> for TaskReasonVisitor {
    type Value = Box<dyn TaskReasonTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid TaskReasonTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl TaskReasonTrait for TaskReason {
}
impl TaskReasonTrait for TaskReasonAlarm {
}
impl TaskReasonTrait for TaskReasonSchedule {
}
impl TaskReasonTrait for TaskReasonSystem {
}
impl TaskReasonTrait for TaskReasonUser {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn TaskReasonTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::TaskReason => Some(from.as_any_ref().downcast_ref::<TaskReason>()?),
            StructType::TaskReasonAlarm => Some(from.as_any_ref().downcast_ref::<TaskReasonAlarm>()?),
            StructType::TaskReasonSchedule => Some(from.as_any_ref().downcast_ref::<TaskReasonSchedule>()?),
            StructType::TaskReasonSystem => Some(from.as_any_ref().downcast_ref::<TaskReasonSystem>()?),
            StructType::TaskReasonUser => Some(from.as_any_ref().downcast_ref::<TaskReasonUser>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::TaskReason => Ok(from.as_any_box().downcast::<TaskReason>()?),
            StructType::TaskReasonAlarm => Ok(from.as_any_box().downcast::<TaskReasonAlarm>()?),
            StructType::TaskReasonSchedule => Ok(from.as_any_box().downcast::<TaskReasonSchedule>()?),
            StructType::TaskReasonSystem => Ok(from.as_any_box().downcast::<TaskReasonSystem>()?),
            StructType::TaskReasonUser => Ok(from.as_any_box().downcast::<TaskReasonUser>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// When searching for users, the search results in
/// some additional information.
/// 
/// This object describes
/// the additional information.
pub trait UserSearchResultTrait : super::traits::DataObjectTrait {
    /// Login name of a user or the name of a group.
    /// 
    /// This key is
    /// the user within the searched domain.
    fn get_principal(&self) -> &str;
    /// Full name of the user found by the search, or the description
    /// of a group, if available.
    fn get_full_name(&self) -> &Option<String>;
    /// If this is true, then the result is a group.
    /// 
    /// If this is false, then the
    /// result is a user.
    fn get_group(&self) -> bool;
}
impl<'s> serde::Serialize for dyn UserSearchResultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn UserSearchResultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(UserSearchResultVisitor)
            }
        }

struct UserSearchResultVisitor;

impl<'de> de::Visitor<'de> for UserSearchResultVisitor {
    type Value = Box<dyn UserSearchResultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid UserSearchResultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl UserSearchResultTrait for UserSearchResult {
    fn get_principal(&self) -> &str { &self.principal }
    fn get_full_name(&self) -> &Option<String> { &self.full_name }
    fn get_group(&self) -> bool { self.group }
}
impl UserSearchResultTrait for PosixUserSearchResult {
    fn get_principal(&self) -> &str { &self.principal }
    fn get_full_name(&self) -> &Option<String> { &self.full_name }
    fn get_group(&self) -> bool { self.group }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn UserSearchResultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::UserSearchResult => Some(from.as_any_ref().downcast_ref::<UserSearchResult>()?),
            StructType::PosixUserSearchResult => Some(from.as_any_ref().downcast_ref::<PosixUserSearchResult>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::UserSearchResult => Ok(from.as_any_box().downcast::<UserSearchResult>()?),
            StructType::PosixUserSearchResult => Ok(from.as_any_box().downcast::<PosixUserSearchResult>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Specification used to create or clone a virtual disk
pub trait VirtualDiskSpecTrait : super::traits::DataObjectTrait {
    /// The type of the new virtual disk.
    /// 
    /// See also *VirtualDiskType_enum*.
    fn get_disk_type(&self) -> &str;
    /// The type of the virtual disk adapter for the new virtual disk.
    /// 
    /// See also *VirtualDiskAdapterType_enum*.
    fn get_adapter_type(&self) -> &str;
}
impl<'s> serde::Serialize for dyn VirtualDiskSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDiskSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDiskSpecVisitor)
            }
        }

struct VirtualDiskSpecVisitor;

impl<'de> de::Visitor<'de> for VirtualDiskSpecVisitor {
    type Value = Box<dyn VirtualDiskSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDiskSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDiskSpecTrait for VirtualDiskSpec {
    fn get_disk_type(&self) -> &str { &self.disk_type }
    fn get_adapter_type(&self) -> &str { &self.adapter_type }
}
impl VirtualDiskSpecTrait for DeviceBackedVirtualDiskSpec {
    fn get_disk_type(&self) -> &str { &self.disk_type }
    fn get_adapter_type(&self) -> &str { &self.adapter_type }
}
impl VirtualDiskSpecTrait for FileBackedVirtualDiskSpec {
    fn get_disk_type(&self) -> &str { &self.disk_type }
    fn get_adapter_type(&self) -> &str { &self.adapter_type }
}
impl VirtualDiskSpecTrait for SeSparseVirtualDiskSpec {
    fn get_disk_type(&self) -> &str { &self.disk_type }
    fn get_adapter_type(&self) -> &str { &self.adapter_type }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDiskSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDiskSpec => Some(from.as_any_ref().downcast_ref::<VirtualDiskSpec>()?),
            StructType::DeviceBackedVirtualDiskSpec => Some(from.as_any_ref().downcast_ref::<DeviceBackedVirtualDiskSpec>()?),
            StructType::FileBackedVirtualDiskSpec => Some(from.as_any_ref().downcast_ref::<FileBackedVirtualDiskSpec>()?),
            StructType::SeSparseVirtualDiskSpec => Some(from.as_any_ref().downcast_ref::<SeSparseVirtualDiskSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDiskSpec => Ok(from.as_any_box().downcast::<VirtualDiskSpec>()?),
            StructType::DeviceBackedVirtualDiskSpec => Ok(from.as_any_box().downcast::<DeviceBackedVirtualDiskSpec>()?),
            StructType::FileBackedVirtualDiskSpec => Ok(from.as_any_box().downcast::<FileBackedVirtualDiskSpec>()?),
            StructType::SeSparseVirtualDiskSpec => Ok(from.as_any_box().downcast::<SeSparseVirtualDiskSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Specification used to create a file based virtual disk
pub trait FileBackedVirtualDiskSpecTrait : super::traits::VirtualDiskSpecTrait {
    /// Specify the capacity of the virtual disk in Kb.
    fn get_capacity_kb(&self) -> i64;
    /// Virtual Disk Profile requirement.
    /// 
    /// Profiles are solution specifics.
    /// Profile Based Storage Management is a vSphere server extension.
    /// The API users who want to provision VMs using Storage Profiles, need to
    /// interact with it.
    /// This is an optional parameter and if user doesn't specify profile,
    /// the default behavior will apply.
    fn get_profile(&self) -> &Option<Vec<Box<dyn super::traits::VirtualMachineProfileSpecTrait>>>;
    /// Encryption options for the new virtual disk.
    fn get_crypto(&self) -> &Option<Box<dyn super::traits::CryptoSpecTrait>>;
}
impl<'s> serde::Serialize for dyn FileBackedVirtualDiskSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn FileBackedVirtualDiskSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(FileBackedVirtualDiskSpecVisitor)
            }
        }

struct FileBackedVirtualDiskSpecVisitor;

impl<'de> de::Visitor<'de> for FileBackedVirtualDiskSpecVisitor {
    type Value = Box<dyn FileBackedVirtualDiskSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid FileBackedVirtualDiskSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl FileBackedVirtualDiskSpecTrait for FileBackedVirtualDiskSpec {
    fn get_capacity_kb(&self) -> i64 { self.capacity_kb }
    fn get_profile(&self) -> &Option<Vec<Box<dyn super::traits::VirtualMachineProfileSpecTrait>>> { &self.profile }
    fn get_crypto(&self) -> &Option<Box<dyn super::traits::CryptoSpecTrait>> { &self.crypto }
}
impl FileBackedVirtualDiskSpecTrait for SeSparseVirtualDiskSpec {
    fn get_capacity_kb(&self) -> i64 { self.capacity_kb }
    fn get_profile(&self) -> &Option<Vec<Box<dyn super::traits::VirtualMachineProfileSpecTrait>>> { &self.profile }
    fn get_crypto(&self) -> &Option<Box<dyn super::traits::CryptoSpecTrait>> { &self.crypto }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn FileBackedVirtualDiskSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::FileBackedVirtualDiskSpec => Some(from.as_any_ref().downcast_ref::<FileBackedVirtualDiskSpec>()?),
            StructType::SeSparseVirtualDiskSpec => Some(from.as_any_ref().downcast_ref::<SeSparseVirtualDiskSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::FileBackedVirtualDiskSpec => Ok(from.as_any_box().downcast::<FileBackedVirtualDiskSpec>()?),
            StructType::SeSparseVirtualDiskSpec => Ok(from.as_any_box().downcast::<SeSparseVirtualDiskSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *VirtualMachineConnection* object describes a connection to the virtual
/// machine.
/// 
/// ***Since:*** vSphere API Release 7.0.1.0
pub trait VirtualMachineConnectionTrait : super::traits::DataObjectTrait {
    /// The unique identifier associated with the connection.
    /// 
    /// The label is a UTF-8 string which specifies a unique identifier for
    /// a connection.
    fn get_label(&self) -> &str;
    /// The client identifer.
    /// 
    /// This identifier is a UTF-8 string which is semantically meaningful
    /// for the connection. Examples of the client identifier are an IP
    /// address (V4 or V6) with or without a port specification, a machine
    /// name that requires a DNS lookup, or any other network oriented
    /// identification scheme.
    fn get_client(&self) -> &str;
    /// The name of the user authorizing the connection.
    /// 
    /// This is used for auditing.
    fn get_user_name(&self) -> &str;
}
impl<'s> serde::Serialize for dyn VirtualMachineConnectionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualMachineConnectionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualMachineConnectionVisitor)
            }
        }

struct VirtualMachineConnectionVisitor;

impl<'de> de::Visitor<'de> for VirtualMachineConnectionVisitor {
    type Value = Box<dyn VirtualMachineConnectionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualMachineConnectionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualMachineConnectionTrait for VirtualMachineConnection {
    fn get_label(&self) -> &str { &self.label }
    fn get_client(&self) -> &str { &self.client }
    fn get_user_name(&self) -> &str { &self.user_name }
}
impl VirtualMachineConnectionTrait for VirtualMachineMksConnection {
    fn get_label(&self) -> &str { &self.label }
    fn get_client(&self) -> &str { &self.client }
    fn get_user_name(&self) -> &str { &self.user_name }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualMachineConnectionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineConnection => Some(from.as_any_ref().downcast_ref::<VirtualMachineConnection>()?),
            StructType::VirtualMachineMksConnection => Some(from.as_any_ref().downcast_ref::<VirtualMachineMksConnection>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineConnection => Ok(from.as_any_box().downcast::<VirtualMachineConnection>()?),
            StructType::VirtualMachineMksConnection => Ok(from.as_any_box().downcast::<VirtualMachineMksConnection>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class for a pre-flight check issue.
/// 
/// Can be used directly
/// but usually a derived class with a specific issue type is used.
pub trait VsanUpgradeSystemPreflightCheckIssueTrait : super::traits::DataObjectTrait {
    /// Message describing the issue.
    fn get_msg(&self) -> &str;
}
impl<'s> serde::Serialize for dyn VsanUpgradeSystemPreflightCheckIssueTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VsanUpgradeSystemPreflightCheckIssueTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VsanUpgradeSystemPreflightCheckIssueVisitor)
            }
        }

struct VsanUpgradeSystemPreflightCheckIssueVisitor;

impl<'de> de::Visitor<'de> for VsanUpgradeSystemPreflightCheckIssueVisitor {
    type Value = Box<dyn VsanUpgradeSystemPreflightCheckIssueTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VsanUpgradeSystemPreflightCheckIssueTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VsanUpgradeSystemPreflightCheckIssueTrait for VsanUpgradeSystemPreflightCheckIssue {
    fn get_msg(&self) -> &str { &self.msg }
}
impl VsanUpgradeSystemPreflightCheckIssueTrait for VsanUpgradeSystemApiBrokenIssue {
    fn get_msg(&self) -> &str { &self.msg }
}
impl VsanUpgradeSystemPreflightCheckIssueTrait for VsanUpgradeSystemAutoClaimEnabledOnHostsIssue {
    fn get_msg(&self) -> &str { &self.msg }
}
impl VsanUpgradeSystemPreflightCheckIssueTrait for VsanUpgradeSystemHostsDisconnectedIssue {
    fn get_msg(&self) -> &str { &self.msg }
}
impl VsanUpgradeSystemPreflightCheckIssueTrait for VsanUpgradeSystemMissingHostsInClusterIssue {
    fn get_msg(&self) -> &str { &self.msg }
}
impl VsanUpgradeSystemPreflightCheckIssueTrait for VsanUpgradeSystemNetworkPartitionIssue {
    fn get_msg(&self) -> &str { &self.msg }
}
impl VsanUpgradeSystemPreflightCheckIssueTrait for VsanUpgradeSystemNotEnoughFreeCapacityIssue {
    fn get_msg(&self) -> &str { &self.msg }
}
impl VsanUpgradeSystemPreflightCheckIssueTrait for VsanUpgradeSystemRogueHostsInClusterIssue {
    fn get_msg(&self) -> &str { &self.msg }
}
impl VsanUpgradeSystemPreflightCheckIssueTrait for VsanUpgradeSystemV2ObjectsPresentDuringDowngradeIssue {
    fn get_msg(&self) -> &str { &self.msg }
}
impl VsanUpgradeSystemPreflightCheckIssueTrait for VsanUpgradeSystemWrongEsxVersionIssue {
    fn get_msg(&self) -> &str { &self.msg }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VsanUpgradeSystemPreflightCheckIssueTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VsanUpgradeSystemPreflightCheckIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemPreflightCheckIssue>()?),
            StructType::VsanUpgradeSystemApiBrokenIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemApiBrokenIssue>()?),
            StructType::VsanUpgradeSystemAutoClaimEnabledOnHostsIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemAutoClaimEnabledOnHostsIssue>()?),
            StructType::VsanUpgradeSystemHostsDisconnectedIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemHostsDisconnectedIssue>()?),
            StructType::VsanUpgradeSystemMissingHostsInClusterIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemMissingHostsInClusterIssue>()?),
            StructType::VsanUpgradeSystemNetworkPartitionIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemNetworkPartitionIssue>()?),
            StructType::VsanUpgradeSystemNotEnoughFreeCapacityIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemNotEnoughFreeCapacityIssue>()?),
            StructType::VsanUpgradeSystemRogueHostsInClusterIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemRogueHostsInClusterIssue>()?),
            StructType::VsanUpgradeSystemV2ObjectsPresentDuringDowngradeIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemV2ObjectsPresentDuringDowngradeIssue>()?),
            StructType::VsanUpgradeSystemWrongEsxVersionIssue => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemWrongEsxVersionIssue>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VsanUpgradeSystemPreflightCheckIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemPreflightCheckIssue>()?),
            StructType::VsanUpgradeSystemApiBrokenIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemApiBrokenIssue>()?),
            StructType::VsanUpgradeSystemAutoClaimEnabledOnHostsIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemAutoClaimEnabledOnHostsIssue>()?),
            StructType::VsanUpgradeSystemHostsDisconnectedIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemHostsDisconnectedIssue>()?),
            StructType::VsanUpgradeSystemMissingHostsInClusterIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemMissingHostsInClusterIssue>()?),
            StructType::VsanUpgradeSystemNetworkPartitionIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemNetworkPartitionIssue>()?),
            StructType::VsanUpgradeSystemNotEnoughFreeCapacityIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemNotEnoughFreeCapacityIssue>()?),
            StructType::VsanUpgradeSystemRogueHostsInClusterIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemRogueHostsInClusterIssue>()?),
            StructType::VsanUpgradeSystemV2ObjectsPresentDuringDowngradeIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemV2ObjectsPresentDuringDowngradeIssue>()?),
            StructType::VsanUpgradeSystemWrongEsxVersionIssue => Ok(from.as_any_box().downcast::<VsanUpgradeSystemWrongEsxVersionIssue>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Captures one "log entry" of an upgrade process.
pub trait VsanUpgradeSystemUpgradeHistoryItemTrait : super::traits::DataObjectTrait {
    /// Time stamp when the history is record.
    fn get_timestamp(&self) -> &str;
    /// The host a history item pertains to.
    /// 
    /// May be unset when item related
    /// to no particular host.
    /// 
    /// Refers instance of *HostSystem*.
    fn get_host(&self) -> &Option<ManagedObjectReference>;
    /// Description of the history item.
    fn get_message(&self) -> &str;
    /// A task associated with the history item.
    /// 
    /// May be unset if no task is
    /// associated.
    /// 
    /// Refers instance of *Task*.
    fn get_task(&self) -> &Option<ManagedObjectReference>;
}
impl<'s> serde::Serialize for dyn VsanUpgradeSystemUpgradeHistoryItemTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VsanUpgradeSystemUpgradeHistoryItemTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VsanUpgradeSystemUpgradeHistoryItemVisitor)
            }
        }

struct VsanUpgradeSystemUpgradeHistoryItemVisitor;

impl<'de> de::Visitor<'de> for VsanUpgradeSystemUpgradeHistoryItemVisitor {
    type Value = Box<dyn VsanUpgradeSystemUpgradeHistoryItemTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VsanUpgradeSystemUpgradeHistoryItemTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VsanUpgradeSystemUpgradeHistoryItemTrait for VsanUpgradeSystemUpgradeHistoryItem {
    fn get_timestamp(&self) -> &str { &self.timestamp }
    fn get_host(&self) -> &Option<ManagedObjectReference> { &self.host }
    fn get_message(&self) -> &str { &self.message }
    fn get_task(&self) -> &Option<ManagedObjectReference> { &self.task }
}
impl VsanUpgradeSystemUpgradeHistoryItemTrait for VsanUpgradeSystemUpgradeHistoryDiskGroupOp {
    fn get_timestamp(&self) -> &str { &self.timestamp }
    fn get_host(&self) -> &Option<ManagedObjectReference> { &self.host }
    fn get_message(&self) -> &str { &self.message }
    fn get_task(&self) -> &Option<ManagedObjectReference> { &self.task }
}
impl VsanUpgradeSystemUpgradeHistoryItemTrait for VsanUpgradeSystemUpgradeHistoryPreflightFail {
    fn get_timestamp(&self) -> &str { &self.timestamp }
    fn get_host(&self) -> &Option<ManagedObjectReference> { &self.host }
    fn get_message(&self) -> &str { &self.message }
    fn get_task(&self) -> &Option<ManagedObjectReference> { &self.task }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VsanUpgradeSystemUpgradeHistoryItemTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VsanUpgradeSystemUpgradeHistoryItem => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemUpgradeHistoryItem>()?),
            StructType::VsanUpgradeSystemUpgradeHistoryDiskGroupOp => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemUpgradeHistoryDiskGroupOp>()?),
            StructType::VsanUpgradeSystemUpgradeHistoryPreflightFail => Some(from.as_any_ref().downcast_ref::<VsanUpgradeSystemUpgradeHistoryPreflightFail>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VsanUpgradeSystemUpgradeHistoryItem => Ok(from.as_any_box().downcast::<VsanUpgradeSystemUpgradeHistoryItem>()?),
            StructType::VsanUpgradeSystemUpgradeHistoryDiskGroupOp => Ok(from.as_any_box().downcast::<VsanUpgradeSystemUpgradeHistoryDiskGroupOp>()?),
            StructType::VsanUpgradeSystemUpgradeHistoryPreflightFail => Ok(from.as_any_box().downcast::<VsanUpgradeSystemUpgradeHistoryPreflightFail>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type defines the action initiated by a scheduled task or alarm.
/// 
/// This is an abstract type.
/// A client creates a scheduled task or an alarm each of which triggers
/// an action, defined by a subclass of this type.
pub trait ActionTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn ActionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ActionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ActionVisitor)
            }
        }

struct ActionVisitor;

impl<'de> de::Visitor<'de> for ActionVisitor {
    type Value = Box<dyn ActionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ActionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ActionTrait for Action {
}
impl ActionTrait for CreateTaskAction {
}
impl ActionTrait for MethodAction {
}
impl ActionTrait for RunScriptAction {
}
impl ActionTrait for SendEmailAction {
}
impl ActionTrait for SendSnmpAction {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ActionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::Action => Some(from.as_any_ref().downcast_ref::<Action>()?),
            StructType::CreateTaskAction => Some(from.as_any_ref().downcast_ref::<CreateTaskAction>()?),
            StructType::MethodAction => Some(from.as_any_ref().downcast_ref::<MethodAction>()?),
            StructType::RunScriptAction => Some(from.as_any_ref().downcast_ref::<RunScriptAction>()?),
            StructType::SendEmailAction => Some(from.as_any_ref().downcast_ref::<SendEmailAction>()?),
            StructType::SendSnmpAction => Some(from.as_any_ref().downcast_ref::<SendSnmpAction>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::Action => Ok(from.as_any_box().downcast::<Action>()?),
            StructType::CreateTaskAction => Ok(from.as_any_box().downcast::<CreateTaskAction>()?),
            StructType::MethodAction => Ok(from.as_any_box().downcast::<MethodAction>()?),
            StructType::RunScriptAction => Ok(from.as_any_box().downcast::<RunScriptAction>()?),
            StructType::SendEmailAction => Ok(from.as_any_box().downcast::<SendEmailAction>()?),
            StructType::SendSnmpAction => Ok(from.as_any_box().downcast::<SendSnmpAction>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Action invoked by triggered alarm.
/// 
/// This is an abstract type.
pub trait AlarmActionTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn AlarmActionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn AlarmActionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(AlarmActionVisitor)
            }
        }

struct AlarmActionVisitor;

impl<'de> de::Visitor<'de> for AlarmActionVisitor {
    type Value = Box<dyn AlarmActionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid AlarmActionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl AlarmActionTrait for AlarmAction {
}
impl AlarmActionTrait for AlarmTriggeringAction {
}
impl AlarmActionTrait for GroupAlarmAction {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn AlarmActionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::AlarmAction => Some(from.as_any_ref().downcast_ref::<AlarmAction>()?),
            StructType::AlarmTriggeringAction => Some(from.as_any_ref().downcast_ref::<AlarmTriggeringAction>()?),
            StructType::GroupAlarmAction => Some(from.as_any_ref().downcast_ref::<GroupAlarmAction>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::AlarmAction => Ok(from.as_any_box().downcast::<AlarmAction>()?),
            StructType::AlarmTriggeringAction => Ok(from.as_any_box().downcast::<AlarmTriggeringAction>()?),
            StructType::GroupAlarmAction => Ok(from.as_any_box().downcast::<GroupAlarmAction>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base type for the expressions specifying the conditions that define
/// the status of an alarm.
pub trait AlarmExpressionTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn AlarmExpressionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn AlarmExpressionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(AlarmExpressionVisitor)
            }
        }

struct AlarmExpressionVisitor;

impl<'de> de::Visitor<'de> for AlarmExpressionVisitor {
    type Value = Box<dyn AlarmExpressionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid AlarmExpressionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl AlarmExpressionTrait for AlarmExpression {
}
impl AlarmExpressionTrait for AndAlarmExpression {
}
impl AlarmExpressionTrait for EventAlarmExpression {
}
impl AlarmExpressionTrait for MetricAlarmExpression {
}
impl AlarmExpressionTrait for OrAlarmExpression {
}
impl AlarmExpressionTrait for StateAlarmExpression {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn AlarmExpressionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::AlarmExpression => Some(from.as_any_ref().downcast_ref::<AlarmExpression>()?),
            StructType::AndAlarmExpression => Some(from.as_any_ref().downcast_ref::<AndAlarmExpression>()?),
            StructType::EventAlarmExpression => Some(from.as_any_ref().downcast_ref::<EventAlarmExpression>()?),
            StructType::MetricAlarmExpression => Some(from.as_any_ref().downcast_ref::<MetricAlarmExpression>()?),
            StructType::OrAlarmExpression => Some(from.as_any_ref().downcast_ref::<OrAlarmExpression>()?),
            StructType::StateAlarmExpression => Some(from.as_any_ref().downcast_ref::<StateAlarmExpression>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::AlarmExpression => Ok(from.as_any_box().downcast::<AlarmExpression>()?),
            StructType::AndAlarmExpression => Ok(from.as_any_box().downcast::<AndAlarmExpression>()?),
            StructType::EventAlarmExpression => Ok(from.as_any_box().downcast::<EventAlarmExpression>()?),
            StructType::MetricAlarmExpression => Ok(from.as_any_box().downcast::<MetricAlarmExpression>()?),
            StructType::OrAlarmExpression => Ok(from.as_any_box().downcast::<OrAlarmExpression>()?),
            StructType::StateAlarmExpression => Ok(from.as_any_box().downcast::<StateAlarmExpression>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Parameters for alarm creation.
pub trait AlarmSpecTrait : super::traits::DataObjectTrait {
    /// Name of the alarm.
    fn get_name(&self) -> &str;
    /// System name of the alarm.
    /// 
    /// This is set only for predefined Alarms - i.e. Alarms created by the
    /// server or extensions automatically. After creation this value cannot be
    /// modified. User-created Alarms do not have a systemName at all.
    /// 
    /// The purpose of this field is to identify system-created Alarms
    /// reliably, even if they are edited by users.
    /// 
    /// When creating Alarms with systemName, the systemName and the name of the
    /// alarm should be equal.
    /// 
    /// When reconfiguring an Alarm with systemName, the same systemName should
    /// be passed in the new AlarmSpec. Renaming Alarms with systemName is not
    /// allowed, i.e. when reconfiguring, the name passed in the new AlarmSpec
    /// should be equal to either the systemName or its localized version (the
    /// current name in the Alarm's info).
    fn get_system_name(&self) -> &Option<String>;
    /// Description of the alarm.
    fn get_description(&self) -> &str;
    /// Flag to indicate whether or not the alarm is enabled or disabled.
    fn get_enabled(&self) -> bool;
    /// Top-level alarm expression that defines trigger conditions.
    fn get_expression(&self) -> &Box<dyn super::traits::AlarmExpressionTrait>;
    /// Action to perform when the alarm is triggered.
    fn get_action(&self) -> &Option<Box<dyn super::traits::AlarmActionTrait>>;
    /// Frequency in seconds, which specifies how often appropriate actions
    /// should repeat when an alarm does not change state.
    fn get_action_frequency(&self) -> Option<i32>;
    /// Tolerance and maximum frequency settings.
    fn get_setting(&self) -> &Option<AlarmSetting>;
}
impl<'s> serde::Serialize for dyn AlarmSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn AlarmSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(AlarmSpecVisitor)
            }
        }

struct AlarmSpecVisitor;

impl<'de> de::Visitor<'de> for AlarmSpecVisitor {
    type Value = Box<dyn AlarmSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid AlarmSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl AlarmSpecTrait for AlarmSpec {
    fn get_name(&self) -> &str { &self.name }
    fn get_system_name(&self) -> &Option<String> { &self.system_name }
    fn get_description(&self) -> &str { &self.description }
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_expression(&self) -> &Box<dyn super::traits::AlarmExpressionTrait> { &self.expression }
    fn get_action(&self) -> &Option<Box<dyn super::traits::AlarmActionTrait>> { &self.action }
    fn get_action_frequency(&self) -> Option<i32> { self.action_frequency }
    fn get_setting(&self) -> &Option<AlarmSetting> { &self.setting }
}
impl AlarmSpecTrait for AlarmInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_system_name(&self) -> &Option<String> { &self.system_name }
    fn get_description(&self) -> &str { &self.description }
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_expression(&self) -> &Box<dyn super::traits::AlarmExpressionTrait> { &self.expression }
    fn get_action(&self) -> &Option<Box<dyn super::traits::AlarmActionTrait>> { &self.action }
    fn get_action_frequency(&self) -> Option<i32> { self.action_frequency }
    fn get_setting(&self) -> &Option<AlarmSetting> { &self.setting }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn AlarmSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::AlarmSpec => Some(from.as_any_ref().downcast_ref::<AlarmSpec>()?),
            StructType::AlarmInfo => Some(from.as_any_ref().downcast_ref::<AlarmInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::AlarmSpec => Ok(from.as_any_box().downcast::<AlarmSpec>()?),
            StructType::AlarmInfo => Ok(from.as_any_box().downcast::<AlarmInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class for all action recommendations in VirtualCenter.
pub trait ClusterActionTrait : super::traits::DataObjectTrait {
    /// Type of the action.
    /// 
    /// This is encoded to differentiate between
    /// different types of actions aimed at achieving different goals.
    fn get_type(&self) -> &str;
    /// The target object on which this action will be applied.
    /// 
    /// For
    /// instance, a migration action will have a virtual machine as its
    /// target object, while a host power action will have a host as its
    /// target action.
    fn get_target(&self) -> &Option<ManagedObjectReference>;
}
impl<'s> serde::Serialize for dyn ClusterActionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ClusterActionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ClusterActionVisitor)
            }
        }

struct ClusterActionVisitor;

impl<'de> de::Visitor<'de> for ClusterActionVisitor {
    type Value = Box<dyn ClusterActionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ClusterActionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ClusterActionTrait for ClusterAction {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_target(&self) -> &Option<ManagedObjectReference> { &self.target }
}
impl ClusterActionTrait for ClusterClusterInitialPlacementAction {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_target(&self) -> &Option<ManagedObjectReference> { &self.target }
}
impl ClusterActionTrait for ClusterHostInfraUpdateHaModeAction {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_target(&self) -> &Option<ManagedObjectReference> { &self.target }
}
impl ClusterActionTrait for ClusterHostPowerAction {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_target(&self) -> &Option<ManagedObjectReference> { &self.target }
}
impl ClusterActionTrait for ClusterInitialPlacementAction {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_target(&self) -> &Option<ManagedObjectReference> { &self.target }
}
impl ClusterActionTrait for ClusterMigrationAction {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_target(&self) -> &Option<ManagedObjectReference> { &self.target }
}
impl ClusterActionTrait for PlacementAction {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_target(&self) -> &Option<ManagedObjectReference> { &self.target }
}
impl ClusterActionTrait for HbrDiskMigrationAction {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_target(&self) -> &Option<ManagedObjectReference> { &self.target }
}
impl ClusterActionTrait for StorageMigrationAction {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_target(&self) -> &Option<ManagedObjectReference> { &self.target }
}
impl ClusterActionTrait for StoragePlacementAction {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_target(&self) -> &Option<ManagedObjectReference> { &self.target }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ClusterActionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterAction => Some(from.as_any_ref().downcast_ref::<ClusterAction>()?),
            StructType::ClusterClusterInitialPlacementAction => Some(from.as_any_ref().downcast_ref::<ClusterClusterInitialPlacementAction>()?),
            StructType::ClusterHostInfraUpdateHaModeAction => Some(from.as_any_ref().downcast_ref::<ClusterHostInfraUpdateHaModeAction>()?),
            StructType::ClusterHostPowerAction => Some(from.as_any_ref().downcast_ref::<ClusterHostPowerAction>()?),
            StructType::ClusterInitialPlacementAction => Some(from.as_any_ref().downcast_ref::<ClusterInitialPlacementAction>()?),
            StructType::ClusterMigrationAction => Some(from.as_any_ref().downcast_ref::<ClusterMigrationAction>()?),
            StructType::PlacementAction => Some(from.as_any_ref().downcast_ref::<PlacementAction>()?),
            StructType::HbrDiskMigrationAction => Some(from.as_any_ref().downcast_ref::<HbrDiskMigrationAction>()?),
            StructType::StorageMigrationAction => Some(from.as_any_ref().downcast_ref::<StorageMigrationAction>()?),
            StructType::StoragePlacementAction => Some(from.as_any_ref().downcast_ref::<StoragePlacementAction>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterAction => Ok(from.as_any_box().downcast::<ClusterAction>()?),
            StructType::ClusterClusterInitialPlacementAction => Ok(from.as_any_box().downcast::<ClusterClusterInitialPlacementAction>()?),
            StructType::ClusterHostInfraUpdateHaModeAction => Ok(from.as_any_box().downcast::<ClusterHostInfraUpdateHaModeAction>()?),
            StructType::ClusterHostPowerAction => Ok(from.as_any_box().downcast::<ClusterHostPowerAction>()?),
            StructType::ClusterInitialPlacementAction => Ok(from.as_any_box().downcast::<ClusterInitialPlacementAction>()?),
            StructType::ClusterMigrationAction => Ok(from.as_any_box().downcast::<ClusterMigrationAction>()?),
            StructType::PlacementAction => Ok(from.as_any_box().downcast::<PlacementAction>()?),
            StructType::HbrDiskMigrationAction => Ok(from.as_any_box().downcast::<HbrDiskMigrationAction>()?),
            StructType::StorageMigrationAction => Ok(from.as_any_box().downcast::<StorageMigrationAction>()?),
            StructType::StoragePlacementAction => Ok(from.as_any_box().downcast::<StoragePlacementAction>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class for admission control related information of a vSphere HA cluster.
pub trait ClusterDasAdmissionControlInfoTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn ClusterDasAdmissionControlInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ClusterDasAdmissionControlInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ClusterDasAdmissionControlInfoVisitor)
            }
        }

struct ClusterDasAdmissionControlInfoVisitor;

impl<'de> de::Visitor<'de> for ClusterDasAdmissionControlInfoVisitor {
    type Value = Box<dyn ClusterDasAdmissionControlInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ClusterDasAdmissionControlInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ClusterDasAdmissionControlInfoTrait for ClusterDasAdmissionControlInfo {
}
impl ClusterDasAdmissionControlInfoTrait for ClusterFailoverHostAdmissionControlInfo {
}
impl ClusterDasAdmissionControlInfoTrait for ClusterFailoverLevelAdmissionControlInfo {
}
impl ClusterDasAdmissionControlInfoTrait for ClusterFailoverResourcesAdmissionControlInfo {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ClusterDasAdmissionControlInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterDasAdmissionControlInfo => Some(from.as_any_ref().downcast_ref::<ClusterDasAdmissionControlInfo>()?),
            StructType::ClusterFailoverHostAdmissionControlInfo => Some(from.as_any_ref().downcast_ref::<ClusterFailoverHostAdmissionControlInfo>()?),
            StructType::ClusterFailoverLevelAdmissionControlInfo => Some(from.as_any_ref().downcast_ref::<ClusterFailoverLevelAdmissionControlInfo>()?),
            StructType::ClusterFailoverResourcesAdmissionControlInfo => Some(from.as_any_ref().downcast_ref::<ClusterFailoverResourcesAdmissionControlInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterDasAdmissionControlInfo => Ok(from.as_any_box().downcast::<ClusterDasAdmissionControlInfo>()?),
            StructType::ClusterFailoverHostAdmissionControlInfo => Ok(from.as_any_box().downcast::<ClusterFailoverHostAdmissionControlInfo>()?),
            StructType::ClusterFailoverLevelAdmissionControlInfo => Ok(from.as_any_box().downcast::<ClusterFailoverLevelAdmissionControlInfo>()?),
            StructType::ClusterFailoverResourcesAdmissionControlInfo => Ok(from.as_any_box().downcast::<ClusterFailoverResourcesAdmissionControlInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class for specifying how admission control should be done for vSphere HA.
pub trait ClusterDasAdmissionControlPolicyTrait : super::traits::DataObjectTrait {
    /// Percentage of resource reduction that a cluster of VMs can tolerate
    /// in case of a failover.
    fn get_resource_reduction_to_tolerate_percent(&self) -> Option<i32>;
    /// Flag that determines whether strict admission control for persistent
    /// memory is enabled.
    /// 
    /// By default, this value is false.
    /// This flag can only be set to true if
    /// *ClusterDasConfigInfo.admissionControlEnabled* is set to true.
    /// When you use persistent memory admission control, the following
    /// operations are prevented, if doing so would violate the
    /// *ClusterDasConfigInfo.admissionControlEnabled*.
    /// - Creating a virtual machine with persistent memory.
    /// - Adding a virtual persistent memory device to a virtual machine.
    /// - Increasing the capacity of a virtual persistent memory device.
    ///   
    /// ***Since:*** vSphere API Release 7.0.2.0
    fn get_p_mem_admission_control_enabled(&self) -> Option<bool>;
}
impl<'s> serde::Serialize for dyn ClusterDasAdmissionControlPolicyTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ClusterDasAdmissionControlPolicyTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ClusterDasAdmissionControlPolicyVisitor)
            }
        }

struct ClusterDasAdmissionControlPolicyVisitor;

impl<'de> de::Visitor<'de> for ClusterDasAdmissionControlPolicyVisitor {
    type Value = Box<dyn ClusterDasAdmissionControlPolicyTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ClusterDasAdmissionControlPolicyTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ClusterDasAdmissionControlPolicyTrait for ClusterDasAdmissionControlPolicy {
    fn get_resource_reduction_to_tolerate_percent(&self) -> Option<i32> { self.resource_reduction_to_tolerate_percent }
    fn get_p_mem_admission_control_enabled(&self) -> Option<bool> { self.p_mem_admission_control_enabled }
}
impl ClusterDasAdmissionControlPolicyTrait for ClusterFailoverHostAdmissionControlPolicy {
    fn get_resource_reduction_to_tolerate_percent(&self) -> Option<i32> { self.resource_reduction_to_tolerate_percent }
    fn get_p_mem_admission_control_enabled(&self) -> Option<bool> { self.p_mem_admission_control_enabled }
}
impl ClusterDasAdmissionControlPolicyTrait for ClusterFailoverLevelAdmissionControlPolicy {
    fn get_resource_reduction_to_tolerate_percent(&self) -> Option<i32> { self.resource_reduction_to_tolerate_percent }
    fn get_p_mem_admission_control_enabled(&self) -> Option<bool> { self.p_mem_admission_control_enabled }
}
impl ClusterDasAdmissionControlPolicyTrait for ClusterFailoverResourcesAdmissionControlPolicy {
    fn get_resource_reduction_to_tolerate_percent(&self) -> Option<i32> { self.resource_reduction_to_tolerate_percent }
    fn get_p_mem_admission_control_enabled(&self) -> Option<bool> { self.p_mem_admission_control_enabled }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ClusterDasAdmissionControlPolicyTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterDasAdmissionControlPolicy => Some(from.as_any_ref().downcast_ref::<ClusterDasAdmissionControlPolicy>()?),
            StructType::ClusterFailoverHostAdmissionControlPolicy => Some(from.as_any_ref().downcast_ref::<ClusterFailoverHostAdmissionControlPolicy>()?),
            StructType::ClusterFailoverLevelAdmissionControlPolicy => Some(from.as_any_ref().downcast_ref::<ClusterFailoverLevelAdmissionControlPolicy>()?),
            StructType::ClusterFailoverResourcesAdmissionControlPolicy => Some(from.as_any_ref().downcast_ref::<ClusterFailoverResourcesAdmissionControlPolicy>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterDasAdmissionControlPolicy => Ok(from.as_any_box().downcast::<ClusterDasAdmissionControlPolicy>()?),
            StructType::ClusterFailoverHostAdmissionControlPolicy => Ok(from.as_any_box().downcast::<ClusterFailoverHostAdmissionControlPolicy>()?),
            StructType::ClusterFailoverLevelAdmissionControlPolicy => Ok(from.as_any_box().downcast::<ClusterFailoverLevelAdmissionControlPolicy>()?),
            StructType::ClusterFailoverResourcesAdmissionControlPolicy => Ok(from.as_any_box().downcast::<ClusterFailoverResourcesAdmissionControlPolicy>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class for advanced runtime information related to the high
/// availability service for a cluster.
pub trait ClusterDasAdvancedRuntimeInfoTrait : super::traits::DataObjectTrait {
    /// The information pertaining to the HA agents on the hosts
    fn get_das_host_info(&self) -> &Option<Box<dyn super::traits::ClusterDasHostInfoTrait>>;
    /// Whether HA VM Component Protection can be enabled for the cluster.
    fn get_vmcp_supported(&self) -> &Option<ClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo>;
    /// The map of a datastore to the set of hosts that are using
    /// the datastore for storage heartbeating.
    fn get_heartbeat_datastore_info(&self) -> &Option<Vec<DasHeartbeatDatastoreInfo>>;
}
impl<'s> serde::Serialize for dyn ClusterDasAdvancedRuntimeInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ClusterDasAdvancedRuntimeInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ClusterDasAdvancedRuntimeInfoVisitor)
            }
        }

struct ClusterDasAdvancedRuntimeInfoVisitor;

impl<'de> de::Visitor<'de> for ClusterDasAdvancedRuntimeInfoVisitor {
    type Value = Box<dyn ClusterDasAdvancedRuntimeInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ClusterDasAdvancedRuntimeInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ClusterDasAdvancedRuntimeInfoTrait for ClusterDasAdvancedRuntimeInfo {
    fn get_das_host_info(&self) -> &Option<Box<dyn super::traits::ClusterDasHostInfoTrait>> { &self.das_host_info }
    fn get_vmcp_supported(&self) -> &Option<ClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo> { &self.vmcp_supported }
    fn get_heartbeat_datastore_info(&self) -> &Option<Vec<DasHeartbeatDatastoreInfo>> { &self.heartbeat_datastore_info }
}
impl ClusterDasAdvancedRuntimeInfoTrait for ClusterDasFailoverLevelAdvancedRuntimeInfo {
    fn get_das_host_info(&self) -> &Option<Box<dyn super::traits::ClusterDasHostInfoTrait>> { &self.das_host_info }
    fn get_vmcp_supported(&self) -> &Option<ClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo> { &self.vmcp_supported }
    fn get_heartbeat_datastore_info(&self) -> &Option<Vec<DasHeartbeatDatastoreInfo>> { &self.heartbeat_datastore_info }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ClusterDasAdvancedRuntimeInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterDasAdvancedRuntimeInfo => Some(from.as_any_ref().downcast_ref::<ClusterDasAdvancedRuntimeInfo>()?),
            StructType::ClusterDasFailoverLevelAdvancedRuntimeInfo => Some(from.as_any_ref().downcast_ref::<ClusterDasFailoverLevelAdvancedRuntimeInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterDasAdvancedRuntimeInfo => Ok(from.as_any_box().downcast::<ClusterDasAdvancedRuntimeInfo>()?),
            StructType::ClusterDasFailoverLevelAdvancedRuntimeInfo => Ok(from.as_any_box().downcast::<ClusterDasFailoverLevelAdvancedRuntimeInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class for DAS data for high availability service for a cluster.
pub trait ClusterDasDataTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn ClusterDasDataTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ClusterDasDataTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ClusterDasDataVisitor)
            }
        }

struct ClusterDasDataVisitor;

impl<'de> de::Visitor<'de> for ClusterDasDataVisitor {
    type Value = Box<dyn ClusterDasDataTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ClusterDasDataTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ClusterDasDataTrait for ClusterDasData {
}
impl ClusterDasDataTrait for ClusterDasDataSummary {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ClusterDasDataTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterDasData => Some(from.as_any_ref().downcast_ref::<ClusterDasData>()?),
            StructType::ClusterDasDataSummary => Some(from.as_any_ref().downcast_ref::<ClusterDasDataSummary>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterDasData => Ok(from.as_any_box().downcast::<ClusterDasData>()?),
            StructType::ClusterDasDataSummary => Ok(from.as_any_box().downcast::<ClusterDasDataSummary>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// HA specific advanced information pertaining to the hosts in the cluster.
pub trait ClusterDasHostInfoTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn ClusterDasHostInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ClusterDasHostInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ClusterDasHostInfoVisitor)
            }
        }

struct ClusterDasHostInfoVisitor;

impl<'de> de::Visitor<'de> for ClusterDasHostInfoVisitor {
    type Value = Box<dyn ClusterDasHostInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ClusterDasHostInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ClusterDasHostInfoTrait for ClusterDasHostInfo {
}
impl ClusterDasHostInfoTrait for ClusterDasAamHostInfo {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ClusterDasHostInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterDasHostInfo => Some(from.as_any_ref().downcast_ref::<ClusterDasHostInfo>()?),
            StructType::ClusterDasAamHostInfo => Some(from.as_any_ref().downcast_ref::<ClusterDasAamHostInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterDasHostInfo => Ok(from.as_any_box().downcast::<ClusterDasHostInfo>()?),
            StructType::ClusterDasAamHostInfo => Ok(from.as_any_box().downcast::<ClusterDasAamHostInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// FaultsByVm is the faults generated by DRS when it tries to
/// move a VM.
pub trait ClusterDrsFaultsFaultsByVmTrait : super::traits::DataObjectTrait {
    /// The VM that DRS was trying to migrate when it generated the faults.
    /// 
    /// If this property is NULL, the fault is not associated with a particular VM.
    /// 
    /// Refers instance of *VirtualMachine*.
    fn get_vm(&self) -> &Option<ManagedObjectReference>;
    /// The faults generated by DRS when it was trying to move the given VM.
    fn get_fault(&self) -> &Vec<Box<dyn super::traits::MethodFaultTrait>>;
}
impl<'s> serde::Serialize for dyn ClusterDrsFaultsFaultsByVmTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ClusterDrsFaultsFaultsByVmTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ClusterDrsFaultsFaultsByVmVisitor)
            }
        }

struct ClusterDrsFaultsFaultsByVmVisitor;

impl<'de> de::Visitor<'de> for ClusterDrsFaultsFaultsByVmVisitor {
    type Value = Box<dyn ClusterDrsFaultsFaultsByVmTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ClusterDrsFaultsFaultsByVmTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ClusterDrsFaultsFaultsByVmTrait for ClusterDrsFaultsFaultsByVm {
    fn get_vm(&self) -> &Option<ManagedObjectReference> { &self.vm }
    fn get_fault(&self) -> &Vec<Box<dyn super::traits::MethodFaultTrait>> { &self.fault }
}
impl ClusterDrsFaultsFaultsByVmTrait for ClusterDrsFaultsFaultsByVirtualDisk {
    fn get_vm(&self) -> &Option<ManagedObjectReference> { &self.vm }
    fn get_fault(&self) -> &Vec<Box<dyn super::traits::MethodFaultTrait>> { &self.fault }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ClusterDrsFaultsFaultsByVmTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterDrsFaultsFaultsByVm => Some(from.as_any_ref().downcast_ref::<ClusterDrsFaultsFaultsByVm>()?),
            StructType::ClusterDrsFaultsFaultsByVirtualDisk => Some(from.as_any_ref().downcast_ref::<ClusterDrsFaultsFaultsByVirtualDisk>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterDrsFaultsFaultsByVm => Ok(from.as_any_box().downcast::<ClusterDrsFaultsFaultsByVm>()?),
            StructType::ClusterDrsFaultsFaultsByVirtualDisk => Ok(from.as_any_box().downcast::<ClusterDrsFaultsFaultsByVirtualDisk>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// *ClusterGroupInfo* is the base type for all virtual machine
/// and host groups.
/// 
/// All virtual machines and hosts that are part of a group
/// must be part of the same cluster.
pub trait ClusterGroupInfoTrait : super::traits::DataObjectTrait {
    /// Unique name of the group.
    fn get_name(&self) -> &str;
    /// Flag to indicate whether the group is created by the user or the system.
    fn get_user_created(&self) -> Option<bool>;
    /// Unique ID for the group.
    /// 
    /// uniqueID is unique within a cluster.
    /// Groups residing in different clusters might share a uniqueID.
    fn get_unique_id(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn ClusterGroupInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ClusterGroupInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ClusterGroupInfoVisitor)
            }
        }

struct ClusterGroupInfoVisitor;

impl<'de> de::Visitor<'de> for ClusterGroupInfoVisitor {
    type Value = Box<dyn ClusterGroupInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ClusterGroupInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ClusterGroupInfoTrait for ClusterGroupInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_user_created(&self) -> Option<bool> { self.user_created }
    fn get_unique_id(&self) -> &Option<String> { &self.unique_id }
}
impl ClusterGroupInfoTrait for ClusterHostGroup {
    fn get_name(&self) -> &str { &self.name }
    fn get_user_created(&self) -> Option<bool> { self.user_created }
    fn get_unique_id(&self) -> &Option<String> { &self.unique_id }
}
impl ClusterGroupInfoTrait for ClusterVmGroup {
    fn get_name(&self) -> &str { &self.name }
    fn get_user_created(&self) -> Option<bool> { self.user_created }
    fn get_unique_id(&self) -> &Option<String> { &self.unique_id }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ClusterGroupInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterGroupInfo => Some(from.as_any_ref().downcast_ref::<ClusterGroupInfo>()?),
            StructType::ClusterHostGroup => Some(from.as_any_ref().downcast_ref::<ClusterHostGroup>()?),
            StructType::ClusterVmGroup => Some(from.as_any_ref().downcast_ref::<ClusterVmGroup>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterGroupInfo => Ok(from.as_any_box().downcast::<ClusterGroupInfo>()?),
            StructType::ClusterHostGroup => Ok(from.as_any_box().downcast::<ClusterHostGroup>()?),
            StructType::ClusterVmGroup => Ok(from.as_any_box().downcast::<ClusterVmGroup>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *ClusterRuleInfo* data object is the base type for affinity
/// and anti-affinity rules.
/// 
/// The affinity and anti-affinity rules
/// are DRS (Distributed Resource Scheduling) rules that affect the placement
/// of virtual machines in a cluster. Hosts and virtual machines referenced
/// in a DRS rule must be in the same cluster.
/// 
/// Note: DRS rules are different than an individual host's CPU affinity rules
/// (*VirtualMachineAffinityInfo*).
/// 
/// The Server uses DRS rule objects to describe the current rule configuration
/// (*ClusterConfigInfoEx*.*ClusterConfigInfoEx.rule*).
/// Your client application uses rule objects to configure the affinity and
/// anti-affinity rules
/// (*ClusterConfigSpecEx*.*ClusterConfigSpecEx.rulesSpec*).
/// 
/// You can create the following types of rules:
/// - An affinity rule defines a set of virtual machines that should run
///   on the same host.
///   The *ClusterAffinityRuleSpec* object describes a rule that
///   identifies virtual machines, but does not identify any specific host.
/// - An anti-affinity rule defines a set of virtual machines that should run
///   on different hosts.
///   The *ClusterAntiAffinityRuleSpec* object describes a rule that
///   identifies virtual machines, but does not identify any specific host.
/// - A VM-Host rule defines affinity and anti-affinity relationships between
///   virtual machines and hosts.
///   The *ClusterVmHostRuleInfo* object describes a rule that identifies
///   a virtual machine group (*ClusterVmGroup*) and affinity and
///   anti-affinity host groups (*ClusterHostGroup*).
///   
/// Rule configuration is a dynamic process. When you create or modify a DRS rule,
/// the Server applies the rule to the cluster. If the existing cluster configuration
/// violates the rule, the Server attempts to correct the situation. If that is not
/// possible, the Server generates a fault and produces a log event.
/// DRS rules do not have precedence; all rules are applied equally.
/// DRS does not validate one rule against another. If you create conflicting
/// rules, the older rule takes precedence and DRS disables the newer rule.
/// 
/// Improperly used, DRS rules can fragment the cluster and inhibit the proper
/// functioning of DRS, HA, and DPM services. vSphere services never
/// take any actions that would result in the violation of mandatory DRS rules.
/// An operation that violates a mandatory rule would produce the following
/// consequences.
/// - DRS does not evacuate virtual machines to place a host in maintenance
///   mode.
/// - DRS does not place virtual machines for power-on or load balance virtual
///   machines.
/// - HA does not perform failovers.
/// - DPM does not optimize power management by placing hosts into standby
///   mode.
///   
/// To avoid these situations, exercise caution when creating more than one
/// mandatory rule, or consider using only optional rules. Make sure that
/// the number of hosts with which a virtual machine is related by affinity rule
/// is large enough that losing a host does not prevent the virtual machine
/// from running.
/// 
/// For manual and partially automated DRS clusters, the Server produces migration
/// recommendations to satisfy the DRS rules. You are not required to act on the
/// recommendations, but the Server maintains the recommendations until the rules
/// are satisfied.
pub trait ClusterRuleInfoTrait : super::traits::DataObjectTrait {
    /// Unique ID for rules.
    /// 
    /// When adding a new rule, do not specify this property.
    /// The Server will assign the key.
    fn get_key(&self) -> Option<i32>;
    /// Flag to indicate whether or not the rule is currently satisfied.
    fn get_status(&self) -> &Option<super::enums::ManagedEntityStatusEnum>;
    /// Flag to indicate whether or not the rule is enabled.
    /// 
    /// Set this property
    /// when you configure the rule. The default value is false (disabled).
    /// If there is a rule conflict, the Server can override the setting to disable
    /// a rule.
    fn get_enabled(&self) -> Option<bool>;
    /// Name of the rule.
    fn get_name(&self) -> &Option<String>;
    /// Flag to indicate whether compliance with this rule is mandatory or optional.
    /// 
    /// The default value is false (optional).
    /// - A mandatory rule will prevent a virtual machine from being powered on
    ///   or migrated to a host that does not satisfy the rule.
    /// - An optional rule specifies a preference. DRS takes an optional rule
    ///   into consideration when it places a virtual machine in the cluster.
    ///   DRS will act on an optional rule as long as it does not impact
    ///   the ability of the host to satisfy current CPU or memory requirements
    ///   for virtual machines on the system. (As long as the operation does not
    ///   cause any host to be more than 100% utilized.)
    fn get_mandatory(&self) -> Option<bool>;
    /// Flag to indicate whether the rule is created by the user or the system.
    fn get_user_created(&self) -> Option<bool>;
    /// Flag to indicate whether or not the placement of Virtual Machines is currently
    /// in compliance with this rule.
    /// 
    /// The Server does not currently use this property.
    fn get_in_compliance(&self) -> Option<bool>;
    /// UUID for the rule.
    /// 
    /// When adding a new rule, do not specify this
    /// property. The Server will assign the key.
    fn get_rule_uuid(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn ClusterRuleInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ClusterRuleInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ClusterRuleInfoVisitor)
            }
        }

struct ClusterRuleInfoVisitor;

impl<'de> de::Visitor<'de> for ClusterRuleInfoVisitor {
    type Value = Box<dyn ClusterRuleInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ClusterRuleInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ClusterRuleInfoTrait for ClusterRuleInfo {
    fn get_key(&self) -> Option<i32> { self.key }
    fn get_status(&self) -> &Option<super::enums::ManagedEntityStatusEnum> { &self.status }
    fn get_enabled(&self) -> Option<bool> { self.enabled }
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_mandatory(&self) -> Option<bool> { self.mandatory }
    fn get_user_created(&self) -> Option<bool> { self.user_created }
    fn get_in_compliance(&self) -> Option<bool> { self.in_compliance }
    fn get_rule_uuid(&self) -> &Option<String> { &self.rule_uuid }
}
impl ClusterRuleInfoTrait for ClusterAffinityRuleSpec {
    fn get_key(&self) -> Option<i32> { self.key }
    fn get_status(&self) -> &Option<super::enums::ManagedEntityStatusEnum> { &self.status }
    fn get_enabled(&self) -> Option<bool> { self.enabled }
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_mandatory(&self) -> Option<bool> { self.mandatory }
    fn get_user_created(&self) -> Option<bool> { self.user_created }
    fn get_in_compliance(&self) -> Option<bool> { self.in_compliance }
    fn get_rule_uuid(&self) -> &Option<String> { &self.rule_uuid }
}
impl ClusterRuleInfoTrait for ClusterAntiAffinityRuleSpec {
    fn get_key(&self) -> Option<i32> { self.key }
    fn get_status(&self) -> &Option<super::enums::ManagedEntityStatusEnum> { &self.status }
    fn get_enabled(&self) -> Option<bool> { self.enabled }
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_mandatory(&self) -> Option<bool> { self.mandatory }
    fn get_user_created(&self) -> Option<bool> { self.user_created }
    fn get_in_compliance(&self) -> Option<bool> { self.in_compliance }
    fn get_rule_uuid(&self) -> &Option<String> { &self.rule_uuid }
}
impl ClusterRuleInfoTrait for ClusterDependencyRuleInfo {
    fn get_key(&self) -> Option<i32> { self.key }
    fn get_status(&self) -> &Option<super::enums::ManagedEntityStatusEnum> { &self.status }
    fn get_enabled(&self) -> Option<bool> { self.enabled }
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_mandatory(&self) -> Option<bool> { self.mandatory }
    fn get_user_created(&self) -> Option<bool> { self.user_created }
    fn get_in_compliance(&self) -> Option<bool> { self.in_compliance }
    fn get_rule_uuid(&self) -> &Option<String> { &self.rule_uuid }
}
impl ClusterRuleInfoTrait for ClusterVmHostRuleInfo {
    fn get_key(&self) -> Option<i32> { self.key }
    fn get_status(&self) -> &Option<super::enums::ManagedEntityStatusEnum> { &self.status }
    fn get_enabled(&self) -> Option<bool> { self.enabled }
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_mandatory(&self) -> Option<bool> { self.mandatory }
    fn get_user_created(&self) -> Option<bool> { self.user_created }
    fn get_in_compliance(&self) -> Option<bool> { self.in_compliance }
    fn get_rule_uuid(&self) -> &Option<String> { &self.rule_uuid }
}
impl ClusterRuleInfoTrait for VirtualDiskAntiAffinityRuleSpec {
    fn get_key(&self) -> Option<i32> { self.key }
    fn get_status(&self) -> &Option<super::enums::ManagedEntityStatusEnum> { &self.status }
    fn get_enabled(&self) -> Option<bool> { self.enabled }
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_mandatory(&self) -> Option<bool> { self.mandatory }
    fn get_user_created(&self) -> Option<bool> { self.user_created }
    fn get_in_compliance(&self) -> Option<bool> { self.in_compliance }
    fn get_rule_uuid(&self) -> &Option<String> { &self.rule_uuid }
}
impl ClusterRuleInfoTrait for VirtualDiskRuleSpec {
    fn get_key(&self) -> Option<i32> { self.key }
    fn get_status(&self) -> &Option<super::enums::ManagedEntityStatusEnum> { &self.status }
    fn get_enabled(&self) -> Option<bool> { self.enabled }
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_mandatory(&self) -> Option<bool> { self.mandatory }
    fn get_user_created(&self) -> Option<bool> { self.user_created }
    fn get_in_compliance(&self) -> Option<bool> { self.in_compliance }
    fn get_rule_uuid(&self) -> &Option<String> { &self.rule_uuid }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ClusterRuleInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterRuleInfo => Some(from.as_any_ref().downcast_ref::<ClusterRuleInfo>()?),
            StructType::ClusterAffinityRuleSpec => Some(from.as_any_ref().downcast_ref::<ClusterAffinityRuleSpec>()?),
            StructType::ClusterAntiAffinityRuleSpec => Some(from.as_any_ref().downcast_ref::<ClusterAntiAffinityRuleSpec>()?),
            StructType::ClusterDependencyRuleInfo => Some(from.as_any_ref().downcast_ref::<ClusterDependencyRuleInfo>()?),
            StructType::ClusterVmHostRuleInfo => Some(from.as_any_ref().downcast_ref::<ClusterVmHostRuleInfo>()?),
            StructType::VirtualDiskAntiAffinityRuleSpec => Some(from.as_any_ref().downcast_ref::<VirtualDiskAntiAffinityRuleSpec>()?),
            StructType::VirtualDiskRuleSpec => Some(from.as_any_ref().downcast_ref::<VirtualDiskRuleSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterRuleInfo => Ok(from.as_any_box().downcast::<ClusterRuleInfo>()?),
            StructType::ClusterAffinityRuleSpec => Ok(from.as_any_box().downcast::<ClusterAffinityRuleSpec>()?),
            StructType::ClusterAntiAffinityRuleSpec => Ok(from.as_any_box().downcast::<ClusterAntiAffinityRuleSpec>()?),
            StructType::ClusterDependencyRuleInfo => Ok(from.as_any_box().downcast::<ClusterDependencyRuleInfo>()?),
            StructType::ClusterVmHostRuleInfo => Ok(from.as_any_box().downcast::<ClusterVmHostRuleInfo>()?),
            StructType::VirtualDiskAntiAffinityRuleSpec => Ok(from.as_any_box().downcast::<VirtualDiskAntiAffinityRuleSpec>()?),
            StructType::VirtualDiskRuleSpec => Ok(from.as_any_box().downcast::<VirtualDiskRuleSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The base class *ClusterSlotPolicy* is used for specifying how
/// the slot size is to be computed for the failover level HA admission control
/// policy.
/// 
/// By default, vSphere HA defines the slot size using the largest memory
/// and cpu reservations of any powered on virtual machine in the cluster.
/// Subclasses of this class define various policies to modify how the slot size
/// is chosen to prevent outlier virtual machines (i.e. those with much larger
/// reservations than the average) from skewing the slot size. If such a policy is chosen,
/// outlier virtual machines will use multiple slots. Using such a policy introduces
/// a risk that vSphere HA will be unable to failover these virtual machines because
/// of resource fragmentation.
pub trait ClusterSlotPolicyTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn ClusterSlotPolicyTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ClusterSlotPolicyTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ClusterSlotPolicyVisitor)
            }
        }

struct ClusterSlotPolicyVisitor;

impl<'de> de::Visitor<'de> for ClusterSlotPolicyVisitor {
    type Value = Box<dyn ClusterSlotPolicyTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ClusterSlotPolicyTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ClusterSlotPolicyTrait for ClusterSlotPolicy {
}
impl ClusterSlotPolicyTrait for ClusterFixedSizeSlotPolicy {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ClusterSlotPolicyTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterSlotPolicy => Some(from.as_any_ref().downcast_ref::<ClusterSlotPolicy>()?),
            StructType::ClusterFixedSizeSlotPolicy => Some(from.as_any_ref().downcast_ref::<ClusterFixedSizeSlotPolicy>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterSlotPolicy => Ok(from.as_any_box().downcast::<ClusterSlotPolicy>()?),
            StructType::ClusterFixedSizeSlotPolicy => Ok(from.as_any_box().downcast::<ClusterFixedSizeSlotPolicy>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *DVPortSetting* data object
/// describes the network configuration of a *DistributedVirtualPort*.
pub trait DvPortSettingTrait : super::traits::DataObjectTrait {
    /// Indicates whether this port is blocked.
    /// 
    /// If a port is blocked,
    /// packet forwarding is stopped.
    fn get_blocked(&self) -> &Option<BoolPolicy>;
    /// Deprecated as of vSphere API 8.0. VMDirectPath Gen 2 is no longer supported and
    /// there is no replacement.
    /// 
    /// Indicates whether this port is allowed to do VMDirectPath Gen2 network passthrough.
    /// 
    /// Direct path capability is defined at host, switch, and device levels.
    /// See the <code>vmDirectPathGen2Supported</code> properties on the
    /// *DVSFeatureCapability*,
    /// *HostCapability*, *PhysicalNic*,
    /// and *VirtualEthernetCardOption* objects.
    fn get_vm_direct_path_gen_2_allowed(&self) -> &Option<BoolPolicy>;
    /// Network shaping policy for controlling throughput of inbound traffic.
    fn get_in_shaping_policy(&self) -> &Option<DvsTrafficShapingPolicy>;
    /// Network shaping policy for controlling throughput of outbound traffic.
    fn get_out_shaping_policy(&self) -> &Option<DvsTrafficShapingPolicy>;
    /// Opaque binary blob that stores vendor specific configuration.
    fn get_vendor_specific_config(&self) -> &Option<DvsVendorSpecificConfig>;
    /// Deprecated as of vSphere API 6.0
    /// Use *DVPortgroupConfigInfo.vmVnicNetworkResourcePoolKey* instead
    /// to reference the virtual NIC network resource pool.
    /// 
    /// The key of user defined network resource pool to be associated with a port.
    /// 
    /// The default value for this property is "-1", indicating that
    /// this port is not associated with any network resource pool.
    fn get_network_resource_pool_key(&self) -> &Option<StringPolicy>;
    /// Configuration for Network Filter Policy.
    fn get_filter_policy(&self) -> &Option<DvsFilterPolicy>;
}
impl<'s> serde::Serialize for dyn DvPortSettingTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DvPortSettingTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DvPortSettingVisitor)
            }
        }

struct DvPortSettingVisitor;

impl<'de> de::Visitor<'de> for DvPortSettingVisitor {
    type Value = Box<dyn DvPortSettingTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DvPortSettingTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DvPortSettingTrait for DvPortSetting {
    fn get_blocked(&self) -> &Option<BoolPolicy> { &self.blocked }
    fn get_vm_direct_path_gen_2_allowed(&self) -> &Option<BoolPolicy> { &self.vm_direct_path_gen_2_allowed }
    fn get_in_shaping_policy(&self) -> &Option<DvsTrafficShapingPolicy> { &self.in_shaping_policy }
    fn get_out_shaping_policy(&self) -> &Option<DvsTrafficShapingPolicy> { &self.out_shaping_policy }
    fn get_vendor_specific_config(&self) -> &Option<DvsVendorSpecificConfig> { &self.vendor_specific_config }
    fn get_network_resource_pool_key(&self) -> &Option<StringPolicy> { &self.network_resource_pool_key }
    fn get_filter_policy(&self) -> &Option<DvsFilterPolicy> { &self.filter_policy }
}
impl DvPortSettingTrait for VMwareDvsPortSetting {
    fn get_blocked(&self) -> &Option<BoolPolicy> { &self.blocked }
    fn get_vm_direct_path_gen_2_allowed(&self) -> &Option<BoolPolicy> { &self.vm_direct_path_gen_2_allowed }
    fn get_in_shaping_policy(&self) -> &Option<DvsTrafficShapingPolicy> { &self.in_shaping_policy }
    fn get_out_shaping_policy(&self) -> &Option<DvsTrafficShapingPolicy> { &self.out_shaping_policy }
    fn get_vendor_specific_config(&self) -> &Option<DvsVendorSpecificConfig> { &self.vendor_specific_config }
    fn get_network_resource_pool_key(&self) -> &Option<StringPolicy> { &self.network_resource_pool_key }
    fn get_filter_policy(&self) -> &Option<DvsFilterPolicy> { &self.filter_policy }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DvPortSettingTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvPortSetting => Some(from.as_any_ref().downcast_ref::<DvPortSetting>()?),
            StructType::VMwareDvsPortSetting => Some(from.as_any_ref().downcast_ref::<VMwareDvsPortSetting>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvPortSetting => Ok(from.as_any_box().downcast::<DvPortSetting>()?),
            StructType::VMwareDvsPortSetting => Ok(from.as_any_box().downcast::<VMwareDvsPortSetting>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The DistributedVirtualPortgroup policies.
/// 
/// This field is not applicable
/// when queried directly against an ESX host.
pub trait DvPortgroupPolicyTrait : super::traits::DataObjectTrait {
    /// Allow the *DVPortSetting.blocked* setting
    /// of an individual port to override the setting in
    /// *DVPortgroupConfigInfo.defaultPortConfig* of
    /// a portgroup.
    fn get_block_override_allowed(&self) -> bool;
    /// Allow the *DVPortSetting.inShapingPolicy* or
    /// *DVPortSetting.outShapingPolicy* settings
    /// of an individual port to override the setting in
    /// *DVPortgroupConfigInfo.defaultPortConfig* of
    /// a portgroup.
    fn get_shaping_override_allowed(&self) -> bool;
    /// Allow the *DVPortSetting.vendorSpecificConfig*
    /// setting of an individual port to override the setting in
    /// *DVPortgroupConfigInfo.defaultPortConfig* of
    /// a portgroup.
    fn get_vendor_config_override_allowed(&self) -> bool;
    /// Allow a live port to be moved in and out of the portgroup.
    fn get_live_port_moving_allowed(&self) -> bool;
    /// If true, reset the port network setting back to the portgroup setting
    /// (thus removing the per-port setting) when the port is disconnected from
    /// the connectee.
    fn get_port_config_reset_at_disconnect(&self) -> bool;
    /// Allow the setting of
    /// *DVPortSetting.networkResourcePoolKey* of an
    /// individual port to override the setting in
    /// *DVPortgroupConfigInfo.defaultPortConfig*
    /// of a portgroup.
    fn get_network_resource_pool_override_allowed(&self) -> Option<bool>;
    /// Allow the setting of
    /// *DVPortSetting.filterPolicy*,
    /// for an individual port to override the setting in
    /// *DVPortgroupConfigInfo.defaultPortConfig* of
    /// a portgroup.
    fn get_traffic_filter_override_allowed(&self) -> Option<bool>;
}
impl<'s> serde::Serialize for dyn DvPortgroupPolicyTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DvPortgroupPolicyTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DvPortgroupPolicyVisitor)
            }
        }

struct DvPortgroupPolicyVisitor;

impl<'de> de::Visitor<'de> for DvPortgroupPolicyVisitor {
    type Value = Box<dyn DvPortgroupPolicyTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DvPortgroupPolicyTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DvPortgroupPolicyTrait for DvPortgroupPolicy {
    fn get_block_override_allowed(&self) -> bool { self.block_override_allowed }
    fn get_shaping_override_allowed(&self) -> bool { self.shaping_override_allowed }
    fn get_vendor_config_override_allowed(&self) -> bool { self.vendor_config_override_allowed }
    fn get_live_port_moving_allowed(&self) -> bool { self.live_port_moving_allowed }
    fn get_port_config_reset_at_disconnect(&self) -> bool { self.port_config_reset_at_disconnect }
    fn get_network_resource_pool_override_allowed(&self) -> Option<bool> { self.network_resource_pool_override_allowed }
    fn get_traffic_filter_override_allowed(&self) -> Option<bool> { self.traffic_filter_override_allowed }
}
impl DvPortgroupPolicyTrait for VMwareDvsPortgroupPolicy {
    fn get_block_override_allowed(&self) -> bool { self.block_override_allowed }
    fn get_shaping_override_allowed(&self) -> bool { self.shaping_override_allowed }
    fn get_vendor_config_override_allowed(&self) -> bool { self.vendor_config_override_allowed }
    fn get_live_port_moving_allowed(&self) -> bool { self.live_port_moving_allowed }
    fn get_port_config_reset_at_disconnect(&self) -> bool { self.port_config_reset_at_disconnect }
    fn get_network_resource_pool_override_allowed(&self) -> Option<bool> { self.network_resource_pool_override_allowed }
    fn get_traffic_filter_override_allowed(&self) -> Option<bool> { self.traffic_filter_override_allowed }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DvPortgroupPolicyTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvPortgroupPolicy => Some(from.as_any_ref().downcast_ref::<DvPortgroupPolicy>()?),
            StructType::VMwareDvsPortgroupPolicy => Some(from.as_any_ref().downcast_ref::<VMwareDvsPortgroupPolicy>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvPortgroupPolicy => Ok(from.as_any_box().downcast::<DvPortgroupPolicy>()?),
            StructType::VMwareDvsPortgroupPolicy => Ok(from.as_any_box().downcast::<VMwareDvsPortgroupPolicy>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class for filters to check host compatibility.
pub trait DistributedVirtualSwitchManagerHostDvsFilterSpecTrait : super::traits::DataObjectTrait {
    /// If this flag is true, then the filter returns the hosts in the
    /// *DistributedVirtualSwitchManagerHostContainer*
    /// that satisfy the criteria specified by this filter, otherwise
    /// it returns hosts that don't meet the criteria.
    fn get_inclusive(&self) -> bool;
}
impl<'s> serde::Serialize for dyn DistributedVirtualSwitchManagerHostDvsFilterSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DistributedVirtualSwitchManagerHostDvsFilterSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DistributedVirtualSwitchManagerHostDvsFilterSpecVisitor)
            }
        }

struct DistributedVirtualSwitchManagerHostDvsFilterSpecVisitor;

impl<'de> de::Visitor<'de> for DistributedVirtualSwitchManagerHostDvsFilterSpecVisitor {
    type Value = Box<dyn DistributedVirtualSwitchManagerHostDvsFilterSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DistributedVirtualSwitchManagerHostDvsFilterSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DistributedVirtualSwitchManagerHostDvsFilterSpecTrait for DistributedVirtualSwitchManagerHostDvsFilterSpec {
    fn get_inclusive(&self) -> bool { self.inclusive }
}
impl DistributedVirtualSwitchManagerHostDvsFilterSpecTrait for DistributedVirtualSwitchManagerHostArrayFilter {
    fn get_inclusive(&self) -> bool { self.inclusive }
}
impl DistributedVirtualSwitchManagerHostDvsFilterSpecTrait for DistributedVirtualSwitchManagerHostContainerFilter {
    fn get_inclusive(&self) -> bool { self.inclusive }
}
impl DistributedVirtualSwitchManagerHostDvsFilterSpecTrait for DistributedVirtualSwitchManagerHostDvsMembershipFilter {
    fn get_inclusive(&self) -> bool { self.inclusive }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DistributedVirtualSwitchManagerHostDvsFilterSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DistributedVirtualSwitchManagerHostDvsFilterSpec => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchManagerHostDvsFilterSpec>()?),
            StructType::DistributedVirtualSwitchManagerHostArrayFilter => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchManagerHostArrayFilter>()?),
            StructType::DistributedVirtualSwitchManagerHostContainerFilter => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchManagerHostContainerFilter>()?),
            StructType::DistributedVirtualSwitchManagerHostDvsMembershipFilter => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchManagerHostDvsMembershipFilter>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DistributedVirtualSwitchManagerHostDvsFilterSpec => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchManagerHostDvsFilterSpec>()?),
            StructType::DistributedVirtualSwitchManagerHostArrayFilter => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchManagerHostArrayFilter>()?),
            StructType::DistributedVirtualSwitchManagerHostContainerFilter => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchManagerHostContainerFilter>()?),
            StructType::DistributedVirtualSwitchManagerHostDvsMembershipFilter => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchManagerHostDvsMembershipFilter>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class.
pub trait DistributedVirtualSwitchHostMemberBackingTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn DistributedVirtualSwitchHostMemberBackingTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DistributedVirtualSwitchHostMemberBackingTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DistributedVirtualSwitchHostMemberBackingVisitor)
            }
        }

struct DistributedVirtualSwitchHostMemberBackingVisitor;

impl<'de> de::Visitor<'de> for DistributedVirtualSwitchHostMemberBackingVisitor {
    type Value = Box<dyn DistributedVirtualSwitchHostMemberBackingTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DistributedVirtualSwitchHostMemberBackingTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DistributedVirtualSwitchHostMemberBackingTrait for DistributedVirtualSwitchHostMemberBacking {
}
impl DistributedVirtualSwitchHostMemberBackingTrait for DistributedVirtualSwitchHostMemberPnicBacking {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DistributedVirtualSwitchHostMemberBackingTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DistributedVirtualSwitchHostMemberBacking => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchHostMemberBacking>()?),
            StructType::DistributedVirtualSwitchHostMemberPnicBacking => Some(from.as_any_ref().downcast_ref::<DistributedVirtualSwitchHostMemberPnicBacking>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DistributedVirtualSwitchHostMemberBacking => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchHostMemberBacking>()?),
            StructType::DistributedVirtualSwitchHostMemberPnicBacking => Ok(from.as_any_box().downcast::<DistributedVirtualSwitchHostMemberPnicBacking>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This class defines healthcheck result of the vSphere Distributed Switch.
pub trait HostMemberHealthCheckResultTrait : super::traits::DataObjectTrait {
    /// The summary of health check result.
    fn get_summary(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn HostMemberHealthCheckResultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostMemberHealthCheckResultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostMemberHealthCheckResultVisitor)
            }
        }

struct HostMemberHealthCheckResultVisitor;

impl<'de> de::Visitor<'de> for HostMemberHealthCheckResultVisitor {
    type Value = Box<dyn HostMemberHealthCheckResultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostMemberHealthCheckResultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostMemberHealthCheckResultTrait for HostMemberHealthCheckResult {
    fn get_summary(&self) -> &Option<String> { &self.summary }
}
impl HostMemberHealthCheckResultTrait for HostMemberUplinkHealthCheckResult {
    fn get_summary(&self) -> &Option<String> { &self.summary }
}
impl HostMemberHealthCheckResultTrait for VMwareDvsMtuHealthCheckResult {
    fn get_summary(&self) -> &Option<String> { &self.summary }
}
impl HostMemberHealthCheckResultTrait for VMwareDvsVlanHealthCheckResult {
    fn get_summary(&self) -> &Option<String> { &self.summary }
}
impl HostMemberHealthCheckResultTrait for VMwareDvsTeamingHealthCheckResult {
    fn get_summary(&self) -> &Option<String> { &self.summary }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostMemberHealthCheckResultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostMemberHealthCheckResult => Some(from.as_any_ref().downcast_ref::<HostMemberHealthCheckResult>()?),
            StructType::HostMemberUplinkHealthCheckResult => Some(from.as_any_ref().downcast_ref::<HostMemberUplinkHealthCheckResult>()?),
            StructType::VMwareDvsMtuHealthCheckResult => Some(from.as_any_ref().downcast_ref::<VMwareDvsMtuHealthCheckResult>()?),
            StructType::VMwareDvsVlanHealthCheckResult => Some(from.as_any_ref().downcast_ref::<VMwareDvsVlanHealthCheckResult>()?),
            StructType::VMwareDvsTeamingHealthCheckResult => Some(from.as_any_ref().downcast_ref::<VMwareDvsTeamingHealthCheckResult>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostMemberHealthCheckResult => Ok(from.as_any_box().downcast::<HostMemberHealthCheckResult>()?),
            StructType::HostMemberUplinkHealthCheckResult => Ok(from.as_any_box().downcast::<HostMemberUplinkHealthCheckResult>()?),
            StructType::VMwareDvsMtuHealthCheckResult => Ok(from.as_any_box().downcast::<VMwareDvsMtuHealthCheckResult>()?),
            StructType::VMwareDvsVlanHealthCheckResult => Ok(from.as_any_box().downcast::<VMwareDvsVlanHealthCheckResult>()?),
            StructType::VMwareDvsTeamingHealthCheckResult => Ok(from.as_any_box().downcast::<VMwareDvsTeamingHealthCheckResult>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This class defines healthcheck result of a specified Uplink port
/// in vSphere Distributed Switch.
pub trait HostMemberUplinkHealthCheckResultTrait : super::traits::HostMemberHealthCheckResultTrait {
    /// The uplink port key.
    fn get_uplink_port_key(&self) -> &str;
}
impl<'s> serde::Serialize for dyn HostMemberUplinkHealthCheckResultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostMemberUplinkHealthCheckResultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostMemberUplinkHealthCheckResultVisitor)
            }
        }

struct HostMemberUplinkHealthCheckResultVisitor;

impl<'de> de::Visitor<'de> for HostMemberUplinkHealthCheckResultVisitor {
    type Value = Box<dyn HostMemberUplinkHealthCheckResultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostMemberUplinkHealthCheckResultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostMemberUplinkHealthCheckResultTrait for HostMemberUplinkHealthCheckResult {
    fn get_uplink_port_key(&self) -> &str { &self.uplink_port_key }
}
impl HostMemberUplinkHealthCheckResultTrait for VMwareDvsMtuHealthCheckResult {
    fn get_uplink_port_key(&self) -> &str { &self.uplink_port_key }
}
impl HostMemberUplinkHealthCheckResultTrait for VMwareDvsVlanHealthCheckResult {
    fn get_uplink_port_key(&self) -> &str { &self.uplink_port_key }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostMemberUplinkHealthCheckResultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostMemberUplinkHealthCheckResult => Some(from.as_any_ref().downcast_ref::<HostMemberUplinkHealthCheckResult>()?),
            StructType::VMwareDvsMtuHealthCheckResult => Some(from.as_any_ref().downcast_ref::<VMwareDvsMtuHealthCheckResult>()?),
            StructType::VMwareDvsVlanHealthCheckResult => Some(from.as_any_ref().downcast_ref::<VMwareDvsVlanHealthCheckResult>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostMemberUplinkHealthCheckResult => Ok(from.as_any_box().downcast::<HostMemberUplinkHealthCheckResult>()?),
            StructType::VMwareDvsMtuHealthCheckResult => Ok(from.as_any_box().downcast::<VMwareDvsMtuHealthCheckResult>()?),
            StructType::VMwareDvsVlanHealthCheckResult => Ok(from.as_any_box().downcast::<VMwareDvsVlanHealthCheckResult>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This class is the base class for network rule action.
pub trait DvsNetworkRuleActionTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn DvsNetworkRuleActionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DvsNetworkRuleActionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DvsNetworkRuleActionVisitor)
            }
        }

struct DvsNetworkRuleActionVisitor;

impl<'de> de::Visitor<'de> for DvsNetworkRuleActionVisitor {
    type Value = Box<dyn DvsNetworkRuleActionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DvsNetworkRuleActionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DvsNetworkRuleActionTrait for DvsNetworkRuleAction {
}
impl DvsNetworkRuleActionTrait for DvsAcceptNetworkRuleAction {
}
impl DvsNetworkRuleActionTrait for DvsCopyNetworkRuleAction {
}
impl DvsNetworkRuleActionTrait for DvsDropNetworkRuleAction {
}
impl DvsNetworkRuleActionTrait for DvsGreEncapNetworkRuleAction {
}
impl DvsNetworkRuleActionTrait for DvsLogNetworkRuleAction {
}
impl DvsNetworkRuleActionTrait for DvsMacRewriteNetworkRuleAction {
}
impl DvsNetworkRuleActionTrait for DvsPuntNetworkRuleAction {
}
impl DvsNetworkRuleActionTrait for DvsRateLimitNetworkRuleAction {
}
impl DvsNetworkRuleActionTrait for DvsUpdateTagNetworkRuleAction {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DvsNetworkRuleActionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsNetworkRuleAction>()?),
            StructType::DvsAcceptNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsAcceptNetworkRuleAction>()?),
            StructType::DvsCopyNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsCopyNetworkRuleAction>()?),
            StructType::DvsDropNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsDropNetworkRuleAction>()?),
            StructType::DvsGreEncapNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsGreEncapNetworkRuleAction>()?),
            StructType::DvsLogNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsLogNetworkRuleAction>()?),
            StructType::DvsMacRewriteNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsMacRewriteNetworkRuleAction>()?),
            StructType::DvsPuntNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsPuntNetworkRuleAction>()?),
            StructType::DvsRateLimitNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsRateLimitNetworkRuleAction>()?),
            StructType::DvsUpdateTagNetworkRuleAction => Some(from.as_any_ref().downcast_ref::<DvsUpdateTagNetworkRuleAction>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsNetworkRuleAction>()?),
            StructType::DvsAcceptNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsAcceptNetworkRuleAction>()?),
            StructType::DvsCopyNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsCopyNetworkRuleAction>()?),
            StructType::DvsDropNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsDropNetworkRuleAction>()?),
            StructType::DvsGreEncapNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsGreEncapNetworkRuleAction>()?),
            StructType::DvsLogNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsLogNetworkRuleAction>()?),
            StructType::DvsMacRewriteNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsMacRewriteNetworkRuleAction>()?),
            StructType::DvsPuntNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsPuntNetworkRuleAction>()?),
            StructType::DvsRateLimitNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsRateLimitNetworkRuleAction>()?),
            StructType::DvsUpdateTagNetworkRuleAction => Ok(from.as_any_box().downcast::<DvsUpdateTagNetworkRuleAction>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This class is the base class for identifying network traffic.
pub trait DvsNetworkRuleQualifierTrait : super::traits::DataObjectTrait {
    /// The key of the Qualifier
    fn get_key(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn DvsNetworkRuleQualifierTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DvsNetworkRuleQualifierTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DvsNetworkRuleQualifierVisitor)
            }
        }

struct DvsNetworkRuleQualifierVisitor;

impl<'de> de::Visitor<'de> for DvsNetworkRuleQualifierVisitor {
    type Value = Box<dyn DvsNetworkRuleQualifierTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DvsNetworkRuleQualifierTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DvsNetworkRuleQualifierTrait for DvsNetworkRuleQualifier {
    fn get_key(&self) -> &Option<String> { &self.key }
}
impl DvsNetworkRuleQualifierTrait for DvsIpNetworkRuleQualifier {
    fn get_key(&self) -> &Option<String> { &self.key }
}
impl DvsNetworkRuleQualifierTrait for DvsMacNetworkRuleQualifier {
    fn get_key(&self) -> &Option<String> { &self.key }
}
impl DvsNetworkRuleQualifierTrait for DvsSystemTrafficNetworkRuleQualifier {
    fn get_key(&self) -> &Option<String> { &self.key }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DvsNetworkRuleQualifierTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsNetworkRuleQualifier => Some(from.as_any_ref().downcast_ref::<DvsNetworkRuleQualifier>()?),
            StructType::DvsIpNetworkRuleQualifier => Some(from.as_any_ref().downcast_ref::<DvsIpNetworkRuleQualifier>()?),
            StructType::DvsMacNetworkRuleQualifier => Some(from.as_any_ref().downcast_ref::<DvsMacNetworkRuleQualifier>()?),
            StructType::DvsSystemTrafficNetworkRuleQualifier => Some(from.as_any_ref().downcast_ref::<DvsSystemTrafficNetworkRuleQualifier>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsNetworkRuleQualifier => Ok(from.as_any_box().downcast::<DvsNetworkRuleQualifier>()?),
            StructType::DvsIpNetworkRuleQualifier => Ok(from.as_any_box().downcast::<DvsIpNetworkRuleQualifier>()?),
            StructType::DvsMacNetworkRuleQualifier => Ok(from.as_any_box().downcast::<DvsMacNetworkRuleQualifier>()?),
            StructType::DvsSystemTrafficNetworkRuleQualifier => Ok(from.as_any_box().downcast::<DvsSystemTrafficNetworkRuleQualifier>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type encapsulates virtual machine or disk encryption
/// settings.
pub trait CryptoSpecTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn CryptoSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn CryptoSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(CryptoSpecVisitor)
            }
        }

struct CryptoSpecVisitor;

impl<'de> de::Visitor<'de> for CryptoSpecVisitor {
    type Value = Box<dyn CryptoSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid CryptoSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl CryptoSpecTrait for CryptoSpec {
}
impl CryptoSpecTrait for CryptoSpecDecrypt {
}
impl CryptoSpecTrait for CryptoSpecDeepRecrypt {
}
impl CryptoSpecTrait for CryptoSpecEncrypt {
}
impl CryptoSpecTrait for CryptoSpecNoOp {
}
impl CryptoSpecTrait for CryptoSpecRegister {
}
impl CryptoSpecTrait for CryptoSpecShallowRecrypt {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn CryptoSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::CryptoSpec => Some(from.as_any_ref().downcast_ref::<CryptoSpec>()?),
            StructType::CryptoSpecDecrypt => Some(from.as_any_ref().downcast_ref::<CryptoSpecDecrypt>()?),
            StructType::CryptoSpecDeepRecrypt => Some(from.as_any_ref().downcast_ref::<CryptoSpecDeepRecrypt>()?),
            StructType::CryptoSpecEncrypt => Some(from.as_any_ref().downcast_ref::<CryptoSpecEncrypt>()?),
            StructType::CryptoSpecNoOp => Some(from.as_any_ref().downcast_ref::<CryptoSpecNoOp>()?),
            StructType::CryptoSpecRegister => Some(from.as_any_ref().downcast_ref::<CryptoSpecRegister>()?),
            StructType::CryptoSpecShallowRecrypt => Some(from.as_any_ref().downcast_ref::<CryptoSpecShallowRecrypt>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::CryptoSpec => Ok(from.as_any_box().downcast::<CryptoSpec>()?),
            StructType::CryptoSpecDecrypt => Ok(from.as_any_box().downcast::<CryptoSpecDecrypt>()?),
            StructType::CryptoSpecDeepRecrypt => Ok(from.as_any_box().downcast::<CryptoSpecDeepRecrypt>()?),
            StructType::CryptoSpecEncrypt => Ok(from.as_any_box().downcast::<CryptoSpecEncrypt>()?),
            StructType::CryptoSpecNoOp => Ok(from.as_any_box().downcast::<CryptoSpecNoOp>()?),
            StructType::CryptoSpecRegister => Ok(from.as_any_box().downcast::<CryptoSpecRegister>()?),
            StructType::CryptoSpecShallowRecrypt => Ok(from.as_any_box().downcast::<CryptoSpecShallowRecrypt>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type indicates that the encryption settings of the
/// virtual machine or disk should not be modified by the operation.
pub trait CryptoSpecNoOpTrait : super::traits::CryptoSpecTrait {
}
impl<'s> serde::Serialize for dyn CryptoSpecNoOpTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn CryptoSpecNoOpTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(CryptoSpecNoOpVisitor)
            }
        }

struct CryptoSpecNoOpVisitor;

impl<'de> de::Visitor<'de> for CryptoSpecNoOpVisitor {
    type Value = Box<dyn CryptoSpecNoOpTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid CryptoSpecNoOpTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl CryptoSpecNoOpTrait for CryptoSpecNoOp {
}
impl CryptoSpecNoOpTrait for CryptoSpecRegister {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn CryptoSpecNoOpTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::CryptoSpecNoOp => Some(from.as_any_ref().downcast_ref::<CryptoSpecNoOp>()?),
            StructType::CryptoSpecRegister => Some(from.as_any_ref().downcast_ref::<CryptoSpecRegister>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::CryptoSpecNoOp => Ok(from.as_any_box().downcast::<CryptoSpecNoOp>()?),
            StructType::CryptoSpecRegister => Ok(from.as_any_box().downcast::<CryptoSpecRegister>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This event is the base data object type from which all events inherit.
/// 
/// All event
/// objects are data structures that describe events. While event data objects are data
/// structures that describe events, event data type documentation may describe what the
/// event records, rather than the data structure, itself.
pub trait EventTrait : super::traits::DataObjectTrait {
    /// The event ID.
    fn get_key(&self) -> i32;
    /// The parent or group ID.
    fn get_chain_id(&self) -> i32;
    /// The time the event was created.
    fn get_created_time(&self) -> &str;
    /// The user who caused the event.
    fn get_user_name(&self) -> &str;
    /// The Datacenter object of the event.
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument>;
    /// The ComputeResource object of the event.
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument>;
    /// The Host object of the event.
    fn get_host(&self) -> &Option<HostEventArgument>;
    /// The VirtualMachine object of the event.
    fn get_vm(&self) -> &Option<VmEventArgument>;
    /// The Datastore object of the event.
    fn get_ds(&self) -> &Option<DatastoreEventArgument>;
    /// The Network object of the event.
    fn get_net(&self) -> &Option<NetworkEventArgument>;
    /// The DistributedVirtualSwitch object of the event.
    fn get_dvs(&self) -> &Option<DvsEventArgument>;
    /// A formatted text message describing the event.
    /// 
    /// The message may be localized.
    fn get_full_formatted_message(&self) -> &Option<String>;
    /// The user entered tag to identify the operations and their side effects
    fn get_change_tag(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn EventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn EventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(EventVisitor)
            }
        }

struct EventVisitor;

impl<'de> de::Visitor<'de> for EventVisitor {
    type Value = Box<dyn EventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid EventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl EventTrait for Event {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for AlarmEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for AlarmAcknowledgedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for AlarmActionTriggeredEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for AlarmClearedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for AlarmCreatedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for AlarmEmailCompletedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for AlarmEmailFailedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for AlarmReconfiguredEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for AlarmRemovedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for AlarmScriptCompleteEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for AlarmScriptFailedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for AlarmSnmpCompletedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for AlarmSnmpFailedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for AlarmStatusChangedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for AuthorizationEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for PermissionEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for PermissionAddedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for PermissionRemovedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for PermissionUpdatedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for RoleEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for RoleAddedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for RoleRemovedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for RoleUpdatedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ClusterEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ClusterComplianceCheckedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ClusterCreatedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ClusterDestroyedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ClusterOvercommittedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostOvercommittedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ClusterReconfiguredEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ClusterStatusChangedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostStatusChangedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DasAdmissionControlDisabledEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DasAdmissionControlEnabledEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DasAgentFoundEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DasAgentUnavailableEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DasClusterIsolatedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DasDisabledEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DasEnabledEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DasHostFailedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DasHostIsolatedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DrsDisabledEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DrsEnabledEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DrsInvocationFailedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DrsRecoveredFromFailureEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for FailoverLevelRestored {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostMonitoringStateChangedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for InsufficientFailoverResourcesEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmHealthMonitoringStateChangedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for CustomFieldEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for CustomFieldDefEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for CustomFieldDefAddedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for CustomFieldDefRemovedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for CustomFieldDefRenamedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for CustomFieldValueChangedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvPortgroupEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvPortgroupCreatedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvPortgroupDestroyedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvPortgroupReconfiguredEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvPortgroupRenamedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvpgImportEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvpgRestoreEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DatacenterEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DatacenterCreatedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DatacenterRenamedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DatastoreEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DatastoreCapacityIncreasedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DatastoreDestroyedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DatastoreDuplicatedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DatastoreFileEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DatastoreFileCopiedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DatastoreFileDeletedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DatastoreFileMovedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DatastoreIormReconfiguredEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DatastoreRenamedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for NonViWorkloadDetectedOnDatastoreEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvsEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvsCreatedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvsDestroyedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvsHostBackInSyncEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvsHostJoinedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvsHostLeftEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvsHostStatusUpdated {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvsHostWentOutOfSyncEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvsImportEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvsMergedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvsPortBlockedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvsPortConnectedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvsPortCreatedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvsPortDeletedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvsPortDisconnectedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvsPortEnteredPassthruEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvsPortExitedPassthruEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvsPortJoinPortgroupEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvsPortLeavePortgroupEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvsPortLinkDownEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvsPortLinkUpEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvsPortReconfiguredEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvsPortRuntimeChangeEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvsPortUnblockedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvsPortVendorSpecificStateChangeEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvsReconfiguredEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvsRenamedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvsRestoreEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvsUpgradeAvailableEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvsUpgradeInProgressEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvsUpgradeRejectedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvsUpgradedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostLocalPortCreatedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for OutOfSyncDvsHost {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for RecoveryEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for RollbackEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmVnicPoolReservationViolationClearEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmVnicPoolReservationViolationRaiseEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for EventEx {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for GeneralEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ExtendedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for GeneralHostErrorEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for GeneralHostInfoEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for GeneralHostWarningEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for GeneralUserEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for GeneralVmErrorEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for GeneralVmInfoEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for GeneralVmWarningEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HealthStatusChangedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for AccountCreatedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for AccountRemovedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for AccountUpdatedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for AdminPasswordNotChangedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for CanceledHostOperationEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DatastoreDiscoveredEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DatastorePrincipalConfigured {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DatastoreRemovedOnHostEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DatastoreRenamedOnHostEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DrsResourceConfigureFailedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DrsResourceConfigureSyncedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DuplicateIpDetectedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DvsHealthStatusChangeEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for MtuMatchEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for MtuMismatchEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for TeamingMatchEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for TeamingMisMatchEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for UplinkPortMtuNotSupportEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for UplinkPortMtuSupportEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for UplinkPortVlanTrunkedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for UplinkPortVlanUntrunkedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for EnteredMaintenanceModeEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for EnteredStandbyModeEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DrsEnteredStandbyModeEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for EnteringMaintenanceModeEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for EnteringStandbyModeEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DrsEnteringStandbyModeEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ExitMaintenanceModeEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ExitStandbyModeFailedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DrsExitStandbyModeFailedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ExitedStandbyModeEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DrsExitedStandbyModeEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ExitingStandbyModeEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DrsExitingStandbyModeEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for GhostDvsProxySwitchDetectedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for GhostDvsProxySwitchRemovedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostAddFailedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostAddedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostAdminDisableEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostAdminEnableEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostCnxFailedAccountFailedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostCnxFailedAlreadyManagedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostCnxFailedBadCcagentEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostCnxFailedBadUsernameEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostCnxFailedBadVersionEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostCnxFailedCcagentUpgradeEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostCnxFailedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostCnxFailedNetworkErrorEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostCnxFailedNoAccessEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostCnxFailedNoConnectionEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostCnxFailedNoLicenseEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostCnxFailedNotFoundEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostCnxFailedTimeoutEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostComplianceCheckedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostCompliantEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostConfigAppliedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostConnectedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostConnectionLostEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostDasDisabledEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostDasDisablingEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostDasEnabledEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostDasEnablingEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostDasErrorEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostDasEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostExtraNetworksEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostIsolationIpPingFailedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostMissingNetworksEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostNoAvailableNetworksEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostNoHaEnabledPortGroupsEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostNoRedundantManagementNetworkEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostNotInClusterEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostPrimaryAgentNotShortNameEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostShortNameInconsistentEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostDasOkEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostDisconnectedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostEnableAdminFailedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostGetShortNameFailedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostInAuditModeEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostIpChangedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostIpInconsistentEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostIpToShortNameFailedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostNonCompliantEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostProfileAppliedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostReconnectionFailedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostRemovedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostShortNameToIpFailedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostShutdownEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostSpecificationChangedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostSpecificationRequireEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostSpecificationUpdateEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostSubSpecificationDeleteEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostSubSpecificationUpdateEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostSyncFailedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostUpgradeFailedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostUserWorldSwapNotEnabledEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostVnicConnectedToCustomizedDvPortEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostWwnChangedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostWwnConflictEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for LocalDatastoreCreatedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for LocalTsmEnabledEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for NasDatastoreCreatedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for NoDatastoresConfiguredEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for RemoteTsmEnabledEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for TimedOutHostOperationEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for UpdatedAgentBeingRestartedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for UserAssignedToGroup {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for UserPasswordChanged {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for UserUnassignedFromGroup {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmfsDatastoreCreatedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmfsDatastoreExpandedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmfsDatastoreExtendedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VcAgentUninstallFailedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VcAgentUninstalledEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VcAgentUpgradeFailedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VcAgentUpgradedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VimAccountPasswordChangedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for IScsiBootFailureEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostInventoryUnreadableEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for LicenseEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for AllVirtualMachinesLicensedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostInventoryFullEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for HostLicenseExpiredEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for IncorrectHostInformationEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for InvalidEditionEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for LicenseNonComplianceEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for LicenseRestrictedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for LicenseServerAvailableEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for LicenseServerUnavailableEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for NoLicenseEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ServerLicenseExpiredEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for UnlicensedVirtualMachinesEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for UnlicensedVirtualMachinesFoundEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VMotionLicenseExpiredEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for LicenseExpiredEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for LockerMisconfiguredEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for LockerReconfiguredEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for NetworkRollbackEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ProfileEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ProfileAssociatedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ProfileChangedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ProfileCreatedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ProfileDissociatedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ProfileReferenceHostChangedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ProfileRemovedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ResourcePoolEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ResourcePoolCreatedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ResourcePoolDestroyedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ResourcePoolMovedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ResourcePoolReconfiguredEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ResourceViolatedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ScheduledTaskEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ScheduledTaskCompletedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ScheduledTaskCreatedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ScheduledTaskEmailCompletedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ScheduledTaskEmailFailedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ScheduledTaskFailedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ScheduledTaskReconfiguredEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ScheduledTaskRemovedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ScheduledTaskStartedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for SessionEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for AlreadyAuthenticatedSessionEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for BadUsernameSessionEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for GlobalMessageChangedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for NoAccessUserEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ServerStartedSessionEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for SessionTerminatedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for UserLoginSessionEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for UserLogoutSessionEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for TaskEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for TaskTimeoutEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for TemplateUpgradeEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for TemplateBeingUpgradedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for TemplateUpgradeFailedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for TemplateUpgradedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for UpgradeEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for ErrorUpgradeEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for InfoUpgradeEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for UserUpgradeEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for WarningUpgradeEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for CustomizationEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for CustomizationFailed {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for CustomizationLinuxIdentityFailed {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for CustomizationNetworkSetupFailed {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for CustomizationSysprepFailed {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for CustomizationUnknownFailure {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for CustomizationStartedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for CustomizationSucceeded {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DrsRuleComplianceEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DrsRuleViolationEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DrsSoftRuleViolationEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for MigrationEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for MigrationErrorEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for MigrationHostErrorEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for MigrationHostWarningEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for MigrationResourceErrorEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for MigrationResourceWarningEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for MigrationWarningEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for NoMaintenanceModeDrsRecommendationForVm {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for NotEnoughResourcesToStartVmEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmAcquiredMksTicketEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmAcquiredTicketEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmAutoRenameEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmBeingCreatedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmBeingDeployedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmBeingHotMigratedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmBeingMigratedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmCloneEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmBeingClonedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmBeingClonedNoFolderEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmCloneFailedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmClonedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmConfigMissingEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmConnectedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmCreatedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmDasBeingResetEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmDasBeingResetWithScreenshotEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmDasResetFailedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmDasUpdateErrorEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmDasUpdateOkEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmDateRolledBackEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmDeployFailedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmDeployedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmDisconnectedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmDiscoveredEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmDiskFailedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmEmigratingEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmEndRecordingEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmEndReplayingEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmFailedMigrateEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmFailedRelayoutEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmFailedRelayoutOnVmfs2DatastoreEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmFailedStartingSecondaryEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmFailedToPowerOffEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmFailedToPowerOnEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmFailedToRebootGuestEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmFailedToResetEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmFailedToShutdownGuestEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmFailedToStandbyGuestEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmFailedToSuspendEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmFailedUpdatingSecondaryConfig {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmFailoverFailed {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmFaultToleranceStateChangedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmFaultToleranceTurnedOffEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmFaultToleranceVmTerminatedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmGuestOsCrashedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmGuestRebootEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmGuestShutdownEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmGuestStandbyEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmInstanceUuidAssignedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmInstanceUuidChangedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmInstanceUuidConflictEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmMacAssignedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmMacChangedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmMacConflictEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmMaxFtRestartCountReached {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmMaxRestartCountReached {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmMessageErrorEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmMessageEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmMessageWarningEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmMigratedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DrsVmMigratedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmNoCompatibleHostForSecondaryEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmNoNetworkAccessEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmOrphanedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmPoweredOffEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmPowerOffOnIsolationEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmShutdownOnIsolationEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmPoweredOnEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for DrsVmPoweredOnEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmRestartedOnAlternateHostEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmPoweringOnWithCustomizedDvPortEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmPrimaryFailoverEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmReconfiguredEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmRegisteredEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmRelayoutSuccessfulEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmRelayoutUpToDateEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmReloadFromPathEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmReloadFromPathFailedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmRelocateSpecEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmBeingRelocatedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmRelocateFailedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmRelocatedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmRemoteConsoleConnectedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmRemoteConsoleDisconnectedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmRemovedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmRenamedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmRequirementsExceedCurrentEvcModeEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmResettingEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmResourcePoolMovedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmResourceReallocatedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmResumingEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmSecondaryAddedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmSecondaryDisabledBySystemEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmSecondaryDisabledEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmSecondaryEnabledEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmSecondaryStartedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmStartRecordingEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmStartReplayingEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmStartingEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmUnsupportedStartingEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmStartingSecondaryEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmStaticMacConflictEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmStoppingEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmSuspendedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmSuspendingEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmTimedoutStartingSecondaryEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmUpgradeCompleteEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmUpgradeFailedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmUpgradingEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmUuidAssignedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmUuidChangedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmUuidConflictEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmWwnAssignedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmWwnChangedEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl EventTrait for VmWwnConflictEvent {
    fn get_key(&self) -> i32 { self.key }
    fn get_chain_id(&self) -> i32 { self.chain_id }
    fn get_created_time(&self) -> &str { &self.created_time }
    fn get_user_name(&self) -> &str { &self.user_name }
    fn get_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.datacenter }
    fn get_compute_resource(&self) -> &Option<ComputeResourceEventArgument> { &self.compute_resource }
    fn get_host(&self) -> &Option<HostEventArgument> { &self.host }
    fn get_vm(&self) -> &Option<VmEventArgument> { &self.vm }
    fn get_ds(&self) -> &Option<DatastoreEventArgument> { &self.ds }
    fn get_net(&self) -> &Option<NetworkEventArgument> { &self.net }
    fn get_dvs(&self) -> &Option<DvsEventArgument> { &self.dvs }
    fn get_full_formatted_message(&self) -> &Option<String> { &self.full_formatted_message }
    fn get_change_tag(&self) -> &Option<String> { &self.change_tag }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn EventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::Event => Some(from.as_any_ref().downcast_ref::<Event>()?),
            StructType::AlarmEvent => Some(from.as_any_ref().downcast_ref::<AlarmEvent>()?),
            StructType::AlarmAcknowledgedEvent => Some(from.as_any_ref().downcast_ref::<AlarmAcknowledgedEvent>()?),
            StructType::AlarmActionTriggeredEvent => Some(from.as_any_ref().downcast_ref::<AlarmActionTriggeredEvent>()?),
            StructType::AlarmClearedEvent => Some(from.as_any_ref().downcast_ref::<AlarmClearedEvent>()?),
            StructType::AlarmCreatedEvent => Some(from.as_any_ref().downcast_ref::<AlarmCreatedEvent>()?),
            StructType::AlarmEmailCompletedEvent => Some(from.as_any_ref().downcast_ref::<AlarmEmailCompletedEvent>()?),
            StructType::AlarmEmailFailedEvent => Some(from.as_any_ref().downcast_ref::<AlarmEmailFailedEvent>()?),
            StructType::AlarmReconfiguredEvent => Some(from.as_any_ref().downcast_ref::<AlarmReconfiguredEvent>()?),
            StructType::AlarmRemovedEvent => Some(from.as_any_ref().downcast_ref::<AlarmRemovedEvent>()?),
            StructType::AlarmScriptCompleteEvent => Some(from.as_any_ref().downcast_ref::<AlarmScriptCompleteEvent>()?),
            StructType::AlarmScriptFailedEvent => Some(from.as_any_ref().downcast_ref::<AlarmScriptFailedEvent>()?),
            StructType::AlarmSnmpCompletedEvent => Some(from.as_any_ref().downcast_ref::<AlarmSnmpCompletedEvent>()?),
            StructType::AlarmSnmpFailedEvent => Some(from.as_any_ref().downcast_ref::<AlarmSnmpFailedEvent>()?),
            StructType::AlarmStatusChangedEvent => Some(from.as_any_ref().downcast_ref::<AlarmStatusChangedEvent>()?),
            StructType::AuthorizationEvent => Some(from.as_any_ref().downcast_ref::<AuthorizationEvent>()?),
            StructType::PermissionEvent => Some(from.as_any_ref().downcast_ref::<PermissionEvent>()?),
            StructType::PermissionAddedEvent => Some(from.as_any_ref().downcast_ref::<PermissionAddedEvent>()?),
            StructType::PermissionRemovedEvent => Some(from.as_any_ref().downcast_ref::<PermissionRemovedEvent>()?),
            StructType::PermissionUpdatedEvent => Some(from.as_any_ref().downcast_ref::<PermissionUpdatedEvent>()?),
            StructType::RoleEvent => Some(from.as_any_ref().downcast_ref::<RoleEvent>()?),
            StructType::RoleAddedEvent => Some(from.as_any_ref().downcast_ref::<RoleAddedEvent>()?),
            StructType::RoleRemovedEvent => Some(from.as_any_ref().downcast_ref::<RoleRemovedEvent>()?),
            StructType::RoleUpdatedEvent => Some(from.as_any_ref().downcast_ref::<RoleUpdatedEvent>()?),
            StructType::ClusterEvent => Some(from.as_any_ref().downcast_ref::<ClusterEvent>()?),
            StructType::ClusterComplianceCheckedEvent => Some(from.as_any_ref().downcast_ref::<ClusterComplianceCheckedEvent>()?),
            StructType::ClusterCreatedEvent => Some(from.as_any_ref().downcast_ref::<ClusterCreatedEvent>()?),
            StructType::ClusterDestroyedEvent => Some(from.as_any_ref().downcast_ref::<ClusterDestroyedEvent>()?),
            StructType::ClusterOvercommittedEvent => Some(from.as_any_ref().downcast_ref::<ClusterOvercommittedEvent>()?),
            StructType::HostOvercommittedEvent => Some(from.as_any_ref().downcast_ref::<HostOvercommittedEvent>()?),
            StructType::ClusterReconfiguredEvent => Some(from.as_any_ref().downcast_ref::<ClusterReconfiguredEvent>()?),
            StructType::ClusterStatusChangedEvent => Some(from.as_any_ref().downcast_ref::<ClusterStatusChangedEvent>()?),
            StructType::HostStatusChangedEvent => Some(from.as_any_ref().downcast_ref::<HostStatusChangedEvent>()?),
            StructType::DasAdmissionControlDisabledEvent => Some(from.as_any_ref().downcast_ref::<DasAdmissionControlDisabledEvent>()?),
            StructType::DasAdmissionControlEnabledEvent => Some(from.as_any_ref().downcast_ref::<DasAdmissionControlEnabledEvent>()?),
            StructType::DasAgentFoundEvent => Some(from.as_any_ref().downcast_ref::<DasAgentFoundEvent>()?),
            StructType::DasAgentUnavailableEvent => Some(from.as_any_ref().downcast_ref::<DasAgentUnavailableEvent>()?),
            StructType::DasClusterIsolatedEvent => Some(from.as_any_ref().downcast_ref::<DasClusterIsolatedEvent>()?),
            StructType::DasDisabledEvent => Some(from.as_any_ref().downcast_ref::<DasDisabledEvent>()?),
            StructType::DasEnabledEvent => Some(from.as_any_ref().downcast_ref::<DasEnabledEvent>()?),
            StructType::DasHostFailedEvent => Some(from.as_any_ref().downcast_ref::<DasHostFailedEvent>()?),
            StructType::DasHostIsolatedEvent => Some(from.as_any_ref().downcast_ref::<DasHostIsolatedEvent>()?),
            StructType::DrsDisabledEvent => Some(from.as_any_ref().downcast_ref::<DrsDisabledEvent>()?),
            StructType::DrsEnabledEvent => Some(from.as_any_ref().downcast_ref::<DrsEnabledEvent>()?),
            StructType::DrsInvocationFailedEvent => Some(from.as_any_ref().downcast_ref::<DrsInvocationFailedEvent>()?),
            StructType::DrsRecoveredFromFailureEvent => Some(from.as_any_ref().downcast_ref::<DrsRecoveredFromFailureEvent>()?),
            StructType::FailoverLevelRestored => Some(from.as_any_ref().downcast_ref::<FailoverLevelRestored>()?),
            StructType::HostMonitoringStateChangedEvent => Some(from.as_any_ref().downcast_ref::<HostMonitoringStateChangedEvent>()?),
            StructType::InsufficientFailoverResourcesEvent => Some(from.as_any_ref().downcast_ref::<InsufficientFailoverResourcesEvent>()?),
            StructType::VmHealthMonitoringStateChangedEvent => Some(from.as_any_ref().downcast_ref::<VmHealthMonitoringStateChangedEvent>()?),
            StructType::CustomFieldEvent => Some(from.as_any_ref().downcast_ref::<CustomFieldEvent>()?),
            StructType::CustomFieldDefEvent => Some(from.as_any_ref().downcast_ref::<CustomFieldDefEvent>()?),
            StructType::CustomFieldDefAddedEvent => Some(from.as_any_ref().downcast_ref::<CustomFieldDefAddedEvent>()?),
            StructType::CustomFieldDefRemovedEvent => Some(from.as_any_ref().downcast_ref::<CustomFieldDefRemovedEvent>()?),
            StructType::CustomFieldDefRenamedEvent => Some(from.as_any_ref().downcast_ref::<CustomFieldDefRenamedEvent>()?),
            StructType::CustomFieldValueChangedEvent => Some(from.as_any_ref().downcast_ref::<CustomFieldValueChangedEvent>()?),
            StructType::DvPortgroupEvent => Some(from.as_any_ref().downcast_ref::<DvPortgroupEvent>()?),
            StructType::DvPortgroupCreatedEvent => Some(from.as_any_ref().downcast_ref::<DvPortgroupCreatedEvent>()?),
            StructType::DvPortgroupDestroyedEvent => Some(from.as_any_ref().downcast_ref::<DvPortgroupDestroyedEvent>()?),
            StructType::DvPortgroupReconfiguredEvent => Some(from.as_any_ref().downcast_ref::<DvPortgroupReconfiguredEvent>()?),
            StructType::DvPortgroupRenamedEvent => Some(from.as_any_ref().downcast_ref::<DvPortgroupRenamedEvent>()?),
            StructType::DvpgImportEvent => Some(from.as_any_ref().downcast_ref::<DvpgImportEvent>()?),
            StructType::DvpgRestoreEvent => Some(from.as_any_ref().downcast_ref::<DvpgRestoreEvent>()?),
            StructType::DatacenterEvent => Some(from.as_any_ref().downcast_ref::<DatacenterEvent>()?),
            StructType::DatacenterCreatedEvent => Some(from.as_any_ref().downcast_ref::<DatacenterCreatedEvent>()?),
            StructType::DatacenterRenamedEvent => Some(from.as_any_ref().downcast_ref::<DatacenterRenamedEvent>()?),
            StructType::DatastoreEvent => Some(from.as_any_ref().downcast_ref::<DatastoreEvent>()?),
            StructType::DatastoreCapacityIncreasedEvent => Some(from.as_any_ref().downcast_ref::<DatastoreCapacityIncreasedEvent>()?),
            StructType::DatastoreDestroyedEvent => Some(from.as_any_ref().downcast_ref::<DatastoreDestroyedEvent>()?),
            StructType::DatastoreDuplicatedEvent => Some(from.as_any_ref().downcast_ref::<DatastoreDuplicatedEvent>()?),
            StructType::DatastoreFileEvent => Some(from.as_any_ref().downcast_ref::<DatastoreFileEvent>()?),
            StructType::DatastoreFileCopiedEvent => Some(from.as_any_ref().downcast_ref::<DatastoreFileCopiedEvent>()?),
            StructType::DatastoreFileDeletedEvent => Some(from.as_any_ref().downcast_ref::<DatastoreFileDeletedEvent>()?),
            StructType::DatastoreFileMovedEvent => Some(from.as_any_ref().downcast_ref::<DatastoreFileMovedEvent>()?),
            StructType::DatastoreIormReconfiguredEvent => Some(from.as_any_ref().downcast_ref::<DatastoreIormReconfiguredEvent>()?),
            StructType::DatastoreRenamedEvent => Some(from.as_any_ref().downcast_ref::<DatastoreRenamedEvent>()?),
            StructType::NonViWorkloadDetectedOnDatastoreEvent => Some(from.as_any_ref().downcast_ref::<NonViWorkloadDetectedOnDatastoreEvent>()?),
            StructType::DvsEvent => Some(from.as_any_ref().downcast_ref::<DvsEvent>()?),
            StructType::DvsCreatedEvent => Some(from.as_any_ref().downcast_ref::<DvsCreatedEvent>()?),
            StructType::DvsDestroyedEvent => Some(from.as_any_ref().downcast_ref::<DvsDestroyedEvent>()?),
            StructType::DvsHostBackInSyncEvent => Some(from.as_any_ref().downcast_ref::<DvsHostBackInSyncEvent>()?),
            StructType::DvsHostJoinedEvent => Some(from.as_any_ref().downcast_ref::<DvsHostJoinedEvent>()?),
            StructType::DvsHostLeftEvent => Some(from.as_any_ref().downcast_ref::<DvsHostLeftEvent>()?),
            StructType::DvsHostStatusUpdated => Some(from.as_any_ref().downcast_ref::<DvsHostStatusUpdated>()?),
            StructType::DvsHostWentOutOfSyncEvent => Some(from.as_any_ref().downcast_ref::<DvsHostWentOutOfSyncEvent>()?),
            StructType::DvsImportEvent => Some(from.as_any_ref().downcast_ref::<DvsImportEvent>()?),
            StructType::DvsMergedEvent => Some(from.as_any_ref().downcast_ref::<DvsMergedEvent>()?),
            StructType::DvsPortBlockedEvent => Some(from.as_any_ref().downcast_ref::<DvsPortBlockedEvent>()?),
            StructType::DvsPortConnectedEvent => Some(from.as_any_ref().downcast_ref::<DvsPortConnectedEvent>()?),
            StructType::DvsPortCreatedEvent => Some(from.as_any_ref().downcast_ref::<DvsPortCreatedEvent>()?),
            StructType::DvsPortDeletedEvent => Some(from.as_any_ref().downcast_ref::<DvsPortDeletedEvent>()?),
            StructType::DvsPortDisconnectedEvent => Some(from.as_any_ref().downcast_ref::<DvsPortDisconnectedEvent>()?),
            StructType::DvsPortEnteredPassthruEvent => Some(from.as_any_ref().downcast_ref::<DvsPortEnteredPassthruEvent>()?),
            StructType::DvsPortExitedPassthruEvent => Some(from.as_any_ref().downcast_ref::<DvsPortExitedPassthruEvent>()?),
            StructType::DvsPortJoinPortgroupEvent => Some(from.as_any_ref().downcast_ref::<DvsPortJoinPortgroupEvent>()?),
            StructType::DvsPortLeavePortgroupEvent => Some(from.as_any_ref().downcast_ref::<DvsPortLeavePortgroupEvent>()?),
            StructType::DvsPortLinkDownEvent => Some(from.as_any_ref().downcast_ref::<DvsPortLinkDownEvent>()?),
            StructType::DvsPortLinkUpEvent => Some(from.as_any_ref().downcast_ref::<DvsPortLinkUpEvent>()?),
            StructType::DvsPortReconfiguredEvent => Some(from.as_any_ref().downcast_ref::<DvsPortReconfiguredEvent>()?),
            StructType::DvsPortRuntimeChangeEvent => Some(from.as_any_ref().downcast_ref::<DvsPortRuntimeChangeEvent>()?),
            StructType::DvsPortUnblockedEvent => Some(from.as_any_ref().downcast_ref::<DvsPortUnblockedEvent>()?),
            StructType::DvsPortVendorSpecificStateChangeEvent => Some(from.as_any_ref().downcast_ref::<DvsPortVendorSpecificStateChangeEvent>()?),
            StructType::DvsReconfiguredEvent => Some(from.as_any_ref().downcast_ref::<DvsReconfiguredEvent>()?),
            StructType::DvsRenamedEvent => Some(from.as_any_ref().downcast_ref::<DvsRenamedEvent>()?),
            StructType::DvsRestoreEvent => Some(from.as_any_ref().downcast_ref::<DvsRestoreEvent>()?),
            StructType::DvsUpgradeAvailableEvent => Some(from.as_any_ref().downcast_ref::<DvsUpgradeAvailableEvent>()?),
            StructType::DvsUpgradeInProgressEvent => Some(from.as_any_ref().downcast_ref::<DvsUpgradeInProgressEvent>()?),
            StructType::DvsUpgradeRejectedEvent => Some(from.as_any_ref().downcast_ref::<DvsUpgradeRejectedEvent>()?),
            StructType::DvsUpgradedEvent => Some(from.as_any_ref().downcast_ref::<DvsUpgradedEvent>()?),
            StructType::HostLocalPortCreatedEvent => Some(from.as_any_ref().downcast_ref::<HostLocalPortCreatedEvent>()?),
            StructType::OutOfSyncDvsHost => Some(from.as_any_ref().downcast_ref::<OutOfSyncDvsHost>()?),
            StructType::RecoveryEvent => Some(from.as_any_ref().downcast_ref::<RecoveryEvent>()?),
            StructType::RollbackEvent => Some(from.as_any_ref().downcast_ref::<RollbackEvent>()?),
            StructType::VmVnicPoolReservationViolationClearEvent => Some(from.as_any_ref().downcast_ref::<VmVnicPoolReservationViolationClearEvent>()?),
            StructType::VmVnicPoolReservationViolationRaiseEvent => Some(from.as_any_ref().downcast_ref::<VmVnicPoolReservationViolationRaiseEvent>()?),
            StructType::EventEx => Some(from.as_any_ref().downcast_ref::<EventEx>()?),
            StructType::GeneralEvent => Some(from.as_any_ref().downcast_ref::<GeneralEvent>()?),
            StructType::ExtendedEvent => Some(from.as_any_ref().downcast_ref::<ExtendedEvent>()?),
            StructType::GeneralHostErrorEvent => Some(from.as_any_ref().downcast_ref::<GeneralHostErrorEvent>()?),
            StructType::GeneralHostInfoEvent => Some(from.as_any_ref().downcast_ref::<GeneralHostInfoEvent>()?),
            StructType::GeneralHostWarningEvent => Some(from.as_any_ref().downcast_ref::<GeneralHostWarningEvent>()?),
            StructType::GeneralUserEvent => Some(from.as_any_ref().downcast_ref::<GeneralUserEvent>()?),
            StructType::GeneralVmErrorEvent => Some(from.as_any_ref().downcast_ref::<GeneralVmErrorEvent>()?),
            StructType::GeneralVmInfoEvent => Some(from.as_any_ref().downcast_ref::<GeneralVmInfoEvent>()?),
            StructType::GeneralVmWarningEvent => Some(from.as_any_ref().downcast_ref::<GeneralVmWarningEvent>()?),
            StructType::HealthStatusChangedEvent => Some(from.as_any_ref().downcast_ref::<HealthStatusChangedEvent>()?),
            StructType::HostEvent => Some(from.as_any_ref().downcast_ref::<HostEvent>()?),
            StructType::AccountCreatedEvent => Some(from.as_any_ref().downcast_ref::<AccountCreatedEvent>()?),
            StructType::AccountRemovedEvent => Some(from.as_any_ref().downcast_ref::<AccountRemovedEvent>()?),
            StructType::AccountUpdatedEvent => Some(from.as_any_ref().downcast_ref::<AccountUpdatedEvent>()?),
            StructType::AdminPasswordNotChangedEvent => Some(from.as_any_ref().downcast_ref::<AdminPasswordNotChangedEvent>()?),
            StructType::CanceledHostOperationEvent => Some(from.as_any_ref().downcast_ref::<CanceledHostOperationEvent>()?),
            StructType::DatastoreDiscoveredEvent => Some(from.as_any_ref().downcast_ref::<DatastoreDiscoveredEvent>()?),
            StructType::DatastorePrincipalConfigured => Some(from.as_any_ref().downcast_ref::<DatastorePrincipalConfigured>()?),
            StructType::DatastoreRemovedOnHostEvent => Some(from.as_any_ref().downcast_ref::<DatastoreRemovedOnHostEvent>()?),
            StructType::DatastoreRenamedOnHostEvent => Some(from.as_any_ref().downcast_ref::<DatastoreRenamedOnHostEvent>()?),
            StructType::DrsResourceConfigureFailedEvent => Some(from.as_any_ref().downcast_ref::<DrsResourceConfigureFailedEvent>()?),
            StructType::DrsResourceConfigureSyncedEvent => Some(from.as_any_ref().downcast_ref::<DrsResourceConfigureSyncedEvent>()?),
            StructType::DuplicateIpDetectedEvent => Some(from.as_any_ref().downcast_ref::<DuplicateIpDetectedEvent>()?),
            StructType::DvsHealthStatusChangeEvent => Some(from.as_any_ref().downcast_ref::<DvsHealthStatusChangeEvent>()?),
            StructType::MtuMatchEvent => Some(from.as_any_ref().downcast_ref::<MtuMatchEvent>()?),
            StructType::MtuMismatchEvent => Some(from.as_any_ref().downcast_ref::<MtuMismatchEvent>()?),
            StructType::TeamingMatchEvent => Some(from.as_any_ref().downcast_ref::<TeamingMatchEvent>()?),
            StructType::TeamingMisMatchEvent => Some(from.as_any_ref().downcast_ref::<TeamingMisMatchEvent>()?),
            StructType::UplinkPortMtuNotSupportEvent => Some(from.as_any_ref().downcast_ref::<UplinkPortMtuNotSupportEvent>()?),
            StructType::UplinkPortMtuSupportEvent => Some(from.as_any_ref().downcast_ref::<UplinkPortMtuSupportEvent>()?),
            StructType::UplinkPortVlanTrunkedEvent => Some(from.as_any_ref().downcast_ref::<UplinkPortVlanTrunkedEvent>()?),
            StructType::UplinkPortVlanUntrunkedEvent => Some(from.as_any_ref().downcast_ref::<UplinkPortVlanUntrunkedEvent>()?),
            StructType::EnteredMaintenanceModeEvent => Some(from.as_any_ref().downcast_ref::<EnteredMaintenanceModeEvent>()?),
            StructType::EnteredStandbyModeEvent => Some(from.as_any_ref().downcast_ref::<EnteredStandbyModeEvent>()?),
            StructType::DrsEnteredStandbyModeEvent => Some(from.as_any_ref().downcast_ref::<DrsEnteredStandbyModeEvent>()?),
            StructType::EnteringMaintenanceModeEvent => Some(from.as_any_ref().downcast_ref::<EnteringMaintenanceModeEvent>()?),
            StructType::EnteringStandbyModeEvent => Some(from.as_any_ref().downcast_ref::<EnteringStandbyModeEvent>()?),
            StructType::DrsEnteringStandbyModeEvent => Some(from.as_any_ref().downcast_ref::<DrsEnteringStandbyModeEvent>()?),
            StructType::ExitMaintenanceModeEvent => Some(from.as_any_ref().downcast_ref::<ExitMaintenanceModeEvent>()?),
            StructType::ExitStandbyModeFailedEvent => Some(from.as_any_ref().downcast_ref::<ExitStandbyModeFailedEvent>()?),
            StructType::DrsExitStandbyModeFailedEvent => Some(from.as_any_ref().downcast_ref::<DrsExitStandbyModeFailedEvent>()?),
            StructType::ExitedStandbyModeEvent => Some(from.as_any_ref().downcast_ref::<ExitedStandbyModeEvent>()?),
            StructType::DrsExitedStandbyModeEvent => Some(from.as_any_ref().downcast_ref::<DrsExitedStandbyModeEvent>()?),
            StructType::ExitingStandbyModeEvent => Some(from.as_any_ref().downcast_ref::<ExitingStandbyModeEvent>()?),
            StructType::DrsExitingStandbyModeEvent => Some(from.as_any_ref().downcast_ref::<DrsExitingStandbyModeEvent>()?),
            StructType::GhostDvsProxySwitchDetectedEvent => Some(from.as_any_ref().downcast_ref::<GhostDvsProxySwitchDetectedEvent>()?),
            StructType::GhostDvsProxySwitchRemovedEvent => Some(from.as_any_ref().downcast_ref::<GhostDvsProxySwitchRemovedEvent>()?),
            StructType::HostAddFailedEvent => Some(from.as_any_ref().downcast_ref::<HostAddFailedEvent>()?),
            StructType::HostAddedEvent => Some(from.as_any_ref().downcast_ref::<HostAddedEvent>()?),
            StructType::HostAdminDisableEvent => Some(from.as_any_ref().downcast_ref::<HostAdminDisableEvent>()?),
            StructType::HostAdminEnableEvent => Some(from.as_any_ref().downcast_ref::<HostAdminEnableEvent>()?),
            StructType::HostCnxFailedAccountFailedEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedAccountFailedEvent>()?),
            StructType::HostCnxFailedAlreadyManagedEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedAlreadyManagedEvent>()?),
            StructType::HostCnxFailedBadCcagentEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedBadCcagentEvent>()?),
            StructType::HostCnxFailedBadUsernameEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedBadUsernameEvent>()?),
            StructType::HostCnxFailedBadVersionEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedBadVersionEvent>()?),
            StructType::HostCnxFailedCcagentUpgradeEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedCcagentUpgradeEvent>()?),
            StructType::HostCnxFailedEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedEvent>()?),
            StructType::HostCnxFailedNetworkErrorEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedNetworkErrorEvent>()?),
            StructType::HostCnxFailedNoAccessEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedNoAccessEvent>()?),
            StructType::HostCnxFailedNoConnectionEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedNoConnectionEvent>()?),
            StructType::HostCnxFailedNoLicenseEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedNoLicenseEvent>()?),
            StructType::HostCnxFailedNotFoundEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedNotFoundEvent>()?),
            StructType::HostCnxFailedTimeoutEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedTimeoutEvent>()?),
            StructType::HostComplianceCheckedEvent => Some(from.as_any_ref().downcast_ref::<HostComplianceCheckedEvent>()?),
            StructType::HostCompliantEvent => Some(from.as_any_ref().downcast_ref::<HostCompliantEvent>()?),
            StructType::HostConfigAppliedEvent => Some(from.as_any_ref().downcast_ref::<HostConfigAppliedEvent>()?),
            StructType::HostConnectedEvent => Some(from.as_any_ref().downcast_ref::<HostConnectedEvent>()?),
            StructType::HostConnectionLostEvent => Some(from.as_any_ref().downcast_ref::<HostConnectionLostEvent>()?),
            StructType::HostDasDisabledEvent => Some(from.as_any_ref().downcast_ref::<HostDasDisabledEvent>()?),
            StructType::HostDasDisablingEvent => Some(from.as_any_ref().downcast_ref::<HostDasDisablingEvent>()?),
            StructType::HostDasEnabledEvent => Some(from.as_any_ref().downcast_ref::<HostDasEnabledEvent>()?),
            StructType::HostDasEnablingEvent => Some(from.as_any_ref().downcast_ref::<HostDasEnablingEvent>()?),
            StructType::HostDasErrorEvent => Some(from.as_any_ref().downcast_ref::<HostDasErrorEvent>()?),
            StructType::HostDasEvent => Some(from.as_any_ref().downcast_ref::<HostDasEvent>()?),
            StructType::HostExtraNetworksEvent => Some(from.as_any_ref().downcast_ref::<HostExtraNetworksEvent>()?),
            StructType::HostIsolationIpPingFailedEvent => Some(from.as_any_ref().downcast_ref::<HostIsolationIpPingFailedEvent>()?),
            StructType::HostMissingNetworksEvent => Some(from.as_any_ref().downcast_ref::<HostMissingNetworksEvent>()?),
            StructType::HostNoAvailableNetworksEvent => Some(from.as_any_ref().downcast_ref::<HostNoAvailableNetworksEvent>()?),
            StructType::HostNoHaEnabledPortGroupsEvent => Some(from.as_any_ref().downcast_ref::<HostNoHaEnabledPortGroupsEvent>()?),
            StructType::HostNoRedundantManagementNetworkEvent => Some(from.as_any_ref().downcast_ref::<HostNoRedundantManagementNetworkEvent>()?),
            StructType::HostNotInClusterEvent => Some(from.as_any_ref().downcast_ref::<HostNotInClusterEvent>()?),
            StructType::HostPrimaryAgentNotShortNameEvent => Some(from.as_any_ref().downcast_ref::<HostPrimaryAgentNotShortNameEvent>()?),
            StructType::HostShortNameInconsistentEvent => Some(from.as_any_ref().downcast_ref::<HostShortNameInconsistentEvent>()?),
            StructType::HostDasOkEvent => Some(from.as_any_ref().downcast_ref::<HostDasOkEvent>()?),
            StructType::HostDisconnectedEvent => Some(from.as_any_ref().downcast_ref::<HostDisconnectedEvent>()?),
            StructType::HostEnableAdminFailedEvent => Some(from.as_any_ref().downcast_ref::<HostEnableAdminFailedEvent>()?),
            StructType::HostGetShortNameFailedEvent => Some(from.as_any_ref().downcast_ref::<HostGetShortNameFailedEvent>()?),
            StructType::HostInAuditModeEvent => Some(from.as_any_ref().downcast_ref::<HostInAuditModeEvent>()?),
            StructType::HostIpChangedEvent => Some(from.as_any_ref().downcast_ref::<HostIpChangedEvent>()?),
            StructType::HostIpInconsistentEvent => Some(from.as_any_ref().downcast_ref::<HostIpInconsistentEvent>()?),
            StructType::HostIpToShortNameFailedEvent => Some(from.as_any_ref().downcast_ref::<HostIpToShortNameFailedEvent>()?),
            StructType::HostNonCompliantEvent => Some(from.as_any_ref().downcast_ref::<HostNonCompliantEvent>()?),
            StructType::HostProfileAppliedEvent => Some(from.as_any_ref().downcast_ref::<HostProfileAppliedEvent>()?),
            StructType::HostReconnectionFailedEvent => Some(from.as_any_ref().downcast_ref::<HostReconnectionFailedEvent>()?),
            StructType::HostRemovedEvent => Some(from.as_any_ref().downcast_ref::<HostRemovedEvent>()?),
            StructType::HostShortNameToIpFailedEvent => Some(from.as_any_ref().downcast_ref::<HostShortNameToIpFailedEvent>()?),
            StructType::HostShutdownEvent => Some(from.as_any_ref().downcast_ref::<HostShutdownEvent>()?),
            StructType::HostSpecificationChangedEvent => Some(from.as_any_ref().downcast_ref::<HostSpecificationChangedEvent>()?),
            StructType::HostSpecificationRequireEvent => Some(from.as_any_ref().downcast_ref::<HostSpecificationRequireEvent>()?),
            StructType::HostSpecificationUpdateEvent => Some(from.as_any_ref().downcast_ref::<HostSpecificationUpdateEvent>()?),
            StructType::HostSubSpecificationDeleteEvent => Some(from.as_any_ref().downcast_ref::<HostSubSpecificationDeleteEvent>()?),
            StructType::HostSubSpecificationUpdateEvent => Some(from.as_any_ref().downcast_ref::<HostSubSpecificationUpdateEvent>()?),
            StructType::HostSyncFailedEvent => Some(from.as_any_ref().downcast_ref::<HostSyncFailedEvent>()?),
            StructType::HostUpgradeFailedEvent => Some(from.as_any_ref().downcast_ref::<HostUpgradeFailedEvent>()?),
            StructType::HostUserWorldSwapNotEnabledEvent => Some(from.as_any_ref().downcast_ref::<HostUserWorldSwapNotEnabledEvent>()?),
            StructType::HostVnicConnectedToCustomizedDvPortEvent => Some(from.as_any_ref().downcast_ref::<HostVnicConnectedToCustomizedDvPortEvent>()?),
            StructType::HostWwnChangedEvent => Some(from.as_any_ref().downcast_ref::<HostWwnChangedEvent>()?),
            StructType::HostWwnConflictEvent => Some(from.as_any_ref().downcast_ref::<HostWwnConflictEvent>()?),
            StructType::LocalDatastoreCreatedEvent => Some(from.as_any_ref().downcast_ref::<LocalDatastoreCreatedEvent>()?),
            StructType::LocalTsmEnabledEvent => Some(from.as_any_ref().downcast_ref::<LocalTsmEnabledEvent>()?),
            StructType::NasDatastoreCreatedEvent => Some(from.as_any_ref().downcast_ref::<NasDatastoreCreatedEvent>()?),
            StructType::NoDatastoresConfiguredEvent => Some(from.as_any_ref().downcast_ref::<NoDatastoresConfiguredEvent>()?),
            StructType::RemoteTsmEnabledEvent => Some(from.as_any_ref().downcast_ref::<RemoteTsmEnabledEvent>()?),
            StructType::TimedOutHostOperationEvent => Some(from.as_any_ref().downcast_ref::<TimedOutHostOperationEvent>()?),
            StructType::UpdatedAgentBeingRestartedEvent => Some(from.as_any_ref().downcast_ref::<UpdatedAgentBeingRestartedEvent>()?),
            StructType::UserAssignedToGroup => Some(from.as_any_ref().downcast_ref::<UserAssignedToGroup>()?),
            StructType::UserPasswordChanged => Some(from.as_any_ref().downcast_ref::<UserPasswordChanged>()?),
            StructType::UserUnassignedFromGroup => Some(from.as_any_ref().downcast_ref::<UserUnassignedFromGroup>()?),
            StructType::VmfsDatastoreCreatedEvent => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreCreatedEvent>()?),
            StructType::VmfsDatastoreExpandedEvent => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreExpandedEvent>()?),
            StructType::VmfsDatastoreExtendedEvent => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreExtendedEvent>()?),
            StructType::VcAgentUninstallFailedEvent => Some(from.as_any_ref().downcast_ref::<VcAgentUninstallFailedEvent>()?),
            StructType::VcAgentUninstalledEvent => Some(from.as_any_ref().downcast_ref::<VcAgentUninstalledEvent>()?),
            StructType::VcAgentUpgradeFailedEvent => Some(from.as_any_ref().downcast_ref::<VcAgentUpgradeFailedEvent>()?),
            StructType::VcAgentUpgradedEvent => Some(from.as_any_ref().downcast_ref::<VcAgentUpgradedEvent>()?),
            StructType::VimAccountPasswordChangedEvent => Some(from.as_any_ref().downcast_ref::<VimAccountPasswordChangedEvent>()?),
            StructType::IScsiBootFailureEvent => Some(from.as_any_ref().downcast_ref::<IScsiBootFailureEvent>()?),
            StructType::HostInventoryUnreadableEvent => Some(from.as_any_ref().downcast_ref::<HostInventoryUnreadableEvent>()?),
            StructType::LicenseEvent => Some(from.as_any_ref().downcast_ref::<LicenseEvent>()?),
            StructType::AllVirtualMachinesLicensedEvent => Some(from.as_any_ref().downcast_ref::<AllVirtualMachinesLicensedEvent>()?),
            StructType::HostInventoryFullEvent => Some(from.as_any_ref().downcast_ref::<HostInventoryFullEvent>()?),
            StructType::HostLicenseExpiredEvent => Some(from.as_any_ref().downcast_ref::<HostLicenseExpiredEvent>()?),
            StructType::IncorrectHostInformationEvent => Some(from.as_any_ref().downcast_ref::<IncorrectHostInformationEvent>()?),
            StructType::InvalidEditionEvent => Some(from.as_any_ref().downcast_ref::<InvalidEditionEvent>()?),
            StructType::LicenseNonComplianceEvent => Some(from.as_any_ref().downcast_ref::<LicenseNonComplianceEvent>()?),
            StructType::LicenseRestrictedEvent => Some(from.as_any_ref().downcast_ref::<LicenseRestrictedEvent>()?),
            StructType::LicenseServerAvailableEvent => Some(from.as_any_ref().downcast_ref::<LicenseServerAvailableEvent>()?),
            StructType::LicenseServerUnavailableEvent => Some(from.as_any_ref().downcast_ref::<LicenseServerUnavailableEvent>()?),
            StructType::NoLicenseEvent => Some(from.as_any_ref().downcast_ref::<NoLicenseEvent>()?),
            StructType::ServerLicenseExpiredEvent => Some(from.as_any_ref().downcast_ref::<ServerLicenseExpiredEvent>()?),
            StructType::UnlicensedVirtualMachinesEvent => Some(from.as_any_ref().downcast_ref::<UnlicensedVirtualMachinesEvent>()?),
            StructType::UnlicensedVirtualMachinesFoundEvent => Some(from.as_any_ref().downcast_ref::<UnlicensedVirtualMachinesFoundEvent>()?),
            StructType::VMotionLicenseExpiredEvent => Some(from.as_any_ref().downcast_ref::<VMotionLicenseExpiredEvent>()?),
            StructType::LicenseExpiredEvent => Some(from.as_any_ref().downcast_ref::<LicenseExpiredEvent>()?),
            StructType::LockerMisconfiguredEvent => Some(from.as_any_ref().downcast_ref::<LockerMisconfiguredEvent>()?),
            StructType::LockerReconfiguredEvent => Some(from.as_any_ref().downcast_ref::<LockerReconfiguredEvent>()?),
            StructType::NetworkRollbackEvent => Some(from.as_any_ref().downcast_ref::<NetworkRollbackEvent>()?),
            StructType::ProfileEvent => Some(from.as_any_ref().downcast_ref::<ProfileEvent>()?),
            StructType::ProfileAssociatedEvent => Some(from.as_any_ref().downcast_ref::<ProfileAssociatedEvent>()?),
            StructType::ProfileChangedEvent => Some(from.as_any_ref().downcast_ref::<ProfileChangedEvent>()?),
            StructType::ProfileCreatedEvent => Some(from.as_any_ref().downcast_ref::<ProfileCreatedEvent>()?),
            StructType::ProfileDissociatedEvent => Some(from.as_any_ref().downcast_ref::<ProfileDissociatedEvent>()?),
            StructType::ProfileReferenceHostChangedEvent => Some(from.as_any_ref().downcast_ref::<ProfileReferenceHostChangedEvent>()?),
            StructType::ProfileRemovedEvent => Some(from.as_any_ref().downcast_ref::<ProfileRemovedEvent>()?),
            StructType::ResourcePoolEvent => Some(from.as_any_ref().downcast_ref::<ResourcePoolEvent>()?),
            StructType::ResourcePoolCreatedEvent => Some(from.as_any_ref().downcast_ref::<ResourcePoolCreatedEvent>()?),
            StructType::ResourcePoolDestroyedEvent => Some(from.as_any_ref().downcast_ref::<ResourcePoolDestroyedEvent>()?),
            StructType::ResourcePoolMovedEvent => Some(from.as_any_ref().downcast_ref::<ResourcePoolMovedEvent>()?),
            StructType::ResourcePoolReconfiguredEvent => Some(from.as_any_ref().downcast_ref::<ResourcePoolReconfiguredEvent>()?),
            StructType::ResourceViolatedEvent => Some(from.as_any_ref().downcast_ref::<ResourceViolatedEvent>()?),
            StructType::ScheduledTaskEvent => Some(from.as_any_ref().downcast_ref::<ScheduledTaskEvent>()?),
            StructType::ScheduledTaskCompletedEvent => Some(from.as_any_ref().downcast_ref::<ScheduledTaskCompletedEvent>()?),
            StructType::ScheduledTaskCreatedEvent => Some(from.as_any_ref().downcast_ref::<ScheduledTaskCreatedEvent>()?),
            StructType::ScheduledTaskEmailCompletedEvent => Some(from.as_any_ref().downcast_ref::<ScheduledTaskEmailCompletedEvent>()?),
            StructType::ScheduledTaskEmailFailedEvent => Some(from.as_any_ref().downcast_ref::<ScheduledTaskEmailFailedEvent>()?),
            StructType::ScheduledTaskFailedEvent => Some(from.as_any_ref().downcast_ref::<ScheduledTaskFailedEvent>()?),
            StructType::ScheduledTaskReconfiguredEvent => Some(from.as_any_ref().downcast_ref::<ScheduledTaskReconfiguredEvent>()?),
            StructType::ScheduledTaskRemovedEvent => Some(from.as_any_ref().downcast_ref::<ScheduledTaskRemovedEvent>()?),
            StructType::ScheduledTaskStartedEvent => Some(from.as_any_ref().downcast_ref::<ScheduledTaskStartedEvent>()?),
            StructType::SessionEvent => Some(from.as_any_ref().downcast_ref::<SessionEvent>()?),
            StructType::AlreadyAuthenticatedSessionEvent => Some(from.as_any_ref().downcast_ref::<AlreadyAuthenticatedSessionEvent>()?),
            StructType::BadUsernameSessionEvent => Some(from.as_any_ref().downcast_ref::<BadUsernameSessionEvent>()?),
            StructType::GlobalMessageChangedEvent => Some(from.as_any_ref().downcast_ref::<GlobalMessageChangedEvent>()?),
            StructType::NoAccessUserEvent => Some(from.as_any_ref().downcast_ref::<NoAccessUserEvent>()?),
            StructType::ServerStartedSessionEvent => Some(from.as_any_ref().downcast_ref::<ServerStartedSessionEvent>()?),
            StructType::SessionTerminatedEvent => Some(from.as_any_ref().downcast_ref::<SessionTerminatedEvent>()?),
            StructType::UserLoginSessionEvent => Some(from.as_any_ref().downcast_ref::<UserLoginSessionEvent>()?),
            StructType::UserLogoutSessionEvent => Some(from.as_any_ref().downcast_ref::<UserLogoutSessionEvent>()?),
            StructType::TaskEvent => Some(from.as_any_ref().downcast_ref::<TaskEvent>()?),
            StructType::TaskTimeoutEvent => Some(from.as_any_ref().downcast_ref::<TaskTimeoutEvent>()?),
            StructType::TemplateUpgradeEvent => Some(from.as_any_ref().downcast_ref::<TemplateUpgradeEvent>()?),
            StructType::TemplateBeingUpgradedEvent => Some(from.as_any_ref().downcast_ref::<TemplateBeingUpgradedEvent>()?),
            StructType::TemplateUpgradeFailedEvent => Some(from.as_any_ref().downcast_ref::<TemplateUpgradeFailedEvent>()?),
            StructType::TemplateUpgradedEvent => Some(from.as_any_ref().downcast_ref::<TemplateUpgradedEvent>()?),
            StructType::UpgradeEvent => Some(from.as_any_ref().downcast_ref::<UpgradeEvent>()?),
            StructType::ErrorUpgradeEvent => Some(from.as_any_ref().downcast_ref::<ErrorUpgradeEvent>()?),
            StructType::InfoUpgradeEvent => Some(from.as_any_ref().downcast_ref::<InfoUpgradeEvent>()?),
            StructType::UserUpgradeEvent => Some(from.as_any_ref().downcast_ref::<UserUpgradeEvent>()?),
            StructType::WarningUpgradeEvent => Some(from.as_any_ref().downcast_ref::<WarningUpgradeEvent>()?),
            StructType::VmEvent => Some(from.as_any_ref().downcast_ref::<VmEvent>()?),
            StructType::CustomizationEvent => Some(from.as_any_ref().downcast_ref::<CustomizationEvent>()?),
            StructType::CustomizationFailed => Some(from.as_any_ref().downcast_ref::<CustomizationFailed>()?),
            StructType::CustomizationLinuxIdentityFailed => Some(from.as_any_ref().downcast_ref::<CustomizationLinuxIdentityFailed>()?),
            StructType::CustomizationNetworkSetupFailed => Some(from.as_any_ref().downcast_ref::<CustomizationNetworkSetupFailed>()?),
            StructType::CustomizationSysprepFailed => Some(from.as_any_ref().downcast_ref::<CustomizationSysprepFailed>()?),
            StructType::CustomizationUnknownFailure => Some(from.as_any_ref().downcast_ref::<CustomizationUnknownFailure>()?),
            StructType::CustomizationStartedEvent => Some(from.as_any_ref().downcast_ref::<CustomizationStartedEvent>()?),
            StructType::CustomizationSucceeded => Some(from.as_any_ref().downcast_ref::<CustomizationSucceeded>()?),
            StructType::DrsRuleComplianceEvent => Some(from.as_any_ref().downcast_ref::<DrsRuleComplianceEvent>()?),
            StructType::DrsRuleViolationEvent => Some(from.as_any_ref().downcast_ref::<DrsRuleViolationEvent>()?),
            StructType::DrsSoftRuleViolationEvent => Some(from.as_any_ref().downcast_ref::<DrsSoftRuleViolationEvent>()?),
            StructType::MigrationEvent => Some(from.as_any_ref().downcast_ref::<MigrationEvent>()?),
            StructType::MigrationErrorEvent => Some(from.as_any_ref().downcast_ref::<MigrationErrorEvent>()?),
            StructType::MigrationHostErrorEvent => Some(from.as_any_ref().downcast_ref::<MigrationHostErrorEvent>()?),
            StructType::MigrationHostWarningEvent => Some(from.as_any_ref().downcast_ref::<MigrationHostWarningEvent>()?),
            StructType::MigrationResourceErrorEvent => Some(from.as_any_ref().downcast_ref::<MigrationResourceErrorEvent>()?),
            StructType::MigrationResourceWarningEvent => Some(from.as_any_ref().downcast_ref::<MigrationResourceWarningEvent>()?),
            StructType::MigrationWarningEvent => Some(from.as_any_ref().downcast_ref::<MigrationWarningEvent>()?),
            StructType::NoMaintenanceModeDrsRecommendationForVm => Some(from.as_any_ref().downcast_ref::<NoMaintenanceModeDrsRecommendationForVm>()?),
            StructType::NotEnoughResourcesToStartVmEvent => Some(from.as_any_ref().downcast_ref::<NotEnoughResourcesToStartVmEvent>()?),
            StructType::VmAcquiredMksTicketEvent => Some(from.as_any_ref().downcast_ref::<VmAcquiredMksTicketEvent>()?),
            StructType::VmAcquiredTicketEvent => Some(from.as_any_ref().downcast_ref::<VmAcquiredTicketEvent>()?),
            StructType::VmAutoRenameEvent => Some(from.as_any_ref().downcast_ref::<VmAutoRenameEvent>()?),
            StructType::VmBeingCreatedEvent => Some(from.as_any_ref().downcast_ref::<VmBeingCreatedEvent>()?),
            StructType::VmBeingDeployedEvent => Some(from.as_any_ref().downcast_ref::<VmBeingDeployedEvent>()?),
            StructType::VmBeingHotMigratedEvent => Some(from.as_any_ref().downcast_ref::<VmBeingHotMigratedEvent>()?),
            StructType::VmBeingMigratedEvent => Some(from.as_any_ref().downcast_ref::<VmBeingMigratedEvent>()?),
            StructType::VmCloneEvent => Some(from.as_any_ref().downcast_ref::<VmCloneEvent>()?),
            StructType::VmBeingClonedEvent => Some(from.as_any_ref().downcast_ref::<VmBeingClonedEvent>()?),
            StructType::VmBeingClonedNoFolderEvent => Some(from.as_any_ref().downcast_ref::<VmBeingClonedNoFolderEvent>()?),
            StructType::VmCloneFailedEvent => Some(from.as_any_ref().downcast_ref::<VmCloneFailedEvent>()?),
            StructType::VmClonedEvent => Some(from.as_any_ref().downcast_ref::<VmClonedEvent>()?),
            StructType::VmConfigMissingEvent => Some(from.as_any_ref().downcast_ref::<VmConfigMissingEvent>()?),
            StructType::VmConnectedEvent => Some(from.as_any_ref().downcast_ref::<VmConnectedEvent>()?),
            StructType::VmCreatedEvent => Some(from.as_any_ref().downcast_ref::<VmCreatedEvent>()?),
            StructType::VmDasBeingResetEvent => Some(from.as_any_ref().downcast_ref::<VmDasBeingResetEvent>()?),
            StructType::VmDasBeingResetWithScreenshotEvent => Some(from.as_any_ref().downcast_ref::<VmDasBeingResetWithScreenshotEvent>()?),
            StructType::VmDasResetFailedEvent => Some(from.as_any_ref().downcast_ref::<VmDasResetFailedEvent>()?),
            StructType::VmDasUpdateErrorEvent => Some(from.as_any_ref().downcast_ref::<VmDasUpdateErrorEvent>()?),
            StructType::VmDasUpdateOkEvent => Some(from.as_any_ref().downcast_ref::<VmDasUpdateOkEvent>()?),
            StructType::VmDateRolledBackEvent => Some(from.as_any_ref().downcast_ref::<VmDateRolledBackEvent>()?),
            StructType::VmDeployFailedEvent => Some(from.as_any_ref().downcast_ref::<VmDeployFailedEvent>()?),
            StructType::VmDeployedEvent => Some(from.as_any_ref().downcast_ref::<VmDeployedEvent>()?),
            StructType::VmDisconnectedEvent => Some(from.as_any_ref().downcast_ref::<VmDisconnectedEvent>()?),
            StructType::VmDiscoveredEvent => Some(from.as_any_ref().downcast_ref::<VmDiscoveredEvent>()?),
            StructType::VmDiskFailedEvent => Some(from.as_any_ref().downcast_ref::<VmDiskFailedEvent>()?),
            StructType::VmEmigratingEvent => Some(from.as_any_ref().downcast_ref::<VmEmigratingEvent>()?),
            StructType::VmEndRecordingEvent => Some(from.as_any_ref().downcast_ref::<VmEndRecordingEvent>()?),
            StructType::VmEndReplayingEvent => Some(from.as_any_ref().downcast_ref::<VmEndReplayingEvent>()?),
            StructType::VmFailedMigrateEvent => Some(from.as_any_ref().downcast_ref::<VmFailedMigrateEvent>()?),
            StructType::VmFailedRelayoutEvent => Some(from.as_any_ref().downcast_ref::<VmFailedRelayoutEvent>()?),
            StructType::VmFailedRelayoutOnVmfs2DatastoreEvent => Some(from.as_any_ref().downcast_ref::<VmFailedRelayoutOnVmfs2DatastoreEvent>()?),
            StructType::VmFailedStartingSecondaryEvent => Some(from.as_any_ref().downcast_ref::<VmFailedStartingSecondaryEvent>()?),
            StructType::VmFailedToPowerOffEvent => Some(from.as_any_ref().downcast_ref::<VmFailedToPowerOffEvent>()?),
            StructType::VmFailedToPowerOnEvent => Some(from.as_any_ref().downcast_ref::<VmFailedToPowerOnEvent>()?),
            StructType::VmFailedToRebootGuestEvent => Some(from.as_any_ref().downcast_ref::<VmFailedToRebootGuestEvent>()?),
            StructType::VmFailedToResetEvent => Some(from.as_any_ref().downcast_ref::<VmFailedToResetEvent>()?),
            StructType::VmFailedToShutdownGuestEvent => Some(from.as_any_ref().downcast_ref::<VmFailedToShutdownGuestEvent>()?),
            StructType::VmFailedToStandbyGuestEvent => Some(from.as_any_ref().downcast_ref::<VmFailedToStandbyGuestEvent>()?),
            StructType::VmFailedToSuspendEvent => Some(from.as_any_ref().downcast_ref::<VmFailedToSuspendEvent>()?),
            StructType::VmFailedUpdatingSecondaryConfig => Some(from.as_any_ref().downcast_ref::<VmFailedUpdatingSecondaryConfig>()?),
            StructType::VmFailoverFailed => Some(from.as_any_ref().downcast_ref::<VmFailoverFailed>()?),
            StructType::VmFaultToleranceStateChangedEvent => Some(from.as_any_ref().downcast_ref::<VmFaultToleranceStateChangedEvent>()?),
            StructType::VmFaultToleranceTurnedOffEvent => Some(from.as_any_ref().downcast_ref::<VmFaultToleranceTurnedOffEvent>()?),
            StructType::VmFaultToleranceVmTerminatedEvent => Some(from.as_any_ref().downcast_ref::<VmFaultToleranceVmTerminatedEvent>()?),
            StructType::VmGuestOsCrashedEvent => Some(from.as_any_ref().downcast_ref::<VmGuestOsCrashedEvent>()?),
            StructType::VmGuestRebootEvent => Some(from.as_any_ref().downcast_ref::<VmGuestRebootEvent>()?),
            StructType::VmGuestShutdownEvent => Some(from.as_any_ref().downcast_ref::<VmGuestShutdownEvent>()?),
            StructType::VmGuestStandbyEvent => Some(from.as_any_ref().downcast_ref::<VmGuestStandbyEvent>()?),
            StructType::VmInstanceUuidAssignedEvent => Some(from.as_any_ref().downcast_ref::<VmInstanceUuidAssignedEvent>()?),
            StructType::VmInstanceUuidChangedEvent => Some(from.as_any_ref().downcast_ref::<VmInstanceUuidChangedEvent>()?),
            StructType::VmInstanceUuidConflictEvent => Some(from.as_any_ref().downcast_ref::<VmInstanceUuidConflictEvent>()?),
            StructType::VmMacAssignedEvent => Some(from.as_any_ref().downcast_ref::<VmMacAssignedEvent>()?),
            StructType::VmMacChangedEvent => Some(from.as_any_ref().downcast_ref::<VmMacChangedEvent>()?),
            StructType::VmMacConflictEvent => Some(from.as_any_ref().downcast_ref::<VmMacConflictEvent>()?),
            StructType::VmMaxFtRestartCountReached => Some(from.as_any_ref().downcast_ref::<VmMaxFtRestartCountReached>()?),
            StructType::VmMaxRestartCountReached => Some(from.as_any_ref().downcast_ref::<VmMaxRestartCountReached>()?),
            StructType::VmMessageErrorEvent => Some(from.as_any_ref().downcast_ref::<VmMessageErrorEvent>()?),
            StructType::VmMessageEvent => Some(from.as_any_ref().downcast_ref::<VmMessageEvent>()?),
            StructType::VmMessageWarningEvent => Some(from.as_any_ref().downcast_ref::<VmMessageWarningEvent>()?),
            StructType::VmMigratedEvent => Some(from.as_any_ref().downcast_ref::<VmMigratedEvent>()?),
            StructType::DrsVmMigratedEvent => Some(from.as_any_ref().downcast_ref::<DrsVmMigratedEvent>()?),
            StructType::VmNoCompatibleHostForSecondaryEvent => Some(from.as_any_ref().downcast_ref::<VmNoCompatibleHostForSecondaryEvent>()?),
            StructType::VmNoNetworkAccessEvent => Some(from.as_any_ref().downcast_ref::<VmNoNetworkAccessEvent>()?),
            StructType::VmOrphanedEvent => Some(from.as_any_ref().downcast_ref::<VmOrphanedEvent>()?),
            StructType::VmPoweredOffEvent => Some(from.as_any_ref().downcast_ref::<VmPoweredOffEvent>()?),
            StructType::VmPowerOffOnIsolationEvent => Some(from.as_any_ref().downcast_ref::<VmPowerOffOnIsolationEvent>()?),
            StructType::VmShutdownOnIsolationEvent => Some(from.as_any_ref().downcast_ref::<VmShutdownOnIsolationEvent>()?),
            StructType::VmPoweredOnEvent => Some(from.as_any_ref().downcast_ref::<VmPoweredOnEvent>()?),
            StructType::DrsVmPoweredOnEvent => Some(from.as_any_ref().downcast_ref::<DrsVmPoweredOnEvent>()?),
            StructType::VmRestartedOnAlternateHostEvent => Some(from.as_any_ref().downcast_ref::<VmRestartedOnAlternateHostEvent>()?),
            StructType::VmPoweringOnWithCustomizedDvPortEvent => Some(from.as_any_ref().downcast_ref::<VmPoweringOnWithCustomizedDvPortEvent>()?),
            StructType::VmPrimaryFailoverEvent => Some(from.as_any_ref().downcast_ref::<VmPrimaryFailoverEvent>()?),
            StructType::VmReconfiguredEvent => Some(from.as_any_ref().downcast_ref::<VmReconfiguredEvent>()?),
            StructType::VmRegisteredEvent => Some(from.as_any_ref().downcast_ref::<VmRegisteredEvent>()?),
            StructType::VmRelayoutSuccessfulEvent => Some(from.as_any_ref().downcast_ref::<VmRelayoutSuccessfulEvent>()?),
            StructType::VmRelayoutUpToDateEvent => Some(from.as_any_ref().downcast_ref::<VmRelayoutUpToDateEvent>()?),
            StructType::VmReloadFromPathEvent => Some(from.as_any_ref().downcast_ref::<VmReloadFromPathEvent>()?),
            StructType::VmReloadFromPathFailedEvent => Some(from.as_any_ref().downcast_ref::<VmReloadFromPathFailedEvent>()?),
            StructType::VmRelocateSpecEvent => Some(from.as_any_ref().downcast_ref::<VmRelocateSpecEvent>()?),
            StructType::VmBeingRelocatedEvent => Some(from.as_any_ref().downcast_ref::<VmBeingRelocatedEvent>()?),
            StructType::VmRelocateFailedEvent => Some(from.as_any_ref().downcast_ref::<VmRelocateFailedEvent>()?),
            StructType::VmRelocatedEvent => Some(from.as_any_ref().downcast_ref::<VmRelocatedEvent>()?),
            StructType::VmRemoteConsoleConnectedEvent => Some(from.as_any_ref().downcast_ref::<VmRemoteConsoleConnectedEvent>()?),
            StructType::VmRemoteConsoleDisconnectedEvent => Some(from.as_any_ref().downcast_ref::<VmRemoteConsoleDisconnectedEvent>()?),
            StructType::VmRemovedEvent => Some(from.as_any_ref().downcast_ref::<VmRemovedEvent>()?),
            StructType::VmRenamedEvent => Some(from.as_any_ref().downcast_ref::<VmRenamedEvent>()?),
            StructType::VmRequirementsExceedCurrentEvcModeEvent => Some(from.as_any_ref().downcast_ref::<VmRequirementsExceedCurrentEvcModeEvent>()?),
            StructType::VmResettingEvent => Some(from.as_any_ref().downcast_ref::<VmResettingEvent>()?),
            StructType::VmResourcePoolMovedEvent => Some(from.as_any_ref().downcast_ref::<VmResourcePoolMovedEvent>()?),
            StructType::VmResourceReallocatedEvent => Some(from.as_any_ref().downcast_ref::<VmResourceReallocatedEvent>()?),
            StructType::VmResumingEvent => Some(from.as_any_ref().downcast_ref::<VmResumingEvent>()?),
            StructType::VmSecondaryAddedEvent => Some(from.as_any_ref().downcast_ref::<VmSecondaryAddedEvent>()?),
            StructType::VmSecondaryDisabledBySystemEvent => Some(from.as_any_ref().downcast_ref::<VmSecondaryDisabledBySystemEvent>()?),
            StructType::VmSecondaryDisabledEvent => Some(from.as_any_ref().downcast_ref::<VmSecondaryDisabledEvent>()?),
            StructType::VmSecondaryEnabledEvent => Some(from.as_any_ref().downcast_ref::<VmSecondaryEnabledEvent>()?),
            StructType::VmSecondaryStartedEvent => Some(from.as_any_ref().downcast_ref::<VmSecondaryStartedEvent>()?),
            StructType::VmStartRecordingEvent => Some(from.as_any_ref().downcast_ref::<VmStartRecordingEvent>()?),
            StructType::VmStartReplayingEvent => Some(from.as_any_ref().downcast_ref::<VmStartReplayingEvent>()?),
            StructType::VmStartingEvent => Some(from.as_any_ref().downcast_ref::<VmStartingEvent>()?),
            StructType::VmUnsupportedStartingEvent => Some(from.as_any_ref().downcast_ref::<VmUnsupportedStartingEvent>()?),
            StructType::VmStartingSecondaryEvent => Some(from.as_any_ref().downcast_ref::<VmStartingSecondaryEvent>()?),
            StructType::VmStaticMacConflictEvent => Some(from.as_any_ref().downcast_ref::<VmStaticMacConflictEvent>()?),
            StructType::VmStoppingEvent => Some(from.as_any_ref().downcast_ref::<VmStoppingEvent>()?),
            StructType::VmSuspendedEvent => Some(from.as_any_ref().downcast_ref::<VmSuspendedEvent>()?),
            StructType::VmSuspendingEvent => Some(from.as_any_ref().downcast_ref::<VmSuspendingEvent>()?),
            StructType::VmTimedoutStartingSecondaryEvent => Some(from.as_any_ref().downcast_ref::<VmTimedoutStartingSecondaryEvent>()?),
            StructType::VmUpgradeCompleteEvent => Some(from.as_any_ref().downcast_ref::<VmUpgradeCompleteEvent>()?),
            StructType::VmUpgradeFailedEvent => Some(from.as_any_ref().downcast_ref::<VmUpgradeFailedEvent>()?),
            StructType::VmUpgradingEvent => Some(from.as_any_ref().downcast_ref::<VmUpgradingEvent>()?),
            StructType::VmUuidAssignedEvent => Some(from.as_any_ref().downcast_ref::<VmUuidAssignedEvent>()?),
            StructType::VmUuidChangedEvent => Some(from.as_any_ref().downcast_ref::<VmUuidChangedEvent>()?),
            StructType::VmUuidConflictEvent => Some(from.as_any_ref().downcast_ref::<VmUuidConflictEvent>()?),
            StructType::VmWwnAssignedEvent => Some(from.as_any_ref().downcast_ref::<VmWwnAssignedEvent>()?),
            StructType::VmWwnChangedEvent => Some(from.as_any_ref().downcast_ref::<VmWwnChangedEvent>()?),
            StructType::VmWwnConflictEvent => Some(from.as_any_ref().downcast_ref::<VmWwnConflictEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::Event => Ok(from.as_any_box().downcast::<Event>()?),
            StructType::AlarmEvent => Ok(from.as_any_box().downcast::<AlarmEvent>()?),
            StructType::AlarmAcknowledgedEvent => Ok(from.as_any_box().downcast::<AlarmAcknowledgedEvent>()?),
            StructType::AlarmActionTriggeredEvent => Ok(from.as_any_box().downcast::<AlarmActionTriggeredEvent>()?),
            StructType::AlarmClearedEvent => Ok(from.as_any_box().downcast::<AlarmClearedEvent>()?),
            StructType::AlarmCreatedEvent => Ok(from.as_any_box().downcast::<AlarmCreatedEvent>()?),
            StructType::AlarmEmailCompletedEvent => Ok(from.as_any_box().downcast::<AlarmEmailCompletedEvent>()?),
            StructType::AlarmEmailFailedEvent => Ok(from.as_any_box().downcast::<AlarmEmailFailedEvent>()?),
            StructType::AlarmReconfiguredEvent => Ok(from.as_any_box().downcast::<AlarmReconfiguredEvent>()?),
            StructType::AlarmRemovedEvent => Ok(from.as_any_box().downcast::<AlarmRemovedEvent>()?),
            StructType::AlarmScriptCompleteEvent => Ok(from.as_any_box().downcast::<AlarmScriptCompleteEvent>()?),
            StructType::AlarmScriptFailedEvent => Ok(from.as_any_box().downcast::<AlarmScriptFailedEvent>()?),
            StructType::AlarmSnmpCompletedEvent => Ok(from.as_any_box().downcast::<AlarmSnmpCompletedEvent>()?),
            StructType::AlarmSnmpFailedEvent => Ok(from.as_any_box().downcast::<AlarmSnmpFailedEvent>()?),
            StructType::AlarmStatusChangedEvent => Ok(from.as_any_box().downcast::<AlarmStatusChangedEvent>()?),
            StructType::AuthorizationEvent => Ok(from.as_any_box().downcast::<AuthorizationEvent>()?),
            StructType::PermissionEvent => Ok(from.as_any_box().downcast::<PermissionEvent>()?),
            StructType::PermissionAddedEvent => Ok(from.as_any_box().downcast::<PermissionAddedEvent>()?),
            StructType::PermissionRemovedEvent => Ok(from.as_any_box().downcast::<PermissionRemovedEvent>()?),
            StructType::PermissionUpdatedEvent => Ok(from.as_any_box().downcast::<PermissionUpdatedEvent>()?),
            StructType::RoleEvent => Ok(from.as_any_box().downcast::<RoleEvent>()?),
            StructType::RoleAddedEvent => Ok(from.as_any_box().downcast::<RoleAddedEvent>()?),
            StructType::RoleRemovedEvent => Ok(from.as_any_box().downcast::<RoleRemovedEvent>()?),
            StructType::RoleUpdatedEvent => Ok(from.as_any_box().downcast::<RoleUpdatedEvent>()?),
            StructType::ClusterEvent => Ok(from.as_any_box().downcast::<ClusterEvent>()?),
            StructType::ClusterComplianceCheckedEvent => Ok(from.as_any_box().downcast::<ClusterComplianceCheckedEvent>()?),
            StructType::ClusterCreatedEvent => Ok(from.as_any_box().downcast::<ClusterCreatedEvent>()?),
            StructType::ClusterDestroyedEvent => Ok(from.as_any_box().downcast::<ClusterDestroyedEvent>()?),
            StructType::ClusterOvercommittedEvent => Ok(from.as_any_box().downcast::<ClusterOvercommittedEvent>()?),
            StructType::HostOvercommittedEvent => Ok(from.as_any_box().downcast::<HostOvercommittedEvent>()?),
            StructType::ClusterReconfiguredEvent => Ok(from.as_any_box().downcast::<ClusterReconfiguredEvent>()?),
            StructType::ClusterStatusChangedEvent => Ok(from.as_any_box().downcast::<ClusterStatusChangedEvent>()?),
            StructType::HostStatusChangedEvent => Ok(from.as_any_box().downcast::<HostStatusChangedEvent>()?),
            StructType::DasAdmissionControlDisabledEvent => Ok(from.as_any_box().downcast::<DasAdmissionControlDisabledEvent>()?),
            StructType::DasAdmissionControlEnabledEvent => Ok(from.as_any_box().downcast::<DasAdmissionControlEnabledEvent>()?),
            StructType::DasAgentFoundEvent => Ok(from.as_any_box().downcast::<DasAgentFoundEvent>()?),
            StructType::DasAgentUnavailableEvent => Ok(from.as_any_box().downcast::<DasAgentUnavailableEvent>()?),
            StructType::DasClusterIsolatedEvent => Ok(from.as_any_box().downcast::<DasClusterIsolatedEvent>()?),
            StructType::DasDisabledEvent => Ok(from.as_any_box().downcast::<DasDisabledEvent>()?),
            StructType::DasEnabledEvent => Ok(from.as_any_box().downcast::<DasEnabledEvent>()?),
            StructType::DasHostFailedEvent => Ok(from.as_any_box().downcast::<DasHostFailedEvent>()?),
            StructType::DasHostIsolatedEvent => Ok(from.as_any_box().downcast::<DasHostIsolatedEvent>()?),
            StructType::DrsDisabledEvent => Ok(from.as_any_box().downcast::<DrsDisabledEvent>()?),
            StructType::DrsEnabledEvent => Ok(from.as_any_box().downcast::<DrsEnabledEvent>()?),
            StructType::DrsInvocationFailedEvent => Ok(from.as_any_box().downcast::<DrsInvocationFailedEvent>()?),
            StructType::DrsRecoveredFromFailureEvent => Ok(from.as_any_box().downcast::<DrsRecoveredFromFailureEvent>()?),
            StructType::FailoverLevelRestored => Ok(from.as_any_box().downcast::<FailoverLevelRestored>()?),
            StructType::HostMonitoringStateChangedEvent => Ok(from.as_any_box().downcast::<HostMonitoringStateChangedEvent>()?),
            StructType::InsufficientFailoverResourcesEvent => Ok(from.as_any_box().downcast::<InsufficientFailoverResourcesEvent>()?),
            StructType::VmHealthMonitoringStateChangedEvent => Ok(from.as_any_box().downcast::<VmHealthMonitoringStateChangedEvent>()?),
            StructType::CustomFieldEvent => Ok(from.as_any_box().downcast::<CustomFieldEvent>()?),
            StructType::CustomFieldDefEvent => Ok(from.as_any_box().downcast::<CustomFieldDefEvent>()?),
            StructType::CustomFieldDefAddedEvent => Ok(from.as_any_box().downcast::<CustomFieldDefAddedEvent>()?),
            StructType::CustomFieldDefRemovedEvent => Ok(from.as_any_box().downcast::<CustomFieldDefRemovedEvent>()?),
            StructType::CustomFieldDefRenamedEvent => Ok(from.as_any_box().downcast::<CustomFieldDefRenamedEvent>()?),
            StructType::CustomFieldValueChangedEvent => Ok(from.as_any_box().downcast::<CustomFieldValueChangedEvent>()?),
            StructType::DvPortgroupEvent => Ok(from.as_any_box().downcast::<DvPortgroupEvent>()?),
            StructType::DvPortgroupCreatedEvent => Ok(from.as_any_box().downcast::<DvPortgroupCreatedEvent>()?),
            StructType::DvPortgroupDestroyedEvent => Ok(from.as_any_box().downcast::<DvPortgroupDestroyedEvent>()?),
            StructType::DvPortgroupReconfiguredEvent => Ok(from.as_any_box().downcast::<DvPortgroupReconfiguredEvent>()?),
            StructType::DvPortgroupRenamedEvent => Ok(from.as_any_box().downcast::<DvPortgroupRenamedEvent>()?),
            StructType::DvpgImportEvent => Ok(from.as_any_box().downcast::<DvpgImportEvent>()?),
            StructType::DvpgRestoreEvent => Ok(from.as_any_box().downcast::<DvpgRestoreEvent>()?),
            StructType::DatacenterEvent => Ok(from.as_any_box().downcast::<DatacenterEvent>()?),
            StructType::DatacenterCreatedEvent => Ok(from.as_any_box().downcast::<DatacenterCreatedEvent>()?),
            StructType::DatacenterRenamedEvent => Ok(from.as_any_box().downcast::<DatacenterRenamedEvent>()?),
            StructType::DatastoreEvent => Ok(from.as_any_box().downcast::<DatastoreEvent>()?),
            StructType::DatastoreCapacityIncreasedEvent => Ok(from.as_any_box().downcast::<DatastoreCapacityIncreasedEvent>()?),
            StructType::DatastoreDestroyedEvent => Ok(from.as_any_box().downcast::<DatastoreDestroyedEvent>()?),
            StructType::DatastoreDuplicatedEvent => Ok(from.as_any_box().downcast::<DatastoreDuplicatedEvent>()?),
            StructType::DatastoreFileEvent => Ok(from.as_any_box().downcast::<DatastoreFileEvent>()?),
            StructType::DatastoreFileCopiedEvent => Ok(from.as_any_box().downcast::<DatastoreFileCopiedEvent>()?),
            StructType::DatastoreFileDeletedEvent => Ok(from.as_any_box().downcast::<DatastoreFileDeletedEvent>()?),
            StructType::DatastoreFileMovedEvent => Ok(from.as_any_box().downcast::<DatastoreFileMovedEvent>()?),
            StructType::DatastoreIormReconfiguredEvent => Ok(from.as_any_box().downcast::<DatastoreIormReconfiguredEvent>()?),
            StructType::DatastoreRenamedEvent => Ok(from.as_any_box().downcast::<DatastoreRenamedEvent>()?),
            StructType::NonViWorkloadDetectedOnDatastoreEvent => Ok(from.as_any_box().downcast::<NonViWorkloadDetectedOnDatastoreEvent>()?),
            StructType::DvsEvent => Ok(from.as_any_box().downcast::<DvsEvent>()?),
            StructType::DvsCreatedEvent => Ok(from.as_any_box().downcast::<DvsCreatedEvent>()?),
            StructType::DvsDestroyedEvent => Ok(from.as_any_box().downcast::<DvsDestroyedEvent>()?),
            StructType::DvsHostBackInSyncEvent => Ok(from.as_any_box().downcast::<DvsHostBackInSyncEvent>()?),
            StructType::DvsHostJoinedEvent => Ok(from.as_any_box().downcast::<DvsHostJoinedEvent>()?),
            StructType::DvsHostLeftEvent => Ok(from.as_any_box().downcast::<DvsHostLeftEvent>()?),
            StructType::DvsHostStatusUpdated => Ok(from.as_any_box().downcast::<DvsHostStatusUpdated>()?),
            StructType::DvsHostWentOutOfSyncEvent => Ok(from.as_any_box().downcast::<DvsHostWentOutOfSyncEvent>()?),
            StructType::DvsImportEvent => Ok(from.as_any_box().downcast::<DvsImportEvent>()?),
            StructType::DvsMergedEvent => Ok(from.as_any_box().downcast::<DvsMergedEvent>()?),
            StructType::DvsPortBlockedEvent => Ok(from.as_any_box().downcast::<DvsPortBlockedEvent>()?),
            StructType::DvsPortConnectedEvent => Ok(from.as_any_box().downcast::<DvsPortConnectedEvent>()?),
            StructType::DvsPortCreatedEvent => Ok(from.as_any_box().downcast::<DvsPortCreatedEvent>()?),
            StructType::DvsPortDeletedEvent => Ok(from.as_any_box().downcast::<DvsPortDeletedEvent>()?),
            StructType::DvsPortDisconnectedEvent => Ok(from.as_any_box().downcast::<DvsPortDisconnectedEvent>()?),
            StructType::DvsPortEnteredPassthruEvent => Ok(from.as_any_box().downcast::<DvsPortEnteredPassthruEvent>()?),
            StructType::DvsPortExitedPassthruEvent => Ok(from.as_any_box().downcast::<DvsPortExitedPassthruEvent>()?),
            StructType::DvsPortJoinPortgroupEvent => Ok(from.as_any_box().downcast::<DvsPortJoinPortgroupEvent>()?),
            StructType::DvsPortLeavePortgroupEvent => Ok(from.as_any_box().downcast::<DvsPortLeavePortgroupEvent>()?),
            StructType::DvsPortLinkDownEvent => Ok(from.as_any_box().downcast::<DvsPortLinkDownEvent>()?),
            StructType::DvsPortLinkUpEvent => Ok(from.as_any_box().downcast::<DvsPortLinkUpEvent>()?),
            StructType::DvsPortReconfiguredEvent => Ok(from.as_any_box().downcast::<DvsPortReconfiguredEvent>()?),
            StructType::DvsPortRuntimeChangeEvent => Ok(from.as_any_box().downcast::<DvsPortRuntimeChangeEvent>()?),
            StructType::DvsPortUnblockedEvent => Ok(from.as_any_box().downcast::<DvsPortUnblockedEvent>()?),
            StructType::DvsPortVendorSpecificStateChangeEvent => Ok(from.as_any_box().downcast::<DvsPortVendorSpecificStateChangeEvent>()?),
            StructType::DvsReconfiguredEvent => Ok(from.as_any_box().downcast::<DvsReconfiguredEvent>()?),
            StructType::DvsRenamedEvent => Ok(from.as_any_box().downcast::<DvsRenamedEvent>()?),
            StructType::DvsRestoreEvent => Ok(from.as_any_box().downcast::<DvsRestoreEvent>()?),
            StructType::DvsUpgradeAvailableEvent => Ok(from.as_any_box().downcast::<DvsUpgradeAvailableEvent>()?),
            StructType::DvsUpgradeInProgressEvent => Ok(from.as_any_box().downcast::<DvsUpgradeInProgressEvent>()?),
            StructType::DvsUpgradeRejectedEvent => Ok(from.as_any_box().downcast::<DvsUpgradeRejectedEvent>()?),
            StructType::DvsUpgradedEvent => Ok(from.as_any_box().downcast::<DvsUpgradedEvent>()?),
            StructType::HostLocalPortCreatedEvent => Ok(from.as_any_box().downcast::<HostLocalPortCreatedEvent>()?),
            StructType::OutOfSyncDvsHost => Ok(from.as_any_box().downcast::<OutOfSyncDvsHost>()?),
            StructType::RecoveryEvent => Ok(from.as_any_box().downcast::<RecoveryEvent>()?),
            StructType::RollbackEvent => Ok(from.as_any_box().downcast::<RollbackEvent>()?),
            StructType::VmVnicPoolReservationViolationClearEvent => Ok(from.as_any_box().downcast::<VmVnicPoolReservationViolationClearEvent>()?),
            StructType::VmVnicPoolReservationViolationRaiseEvent => Ok(from.as_any_box().downcast::<VmVnicPoolReservationViolationRaiseEvent>()?),
            StructType::EventEx => Ok(from.as_any_box().downcast::<EventEx>()?),
            StructType::GeneralEvent => Ok(from.as_any_box().downcast::<GeneralEvent>()?),
            StructType::ExtendedEvent => Ok(from.as_any_box().downcast::<ExtendedEvent>()?),
            StructType::GeneralHostErrorEvent => Ok(from.as_any_box().downcast::<GeneralHostErrorEvent>()?),
            StructType::GeneralHostInfoEvent => Ok(from.as_any_box().downcast::<GeneralHostInfoEvent>()?),
            StructType::GeneralHostWarningEvent => Ok(from.as_any_box().downcast::<GeneralHostWarningEvent>()?),
            StructType::GeneralUserEvent => Ok(from.as_any_box().downcast::<GeneralUserEvent>()?),
            StructType::GeneralVmErrorEvent => Ok(from.as_any_box().downcast::<GeneralVmErrorEvent>()?),
            StructType::GeneralVmInfoEvent => Ok(from.as_any_box().downcast::<GeneralVmInfoEvent>()?),
            StructType::GeneralVmWarningEvent => Ok(from.as_any_box().downcast::<GeneralVmWarningEvent>()?),
            StructType::HealthStatusChangedEvent => Ok(from.as_any_box().downcast::<HealthStatusChangedEvent>()?),
            StructType::HostEvent => Ok(from.as_any_box().downcast::<HostEvent>()?),
            StructType::AccountCreatedEvent => Ok(from.as_any_box().downcast::<AccountCreatedEvent>()?),
            StructType::AccountRemovedEvent => Ok(from.as_any_box().downcast::<AccountRemovedEvent>()?),
            StructType::AccountUpdatedEvent => Ok(from.as_any_box().downcast::<AccountUpdatedEvent>()?),
            StructType::AdminPasswordNotChangedEvent => Ok(from.as_any_box().downcast::<AdminPasswordNotChangedEvent>()?),
            StructType::CanceledHostOperationEvent => Ok(from.as_any_box().downcast::<CanceledHostOperationEvent>()?),
            StructType::DatastoreDiscoveredEvent => Ok(from.as_any_box().downcast::<DatastoreDiscoveredEvent>()?),
            StructType::DatastorePrincipalConfigured => Ok(from.as_any_box().downcast::<DatastorePrincipalConfigured>()?),
            StructType::DatastoreRemovedOnHostEvent => Ok(from.as_any_box().downcast::<DatastoreRemovedOnHostEvent>()?),
            StructType::DatastoreRenamedOnHostEvent => Ok(from.as_any_box().downcast::<DatastoreRenamedOnHostEvent>()?),
            StructType::DrsResourceConfigureFailedEvent => Ok(from.as_any_box().downcast::<DrsResourceConfigureFailedEvent>()?),
            StructType::DrsResourceConfigureSyncedEvent => Ok(from.as_any_box().downcast::<DrsResourceConfigureSyncedEvent>()?),
            StructType::DuplicateIpDetectedEvent => Ok(from.as_any_box().downcast::<DuplicateIpDetectedEvent>()?),
            StructType::DvsHealthStatusChangeEvent => Ok(from.as_any_box().downcast::<DvsHealthStatusChangeEvent>()?),
            StructType::MtuMatchEvent => Ok(from.as_any_box().downcast::<MtuMatchEvent>()?),
            StructType::MtuMismatchEvent => Ok(from.as_any_box().downcast::<MtuMismatchEvent>()?),
            StructType::TeamingMatchEvent => Ok(from.as_any_box().downcast::<TeamingMatchEvent>()?),
            StructType::TeamingMisMatchEvent => Ok(from.as_any_box().downcast::<TeamingMisMatchEvent>()?),
            StructType::UplinkPortMtuNotSupportEvent => Ok(from.as_any_box().downcast::<UplinkPortMtuNotSupportEvent>()?),
            StructType::UplinkPortMtuSupportEvent => Ok(from.as_any_box().downcast::<UplinkPortMtuSupportEvent>()?),
            StructType::UplinkPortVlanTrunkedEvent => Ok(from.as_any_box().downcast::<UplinkPortVlanTrunkedEvent>()?),
            StructType::UplinkPortVlanUntrunkedEvent => Ok(from.as_any_box().downcast::<UplinkPortVlanUntrunkedEvent>()?),
            StructType::EnteredMaintenanceModeEvent => Ok(from.as_any_box().downcast::<EnteredMaintenanceModeEvent>()?),
            StructType::EnteredStandbyModeEvent => Ok(from.as_any_box().downcast::<EnteredStandbyModeEvent>()?),
            StructType::DrsEnteredStandbyModeEvent => Ok(from.as_any_box().downcast::<DrsEnteredStandbyModeEvent>()?),
            StructType::EnteringMaintenanceModeEvent => Ok(from.as_any_box().downcast::<EnteringMaintenanceModeEvent>()?),
            StructType::EnteringStandbyModeEvent => Ok(from.as_any_box().downcast::<EnteringStandbyModeEvent>()?),
            StructType::DrsEnteringStandbyModeEvent => Ok(from.as_any_box().downcast::<DrsEnteringStandbyModeEvent>()?),
            StructType::ExitMaintenanceModeEvent => Ok(from.as_any_box().downcast::<ExitMaintenanceModeEvent>()?),
            StructType::ExitStandbyModeFailedEvent => Ok(from.as_any_box().downcast::<ExitStandbyModeFailedEvent>()?),
            StructType::DrsExitStandbyModeFailedEvent => Ok(from.as_any_box().downcast::<DrsExitStandbyModeFailedEvent>()?),
            StructType::ExitedStandbyModeEvent => Ok(from.as_any_box().downcast::<ExitedStandbyModeEvent>()?),
            StructType::DrsExitedStandbyModeEvent => Ok(from.as_any_box().downcast::<DrsExitedStandbyModeEvent>()?),
            StructType::ExitingStandbyModeEvent => Ok(from.as_any_box().downcast::<ExitingStandbyModeEvent>()?),
            StructType::DrsExitingStandbyModeEvent => Ok(from.as_any_box().downcast::<DrsExitingStandbyModeEvent>()?),
            StructType::GhostDvsProxySwitchDetectedEvent => Ok(from.as_any_box().downcast::<GhostDvsProxySwitchDetectedEvent>()?),
            StructType::GhostDvsProxySwitchRemovedEvent => Ok(from.as_any_box().downcast::<GhostDvsProxySwitchRemovedEvent>()?),
            StructType::HostAddFailedEvent => Ok(from.as_any_box().downcast::<HostAddFailedEvent>()?),
            StructType::HostAddedEvent => Ok(from.as_any_box().downcast::<HostAddedEvent>()?),
            StructType::HostAdminDisableEvent => Ok(from.as_any_box().downcast::<HostAdminDisableEvent>()?),
            StructType::HostAdminEnableEvent => Ok(from.as_any_box().downcast::<HostAdminEnableEvent>()?),
            StructType::HostCnxFailedAccountFailedEvent => Ok(from.as_any_box().downcast::<HostCnxFailedAccountFailedEvent>()?),
            StructType::HostCnxFailedAlreadyManagedEvent => Ok(from.as_any_box().downcast::<HostCnxFailedAlreadyManagedEvent>()?),
            StructType::HostCnxFailedBadCcagentEvent => Ok(from.as_any_box().downcast::<HostCnxFailedBadCcagentEvent>()?),
            StructType::HostCnxFailedBadUsernameEvent => Ok(from.as_any_box().downcast::<HostCnxFailedBadUsernameEvent>()?),
            StructType::HostCnxFailedBadVersionEvent => Ok(from.as_any_box().downcast::<HostCnxFailedBadVersionEvent>()?),
            StructType::HostCnxFailedCcagentUpgradeEvent => Ok(from.as_any_box().downcast::<HostCnxFailedCcagentUpgradeEvent>()?),
            StructType::HostCnxFailedEvent => Ok(from.as_any_box().downcast::<HostCnxFailedEvent>()?),
            StructType::HostCnxFailedNetworkErrorEvent => Ok(from.as_any_box().downcast::<HostCnxFailedNetworkErrorEvent>()?),
            StructType::HostCnxFailedNoAccessEvent => Ok(from.as_any_box().downcast::<HostCnxFailedNoAccessEvent>()?),
            StructType::HostCnxFailedNoConnectionEvent => Ok(from.as_any_box().downcast::<HostCnxFailedNoConnectionEvent>()?),
            StructType::HostCnxFailedNoLicenseEvent => Ok(from.as_any_box().downcast::<HostCnxFailedNoLicenseEvent>()?),
            StructType::HostCnxFailedNotFoundEvent => Ok(from.as_any_box().downcast::<HostCnxFailedNotFoundEvent>()?),
            StructType::HostCnxFailedTimeoutEvent => Ok(from.as_any_box().downcast::<HostCnxFailedTimeoutEvent>()?),
            StructType::HostComplianceCheckedEvent => Ok(from.as_any_box().downcast::<HostComplianceCheckedEvent>()?),
            StructType::HostCompliantEvent => Ok(from.as_any_box().downcast::<HostCompliantEvent>()?),
            StructType::HostConfigAppliedEvent => Ok(from.as_any_box().downcast::<HostConfigAppliedEvent>()?),
            StructType::HostConnectedEvent => Ok(from.as_any_box().downcast::<HostConnectedEvent>()?),
            StructType::HostConnectionLostEvent => Ok(from.as_any_box().downcast::<HostConnectionLostEvent>()?),
            StructType::HostDasDisabledEvent => Ok(from.as_any_box().downcast::<HostDasDisabledEvent>()?),
            StructType::HostDasDisablingEvent => Ok(from.as_any_box().downcast::<HostDasDisablingEvent>()?),
            StructType::HostDasEnabledEvent => Ok(from.as_any_box().downcast::<HostDasEnabledEvent>()?),
            StructType::HostDasEnablingEvent => Ok(from.as_any_box().downcast::<HostDasEnablingEvent>()?),
            StructType::HostDasErrorEvent => Ok(from.as_any_box().downcast::<HostDasErrorEvent>()?),
            StructType::HostDasEvent => Ok(from.as_any_box().downcast::<HostDasEvent>()?),
            StructType::HostExtraNetworksEvent => Ok(from.as_any_box().downcast::<HostExtraNetworksEvent>()?),
            StructType::HostIsolationIpPingFailedEvent => Ok(from.as_any_box().downcast::<HostIsolationIpPingFailedEvent>()?),
            StructType::HostMissingNetworksEvent => Ok(from.as_any_box().downcast::<HostMissingNetworksEvent>()?),
            StructType::HostNoAvailableNetworksEvent => Ok(from.as_any_box().downcast::<HostNoAvailableNetworksEvent>()?),
            StructType::HostNoHaEnabledPortGroupsEvent => Ok(from.as_any_box().downcast::<HostNoHaEnabledPortGroupsEvent>()?),
            StructType::HostNoRedundantManagementNetworkEvent => Ok(from.as_any_box().downcast::<HostNoRedundantManagementNetworkEvent>()?),
            StructType::HostNotInClusterEvent => Ok(from.as_any_box().downcast::<HostNotInClusterEvent>()?),
            StructType::HostPrimaryAgentNotShortNameEvent => Ok(from.as_any_box().downcast::<HostPrimaryAgentNotShortNameEvent>()?),
            StructType::HostShortNameInconsistentEvent => Ok(from.as_any_box().downcast::<HostShortNameInconsistentEvent>()?),
            StructType::HostDasOkEvent => Ok(from.as_any_box().downcast::<HostDasOkEvent>()?),
            StructType::HostDisconnectedEvent => Ok(from.as_any_box().downcast::<HostDisconnectedEvent>()?),
            StructType::HostEnableAdminFailedEvent => Ok(from.as_any_box().downcast::<HostEnableAdminFailedEvent>()?),
            StructType::HostGetShortNameFailedEvent => Ok(from.as_any_box().downcast::<HostGetShortNameFailedEvent>()?),
            StructType::HostInAuditModeEvent => Ok(from.as_any_box().downcast::<HostInAuditModeEvent>()?),
            StructType::HostIpChangedEvent => Ok(from.as_any_box().downcast::<HostIpChangedEvent>()?),
            StructType::HostIpInconsistentEvent => Ok(from.as_any_box().downcast::<HostIpInconsistentEvent>()?),
            StructType::HostIpToShortNameFailedEvent => Ok(from.as_any_box().downcast::<HostIpToShortNameFailedEvent>()?),
            StructType::HostNonCompliantEvent => Ok(from.as_any_box().downcast::<HostNonCompliantEvent>()?),
            StructType::HostProfileAppliedEvent => Ok(from.as_any_box().downcast::<HostProfileAppliedEvent>()?),
            StructType::HostReconnectionFailedEvent => Ok(from.as_any_box().downcast::<HostReconnectionFailedEvent>()?),
            StructType::HostRemovedEvent => Ok(from.as_any_box().downcast::<HostRemovedEvent>()?),
            StructType::HostShortNameToIpFailedEvent => Ok(from.as_any_box().downcast::<HostShortNameToIpFailedEvent>()?),
            StructType::HostShutdownEvent => Ok(from.as_any_box().downcast::<HostShutdownEvent>()?),
            StructType::HostSpecificationChangedEvent => Ok(from.as_any_box().downcast::<HostSpecificationChangedEvent>()?),
            StructType::HostSpecificationRequireEvent => Ok(from.as_any_box().downcast::<HostSpecificationRequireEvent>()?),
            StructType::HostSpecificationUpdateEvent => Ok(from.as_any_box().downcast::<HostSpecificationUpdateEvent>()?),
            StructType::HostSubSpecificationDeleteEvent => Ok(from.as_any_box().downcast::<HostSubSpecificationDeleteEvent>()?),
            StructType::HostSubSpecificationUpdateEvent => Ok(from.as_any_box().downcast::<HostSubSpecificationUpdateEvent>()?),
            StructType::HostSyncFailedEvent => Ok(from.as_any_box().downcast::<HostSyncFailedEvent>()?),
            StructType::HostUpgradeFailedEvent => Ok(from.as_any_box().downcast::<HostUpgradeFailedEvent>()?),
            StructType::HostUserWorldSwapNotEnabledEvent => Ok(from.as_any_box().downcast::<HostUserWorldSwapNotEnabledEvent>()?),
            StructType::HostVnicConnectedToCustomizedDvPortEvent => Ok(from.as_any_box().downcast::<HostVnicConnectedToCustomizedDvPortEvent>()?),
            StructType::HostWwnChangedEvent => Ok(from.as_any_box().downcast::<HostWwnChangedEvent>()?),
            StructType::HostWwnConflictEvent => Ok(from.as_any_box().downcast::<HostWwnConflictEvent>()?),
            StructType::LocalDatastoreCreatedEvent => Ok(from.as_any_box().downcast::<LocalDatastoreCreatedEvent>()?),
            StructType::LocalTsmEnabledEvent => Ok(from.as_any_box().downcast::<LocalTsmEnabledEvent>()?),
            StructType::NasDatastoreCreatedEvent => Ok(from.as_any_box().downcast::<NasDatastoreCreatedEvent>()?),
            StructType::NoDatastoresConfiguredEvent => Ok(from.as_any_box().downcast::<NoDatastoresConfiguredEvent>()?),
            StructType::RemoteTsmEnabledEvent => Ok(from.as_any_box().downcast::<RemoteTsmEnabledEvent>()?),
            StructType::TimedOutHostOperationEvent => Ok(from.as_any_box().downcast::<TimedOutHostOperationEvent>()?),
            StructType::UpdatedAgentBeingRestartedEvent => Ok(from.as_any_box().downcast::<UpdatedAgentBeingRestartedEvent>()?),
            StructType::UserAssignedToGroup => Ok(from.as_any_box().downcast::<UserAssignedToGroup>()?),
            StructType::UserPasswordChanged => Ok(from.as_any_box().downcast::<UserPasswordChanged>()?),
            StructType::UserUnassignedFromGroup => Ok(from.as_any_box().downcast::<UserUnassignedFromGroup>()?),
            StructType::VmfsDatastoreCreatedEvent => Ok(from.as_any_box().downcast::<VmfsDatastoreCreatedEvent>()?),
            StructType::VmfsDatastoreExpandedEvent => Ok(from.as_any_box().downcast::<VmfsDatastoreExpandedEvent>()?),
            StructType::VmfsDatastoreExtendedEvent => Ok(from.as_any_box().downcast::<VmfsDatastoreExtendedEvent>()?),
            StructType::VcAgentUninstallFailedEvent => Ok(from.as_any_box().downcast::<VcAgentUninstallFailedEvent>()?),
            StructType::VcAgentUninstalledEvent => Ok(from.as_any_box().downcast::<VcAgentUninstalledEvent>()?),
            StructType::VcAgentUpgradeFailedEvent => Ok(from.as_any_box().downcast::<VcAgentUpgradeFailedEvent>()?),
            StructType::VcAgentUpgradedEvent => Ok(from.as_any_box().downcast::<VcAgentUpgradedEvent>()?),
            StructType::VimAccountPasswordChangedEvent => Ok(from.as_any_box().downcast::<VimAccountPasswordChangedEvent>()?),
            StructType::IScsiBootFailureEvent => Ok(from.as_any_box().downcast::<IScsiBootFailureEvent>()?),
            StructType::HostInventoryUnreadableEvent => Ok(from.as_any_box().downcast::<HostInventoryUnreadableEvent>()?),
            StructType::LicenseEvent => Ok(from.as_any_box().downcast::<LicenseEvent>()?),
            StructType::AllVirtualMachinesLicensedEvent => Ok(from.as_any_box().downcast::<AllVirtualMachinesLicensedEvent>()?),
            StructType::HostInventoryFullEvent => Ok(from.as_any_box().downcast::<HostInventoryFullEvent>()?),
            StructType::HostLicenseExpiredEvent => Ok(from.as_any_box().downcast::<HostLicenseExpiredEvent>()?),
            StructType::IncorrectHostInformationEvent => Ok(from.as_any_box().downcast::<IncorrectHostInformationEvent>()?),
            StructType::InvalidEditionEvent => Ok(from.as_any_box().downcast::<InvalidEditionEvent>()?),
            StructType::LicenseNonComplianceEvent => Ok(from.as_any_box().downcast::<LicenseNonComplianceEvent>()?),
            StructType::LicenseRestrictedEvent => Ok(from.as_any_box().downcast::<LicenseRestrictedEvent>()?),
            StructType::LicenseServerAvailableEvent => Ok(from.as_any_box().downcast::<LicenseServerAvailableEvent>()?),
            StructType::LicenseServerUnavailableEvent => Ok(from.as_any_box().downcast::<LicenseServerUnavailableEvent>()?),
            StructType::NoLicenseEvent => Ok(from.as_any_box().downcast::<NoLicenseEvent>()?),
            StructType::ServerLicenseExpiredEvent => Ok(from.as_any_box().downcast::<ServerLicenseExpiredEvent>()?),
            StructType::UnlicensedVirtualMachinesEvent => Ok(from.as_any_box().downcast::<UnlicensedVirtualMachinesEvent>()?),
            StructType::UnlicensedVirtualMachinesFoundEvent => Ok(from.as_any_box().downcast::<UnlicensedVirtualMachinesFoundEvent>()?),
            StructType::VMotionLicenseExpiredEvent => Ok(from.as_any_box().downcast::<VMotionLicenseExpiredEvent>()?),
            StructType::LicenseExpiredEvent => Ok(from.as_any_box().downcast::<LicenseExpiredEvent>()?),
            StructType::LockerMisconfiguredEvent => Ok(from.as_any_box().downcast::<LockerMisconfiguredEvent>()?),
            StructType::LockerReconfiguredEvent => Ok(from.as_any_box().downcast::<LockerReconfiguredEvent>()?),
            StructType::NetworkRollbackEvent => Ok(from.as_any_box().downcast::<NetworkRollbackEvent>()?),
            StructType::ProfileEvent => Ok(from.as_any_box().downcast::<ProfileEvent>()?),
            StructType::ProfileAssociatedEvent => Ok(from.as_any_box().downcast::<ProfileAssociatedEvent>()?),
            StructType::ProfileChangedEvent => Ok(from.as_any_box().downcast::<ProfileChangedEvent>()?),
            StructType::ProfileCreatedEvent => Ok(from.as_any_box().downcast::<ProfileCreatedEvent>()?),
            StructType::ProfileDissociatedEvent => Ok(from.as_any_box().downcast::<ProfileDissociatedEvent>()?),
            StructType::ProfileReferenceHostChangedEvent => Ok(from.as_any_box().downcast::<ProfileReferenceHostChangedEvent>()?),
            StructType::ProfileRemovedEvent => Ok(from.as_any_box().downcast::<ProfileRemovedEvent>()?),
            StructType::ResourcePoolEvent => Ok(from.as_any_box().downcast::<ResourcePoolEvent>()?),
            StructType::ResourcePoolCreatedEvent => Ok(from.as_any_box().downcast::<ResourcePoolCreatedEvent>()?),
            StructType::ResourcePoolDestroyedEvent => Ok(from.as_any_box().downcast::<ResourcePoolDestroyedEvent>()?),
            StructType::ResourcePoolMovedEvent => Ok(from.as_any_box().downcast::<ResourcePoolMovedEvent>()?),
            StructType::ResourcePoolReconfiguredEvent => Ok(from.as_any_box().downcast::<ResourcePoolReconfiguredEvent>()?),
            StructType::ResourceViolatedEvent => Ok(from.as_any_box().downcast::<ResourceViolatedEvent>()?),
            StructType::ScheduledTaskEvent => Ok(from.as_any_box().downcast::<ScheduledTaskEvent>()?),
            StructType::ScheduledTaskCompletedEvent => Ok(from.as_any_box().downcast::<ScheduledTaskCompletedEvent>()?),
            StructType::ScheduledTaskCreatedEvent => Ok(from.as_any_box().downcast::<ScheduledTaskCreatedEvent>()?),
            StructType::ScheduledTaskEmailCompletedEvent => Ok(from.as_any_box().downcast::<ScheduledTaskEmailCompletedEvent>()?),
            StructType::ScheduledTaskEmailFailedEvent => Ok(from.as_any_box().downcast::<ScheduledTaskEmailFailedEvent>()?),
            StructType::ScheduledTaskFailedEvent => Ok(from.as_any_box().downcast::<ScheduledTaskFailedEvent>()?),
            StructType::ScheduledTaskReconfiguredEvent => Ok(from.as_any_box().downcast::<ScheduledTaskReconfiguredEvent>()?),
            StructType::ScheduledTaskRemovedEvent => Ok(from.as_any_box().downcast::<ScheduledTaskRemovedEvent>()?),
            StructType::ScheduledTaskStartedEvent => Ok(from.as_any_box().downcast::<ScheduledTaskStartedEvent>()?),
            StructType::SessionEvent => Ok(from.as_any_box().downcast::<SessionEvent>()?),
            StructType::AlreadyAuthenticatedSessionEvent => Ok(from.as_any_box().downcast::<AlreadyAuthenticatedSessionEvent>()?),
            StructType::BadUsernameSessionEvent => Ok(from.as_any_box().downcast::<BadUsernameSessionEvent>()?),
            StructType::GlobalMessageChangedEvent => Ok(from.as_any_box().downcast::<GlobalMessageChangedEvent>()?),
            StructType::NoAccessUserEvent => Ok(from.as_any_box().downcast::<NoAccessUserEvent>()?),
            StructType::ServerStartedSessionEvent => Ok(from.as_any_box().downcast::<ServerStartedSessionEvent>()?),
            StructType::SessionTerminatedEvent => Ok(from.as_any_box().downcast::<SessionTerminatedEvent>()?),
            StructType::UserLoginSessionEvent => Ok(from.as_any_box().downcast::<UserLoginSessionEvent>()?),
            StructType::UserLogoutSessionEvent => Ok(from.as_any_box().downcast::<UserLogoutSessionEvent>()?),
            StructType::TaskEvent => Ok(from.as_any_box().downcast::<TaskEvent>()?),
            StructType::TaskTimeoutEvent => Ok(from.as_any_box().downcast::<TaskTimeoutEvent>()?),
            StructType::TemplateUpgradeEvent => Ok(from.as_any_box().downcast::<TemplateUpgradeEvent>()?),
            StructType::TemplateBeingUpgradedEvent => Ok(from.as_any_box().downcast::<TemplateBeingUpgradedEvent>()?),
            StructType::TemplateUpgradeFailedEvent => Ok(from.as_any_box().downcast::<TemplateUpgradeFailedEvent>()?),
            StructType::TemplateUpgradedEvent => Ok(from.as_any_box().downcast::<TemplateUpgradedEvent>()?),
            StructType::UpgradeEvent => Ok(from.as_any_box().downcast::<UpgradeEvent>()?),
            StructType::ErrorUpgradeEvent => Ok(from.as_any_box().downcast::<ErrorUpgradeEvent>()?),
            StructType::InfoUpgradeEvent => Ok(from.as_any_box().downcast::<InfoUpgradeEvent>()?),
            StructType::UserUpgradeEvent => Ok(from.as_any_box().downcast::<UserUpgradeEvent>()?),
            StructType::WarningUpgradeEvent => Ok(from.as_any_box().downcast::<WarningUpgradeEvent>()?),
            StructType::VmEvent => Ok(from.as_any_box().downcast::<VmEvent>()?),
            StructType::CustomizationEvent => Ok(from.as_any_box().downcast::<CustomizationEvent>()?),
            StructType::CustomizationFailed => Ok(from.as_any_box().downcast::<CustomizationFailed>()?),
            StructType::CustomizationLinuxIdentityFailed => Ok(from.as_any_box().downcast::<CustomizationLinuxIdentityFailed>()?),
            StructType::CustomizationNetworkSetupFailed => Ok(from.as_any_box().downcast::<CustomizationNetworkSetupFailed>()?),
            StructType::CustomizationSysprepFailed => Ok(from.as_any_box().downcast::<CustomizationSysprepFailed>()?),
            StructType::CustomizationUnknownFailure => Ok(from.as_any_box().downcast::<CustomizationUnknownFailure>()?),
            StructType::CustomizationStartedEvent => Ok(from.as_any_box().downcast::<CustomizationStartedEvent>()?),
            StructType::CustomizationSucceeded => Ok(from.as_any_box().downcast::<CustomizationSucceeded>()?),
            StructType::DrsRuleComplianceEvent => Ok(from.as_any_box().downcast::<DrsRuleComplianceEvent>()?),
            StructType::DrsRuleViolationEvent => Ok(from.as_any_box().downcast::<DrsRuleViolationEvent>()?),
            StructType::DrsSoftRuleViolationEvent => Ok(from.as_any_box().downcast::<DrsSoftRuleViolationEvent>()?),
            StructType::MigrationEvent => Ok(from.as_any_box().downcast::<MigrationEvent>()?),
            StructType::MigrationErrorEvent => Ok(from.as_any_box().downcast::<MigrationErrorEvent>()?),
            StructType::MigrationHostErrorEvent => Ok(from.as_any_box().downcast::<MigrationHostErrorEvent>()?),
            StructType::MigrationHostWarningEvent => Ok(from.as_any_box().downcast::<MigrationHostWarningEvent>()?),
            StructType::MigrationResourceErrorEvent => Ok(from.as_any_box().downcast::<MigrationResourceErrorEvent>()?),
            StructType::MigrationResourceWarningEvent => Ok(from.as_any_box().downcast::<MigrationResourceWarningEvent>()?),
            StructType::MigrationWarningEvent => Ok(from.as_any_box().downcast::<MigrationWarningEvent>()?),
            StructType::NoMaintenanceModeDrsRecommendationForVm => Ok(from.as_any_box().downcast::<NoMaintenanceModeDrsRecommendationForVm>()?),
            StructType::NotEnoughResourcesToStartVmEvent => Ok(from.as_any_box().downcast::<NotEnoughResourcesToStartVmEvent>()?),
            StructType::VmAcquiredMksTicketEvent => Ok(from.as_any_box().downcast::<VmAcquiredMksTicketEvent>()?),
            StructType::VmAcquiredTicketEvent => Ok(from.as_any_box().downcast::<VmAcquiredTicketEvent>()?),
            StructType::VmAutoRenameEvent => Ok(from.as_any_box().downcast::<VmAutoRenameEvent>()?),
            StructType::VmBeingCreatedEvent => Ok(from.as_any_box().downcast::<VmBeingCreatedEvent>()?),
            StructType::VmBeingDeployedEvent => Ok(from.as_any_box().downcast::<VmBeingDeployedEvent>()?),
            StructType::VmBeingHotMigratedEvent => Ok(from.as_any_box().downcast::<VmBeingHotMigratedEvent>()?),
            StructType::VmBeingMigratedEvent => Ok(from.as_any_box().downcast::<VmBeingMigratedEvent>()?),
            StructType::VmCloneEvent => Ok(from.as_any_box().downcast::<VmCloneEvent>()?),
            StructType::VmBeingClonedEvent => Ok(from.as_any_box().downcast::<VmBeingClonedEvent>()?),
            StructType::VmBeingClonedNoFolderEvent => Ok(from.as_any_box().downcast::<VmBeingClonedNoFolderEvent>()?),
            StructType::VmCloneFailedEvent => Ok(from.as_any_box().downcast::<VmCloneFailedEvent>()?),
            StructType::VmClonedEvent => Ok(from.as_any_box().downcast::<VmClonedEvent>()?),
            StructType::VmConfigMissingEvent => Ok(from.as_any_box().downcast::<VmConfigMissingEvent>()?),
            StructType::VmConnectedEvent => Ok(from.as_any_box().downcast::<VmConnectedEvent>()?),
            StructType::VmCreatedEvent => Ok(from.as_any_box().downcast::<VmCreatedEvent>()?),
            StructType::VmDasBeingResetEvent => Ok(from.as_any_box().downcast::<VmDasBeingResetEvent>()?),
            StructType::VmDasBeingResetWithScreenshotEvent => Ok(from.as_any_box().downcast::<VmDasBeingResetWithScreenshotEvent>()?),
            StructType::VmDasResetFailedEvent => Ok(from.as_any_box().downcast::<VmDasResetFailedEvent>()?),
            StructType::VmDasUpdateErrorEvent => Ok(from.as_any_box().downcast::<VmDasUpdateErrorEvent>()?),
            StructType::VmDasUpdateOkEvent => Ok(from.as_any_box().downcast::<VmDasUpdateOkEvent>()?),
            StructType::VmDateRolledBackEvent => Ok(from.as_any_box().downcast::<VmDateRolledBackEvent>()?),
            StructType::VmDeployFailedEvent => Ok(from.as_any_box().downcast::<VmDeployFailedEvent>()?),
            StructType::VmDeployedEvent => Ok(from.as_any_box().downcast::<VmDeployedEvent>()?),
            StructType::VmDisconnectedEvent => Ok(from.as_any_box().downcast::<VmDisconnectedEvent>()?),
            StructType::VmDiscoveredEvent => Ok(from.as_any_box().downcast::<VmDiscoveredEvent>()?),
            StructType::VmDiskFailedEvent => Ok(from.as_any_box().downcast::<VmDiskFailedEvent>()?),
            StructType::VmEmigratingEvent => Ok(from.as_any_box().downcast::<VmEmigratingEvent>()?),
            StructType::VmEndRecordingEvent => Ok(from.as_any_box().downcast::<VmEndRecordingEvent>()?),
            StructType::VmEndReplayingEvent => Ok(from.as_any_box().downcast::<VmEndReplayingEvent>()?),
            StructType::VmFailedMigrateEvent => Ok(from.as_any_box().downcast::<VmFailedMigrateEvent>()?),
            StructType::VmFailedRelayoutEvent => Ok(from.as_any_box().downcast::<VmFailedRelayoutEvent>()?),
            StructType::VmFailedRelayoutOnVmfs2DatastoreEvent => Ok(from.as_any_box().downcast::<VmFailedRelayoutOnVmfs2DatastoreEvent>()?),
            StructType::VmFailedStartingSecondaryEvent => Ok(from.as_any_box().downcast::<VmFailedStartingSecondaryEvent>()?),
            StructType::VmFailedToPowerOffEvent => Ok(from.as_any_box().downcast::<VmFailedToPowerOffEvent>()?),
            StructType::VmFailedToPowerOnEvent => Ok(from.as_any_box().downcast::<VmFailedToPowerOnEvent>()?),
            StructType::VmFailedToRebootGuestEvent => Ok(from.as_any_box().downcast::<VmFailedToRebootGuestEvent>()?),
            StructType::VmFailedToResetEvent => Ok(from.as_any_box().downcast::<VmFailedToResetEvent>()?),
            StructType::VmFailedToShutdownGuestEvent => Ok(from.as_any_box().downcast::<VmFailedToShutdownGuestEvent>()?),
            StructType::VmFailedToStandbyGuestEvent => Ok(from.as_any_box().downcast::<VmFailedToStandbyGuestEvent>()?),
            StructType::VmFailedToSuspendEvent => Ok(from.as_any_box().downcast::<VmFailedToSuspendEvent>()?),
            StructType::VmFailedUpdatingSecondaryConfig => Ok(from.as_any_box().downcast::<VmFailedUpdatingSecondaryConfig>()?),
            StructType::VmFailoverFailed => Ok(from.as_any_box().downcast::<VmFailoverFailed>()?),
            StructType::VmFaultToleranceStateChangedEvent => Ok(from.as_any_box().downcast::<VmFaultToleranceStateChangedEvent>()?),
            StructType::VmFaultToleranceTurnedOffEvent => Ok(from.as_any_box().downcast::<VmFaultToleranceTurnedOffEvent>()?),
            StructType::VmFaultToleranceVmTerminatedEvent => Ok(from.as_any_box().downcast::<VmFaultToleranceVmTerminatedEvent>()?),
            StructType::VmGuestOsCrashedEvent => Ok(from.as_any_box().downcast::<VmGuestOsCrashedEvent>()?),
            StructType::VmGuestRebootEvent => Ok(from.as_any_box().downcast::<VmGuestRebootEvent>()?),
            StructType::VmGuestShutdownEvent => Ok(from.as_any_box().downcast::<VmGuestShutdownEvent>()?),
            StructType::VmGuestStandbyEvent => Ok(from.as_any_box().downcast::<VmGuestStandbyEvent>()?),
            StructType::VmInstanceUuidAssignedEvent => Ok(from.as_any_box().downcast::<VmInstanceUuidAssignedEvent>()?),
            StructType::VmInstanceUuidChangedEvent => Ok(from.as_any_box().downcast::<VmInstanceUuidChangedEvent>()?),
            StructType::VmInstanceUuidConflictEvent => Ok(from.as_any_box().downcast::<VmInstanceUuidConflictEvent>()?),
            StructType::VmMacAssignedEvent => Ok(from.as_any_box().downcast::<VmMacAssignedEvent>()?),
            StructType::VmMacChangedEvent => Ok(from.as_any_box().downcast::<VmMacChangedEvent>()?),
            StructType::VmMacConflictEvent => Ok(from.as_any_box().downcast::<VmMacConflictEvent>()?),
            StructType::VmMaxFtRestartCountReached => Ok(from.as_any_box().downcast::<VmMaxFtRestartCountReached>()?),
            StructType::VmMaxRestartCountReached => Ok(from.as_any_box().downcast::<VmMaxRestartCountReached>()?),
            StructType::VmMessageErrorEvent => Ok(from.as_any_box().downcast::<VmMessageErrorEvent>()?),
            StructType::VmMessageEvent => Ok(from.as_any_box().downcast::<VmMessageEvent>()?),
            StructType::VmMessageWarningEvent => Ok(from.as_any_box().downcast::<VmMessageWarningEvent>()?),
            StructType::VmMigratedEvent => Ok(from.as_any_box().downcast::<VmMigratedEvent>()?),
            StructType::DrsVmMigratedEvent => Ok(from.as_any_box().downcast::<DrsVmMigratedEvent>()?),
            StructType::VmNoCompatibleHostForSecondaryEvent => Ok(from.as_any_box().downcast::<VmNoCompatibleHostForSecondaryEvent>()?),
            StructType::VmNoNetworkAccessEvent => Ok(from.as_any_box().downcast::<VmNoNetworkAccessEvent>()?),
            StructType::VmOrphanedEvent => Ok(from.as_any_box().downcast::<VmOrphanedEvent>()?),
            StructType::VmPoweredOffEvent => Ok(from.as_any_box().downcast::<VmPoweredOffEvent>()?),
            StructType::VmPowerOffOnIsolationEvent => Ok(from.as_any_box().downcast::<VmPowerOffOnIsolationEvent>()?),
            StructType::VmShutdownOnIsolationEvent => Ok(from.as_any_box().downcast::<VmShutdownOnIsolationEvent>()?),
            StructType::VmPoweredOnEvent => Ok(from.as_any_box().downcast::<VmPoweredOnEvent>()?),
            StructType::DrsVmPoweredOnEvent => Ok(from.as_any_box().downcast::<DrsVmPoweredOnEvent>()?),
            StructType::VmRestartedOnAlternateHostEvent => Ok(from.as_any_box().downcast::<VmRestartedOnAlternateHostEvent>()?),
            StructType::VmPoweringOnWithCustomizedDvPortEvent => Ok(from.as_any_box().downcast::<VmPoweringOnWithCustomizedDvPortEvent>()?),
            StructType::VmPrimaryFailoverEvent => Ok(from.as_any_box().downcast::<VmPrimaryFailoverEvent>()?),
            StructType::VmReconfiguredEvent => Ok(from.as_any_box().downcast::<VmReconfiguredEvent>()?),
            StructType::VmRegisteredEvent => Ok(from.as_any_box().downcast::<VmRegisteredEvent>()?),
            StructType::VmRelayoutSuccessfulEvent => Ok(from.as_any_box().downcast::<VmRelayoutSuccessfulEvent>()?),
            StructType::VmRelayoutUpToDateEvent => Ok(from.as_any_box().downcast::<VmRelayoutUpToDateEvent>()?),
            StructType::VmReloadFromPathEvent => Ok(from.as_any_box().downcast::<VmReloadFromPathEvent>()?),
            StructType::VmReloadFromPathFailedEvent => Ok(from.as_any_box().downcast::<VmReloadFromPathFailedEvent>()?),
            StructType::VmRelocateSpecEvent => Ok(from.as_any_box().downcast::<VmRelocateSpecEvent>()?),
            StructType::VmBeingRelocatedEvent => Ok(from.as_any_box().downcast::<VmBeingRelocatedEvent>()?),
            StructType::VmRelocateFailedEvent => Ok(from.as_any_box().downcast::<VmRelocateFailedEvent>()?),
            StructType::VmRelocatedEvent => Ok(from.as_any_box().downcast::<VmRelocatedEvent>()?),
            StructType::VmRemoteConsoleConnectedEvent => Ok(from.as_any_box().downcast::<VmRemoteConsoleConnectedEvent>()?),
            StructType::VmRemoteConsoleDisconnectedEvent => Ok(from.as_any_box().downcast::<VmRemoteConsoleDisconnectedEvent>()?),
            StructType::VmRemovedEvent => Ok(from.as_any_box().downcast::<VmRemovedEvent>()?),
            StructType::VmRenamedEvent => Ok(from.as_any_box().downcast::<VmRenamedEvent>()?),
            StructType::VmRequirementsExceedCurrentEvcModeEvent => Ok(from.as_any_box().downcast::<VmRequirementsExceedCurrentEvcModeEvent>()?),
            StructType::VmResettingEvent => Ok(from.as_any_box().downcast::<VmResettingEvent>()?),
            StructType::VmResourcePoolMovedEvent => Ok(from.as_any_box().downcast::<VmResourcePoolMovedEvent>()?),
            StructType::VmResourceReallocatedEvent => Ok(from.as_any_box().downcast::<VmResourceReallocatedEvent>()?),
            StructType::VmResumingEvent => Ok(from.as_any_box().downcast::<VmResumingEvent>()?),
            StructType::VmSecondaryAddedEvent => Ok(from.as_any_box().downcast::<VmSecondaryAddedEvent>()?),
            StructType::VmSecondaryDisabledBySystemEvent => Ok(from.as_any_box().downcast::<VmSecondaryDisabledBySystemEvent>()?),
            StructType::VmSecondaryDisabledEvent => Ok(from.as_any_box().downcast::<VmSecondaryDisabledEvent>()?),
            StructType::VmSecondaryEnabledEvent => Ok(from.as_any_box().downcast::<VmSecondaryEnabledEvent>()?),
            StructType::VmSecondaryStartedEvent => Ok(from.as_any_box().downcast::<VmSecondaryStartedEvent>()?),
            StructType::VmStartRecordingEvent => Ok(from.as_any_box().downcast::<VmStartRecordingEvent>()?),
            StructType::VmStartReplayingEvent => Ok(from.as_any_box().downcast::<VmStartReplayingEvent>()?),
            StructType::VmStartingEvent => Ok(from.as_any_box().downcast::<VmStartingEvent>()?),
            StructType::VmUnsupportedStartingEvent => Ok(from.as_any_box().downcast::<VmUnsupportedStartingEvent>()?),
            StructType::VmStartingSecondaryEvent => Ok(from.as_any_box().downcast::<VmStartingSecondaryEvent>()?),
            StructType::VmStaticMacConflictEvent => Ok(from.as_any_box().downcast::<VmStaticMacConflictEvent>()?),
            StructType::VmStoppingEvent => Ok(from.as_any_box().downcast::<VmStoppingEvent>()?),
            StructType::VmSuspendedEvent => Ok(from.as_any_box().downcast::<VmSuspendedEvent>()?),
            StructType::VmSuspendingEvent => Ok(from.as_any_box().downcast::<VmSuspendingEvent>()?),
            StructType::VmTimedoutStartingSecondaryEvent => Ok(from.as_any_box().downcast::<VmTimedoutStartingSecondaryEvent>()?),
            StructType::VmUpgradeCompleteEvent => Ok(from.as_any_box().downcast::<VmUpgradeCompleteEvent>()?),
            StructType::VmUpgradeFailedEvent => Ok(from.as_any_box().downcast::<VmUpgradeFailedEvent>()?),
            StructType::VmUpgradingEvent => Ok(from.as_any_box().downcast::<VmUpgradingEvent>()?),
            StructType::VmUuidAssignedEvent => Ok(from.as_any_box().downcast::<VmUuidAssignedEvent>()?),
            StructType::VmUuidChangedEvent => Ok(from.as_any_box().downcast::<VmUuidChangedEvent>()?),
            StructType::VmUuidConflictEvent => Ok(from.as_any_box().downcast::<VmUuidConflictEvent>()?),
            StructType::VmWwnAssignedEvent => Ok(from.as_any_box().downcast::<VmWwnAssignedEvent>()?),
            StructType::VmWwnChangedEvent => Ok(from.as_any_box().downcast::<VmWwnChangedEvent>()?),
            StructType::VmWwnConflictEvent => Ok(from.as_any_box().downcast::<VmWwnConflictEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This event is an alarm events.
pub trait AlarmEventTrait : super::traits::EventTrait {
    /// The associated alarm object.
    fn get_alarm(&self) -> &AlarmEventArgument;
}
impl<'s> serde::Serialize for dyn AlarmEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn AlarmEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(AlarmEventVisitor)
            }
        }

struct AlarmEventVisitor;

impl<'de> de::Visitor<'de> for AlarmEventVisitor {
    type Value = Box<dyn AlarmEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid AlarmEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl AlarmEventTrait for AlarmEvent {
    fn get_alarm(&self) -> &AlarmEventArgument { &self.alarm }
}
impl AlarmEventTrait for AlarmAcknowledgedEvent {
    fn get_alarm(&self) -> &AlarmEventArgument { &self.alarm }
}
impl AlarmEventTrait for AlarmActionTriggeredEvent {
    fn get_alarm(&self) -> &AlarmEventArgument { &self.alarm }
}
impl AlarmEventTrait for AlarmClearedEvent {
    fn get_alarm(&self) -> &AlarmEventArgument { &self.alarm }
}
impl AlarmEventTrait for AlarmCreatedEvent {
    fn get_alarm(&self) -> &AlarmEventArgument { &self.alarm }
}
impl AlarmEventTrait for AlarmEmailCompletedEvent {
    fn get_alarm(&self) -> &AlarmEventArgument { &self.alarm }
}
impl AlarmEventTrait for AlarmEmailFailedEvent {
    fn get_alarm(&self) -> &AlarmEventArgument { &self.alarm }
}
impl AlarmEventTrait for AlarmReconfiguredEvent {
    fn get_alarm(&self) -> &AlarmEventArgument { &self.alarm }
}
impl AlarmEventTrait for AlarmRemovedEvent {
    fn get_alarm(&self) -> &AlarmEventArgument { &self.alarm }
}
impl AlarmEventTrait for AlarmScriptCompleteEvent {
    fn get_alarm(&self) -> &AlarmEventArgument { &self.alarm }
}
impl AlarmEventTrait for AlarmScriptFailedEvent {
    fn get_alarm(&self) -> &AlarmEventArgument { &self.alarm }
}
impl AlarmEventTrait for AlarmSnmpCompletedEvent {
    fn get_alarm(&self) -> &AlarmEventArgument { &self.alarm }
}
impl AlarmEventTrait for AlarmSnmpFailedEvent {
    fn get_alarm(&self) -> &AlarmEventArgument { &self.alarm }
}
impl AlarmEventTrait for AlarmStatusChangedEvent {
    fn get_alarm(&self) -> &AlarmEventArgument { &self.alarm }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn AlarmEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::AlarmEvent => Some(from.as_any_ref().downcast_ref::<AlarmEvent>()?),
            StructType::AlarmAcknowledgedEvent => Some(from.as_any_ref().downcast_ref::<AlarmAcknowledgedEvent>()?),
            StructType::AlarmActionTriggeredEvent => Some(from.as_any_ref().downcast_ref::<AlarmActionTriggeredEvent>()?),
            StructType::AlarmClearedEvent => Some(from.as_any_ref().downcast_ref::<AlarmClearedEvent>()?),
            StructType::AlarmCreatedEvent => Some(from.as_any_ref().downcast_ref::<AlarmCreatedEvent>()?),
            StructType::AlarmEmailCompletedEvent => Some(from.as_any_ref().downcast_ref::<AlarmEmailCompletedEvent>()?),
            StructType::AlarmEmailFailedEvent => Some(from.as_any_ref().downcast_ref::<AlarmEmailFailedEvent>()?),
            StructType::AlarmReconfiguredEvent => Some(from.as_any_ref().downcast_ref::<AlarmReconfiguredEvent>()?),
            StructType::AlarmRemovedEvent => Some(from.as_any_ref().downcast_ref::<AlarmRemovedEvent>()?),
            StructType::AlarmScriptCompleteEvent => Some(from.as_any_ref().downcast_ref::<AlarmScriptCompleteEvent>()?),
            StructType::AlarmScriptFailedEvent => Some(from.as_any_ref().downcast_ref::<AlarmScriptFailedEvent>()?),
            StructType::AlarmSnmpCompletedEvent => Some(from.as_any_ref().downcast_ref::<AlarmSnmpCompletedEvent>()?),
            StructType::AlarmSnmpFailedEvent => Some(from.as_any_ref().downcast_ref::<AlarmSnmpFailedEvent>()?),
            StructType::AlarmStatusChangedEvent => Some(from.as_any_ref().downcast_ref::<AlarmStatusChangedEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::AlarmEvent => Ok(from.as_any_box().downcast::<AlarmEvent>()?),
            StructType::AlarmAcknowledgedEvent => Ok(from.as_any_box().downcast::<AlarmAcknowledgedEvent>()?),
            StructType::AlarmActionTriggeredEvent => Ok(from.as_any_box().downcast::<AlarmActionTriggeredEvent>()?),
            StructType::AlarmClearedEvent => Ok(from.as_any_box().downcast::<AlarmClearedEvent>()?),
            StructType::AlarmCreatedEvent => Ok(from.as_any_box().downcast::<AlarmCreatedEvent>()?),
            StructType::AlarmEmailCompletedEvent => Ok(from.as_any_box().downcast::<AlarmEmailCompletedEvent>()?),
            StructType::AlarmEmailFailedEvent => Ok(from.as_any_box().downcast::<AlarmEmailFailedEvent>()?),
            StructType::AlarmReconfiguredEvent => Ok(from.as_any_box().downcast::<AlarmReconfiguredEvent>()?),
            StructType::AlarmRemovedEvent => Ok(from.as_any_box().downcast::<AlarmRemovedEvent>()?),
            StructType::AlarmScriptCompleteEvent => Ok(from.as_any_box().downcast::<AlarmScriptCompleteEvent>()?),
            StructType::AlarmScriptFailedEvent => Ok(from.as_any_box().downcast::<AlarmScriptFailedEvent>()?),
            StructType::AlarmSnmpCompletedEvent => Ok(from.as_any_box().downcast::<AlarmSnmpCompletedEvent>()?),
            StructType::AlarmSnmpFailedEvent => Ok(from.as_any_box().downcast::<AlarmSnmpFailedEvent>()?),
            StructType::AlarmStatusChangedEvent => Ok(from.as_any_box().downcast::<AlarmStatusChangedEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// These events indicate authorization events.
pub trait AuthorizationEventTrait : super::traits::EventTrait {
}
impl<'s> serde::Serialize for dyn AuthorizationEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn AuthorizationEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(AuthorizationEventVisitor)
            }
        }

struct AuthorizationEventVisitor;

impl<'de> de::Visitor<'de> for AuthorizationEventVisitor {
    type Value = Box<dyn AuthorizationEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid AuthorizationEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl AuthorizationEventTrait for AuthorizationEvent {
}
impl AuthorizationEventTrait for PermissionEvent {
}
impl AuthorizationEventTrait for PermissionAddedEvent {
}
impl AuthorizationEventTrait for PermissionRemovedEvent {
}
impl AuthorizationEventTrait for PermissionUpdatedEvent {
}
impl AuthorizationEventTrait for RoleEvent {
}
impl AuthorizationEventTrait for RoleAddedEvent {
}
impl AuthorizationEventTrait for RoleRemovedEvent {
}
impl AuthorizationEventTrait for RoleUpdatedEvent {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn AuthorizationEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::AuthorizationEvent => Some(from.as_any_ref().downcast_ref::<AuthorizationEvent>()?),
            StructType::PermissionEvent => Some(from.as_any_ref().downcast_ref::<PermissionEvent>()?),
            StructType::PermissionAddedEvent => Some(from.as_any_ref().downcast_ref::<PermissionAddedEvent>()?),
            StructType::PermissionRemovedEvent => Some(from.as_any_ref().downcast_ref::<PermissionRemovedEvent>()?),
            StructType::PermissionUpdatedEvent => Some(from.as_any_ref().downcast_ref::<PermissionUpdatedEvent>()?),
            StructType::RoleEvent => Some(from.as_any_ref().downcast_ref::<RoleEvent>()?),
            StructType::RoleAddedEvent => Some(from.as_any_ref().downcast_ref::<RoleAddedEvent>()?),
            StructType::RoleRemovedEvent => Some(from.as_any_ref().downcast_ref::<RoleRemovedEvent>()?),
            StructType::RoleUpdatedEvent => Some(from.as_any_ref().downcast_ref::<RoleUpdatedEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::AuthorizationEvent => Ok(from.as_any_box().downcast::<AuthorizationEvent>()?),
            StructType::PermissionEvent => Ok(from.as_any_box().downcast::<PermissionEvent>()?),
            StructType::PermissionAddedEvent => Ok(from.as_any_box().downcast::<PermissionAddedEvent>()?),
            StructType::PermissionRemovedEvent => Ok(from.as_any_box().downcast::<PermissionRemovedEvent>()?),
            StructType::PermissionUpdatedEvent => Ok(from.as_any_box().downcast::<PermissionUpdatedEvent>()?),
            StructType::RoleEvent => Ok(from.as_any_box().downcast::<RoleEvent>()?),
            StructType::RoleAddedEvent => Ok(from.as_any_box().downcast::<RoleAddedEvent>()?),
            StructType::RoleRemovedEvent => Ok(from.as_any_box().downcast::<RoleRemovedEvent>()?),
            StructType::RoleUpdatedEvent => Ok(from.as_any_box().downcast::<RoleUpdatedEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This event records a permission operation.
pub trait PermissionEventTrait : super::traits::AuthorizationEventTrait {
    /// The entity to which the permission applied.
    fn get_entity(&self) -> &ManagedEntityEventArgument;
    /// The user name or group to which the permission was granted.
    fn get_principal(&self) -> &str;
    /// Whether or not the principal was a group.
    fn get_group(&self) -> bool;
}
impl<'s> serde::Serialize for dyn PermissionEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn PermissionEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(PermissionEventVisitor)
            }
        }

struct PermissionEventVisitor;

impl<'de> de::Visitor<'de> for PermissionEventVisitor {
    type Value = Box<dyn PermissionEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid PermissionEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl PermissionEventTrait for PermissionEvent {
    fn get_entity(&self) -> &ManagedEntityEventArgument { &self.entity }
    fn get_principal(&self) -> &str { &self.principal }
    fn get_group(&self) -> bool { self.group }
}
impl PermissionEventTrait for PermissionAddedEvent {
    fn get_entity(&self) -> &ManagedEntityEventArgument { &self.entity }
    fn get_principal(&self) -> &str { &self.principal }
    fn get_group(&self) -> bool { self.group }
}
impl PermissionEventTrait for PermissionRemovedEvent {
    fn get_entity(&self) -> &ManagedEntityEventArgument { &self.entity }
    fn get_principal(&self) -> &str { &self.principal }
    fn get_group(&self) -> bool { self.group }
}
impl PermissionEventTrait for PermissionUpdatedEvent {
    fn get_entity(&self) -> &ManagedEntityEventArgument { &self.entity }
    fn get_principal(&self) -> &str { &self.principal }
    fn get_group(&self) -> bool { self.group }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn PermissionEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::PermissionEvent => Some(from.as_any_ref().downcast_ref::<PermissionEvent>()?),
            StructType::PermissionAddedEvent => Some(from.as_any_ref().downcast_ref::<PermissionAddedEvent>()?),
            StructType::PermissionRemovedEvent => Some(from.as_any_ref().downcast_ref::<PermissionRemovedEvent>()?),
            StructType::PermissionUpdatedEvent => Some(from.as_any_ref().downcast_ref::<PermissionUpdatedEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::PermissionEvent => Ok(from.as_any_box().downcast::<PermissionEvent>()?),
            StructType::PermissionAddedEvent => Ok(from.as_any_box().downcast::<PermissionAddedEvent>()?),
            StructType::PermissionRemovedEvent => Ok(from.as_any_box().downcast::<PermissionRemovedEvent>()?),
            StructType::PermissionUpdatedEvent => Ok(from.as_any_box().downcast::<PermissionUpdatedEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This event records a role operation.
pub trait RoleEventTrait : super::traits::AuthorizationEventTrait {
    /// The associated role.
    fn get_role(&self) -> &RoleEventArgument;
}
impl<'s> serde::Serialize for dyn RoleEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn RoleEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(RoleEventVisitor)
            }
        }

struct RoleEventVisitor;

impl<'de> de::Visitor<'de> for RoleEventVisitor {
    type Value = Box<dyn RoleEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid RoleEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl RoleEventTrait for RoleEvent {
    fn get_role(&self) -> &RoleEventArgument { &self.role }
}
impl RoleEventTrait for RoleAddedEvent {
    fn get_role(&self) -> &RoleEventArgument { &self.role }
}
impl RoleEventTrait for RoleRemovedEvent {
    fn get_role(&self) -> &RoleEventArgument { &self.role }
}
impl RoleEventTrait for RoleUpdatedEvent {
    fn get_role(&self) -> &RoleEventArgument { &self.role }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn RoleEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::RoleEvent => Some(from.as_any_ref().downcast_ref::<RoleEvent>()?),
            StructType::RoleAddedEvent => Some(from.as_any_ref().downcast_ref::<RoleAddedEvent>()?),
            StructType::RoleRemovedEvent => Some(from.as_any_ref().downcast_ref::<RoleRemovedEvent>()?),
            StructType::RoleUpdatedEvent => Some(from.as_any_ref().downcast_ref::<RoleUpdatedEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::RoleEvent => Ok(from.as_any_box().downcast::<RoleEvent>()?),
            StructType::RoleAddedEvent => Ok(from.as_any_box().downcast::<RoleAddedEvent>()?),
            StructType::RoleRemovedEvent => Ok(from.as_any_box().downcast::<RoleRemovedEvent>()?),
            StructType::RoleUpdatedEvent => Ok(from.as_any_box().downcast::<RoleUpdatedEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// These are cluster events.
pub trait ClusterEventTrait : super::traits::EventTrait {
}
impl<'s> serde::Serialize for dyn ClusterEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ClusterEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ClusterEventVisitor)
            }
        }

struct ClusterEventVisitor;

impl<'de> de::Visitor<'de> for ClusterEventVisitor {
    type Value = Box<dyn ClusterEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ClusterEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ClusterEventTrait for ClusterEvent {
}
impl ClusterEventTrait for ClusterComplianceCheckedEvent {
}
impl ClusterEventTrait for ClusterCreatedEvent {
}
impl ClusterEventTrait for ClusterDestroyedEvent {
}
impl ClusterEventTrait for ClusterOvercommittedEvent {
}
impl ClusterEventTrait for HostOvercommittedEvent {
}
impl ClusterEventTrait for ClusterReconfiguredEvent {
}
impl ClusterEventTrait for ClusterStatusChangedEvent {
}
impl ClusterEventTrait for HostStatusChangedEvent {
}
impl ClusterEventTrait for DasAdmissionControlDisabledEvent {
}
impl ClusterEventTrait for DasAdmissionControlEnabledEvent {
}
impl ClusterEventTrait for DasAgentFoundEvent {
}
impl ClusterEventTrait for DasAgentUnavailableEvent {
}
impl ClusterEventTrait for DasClusterIsolatedEvent {
}
impl ClusterEventTrait for DasDisabledEvent {
}
impl ClusterEventTrait for DasEnabledEvent {
}
impl ClusterEventTrait for DasHostFailedEvent {
}
impl ClusterEventTrait for DasHostIsolatedEvent {
}
impl ClusterEventTrait for DrsDisabledEvent {
}
impl ClusterEventTrait for DrsEnabledEvent {
}
impl ClusterEventTrait for DrsInvocationFailedEvent {
}
impl ClusterEventTrait for DrsRecoveredFromFailureEvent {
}
impl ClusterEventTrait for FailoverLevelRestored {
}
impl ClusterEventTrait for HostMonitoringStateChangedEvent {
}
impl ClusterEventTrait for InsufficientFailoverResourcesEvent {
}
impl ClusterEventTrait for VmHealthMonitoringStateChangedEvent {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ClusterEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterEvent => Some(from.as_any_ref().downcast_ref::<ClusterEvent>()?),
            StructType::ClusterComplianceCheckedEvent => Some(from.as_any_ref().downcast_ref::<ClusterComplianceCheckedEvent>()?),
            StructType::ClusterCreatedEvent => Some(from.as_any_ref().downcast_ref::<ClusterCreatedEvent>()?),
            StructType::ClusterDestroyedEvent => Some(from.as_any_ref().downcast_ref::<ClusterDestroyedEvent>()?),
            StructType::ClusterOvercommittedEvent => Some(from.as_any_ref().downcast_ref::<ClusterOvercommittedEvent>()?),
            StructType::HostOvercommittedEvent => Some(from.as_any_ref().downcast_ref::<HostOvercommittedEvent>()?),
            StructType::ClusterReconfiguredEvent => Some(from.as_any_ref().downcast_ref::<ClusterReconfiguredEvent>()?),
            StructType::ClusterStatusChangedEvent => Some(from.as_any_ref().downcast_ref::<ClusterStatusChangedEvent>()?),
            StructType::HostStatusChangedEvent => Some(from.as_any_ref().downcast_ref::<HostStatusChangedEvent>()?),
            StructType::DasAdmissionControlDisabledEvent => Some(from.as_any_ref().downcast_ref::<DasAdmissionControlDisabledEvent>()?),
            StructType::DasAdmissionControlEnabledEvent => Some(from.as_any_ref().downcast_ref::<DasAdmissionControlEnabledEvent>()?),
            StructType::DasAgentFoundEvent => Some(from.as_any_ref().downcast_ref::<DasAgentFoundEvent>()?),
            StructType::DasAgentUnavailableEvent => Some(from.as_any_ref().downcast_ref::<DasAgentUnavailableEvent>()?),
            StructType::DasClusterIsolatedEvent => Some(from.as_any_ref().downcast_ref::<DasClusterIsolatedEvent>()?),
            StructType::DasDisabledEvent => Some(from.as_any_ref().downcast_ref::<DasDisabledEvent>()?),
            StructType::DasEnabledEvent => Some(from.as_any_ref().downcast_ref::<DasEnabledEvent>()?),
            StructType::DasHostFailedEvent => Some(from.as_any_ref().downcast_ref::<DasHostFailedEvent>()?),
            StructType::DasHostIsolatedEvent => Some(from.as_any_ref().downcast_ref::<DasHostIsolatedEvent>()?),
            StructType::DrsDisabledEvent => Some(from.as_any_ref().downcast_ref::<DrsDisabledEvent>()?),
            StructType::DrsEnabledEvent => Some(from.as_any_ref().downcast_ref::<DrsEnabledEvent>()?),
            StructType::DrsInvocationFailedEvent => Some(from.as_any_ref().downcast_ref::<DrsInvocationFailedEvent>()?),
            StructType::DrsRecoveredFromFailureEvent => Some(from.as_any_ref().downcast_ref::<DrsRecoveredFromFailureEvent>()?),
            StructType::FailoverLevelRestored => Some(from.as_any_ref().downcast_ref::<FailoverLevelRestored>()?),
            StructType::HostMonitoringStateChangedEvent => Some(from.as_any_ref().downcast_ref::<HostMonitoringStateChangedEvent>()?),
            StructType::InsufficientFailoverResourcesEvent => Some(from.as_any_ref().downcast_ref::<InsufficientFailoverResourcesEvent>()?),
            StructType::VmHealthMonitoringStateChangedEvent => Some(from.as_any_ref().downcast_ref::<VmHealthMonitoringStateChangedEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterEvent => Ok(from.as_any_box().downcast::<ClusterEvent>()?),
            StructType::ClusterComplianceCheckedEvent => Ok(from.as_any_box().downcast::<ClusterComplianceCheckedEvent>()?),
            StructType::ClusterCreatedEvent => Ok(from.as_any_box().downcast::<ClusterCreatedEvent>()?),
            StructType::ClusterDestroyedEvent => Ok(from.as_any_box().downcast::<ClusterDestroyedEvent>()?),
            StructType::ClusterOvercommittedEvent => Ok(from.as_any_box().downcast::<ClusterOvercommittedEvent>()?),
            StructType::HostOvercommittedEvent => Ok(from.as_any_box().downcast::<HostOvercommittedEvent>()?),
            StructType::ClusterReconfiguredEvent => Ok(from.as_any_box().downcast::<ClusterReconfiguredEvent>()?),
            StructType::ClusterStatusChangedEvent => Ok(from.as_any_box().downcast::<ClusterStatusChangedEvent>()?),
            StructType::HostStatusChangedEvent => Ok(from.as_any_box().downcast::<HostStatusChangedEvent>()?),
            StructType::DasAdmissionControlDisabledEvent => Ok(from.as_any_box().downcast::<DasAdmissionControlDisabledEvent>()?),
            StructType::DasAdmissionControlEnabledEvent => Ok(from.as_any_box().downcast::<DasAdmissionControlEnabledEvent>()?),
            StructType::DasAgentFoundEvent => Ok(from.as_any_box().downcast::<DasAgentFoundEvent>()?),
            StructType::DasAgentUnavailableEvent => Ok(from.as_any_box().downcast::<DasAgentUnavailableEvent>()?),
            StructType::DasClusterIsolatedEvent => Ok(from.as_any_box().downcast::<DasClusterIsolatedEvent>()?),
            StructType::DasDisabledEvent => Ok(from.as_any_box().downcast::<DasDisabledEvent>()?),
            StructType::DasEnabledEvent => Ok(from.as_any_box().downcast::<DasEnabledEvent>()?),
            StructType::DasHostFailedEvent => Ok(from.as_any_box().downcast::<DasHostFailedEvent>()?),
            StructType::DasHostIsolatedEvent => Ok(from.as_any_box().downcast::<DasHostIsolatedEvent>()?),
            StructType::DrsDisabledEvent => Ok(from.as_any_box().downcast::<DrsDisabledEvent>()?),
            StructType::DrsEnabledEvent => Ok(from.as_any_box().downcast::<DrsEnabledEvent>()?),
            StructType::DrsInvocationFailedEvent => Ok(from.as_any_box().downcast::<DrsInvocationFailedEvent>()?),
            StructType::DrsRecoveredFromFailureEvent => Ok(from.as_any_box().downcast::<DrsRecoveredFromFailureEvent>()?),
            StructType::FailoverLevelRestored => Ok(from.as_any_box().downcast::<FailoverLevelRestored>()?),
            StructType::HostMonitoringStateChangedEvent => Ok(from.as_any_box().downcast::<HostMonitoringStateChangedEvent>()?),
            StructType::InsufficientFailoverResourcesEvent => Ok(from.as_any_box().downcast::<InsufficientFailoverResourcesEvent>()?),
            StructType::VmHealthMonitoringStateChangedEvent => Ok(from.as_any_box().downcast::<VmHealthMonitoringStateChangedEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This event records when a cluster's host capacity cannot satisfy resource
/// configuration constraints.
pub trait ClusterOvercommittedEventTrait : super::traits::ClusterEventTrait {
}
impl<'s> serde::Serialize for dyn ClusterOvercommittedEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ClusterOvercommittedEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ClusterOvercommittedEventVisitor)
            }
        }

struct ClusterOvercommittedEventVisitor;

impl<'de> de::Visitor<'de> for ClusterOvercommittedEventVisitor {
    type Value = Box<dyn ClusterOvercommittedEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ClusterOvercommittedEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ClusterOvercommittedEventTrait for ClusterOvercommittedEvent {
}
impl ClusterOvercommittedEventTrait for HostOvercommittedEvent {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ClusterOvercommittedEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterOvercommittedEvent => Some(from.as_any_ref().downcast_ref::<ClusterOvercommittedEvent>()?),
            StructType::HostOvercommittedEvent => Some(from.as_any_ref().downcast_ref::<HostOvercommittedEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterOvercommittedEvent => Ok(from.as_any_box().downcast::<ClusterOvercommittedEvent>()?),
            StructType::HostOvercommittedEvent => Ok(from.as_any_box().downcast::<HostOvercommittedEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This event records when a cluster's overall status changed.
pub trait ClusterStatusChangedEventTrait : super::traits::ClusterEventTrait {
    /// The old (*status*).
    fn get_old_status(&self) -> &str;
    /// The new (*status*).
    fn get_new_status(&self) -> &str;
}
impl<'s> serde::Serialize for dyn ClusterStatusChangedEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ClusterStatusChangedEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ClusterStatusChangedEventVisitor)
            }
        }

struct ClusterStatusChangedEventVisitor;

impl<'de> de::Visitor<'de> for ClusterStatusChangedEventVisitor {
    type Value = Box<dyn ClusterStatusChangedEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ClusterStatusChangedEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ClusterStatusChangedEventTrait for ClusterStatusChangedEvent {
    fn get_old_status(&self) -> &str { &self.old_status }
    fn get_new_status(&self) -> &str { &self.new_status }
}
impl ClusterStatusChangedEventTrait for HostStatusChangedEvent {
    fn get_old_status(&self) -> &str { &self.old_status }
    fn get_new_status(&self) -> &str { &self.new_status }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ClusterStatusChangedEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterStatusChangedEvent => Some(from.as_any_ref().downcast_ref::<ClusterStatusChangedEvent>()?),
            StructType::HostStatusChangedEvent => Some(from.as_any_ref().downcast_ref::<HostStatusChangedEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterStatusChangedEvent => Ok(from.as_any_box().downcast::<ClusterStatusChangedEvent>()?),
            StructType::HostStatusChangedEvent => Ok(from.as_any_box().downcast::<HostStatusChangedEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// These are custom field events.
pub trait CustomFieldEventTrait : super::traits::EventTrait {
}
impl<'s> serde::Serialize for dyn CustomFieldEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn CustomFieldEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(CustomFieldEventVisitor)
            }
        }

struct CustomFieldEventVisitor;

impl<'de> de::Visitor<'de> for CustomFieldEventVisitor {
    type Value = Box<dyn CustomFieldEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid CustomFieldEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl CustomFieldEventTrait for CustomFieldEvent {
}
impl CustomFieldEventTrait for CustomFieldDefEvent {
}
impl CustomFieldEventTrait for CustomFieldDefAddedEvent {
}
impl CustomFieldEventTrait for CustomFieldDefRemovedEvent {
}
impl CustomFieldEventTrait for CustomFieldDefRenamedEvent {
}
impl CustomFieldEventTrait for CustomFieldValueChangedEvent {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn CustomFieldEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::CustomFieldEvent => Some(from.as_any_ref().downcast_ref::<CustomFieldEvent>()?),
            StructType::CustomFieldDefEvent => Some(from.as_any_ref().downcast_ref::<CustomFieldDefEvent>()?),
            StructType::CustomFieldDefAddedEvent => Some(from.as_any_ref().downcast_ref::<CustomFieldDefAddedEvent>()?),
            StructType::CustomFieldDefRemovedEvent => Some(from.as_any_ref().downcast_ref::<CustomFieldDefRemovedEvent>()?),
            StructType::CustomFieldDefRenamedEvent => Some(from.as_any_ref().downcast_ref::<CustomFieldDefRenamedEvent>()?),
            StructType::CustomFieldValueChangedEvent => Some(from.as_any_ref().downcast_ref::<CustomFieldValueChangedEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::CustomFieldEvent => Ok(from.as_any_box().downcast::<CustomFieldEvent>()?),
            StructType::CustomFieldDefEvent => Ok(from.as_any_box().downcast::<CustomFieldDefEvent>()?),
            StructType::CustomFieldDefAddedEvent => Ok(from.as_any_box().downcast::<CustomFieldDefAddedEvent>()?),
            StructType::CustomFieldDefRemovedEvent => Ok(from.as_any_box().downcast::<CustomFieldDefRemovedEvent>()?),
            StructType::CustomFieldDefRenamedEvent => Ok(from.as_any_box().downcast::<CustomFieldDefRenamedEvent>()?),
            StructType::CustomFieldValueChangedEvent => Ok(from.as_any_box().downcast::<CustomFieldValueChangedEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This event records a custom field definition event.
pub trait CustomFieldDefEventTrait : super::traits::CustomFieldEventTrait {
    /// The unique identifier of the custom field definition.
    fn get_field_key(&self) -> i32;
    /// The name of the custom field.
    fn get_name(&self) -> &str;
}
impl<'s> serde::Serialize for dyn CustomFieldDefEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn CustomFieldDefEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(CustomFieldDefEventVisitor)
            }
        }

struct CustomFieldDefEventVisitor;

impl<'de> de::Visitor<'de> for CustomFieldDefEventVisitor {
    type Value = Box<dyn CustomFieldDefEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid CustomFieldDefEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl CustomFieldDefEventTrait for CustomFieldDefEvent {
    fn get_field_key(&self) -> i32 { self.field_key }
    fn get_name(&self) -> &str { &self.name }
}
impl CustomFieldDefEventTrait for CustomFieldDefAddedEvent {
    fn get_field_key(&self) -> i32 { self.field_key }
    fn get_name(&self) -> &str { &self.name }
}
impl CustomFieldDefEventTrait for CustomFieldDefRemovedEvent {
    fn get_field_key(&self) -> i32 { self.field_key }
    fn get_name(&self) -> &str { &self.name }
}
impl CustomFieldDefEventTrait for CustomFieldDefRenamedEvent {
    fn get_field_key(&self) -> i32 { self.field_key }
    fn get_name(&self) -> &str { &self.name }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn CustomFieldDefEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::CustomFieldDefEvent => Some(from.as_any_ref().downcast_ref::<CustomFieldDefEvent>()?),
            StructType::CustomFieldDefAddedEvent => Some(from.as_any_ref().downcast_ref::<CustomFieldDefAddedEvent>()?),
            StructType::CustomFieldDefRemovedEvent => Some(from.as_any_ref().downcast_ref::<CustomFieldDefRemovedEvent>()?),
            StructType::CustomFieldDefRenamedEvent => Some(from.as_any_ref().downcast_ref::<CustomFieldDefRenamedEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::CustomFieldDefEvent => Ok(from.as_any_box().downcast::<CustomFieldDefEvent>()?),
            StructType::CustomFieldDefAddedEvent => Ok(from.as_any_box().downcast::<CustomFieldDefAddedEvent>()?),
            StructType::CustomFieldDefRemovedEvent => Ok(from.as_any_box().downcast::<CustomFieldDefRemovedEvent>()?),
            StructType::CustomFieldDefRenamedEvent => Ok(from.as_any_box().downcast::<CustomFieldDefRenamedEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// DVPortgroup related events.
pub trait DvPortgroupEventTrait : super::traits::EventTrait {
}
impl<'s> serde::Serialize for dyn DvPortgroupEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DvPortgroupEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DvPortgroupEventVisitor)
            }
        }

struct DvPortgroupEventVisitor;

impl<'de> de::Visitor<'de> for DvPortgroupEventVisitor {
    type Value = Box<dyn DvPortgroupEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DvPortgroupEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DvPortgroupEventTrait for DvPortgroupEvent {
}
impl DvPortgroupEventTrait for DvPortgroupCreatedEvent {
}
impl DvPortgroupEventTrait for DvPortgroupDestroyedEvent {
}
impl DvPortgroupEventTrait for DvPortgroupReconfiguredEvent {
}
impl DvPortgroupEventTrait for DvPortgroupRenamedEvent {
}
impl DvPortgroupEventTrait for DvpgImportEvent {
}
impl DvPortgroupEventTrait for DvpgRestoreEvent {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DvPortgroupEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvPortgroupEvent => Some(from.as_any_ref().downcast_ref::<DvPortgroupEvent>()?),
            StructType::DvPortgroupCreatedEvent => Some(from.as_any_ref().downcast_ref::<DvPortgroupCreatedEvent>()?),
            StructType::DvPortgroupDestroyedEvent => Some(from.as_any_ref().downcast_ref::<DvPortgroupDestroyedEvent>()?),
            StructType::DvPortgroupReconfiguredEvent => Some(from.as_any_ref().downcast_ref::<DvPortgroupReconfiguredEvent>()?),
            StructType::DvPortgroupRenamedEvent => Some(from.as_any_ref().downcast_ref::<DvPortgroupRenamedEvent>()?),
            StructType::DvpgImportEvent => Some(from.as_any_ref().downcast_ref::<DvpgImportEvent>()?),
            StructType::DvpgRestoreEvent => Some(from.as_any_ref().downcast_ref::<DvpgRestoreEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvPortgroupEvent => Ok(from.as_any_box().downcast::<DvPortgroupEvent>()?),
            StructType::DvPortgroupCreatedEvent => Ok(from.as_any_box().downcast::<DvPortgroupCreatedEvent>()?),
            StructType::DvPortgroupDestroyedEvent => Ok(from.as_any_box().downcast::<DvPortgroupDestroyedEvent>()?),
            StructType::DvPortgroupReconfiguredEvent => Ok(from.as_any_box().downcast::<DvPortgroupReconfiguredEvent>()?),
            StructType::DvPortgroupRenamedEvent => Ok(from.as_any_box().downcast::<DvPortgroupRenamedEvent>()?),
            StructType::DvpgImportEvent => Ok(from.as_any_box().downcast::<DvpgImportEvent>()?),
            StructType::DvpgRestoreEvent => Ok(from.as_any_box().downcast::<DvpgRestoreEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// These are datacenter events.
pub trait DatacenterEventTrait : super::traits::EventTrait {
}
impl<'s> serde::Serialize for dyn DatacenterEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DatacenterEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DatacenterEventVisitor)
            }
        }

struct DatacenterEventVisitor;

impl<'de> de::Visitor<'de> for DatacenterEventVisitor {
    type Value = Box<dyn DatacenterEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DatacenterEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DatacenterEventTrait for DatacenterEvent {
}
impl DatacenterEventTrait for DatacenterCreatedEvent {
}
impl DatacenterEventTrait for DatacenterRenamedEvent {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DatacenterEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DatacenterEvent => Some(from.as_any_ref().downcast_ref::<DatacenterEvent>()?),
            StructType::DatacenterCreatedEvent => Some(from.as_any_ref().downcast_ref::<DatacenterCreatedEvent>()?),
            StructType::DatacenterRenamedEvent => Some(from.as_any_ref().downcast_ref::<DatacenterRenamedEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DatacenterEvent => Ok(from.as_any_box().downcast::<DatacenterEvent>()?),
            StructType::DatacenterCreatedEvent => Ok(from.as_any_box().downcast::<DatacenterCreatedEvent>()?),
            StructType::DatacenterRenamedEvent => Ok(from.as_any_box().downcast::<DatacenterRenamedEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// These are datastore events.
pub trait DatastoreEventTrait : super::traits::EventTrait {
    /// The associated datastore.
    fn get_datastore(&self) -> &Option<DatastoreEventArgument>;
}
impl<'s> serde::Serialize for dyn DatastoreEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DatastoreEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DatastoreEventVisitor)
            }
        }

struct DatastoreEventVisitor;

impl<'de> de::Visitor<'de> for DatastoreEventVisitor {
    type Value = Box<dyn DatastoreEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DatastoreEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DatastoreEventTrait for DatastoreEvent {
    fn get_datastore(&self) -> &Option<DatastoreEventArgument> { &self.datastore }
}
impl DatastoreEventTrait for DatastoreCapacityIncreasedEvent {
    fn get_datastore(&self) -> &Option<DatastoreEventArgument> { &self.datastore }
}
impl DatastoreEventTrait for DatastoreDestroyedEvent {
    fn get_datastore(&self) -> &Option<DatastoreEventArgument> { &self.datastore }
}
impl DatastoreEventTrait for DatastoreDuplicatedEvent {
    fn get_datastore(&self) -> &Option<DatastoreEventArgument> { &self.datastore }
}
impl DatastoreEventTrait for DatastoreFileEvent {
    fn get_datastore(&self) -> &Option<DatastoreEventArgument> { &self.datastore }
}
impl DatastoreEventTrait for DatastoreFileCopiedEvent {
    fn get_datastore(&self) -> &Option<DatastoreEventArgument> { &self.datastore }
}
impl DatastoreEventTrait for DatastoreFileDeletedEvent {
    fn get_datastore(&self) -> &Option<DatastoreEventArgument> { &self.datastore }
}
impl DatastoreEventTrait for DatastoreFileMovedEvent {
    fn get_datastore(&self) -> &Option<DatastoreEventArgument> { &self.datastore }
}
impl DatastoreEventTrait for DatastoreIormReconfiguredEvent {
    fn get_datastore(&self) -> &Option<DatastoreEventArgument> { &self.datastore }
}
impl DatastoreEventTrait for DatastoreRenamedEvent {
    fn get_datastore(&self) -> &Option<DatastoreEventArgument> { &self.datastore }
}
impl DatastoreEventTrait for NonViWorkloadDetectedOnDatastoreEvent {
    fn get_datastore(&self) -> &Option<DatastoreEventArgument> { &self.datastore }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DatastoreEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DatastoreEvent => Some(from.as_any_ref().downcast_ref::<DatastoreEvent>()?),
            StructType::DatastoreCapacityIncreasedEvent => Some(from.as_any_ref().downcast_ref::<DatastoreCapacityIncreasedEvent>()?),
            StructType::DatastoreDestroyedEvent => Some(from.as_any_ref().downcast_ref::<DatastoreDestroyedEvent>()?),
            StructType::DatastoreDuplicatedEvent => Some(from.as_any_ref().downcast_ref::<DatastoreDuplicatedEvent>()?),
            StructType::DatastoreFileEvent => Some(from.as_any_ref().downcast_ref::<DatastoreFileEvent>()?),
            StructType::DatastoreFileCopiedEvent => Some(from.as_any_ref().downcast_ref::<DatastoreFileCopiedEvent>()?),
            StructType::DatastoreFileDeletedEvent => Some(from.as_any_ref().downcast_ref::<DatastoreFileDeletedEvent>()?),
            StructType::DatastoreFileMovedEvent => Some(from.as_any_ref().downcast_ref::<DatastoreFileMovedEvent>()?),
            StructType::DatastoreIormReconfiguredEvent => Some(from.as_any_ref().downcast_ref::<DatastoreIormReconfiguredEvent>()?),
            StructType::DatastoreRenamedEvent => Some(from.as_any_ref().downcast_ref::<DatastoreRenamedEvent>()?),
            StructType::NonViWorkloadDetectedOnDatastoreEvent => Some(from.as_any_ref().downcast_ref::<NonViWorkloadDetectedOnDatastoreEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DatastoreEvent => Ok(from.as_any_box().downcast::<DatastoreEvent>()?),
            StructType::DatastoreCapacityIncreasedEvent => Ok(from.as_any_box().downcast::<DatastoreCapacityIncreasedEvent>()?),
            StructType::DatastoreDestroyedEvent => Ok(from.as_any_box().downcast::<DatastoreDestroyedEvent>()?),
            StructType::DatastoreDuplicatedEvent => Ok(from.as_any_box().downcast::<DatastoreDuplicatedEvent>()?),
            StructType::DatastoreFileEvent => Ok(from.as_any_box().downcast::<DatastoreFileEvent>()?),
            StructType::DatastoreFileCopiedEvent => Ok(from.as_any_box().downcast::<DatastoreFileCopiedEvent>()?),
            StructType::DatastoreFileDeletedEvent => Ok(from.as_any_box().downcast::<DatastoreFileDeletedEvent>()?),
            StructType::DatastoreFileMovedEvent => Ok(from.as_any_box().downcast::<DatastoreFileMovedEvent>()?),
            StructType::DatastoreIormReconfiguredEvent => Ok(from.as_any_box().downcast::<DatastoreIormReconfiguredEvent>()?),
            StructType::DatastoreRenamedEvent => Ok(from.as_any_box().downcast::<DatastoreRenamedEvent>()?),
            StructType::NonViWorkloadDetectedOnDatastoreEvent => Ok(from.as_any_box().downcast::<NonViWorkloadDetectedOnDatastoreEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class for events related to datastore file and directory
/// operations.
/// 
/// Property _datastore_ inherited from DatastoreEvent refers
/// to the destination datastore in case there is more than datastore
/// involved in the operation.
pub trait DatastoreFileEventTrait : super::traits::DatastoreEventTrait {
    /// Datastore path of the target file or directory.
    fn get_target_file(&self) -> &str;
    /// Identifier of the initiator of the file operation.
    fn get_source_of_operation(&self) -> &Option<String>;
    /// Indicator whether the datastore file operation succeeded.
    fn get_succeeded(&self) -> Option<bool>;
}
impl<'s> serde::Serialize for dyn DatastoreFileEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DatastoreFileEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DatastoreFileEventVisitor)
            }
        }

struct DatastoreFileEventVisitor;

impl<'de> de::Visitor<'de> for DatastoreFileEventVisitor {
    type Value = Box<dyn DatastoreFileEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DatastoreFileEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DatastoreFileEventTrait for DatastoreFileEvent {
    fn get_target_file(&self) -> &str { &self.target_file }
    fn get_source_of_operation(&self) -> &Option<String> { &self.source_of_operation }
    fn get_succeeded(&self) -> Option<bool> { self.succeeded }
}
impl DatastoreFileEventTrait for DatastoreFileCopiedEvent {
    fn get_target_file(&self) -> &str { &self.target_file }
    fn get_source_of_operation(&self) -> &Option<String> { &self.source_of_operation }
    fn get_succeeded(&self) -> Option<bool> { self.succeeded }
}
impl DatastoreFileEventTrait for DatastoreFileDeletedEvent {
    fn get_target_file(&self) -> &str { &self.target_file }
    fn get_source_of_operation(&self) -> &Option<String> { &self.source_of_operation }
    fn get_succeeded(&self) -> Option<bool> { self.succeeded }
}
impl DatastoreFileEventTrait for DatastoreFileMovedEvent {
    fn get_target_file(&self) -> &str { &self.target_file }
    fn get_source_of_operation(&self) -> &Option<String> { &self.source_of_operation }
    fn get_succeeded(&self) -> Option<bool> { self.succeeded }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DatastoreFileEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DatastoreFileEvent => Some(from.as_any_ref().downcast_ref::<DatastoreFileEvent>()?),
            StructType::DatastoreFileCopiedEvent => Some(from.as_any_ref().downcast_ref::<DatastoreFileCopiedEvent>()?),
            StructType::DatastoreFileDeletedEvent => Some(from.as_any_ref().downcast_ref::<DatastoreFileDeletedEvent>()?),
            StructType::DatastoreFileMovedEvent => Some(from.as_any_ref().downcast_ref::<DatastoreFileMovedEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DatastoreFileEvent => Ok(from.as_any_box().downcast::<DatastoreFileEvent>()?),
            StructType::DatastoreFileCopiedEvent => Ok(from.as_any_box().downcast::<DatastoreFileCopiedEvent>()?),
            StructType::DatastoreFileDeletedEvent => Ok(from.as_any_box().downcast::<DatastoreFileDeletedEvent>()?),
            StructType::DatastoreFileMovedEvent => Ok(from.as_any_box().downcast::<DatastoreFileMovedEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// These are dvs-related events.
pub trait DvsEventTrait : super::traits::EventTrait {
}
impl<'s> serde::Serialize for dyn DvsEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DvsEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DvsEventVisitor)
            }
        }

struct DvsEventVisitor;

impl<'de> de::Visitor<'de> for DvsEventVisitor {
    type Value = Box<dyn DvsEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DvsEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DvsEventTrait for DvsEvent {
}
impl DvsEventTrait for DvsCreatedEvent {
}
impl DvsEventTrait for DvsDestroyedEvent {
}
impl DvsEventTrait for DvsHostBackInSyncEvent {
}
impl DvsEventTrait for DvsHostJoinedEvent {
}
impl DvsEventTrait for DvsHostLeftEvent {
}
impl DvsEventTrait for DvsHostStatusUpdated {
}
impl DvsEventTrait for DvsHostWentOutOfSyncEvent {
}
impl DvsEventTrait for DvsImportEvent {
}
impl DvsEventTrait for DvsMergedEvent {
}
impl DvsEventTrait for DvsPortBlockedEvent {
}
impl DvsEventTrait for DvsPortConnectedEvent {
}
impl DvsEventTrait for DvsPortCreatedEvent {
}
impl DvsEventTrait for DvsPortDeletedEvent {
}
impl DvsEventTrait for DvsPortDisconnectedEvent {
}
impl DvsEventTrait for DvsPortEnteredPassthruEvent {
}
impl DvsEventTrait for DvsPortExitedPassthruEvent {
}
impl DvsEventTrait for DvsPortJoinPortgroupEvent {
}
impl DvsEventTrait for DvsPortLeavePortgroupEvent {
}
impl DvsEventTrait for DvsPortLinkDownEvent {
}
impl DvsEventTrait for DvsPortLinkUpEvent {
}
impl DvsEventTrait for DvsPortReconfiguredEvent {
}
impl DvsEventTrait for DvsPortRuntimeChangeEvent {
}
impl DvsEventTrait for DvsPortUnblockedEvent {
}
impl DvsEventTrait for DvsPortVendorSpecificStateChangeEvent {
}
impl DvsEventTrait for DvsReconfiguredEvent {
}
impl DvsEventTrait for DvsRenamedEvent {
}
impl DvsEventTrait for DvsRestoreEvent {
}
impl DvsEventTrait for DvsUpgradeAvailableEvent {
}
impl DvsEventTrait for DvsUpgradeInProgressEvent {
}
impl DvsEventTrait for DvsUpgradeRejectedEvent {
}
impl DvsEventTrait for DvsUpgradedEvent {
}
impl DvsEventTrait for HostLocalPortCreatedEvent {
}
impl DvsEventTrait for OutOfSyncDvsHost {
}
impl DvsEventTrait for RecoveryEvent {
}
impl DvsEventTrait for RollbackEvent {
}
impl DvsEventTrait for VmVnicPoolReservationViolationClearEvent {
}
impl DvsEventTrait for VmVnicPoolReservationViolationRaiseEvent {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DvsEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsEvent => Some(from.as_any_ref().downcast_ref::<DvsEvent>()?),
            StructType::DvsCreatedEvent => Some(from.as_any_ref().downcast_ref::<DvsCreatedEvent>()?),
            StructType::DvsDestroyedEvent => Some(from.as_any_ref().downcast_ref::<DvsDestroyedEvent>()?),
            StructType::DvsHostBackInSyncEvent => Some(from.as_any_ref().downcast_ref::<DvsHostBackInSyncEvent>()?),
            StructType::DvsHostJoinedEvent => Some(from.as_any_ref().downcast_ref::<DvsHostJoinedEvent>()?),
            StructType::DvsHostLeftEvent => Some(from.as_any_ref().downcast_ref::<DvsHostLeftEvent>()?),
            StructType::DvsHostStatusUpdated => Some(from.as_any_ref().downcast_ref::<DvsHostStatusUpdated>()?),
            StructType::DvsHostWentOutOfSyncEvent => Some(from.as_any_ref().downcast_ref::<DvsHostWentOutOfSyncEvent>()?),
            StructType::DvsImportEvent => Some(from.as_any_ref().downcast_ref::<DvsImportEvent>()?),
            StructType::DvsMergedEvent => Some(from.as_any_ref().downcast_ref::<DvsMergedEvent>()?),
            StructType::DvsPortBlockedEvent => Some(from.as_any_ref().downcast_ref::<DvsPortBlockedEvent>()?),
            StructType::DvsPortConnectedEvent => Some(from.as_any_ref().downcast_ref::<DvsPortConnectedEvent>()?),
            StructType::DvsPortCreatedEvent => Some(from.as_any_ref().downcast_ref::<DvsPortCreatedEvent>()?),
            StructType::DvsPortDeletedEvent => Some(from.as_any_ref().downcast_ref::<DvsPortDeletedEvent>()?),
            StructType::DvsPortDisconnectedEvent => Some(from.as_any_ref().downcast_ref::<DvsPortDisconnectedEvent>()?),
            StructType::DvsPortEnteredPassthruEvent => Some(from.as_any_ref().downcast_ref::<DvsPortEnteredPassthruEvent>()?),
            StructType::DvsPortExitedPassthruEvent => Some(from.as_any_ref().downcast_ref::<DvsPortExitedPassthruEvent>()?),
            StructType::DvsPortJoinPortgroupEvent => Some(from.as_any_ref().downcast_ref::<DvsPortJoinPortgroupEvent>()?),
            StructType::DvsPortLeavePortgroupEvent => Some(from.as_any_ref().downcast_ref::<DvsPortLeavePortgroupEvent>()?),
            StructType::DvsPortLinkDownEvent => Some(from.as_any_ref().downcast_ref::<DvsPortLinkDownEvent>()?),
            StructType::DvsPortLinkUpEvent => Some(from.as_any_ref().downcast_ref::<DvsPortLinkUpEvent>()?),
            StructType::DvsPortReconfiguredEvent => Some(from.as_any_ref().downcast_ref::<DvsPortReconfiguredEvent>()?),
            StructType::DvsPortRuntimeChangeEvent => Some(from.as_any_ref().downcast_ref::<DvsPortRuntimeChangeEvent>()?),
            StructType::DvsPortUnblockedEvent => Some(from.as_any_ref().downcast_ref::<DvsPortUnblockedEvent>()?),
            StructType::DvsPortVendorSpecificStateChangeEvent => Some(from.as_any_ref().downcast_ref::<DvsPortVendorSpecificStateChangeEvent>()?),
            StructType::DvsReconfiguredEvent => Some(from.as_any_ref().downcast_ref::<DvsReconfiguredEvent>()?),
            StructType::DvsRenamedEvent => Some(from.as_any_ref().downcast_ref::<DvsRenamedEvent>()?),
            StructType::DvsRestoreEvent => Some(from.as_any_ref().downcast_ref::<DvsRestoreEvent>()?),
            StructType::DvsUpgradeAvailableEvent => Some(from.as_any_ref().downcast_ref::<DvsUpgradeAvailableEvent>()?),
            StructType::DvsUpgradeInProgressEvent => Some(from.as_any_ref().downcast_ref::<DvsUpgradeInProgressEvent>()?),
            StructType::DvsUpgradeRejectedEvent => Some(from.as_any_ref().downcast_ref::<DvsUpgradeRejectedEvent>()?),
            StructType::DvsUpgradedEvent => Some(from.as_any_ref().downcast_ref::<DvsUpgradedEvent>()?),
            StructType::HostLocalPortCreatedEvent => Some(from.as_any_ref().downcast_ref::<HostLocalPortCreatedEvent>()?),
            StructType::OutOfSyncDvsHost => Some(from.as_any_ref().downcast_ref::<OutOfSyncDvsHost>()?),
            StructType::RecoveryEvent => Some(from.as_any_ref().downcast_ref::<RecoveryEvent>()?),
            StructType::RollbackEvent => Some(from.as_any_ref().downcast_ref::<RollbackEvent>()?),
            StructType::VmVnicPoolReservationViolationClearEvent => Some(from.as_any_ref().downcast_ref::<VmVnicPoolReservationViolationClearEvent>()?),
            StructType::VmVnicPoolReservationViolationRaiseEvent => Some(from.as_any_ref().downcast_ref::<VmVnicPoolReservationViolationRaiseEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsEvent => Ok(from.as_any_box().downcast::<DvsEvent>()?),
            StructType::DvsCreatedEvent => Ok(from.as_any_box().downcast::<DvsCreatedEvent>()?),
            StructType::DvsDestroyedEvent => Ok(from.as_any_box().downcast::<DvsDestroyedEvent>()?),
            StructType::DvsHostBackInSyncEvent => Ok(from.as_any_box().downcast::<DvsHostBackInSyncEvent>()?),
            StructType::DvsHostJoinedEvent => Ok(from.as_any_box().downcast::<DvsHostJoinedEvent>()?),
            StructType::DvsHostLeftEvent => Ok(from.as_any_box().downcast::<DvsHostLeftEvent>()?),
            StructType::DvsHostStatusUpdated => Ok(from.as_any_box().downcast::<DvsHostStatusUpdated>()?),
            StructType::DvsHostWentOutOfSyncEvent => Ok(from.as_any_box().downcast::<DvsHostWentOutOfSyncEvent>()?),
            StructType::DvsImportEvent => Ok(from.as_any_box().downcast::<DvsImportEvent>()?),
            StructType::DvsMergedEvent => Ok(from.as_any_box().downcast::<DvsMergedEvent>()?),
            StructType::DvsPortBlockedEvent => Ok(from.as_any_box().downcast::<DvsPortBlockedEvent>()?),
            StructType::DvsPortConnectedEvent => Ok(from.as_any_box().downcast::<DvsPortConnectedEvent>()?),
            StructType::DvsPortCreatedEvent => Ok(from.as_any_box().downcast::<DvsPortCreatedEvent>()?),
            StructType::DvsPortDeletedEvent => Ok(from.as_any_box().downcast::<DvsPortDeletedEvent>()?),
            StructType::DvsPortDisconnectedEvent => Ok(from.as_any_box().downcast::<DvsPortDisconnectedEvent>()?),
            StructType::DvsPortEnteredPassthruEvent => Ok(from.as_any_box().downcast::<DvsPortEnteredPassthruEvent>()?),
            StructType::DvsPortExitedPassthruEvent => Ok(from.as_any_box().downcast::<DvsPortExitedPassthruEvent>()?),
            StructType::DvsPortJoinPortgroupEvent => Ok(from.as_any_box().downcast::<DvsPortJoinPortgroupEvent>()?),
            StructType::DvsPortLeavePortgroupEvent => Ok(from.as_any_box().downcast::<DvsPortLeavePortgroupEvent>()?),
            StructType::DvsPortLinkDownEvent => Ok(from.as_any_box().downcast::<DvsPortLinkDownEvent>()?),
            StructType::DvsPortLinkUpEvent => Ok(from.as_any_box().downcast::<DvsPortLinkUpEvent>()?),
            StructType::DvsPortReconfiguredEvent => Ok(from.as_any_box().downcast::<DvsPortReconfiguredEvent>()?),
            StructType::DvsPortRuntimeChangeEvent => Ok(from.as_any_box().downcast::<DvsPortRuntimeChangeEvent>()?),
            StructType::DvsPortUnblockedEvent => Ok(from.as_any_box().downcast::<DvsPortUnblockedEvent>()?),
            StructType::DvsPortVendorSpecificStateChangeEvent => Ok(from.as_any_box().downcast::<DvsPortVendorSpecificStateChangeEvent>()?),
            StructType::DvsReconfiguredEvent => Ok(from.as_any_box().downcast::<DvsReconfiguredEvent>()?),
            StructType::DvsRenamedEvent => Ok(from.as_any_box().downcast::<DvsRenamedEvent>()?),
            StructType::DvsRestoreEvent => Ok(from.as_any_box().downcast::<DvsRestoreEvent>()?),
            StructType::DvsUpgradeAvailableEvent => Ok(from.as_any_box().downcast::<DvsUpgradeAvailableEvent>()?),
            StructType::DvsUpgradeInProgressEvent => Ok(from.as_any_box().downcast::<DvsUpgradeInProgressEvent>()?),
            StructType::DvsUpgradeRejectedEvent => Ok(from.as_any_box().downcast::<DvsUpgradeRejectedEvent>()?),
            StructType::DvsUpgradedEvent => Ok(from.as_any_box().downcast::<DvsUpgradedEvent>()?),
            StructType::HostLocalPortCreatedEvent => Ok(from.as_any_box().downcast::<HostLocalPortCreatedEvent>()?),
            StructType::OutOfSyncDvsHost => Ok(from.as_any_box().downcast::<OutOfSyncDvsHost>()?),
            StructType::RecoveryEvent => Ok(from.as_any_box().downcast::<RecoveryEvent>()?),
            StructType::RollbackEvent => Ok(from.as_any_box().downcast::<RollbackEvent>()?),
            StructType::VmVnicPoolReservationViolationClearEvent => Ok(from.as_any_box().downcast::<VmVnicPoolReservationViolationClearEvent>()?),
            StructType::VmVnicPoolReservationViolationRaiseEvent => Ok(from.as_any_box().downcast::<VmVnicPoolReservationViolationRaiseEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// These are general events.
pub trait GeneralEventTrait : super::traits::EventTrait {
    /// A short form of the message string, not localized.
    fn get_message(&self) -> &str;
}
impl<'s> serde::Serialize for dyn GeneralEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn GeneralEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(GeneralEventVisitor)
            }
        }

struct GeneralEventVisitor;

impl<'de> de::Visitor<'de> for GeneralEventVisitor {
    type Value = Box<dyn GeneralEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid GeneralEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl GeneralEventTrait for GeneralEvent {
    fn get_message(&self) -> &str { &self.message }
}
impl GeneralEventTrait for ExtendedEvent {
    fn get_message(&self) -> &str { &self.message }
}
impl GeneralEventTrait for GeneralHostErrorEvent {
    fn get_message(&self) -> &str { &self.message }
}
impl GeneralEventTrait for GeneralHostInfoEvent {
    fn get_message(&self) -> &str { &self.message }
}
impl GeneralEventTrait for GeneralHostWarningEvent {
    fn get_message(&self) -> &str { &self.message }
}
impl GeneralEventTrait for GeneralUserEvent {
    fn get_message(&self) -> &str { &self.message }
}
impl GeneralEventTrait for GeneralVmErrorEvent {
    fn get_message(&self) -> &str { &self.message }
}
impl GeneralEventTrait for GeneralVmInfoEvent {
    fn get_message(&self) -> &str { &self.message }
}
impl GeneralEventTrait for GeneralVmWarningEvent {
    fn get_message(&self) -> &str { &self.message }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn GeneralEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::GeneralEvent => Some(from.as_any_ref().downcast_ref::<GeneralEvent>()?),
            StructType::ExtendedEvent => Some(from.as_any_ref().downcast_ref::<ExtendedEvent>()?),
            StructType::GeneralHostErrorEvent => Some(from.as_any_ref().downcast_ref::<GeneralHostErrorEvent>()?),
            StructType::GeneralHostInfoEvent => Some(from.as_any_ref().downcast_ref::<GeneralHostInfoEvent>()?),
            StructType::GeneralHostWarningEvent => Some(from.as_any_ref().downcast_ref::<GeneralHostWarningEvent>()?),
            StructType::GeneralUserEvent => Some(from.as_any_ref().downcast_ref::<GeneralUserEvent>()?),
            StructType::GeneralVmErrorEvent => Some(from.as_any_ref().downcast_ref::<GeneralVmErrorEvent>()?),
            StructType::GeneralVmInfoEvent => Some(from.as_any_ref().downcast_ref::<GeneralVmInfoEvent>()?),
            StructType::GeneralVmWarningEvent => Some(from.as_any_ref().downcast_ref::<GeneralVmWarningEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::GeneralEvent => Ok(from.as_any_box().downcast::<GeneralEvent>()?),
            StructType::ExtendedEvent => Ok(from.as_any_box().downcast::<ExtendedEvent>()?),
            StructType::GeneralHostErrorEvent => Ok(from.as_any_box().downcast::<GeneralHostErrorEvent>()?),
            StructType::GeneralHostInfoEvent => Ok(from.as_any_box().downcast::<GeneralHostInfoEvent>()?),
            StructType::GeneralHostWarningEvent => Ok(from.as_any_box().downcast::<GeneralHostWarningEvent>()?),
            StructType::GeneralUserEvent => Ok(from.as_any_box().downcast::<GeneralUserEvent>()?),
            StructType::GeneralVmErrorEvent => Ok(from.as_any_box().downcast::<GeneralVmErrorEvent>()?),
            StructType::GeneralVmInfoEvent => Ok(from.as_any_box().downcast::<GeneralVmInfoEvent>()?),
            StructType::GeneralVmWarningEvent => Ok(from.as_any_box().downcast::<GeneralVmWarningEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// These are host-related events.
pub trait HostEventTrait : super::traits::EventTrait {
}
impl<'s> serde::Serialize for dyn HostEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostEventVisitor)
            }
        }

struct HostEventVisitor;

impl<'de> de::Visitor<'de> for HostEventVisitor {
    type Value = Box<dyn HostEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostEventTrait for HostEvent {
}
impl HostEventTrait for AccountCreatedEvent {
}
impl HostEventTrait for AccountRemovedEvent {
}
impl HostEventTrait for AccountUpdatedEvent {
}
impl HostEventTrait for AdminPasswordNotChangedEvent {
}
impl HostEventTrait for CanceledHostOperationEvent {
}
impl HostEventTrait for DatastoreDiscoveredEvent {
}
impl HostEventTrait for DatastorePrincipalConfigured {
}
impl HostEventTrait for DatastoreRemovedOnHostEvent {
}
impl HostEventTrait for DatastoreRenamedOnHostEvent {
}
impl HostEventTrait for DrsResourceConfigureFailedEvent {
}
impl HostEventTrait for DrsResourceConfigureSyncedEvent {
}
impl HostEventTrait for DuplicateIpDetectedEvent {
}
impl HostEventTrait for DvsHealthStatusChangeEvent {
}
impl HostEventTrait for MtuMatchEvent {
}
impl HostEventTrait for MtuMismatchEvent {
}
impl HostEventTrait for TeamingMatchEvent {
}
impl HostEventTrait for TeamingMisMatchEvent {
}
impl HostEventTrait for UplinkPortMtuNotSupportEvent {
}
impl HostEventTrait for UplinkPortMtuSupportEvent {
}
impl HostEventTrait for UplinkPortVlanTrunkedEvent {
}
impl HostEventTrait for UplinkPortVlanUntrunkedEvent {
}
impl HostEventTrait for EnteredMaintenanceModeEvent {
}
impl HostEventTrait for EnteredStandbyModeEvent {
}
impl HostEventTrait for DrsEnteredStandbyModeEvent {
}
impl HostEventTrait for EnteringMaintenanceModeEvent {
}
impl HostEventTrait for EnteringStandbyModeEvent {
}
impl HostEventTrait for DrsEnteringStandbyModeEvent {
}
impl HostEventTrait for ExitMaintenanceModeEvent {
}
impl HostEventTrait for ExitStandbyModeFailedEvent {
}
impl HostEventTrait for DrsExitStandbyModeFailedEvent {
}
impl HostEventTrait for ExitedStandbyModeEvent {
}
impl HostEventTrait for DrsExitedStandbyModeEvent {
}
impl HostEventTrait for ExitingStandbyModeEvent {
}
impl HostEventTrait for DrsExitingStandbyModeEvent {
}
impl HostEventTrait for GhostDvsProxySwitchDetectedEvent {
}
impl HostEventTrait for GhostDvsProxySwitchRemovedEvent {
}
impl HostEventTrait for HostAddFailedEvent {
}
impl HostEventTrait for HostAddedEvent {
}
impl HostEventTrait for HostAdminDisableEvent {
}
impl HostEventTrait for HostAdminEnableEvent {
}
impl HostEventTrait for HostCnxFailedAccountFailedEvent {
}
impl HostEventTrait for HostCnxFailedAlreadyManagedEvent {
}
impl HostEventTrait for HostCnxFailedBadCcagentEvent {
}
impl HostEventTrait for HostCnxFailedBadUsernameEvent {
}
impl HostEventTrait for HostCnxFailedBadVersionEvent {
}
impl HostEventTrait for HostCnxFailedCcagentUpgradeEvent {
}
impl HostEventTrait for HostCnxFailedEvent {
}
impl HostEventTrait for HostCnxFailedNetworkErrorEvent {
}
impl HostEventTrait for HostCnxFailedNoAccessEvent {
}
impl HostEventTrait for HostCnxFailedNoConnectionEvent {
}
impl HostEventTrait for HostCnxFailedNoLicenseEvent {
}
impl HostEventTrait for HostCnxFailedNotFoundEvent {
}
impl HostEventTrait for HostCnxFailedTimeoutEvent {
}
impl HostEventTrait for HostComplianceCheckedEvent {
}
impl HostEventTrait for HostCompliantEvent {
}
impl HostEventTrait for HostConfigAppliedEvent {
}
impl HostEventTrait for HostConnectedEvent {
}
impl HostEventTrait for HostConnectionLostEvent {
}
impl HostEventTrait for HostDasDisabledEvent {
}
impl HostEventTrait for HostDasDisablingEvent {
}
impl HostEventTrait for HostDasEnabledEvent {
}
impl HostEventTrait for HostDasEnablingEvent {
}
impl HostEventTrait for HostDasErrorEvent {
}
impl HostEventTrait for HostDasEvent {
}
impl HostEventTrait for HostExtraNetworksEvent {
}
impl HostEventTrait for HostIsolationIpPingFailedEvent {
}
impl HostEventTrait for HostMissingNetworksEvent {
}
impl HostEventTrait for HostNoAvailableNetworksEvent {
}
impl HostEventTrait for HostNoHaEnabledPortGroupsEvent {
}
impl HostEventTrait for HostNoRedundantManagementNetworkEvent {
}
impl HostEventTrait for HostNotInClusterEvent {
}
impl HostEventTrait for HostPrimaryAgentNotShortNameEvent {
}
impl HostEventTrait for HostShortNameInconsistentEvent {
}
impl HostEventTrait for HostDasOkEvent {
}
impl HostEventTrait for HostDisconnectedEvent {
}
impl HostEventTrait for HostEnableAdminFailedEvent {
}
impl HostEventTrait for HostGetShortNameFailedEvent {
}
impl HostEventTrait for HostInAuditModeEvent {
}
impl HostEventTrait for HostIpChangedEvent {
}
impl HostEventTrait for HostIpInconsistentEvent {
}
impl HostEventTrait for HostIpToShortNameFailedEvent {
}
impl HostEventTrait for HostNonCompliantEvent {
}
impl HostEventTrait for HostProfileAppliedEvent {
}
impl HostEventTrait for HostReconnectionFailedEvent {
}
impl HostEventTrait for HostRemovedEvent {
}
impl HostEventTrait for HostShortNameToIpFailedEvent {
}
impl HostEventTrait for HostShutdownEvent {
}
impl HostEventTrait for HostSpecificationChangedEvent {
}
impl HostEventTrait for HostSpecificationRequireEvent {
}
impl HostEventTrait for HostSpecificationUpdateEvent {
}
impl HostEventTrait for HostSubSpecificationDeleteEvent {
}
impl HostEventTrait for HostSubSpecificationUpdateEvent {
}
impl HostEventTrait for HostSyncFailedEvent {
}
impl HostEventTrait for HostUpgradeFailedEvent {
}
impl HostEventTrait for HostUserWorldSwapNotEnabledEvent {
}
impl HostEventTrait for HostVnicConnectedToCustomizedDvPortEvent {
}
impl HostEventTrait for HostWwnChangedEvent {
}
impl HostEventTrait for HostWwnConflictEvent {
}
impl HostEventTrait for LocalDatastoreCreatedEvent {
}
impl HostEventTrait for LocalTsmEnabledEvent {
}
impl HostEventTrait for NasDatastoreCreatedEvent {
}
impl HostEventTrait for NoDatastoresConfiguredEvent {
}
impl HostEventTrait for RemoteTsmEnabledEvent {
}
impl HostEventTrait for TimedOutHostOperationEvent {
}
impl HostEventTrait for UpdatedAgentBeingRestartedEvent {
}
impl HostEventTrait for UserAssignedToGroup {
}
impl HostEventTrait for UserPasswordChanged {
}
impl HostEventTrait for UserUnassignedFromGroup {
}
impl HostEventTrait for VmfsDatastoreCreatedEvent {
}
impl HostEventTrait for VmfsDatastoreExpandedEvent {
}
impl HostEventTrait for VmfsDatastoreExtendedEvent {
}
impl HostEventTrait for VcAgentUninstallFailedEvent {
}
impl HostEventTrait for VcAgentUninstalledEvent {
}
impl HostEventTrait for VcAgentUpgradeFailedEvent {
}
impl HostEventTrait for VcAgentUpgradedEvent {
}
impl HostEventTrait for VimAccountPasswordChangedEvent {
}
impl HostEventTrait for IScsiBootFailureEvent {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostEvent => Some(from.as_any_ref().downcast_ref::<HostEvent>()?),
            StructType::AccountCreatedEvent => Some(from.as_any_ref().downcast_ref::<AccountCreatedEvent>()?),
            StructType::AccountRemovedEvent => Some(from.as_any_ref().downcast_ref::<AccountRemovedEvent>()?),
            StructType::AccountUpdatedEvent => Some(from.as_any_ref().downcast_ref::<AccountUpdatedEvent>()?),
            StructType::AdminPasswordNotChangedEvent => Some(from.as_any_ref().downcast_ref::<AdminPasswordNotChangedEvent>()?),
            StructType::CanceledHostOperationEvent => Some(from.as_any_ref().downcast_ref::<CanceledHostOperationEvent>()?),
            StructType::DatastoreDiscoveredEvent => Some(from.as_any_ref().downcast_ref::<DatastoreDiscoveredEvent>()?),
            StructType::DatastorePrincipalConfigured => Some(from.as_any_ref().downcast_ref::<DatastorePrincipalConfigured>()?),
            StructType::DatastoreRemovedOnHostEvent => Some(from.as_any_ref().downcast_ref::<DatastoreRemovedOnHostEvent>()?),
            StructType::DatastoreRenamedOnHostEvent => Some(from.as_any_ref().downcast_ref::<DatastoreRenamedOnHostEvent>()?),
            StructType::DrsResourceConfigureFailedEvent => Some(from.as_any_ref().downcast_ref::<DrsResourceConfigureFailedEvent>()?),
            StructType::DrsResourceConfigureSyncedEvent => Some(from.as_any_ref().downcast_ref::<DrsResourceConfigureSyncedEvent>()?),
            StructType::DuplicateIpDetectedEvent => Some(from.as_any_ref().downcast_ref::<DuplicateIpDetectedEvent>()?),
            StructType::DvsHealthStatusChangeEvent => Some(from.as_any_ref().downcast_ref::<DvsHealthStatusChangeEvent>()?),
            StructType::MtuMatchEvent => Some(from.as_any_ref().downcast_ref::<MtuMatchEvent>()?),
            StructType::MtuMismatchEvent => Some(from.as_any_ref().downcast_ref::<MtuMismatchEvent>()?),
            StructType::TeamingMatchEvent => Some(from.as_any_ref().downcast_ref::<TeamingMatchEvent>()?),
            StructType::TeamingMisMatchEvent => Some(from.as_any_ref().downcast_ref::<TeamingMisMatchEvent>()?),
            StructType::UplinkPortMtuNotSupportEvent => Some(from.as_any_ref().downcast_ref::<UplinkPortMtuNotSupportEvent>()?),
            StructType::UplinkPortMtuSupportEvent => Some(from.as_any_ref().downcast_ref::<UplinkPortMtuSupportEvent>()?),
            StructType::UplinkPortVlanTrunkedEvent => Some(from.as_any_ref().downcast_ref::<UplinkPortVlanTrunkedEvent>()?),
            StructType::UplinkPortVlanUntrunkedEvent => Some(from.as_any_ref().downcast_ref::<UplinkPortVlanUntrunkedEvent>()?),
            StructType::EnteredMaintenanceModeEvent => Some(from.as_any_ref().downcast_ref::<EnteredMaintenanceModeEvent>()?),
            StructType::EnteredStandbyModeEvent => Some(from.as_any_ref().downcast_ref::<EnteredStandbyModeEvent>()?),
            StructType::DrsEnteredStandbyModeEvent => Some(from.as_any_ref().downcast_ref::<DrsEnteredStandbyModeEvent>()?),
            StructType::EnteringMaintenanceModeEvent => Some(from.as_any_ref().downcast_ref::<EnteringMaintenanceModeEvent>()?),
            StructType::EnteringStandbyModeEvent => Some(from.as_any_ref().downcast_ref::<EnteringStandbyModeEvent>()?),
            StructType::DrsEnteringStandbyModeEvent => Some(from.as_any_ref().downcast_ref::<DrsEnteringStandbyModeEvent>()?),
            StructType::ExitMaintenanceModeEvent => Some(from.as_any_ref().downcast_ref::<ExitMaintenanceModeEvent>()?),
            StructType::ExitStandbyModeFailedEvent => Some(from.as_any_ref().downcast_ref::<ExitStandbyModeFailedEvent>()?),
            StructType::DrsExitStandbyModeFailedEvent => Some(from.as_any_ref().downcast_ref::<DrsExitStandbyModeFailedEvent>()?),
            StructType::ExitedStandbyModeEvent => Some(from.as_any_ref().downcast_ref::<ExitedStandbyModeEvent>()?),
            StructType::DrsExitedStandbyModeEvent => Some(from.as_any_ref().downcast_ref::<DrsExitedStandbyModeEvent>()?),
            StructType::ExitingStandbyModeEvent => Some(from.as_any_ref().downcast_ref::<ExitingStandbyModeEvent>()?),
            StructType::DrsExitingStandbyModeEvent => Some(from.as_any_ref().downcast_ref::<DrsExitingStandbyModeEvent>()?),
            StructType::GhostDvsProxySwitchDetectedEvent => Some(from.as_any_ref().downcast_ref::<GhostDvsProxySwitchDetectedEvent>()?),
            StructType::GhostDvsProxySwitchRemovedEvent => Some(from.as_any_ref().downcast_ref::<GhostDvsProxySwitchRemovedEvent>()?),
            StructType::HostAddFailedEvent => Some(from.as_any_ref().downcast_ref::<HostAddFailedEvent>()?),
            StructType::HostAddedEvent => Some(from.as_any_ref().downcast_ref::<HostAddedEvent>()?),
            StructType::HostAdminDisableEvent => Some(from.as_any_ref().downcast_ref::<HostAdminDisableEvent>()?),
            StructType::HostAdminEnableEvent => Some(from.as_any_ref().downcast_ref::<HostAdminEnableEvent>()?),
            StructType::HostCnxFailedAccountFailedEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedAccountFailedEvent>()?),
            StructType::HostCnxFailedAlreadyManagedEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedAlreadyManagedEvent>()?),
            StructType::HostCnxFailedBadCcagentEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedBadCcagentEvent>()?),
            StructType::HostCnxFailedBadUsernameEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedBadUsernameEvent>()?),
            StructType::HostCnxFailedBadVersionEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedBadVersionEvent>()?),
            StructType::HostCnxFailedCcagentUpgradeEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedCcagentUpgradeEvent>()?),
            StructType::HostCnxFailedEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedEvent>()?),
            StructType::HostCnxFailedNetworkErrorEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedNetworkErrorEvent>()?),
            StructType::HostCnxFailedNoAccessEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedNoAccessEvent>()?),
            StructType::HostCnxFailedNoConnectionEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedNoConnectionEvent>()?),
            StructType::HostCnxFailedNoLicenseEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedNoLicenseEvent>()?),
            StructType::HostCnxFailedNotFoundEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedNotFoundEvent>()?),
            StructType::HostCnxFailedTimeoutEvent => Some(from.as_any_ref().downcast_ref::<HostCnxFailedTimeoutEvent>()?),
            StructType::HostComplianceCheckedEvent => Some(from.as_any_ref().downcast_ref::<HostComplianceCheckedEvent>()?),
            StructType::HostCompliantEvent => Some(from.as_any_ref().downcast_ref::<HostCompliantEvent>()?),
            StructType::HostConfigAppliedEvent => Some(from.as_any_ref().downcast_ref::<HostConfigAppliedEvent>()?),
            StructType::HostConnectedEvent => Some(from.as_any_ref().downcast_ref::<HostConnectedEvent>()?),
            StructType::HostConnectionLostEvent => Some(from.as_any_ref().downcast_ref::<HostConnectionLostEvent>()?),
            StructType::HostDasDisabledEvent => Some(from.as_any_ref().downcast_ref::<HostDasDisabledEvent>()?),
            StructType::HostDasDisablingEvent => Some(from.as_any_ref().downcast_ref::<HostDasDisablingEvent>()?),
            StructType::HostDasEnabledEvent => Some(from.as_any_ref().downcast_ref::<HostDasEnabledEvent>()?),
            StructType::HostDasEnablingEvent => Some(from.as_any_ref().downcast_ref::<HostDasEnablingEvent>()?),
            StructType::HostDasErrorEvent => Some(from.as_any_ref().downcast_ref::<HostDasErrorEvent>()?),
            StructType::HostDasEvent => Some(from.as_any_ref().downcast_ref::<HostDasEvent>()?),
            StructType::HostExtraNetworksEvent => Some(from.as_any_ref().downcast_ref::<HostExtraNetworksEvent>()?),
            StructType::HostIsolationIpPingFailedEvent => Some(from.as_any_ref().downcast_ref::<HostIsolationIpPingFailedEvent>()?),
            StructType::HostMissingNetworksEvent => Some(from.as_any_ref().downcast_ref::<HostMissingNetworksEvent>()?),
            StructType::HostNoAvailableNetworksEvent => Some(from.as_any_ref().downcast_ref::<HostNoAvailableNetworksEvent>()?),
            StructType::HostNoHaEnabledPortGroupsEvent => Some(from.as_any_ref().downcast_ref::<HostNoHaEnabledPortGroupsEvent>()?),
            StructType::HostNoRedundantManagementNetworkEvent => Some(from.as_any_ref().downcast_ref::<HostNoRedundantManagementNetworkEvent>()?),
            StructType::HostNotInClusterEvent => Some(from.as_any_ref().downcast_ref::<HostNotInClusterEvent>()?),
            StructType::HostPrimaryAgentNotShortNameEvent => Some(from.as_any_ref().downcast_ref::<HostPrimaryAgentNotShortNameEvent>()?),
            StructType::HostShortNameInconsistentEvent => Some(from.as_any_ref().downcast_ref::<HostShortNameInconsistentEvent>()?),
            StructType::HostDasOkEvent => Some(from.as_any_ref().downcast_ref::<HostDasOkEvent>()?),
            StructType::HostDisconnectedEvent => Some(from.as_any_ref().downcast_ref::<HostDisconnectedEvent>()?),
            StructType::HostEnableAdminFailedEvent => Some(from.as_any_ref().downcast_ref::<HostEnableAdminFailedEvent>()?),
            StructType::HostGetShortNameFailedEvent => Some(from.as_any_ref().downcast_ref::<HostGetShortNameFailedEvent>()?),
            StructType::HostInAuditModeEvent => Some(from.as_any_ref().downcast_ref::<HostInAuditModeEvent>()?),
            StructType::HostIpChangedEvent => Some(from.as_any_ref().downcast_ref::<HostIpChangedEvent>()?),
            StructType::HostIpInconsistentEvent => Some(from.as_any_ref().downcast_ref::<HostIpInconsistentEvent>()?),
            StructType::HostIpToShortNameFailedEvent => Some(from.as_any_ref().downcast_ref::<HostIpToShortNameFailedEvent>()?),
            StructType::HostNonCompliantEvent => Some(from.as_any_ref().downcast_ref::<HostNonCompliantEvent>()?),
            StructType::HostProfileAppliedEvent => Some(from.as_any_ref().downcast_ref::<HostProfileAppliedEvent>()?),
            StructType::HostReconnectionFailedEvent => Some(from.as_any_ref().downcast_ref::<HostReconnectionFailedEvent>()?),
            StructType::HostRemovedEvent => Some(from.as_any_ref().downcast_ref::<HostRemovedEvent>()?),
            StructType::HostShortNameToIpFailedEvent => Some(from.as_any_ref().downcast_ref::<HostShortNameToIpFailedEvent>()?),
            StructType::HostShutdownEvent => Some(from.as_any_ref().downcast_ref::<HostShutdownEvent>()?),
            StructType::HostSpecificationChangedEvent => Some(from.as_any_ref().downcast_ref::<HostSpecificationChangedEvent>()?),
            StructType::HostSpecificationRequireEvent => Some(from.as_any_ref().downcast_ref::<HostSpecificationRequireEvent>()?),
            StructType::HostSpecificationUpdateEvent => Some(from.as_any_ref().downcast_ref::<HostSpecificationUpdateEvent>()?),
            StructType::HostSubSpecificationDeleteEvent => Some(from.as_any_ref().downcast_ref::<HostSubSpecificationDeleteEvent>()?),
            StructType::HostSubSpecificationUpdateEvent => Some(from.as_any_ref().downcast_ref::<HostSubSpecificationUpdateEvent>()?),
            StructType::HostSyncFailedEvent => Some(from.as_any_ref().downcast_ref::<HostSyncFailedEvent>()?),
            StructType::HostUpgradeFailedEvent => Some(from.as_any_ref().downcast_ref::<HostUpgradeFailedEvent>()?),
            StructType::HostUserWorldSwapNotEnabledEvent => Some(from.as_any_ref().downcast_ref::<HostUserWorldSwapNotEnabledEvent>()?),
            StructType::HostVnicConnectedToCustomizedDvPortEvent => Some(from.as_any_ref().downcast_ref::<HostVnicConnectedToCustomizedDvPortEvent>()?),
            StructType::HostWwnChangedEvent => Some(from.as_any_ref().downcast_ref::<HostWwnChangedEvent>()?),
            StructType::HostWwnConflictEvent => Some(from.as_any_ref().downcast_ref::<HostWwnConflictEvent>()?),
            StructType::LocalDatastoreCreatedEvent => Some(from.as_any_ref().downcast_ref::<LocalDatastoreCreatedEvent>()?),
            StructType::LocalTsmEnabledEvent => Some(from.as_any_ref().downcast_ref::<LocalTsmEnabledEvent>()?),
            StructType::NasDatastoreCreatedEvent => Some(from.as_any_ref().downcast_ref::<NasDatastoreCreatedEvent>()?),
            StructType::NoDatastoresConfiguredEvent => Some(from.as_any_ref().downcast_ref::<NoDatastoresConfiguredEvent>()?),
            StructType::RemoteTsmEnabledEvent => Some(from.as_any_ref().downcast_ref::<RemoteTsmEnabledEvent>()?),
            StructType::TimedOutHostOperationEvent => Some(from.as_any_ref().downcast_ref::<TimedOutHostOperationEvent>()?),
            StructType::UpdatedAgentBeingRestartedEvent => Some(from.as_any_ref().downcast_ref::<UpdatedAgentBeingRestartedEvent>()?),
            StructType::UserAssignedToGroup => Some(from.as_any_ref().downcast_ref::<UserAssignedToGroup>()?),
            StructType::UserPasswordChanged => Some(from.as_any_ref().downcast_ref::<UserPasswordChanged>()?),
            StructType::UserUnassignedFromGroup => Some(from.as_any_ref().downcast_ref::<UserUnassignedFromGroup>()?),
            StructType::VmfsDatastoreCreatedEvent => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreCreatedEvent>()?),
            StructType::VmfsDatastoreExpandedEvent => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreExpandedEvent>()?),
            StructType::VmfsDatastoreExtendedEvent => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreExtendedEvent>()?),
            StructType::VcAgentUninstallFailedEvent => Some(from.as_any_ref().downcast_ref::<VcAgentUninstallFailedEvent>()?),
            StructType::VcAgentUninstalledEvent => Some(from.as_any_ref().downcast_ref::<VcAgentUninstalledEvent>()?),
            StructType::VcAgentUpgradeFailedEvent => Some(from.as_any_ref().downcast_ref::<VcAgentUpgradeFailedEvent>()?),
            StructType::VcAgentUpgradedEvent => Some(from.as_any_ref().downcast_ref::<VcAgentUpgradedEvent>()?),
            StructType::VimAccountPasswordChangedEvent => Some(from.as_any_ref().downcast_ref::<VimAccountPasswordChangedEvent>()?),
            StructType::IScsiBootFailureEvent => Some(from.as_any_ref().downcast_ref::<IScsiBootFailureEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostEvent => Ok(from.as_any_box().downcast::<HostEvent>()?),
            StructType::AccountCreatedEvent => Ok(from.as_any_box().downcast::<AccountCreatedEvent>()?),
            StructType::AccountRemovedEvent => Ok(from.as_any_box().downcast::<AccountRemovedEvent>()?),
            StructType::AccountUpdatedEvent => Ok(from.as_any_box().downcast::<AccountUpdatedEvent>()?),
            StructType::AdminPasswordNotChangedEvent => Ok(from.as_any_box().downcast::<AdminPasswordNotChangedEvent>()?),
            StructType::CanceledHostOperationEvent => Ok(from.as_any_box().downcast::<CanceledHostOperationEvent>()?),
            StructType::DatastoreDiscoveredEvent => Ok(from.as_any_box().downcast::<DatastoreDiscoveredEvent>()?),
            StructType::DatastorePrincipalConfigured => Ok(from.as_any_box().downcast::<DatastorePrincipalConfigured>()?),
            StructType::DatastoreRemovedOnHostEvent => Ok(from.as_any_box().downcast::<DatastoreRemovedOnHostEvent>()?),
            StructType::DatastoreRenamedOnHostEvent => Ok(from.as_any_box().downcast::<DatastoreRenamedOnHostEvent>()?),
            StructType::DrsResourceConfigureFailedEvent => Ok(from.as_any_box().downcast::<DrsResourceConfigureFailedEvent>()?),
            StructType::DrsResourceConfigureSyncedEvent => Ok(from.as_any_box().downcast::<DrsResourceConfigureSyncedEvent>()?),
            StructType::DuplicateIpDetectedEvent => Ok(from.as_any_box().downcast::<DuplicateIpDetectedEvent>()?),
            StructType::DvsHealthStatusChangeEvent => Ok(from.as_any_box().downcast::<DvsHealthStatusChangeEvent>()?),
            StructType::MtuMatchEvent => Ok(from.as_any_box().downcast::<MtuMatchEvent>()?),
            StructType::MtuMismatchEvent => Ok(from.as_any_box().downcast::<MtuMismatchEvent>()?),
            StructType::TeamingMatchEvent => Ok(from.as_any_box().downcast::<TeamingMatchEvent>()?),
            StructType::TeamingMisMatchEvent => Ok(from.as_any_box().downcast::<TeamingMisMatchEvent>()?),
            StructType::UplinkPortMtuNotSupportEvent => Ok(from.as_any_box().downcast::<UplinkPortMtuNotSupportEvent>()?),
            StructType::UplinkPortMtuSupportEvent => Ok(from.as_any_box().downcast::<UplinkPortMtuSupportEvent>()?),
            StructType::UplinkPortVlanTrunkedEvent => Ok(from.as_any_box().downcast::<UplinkPortVlanTrunkedEvent>()?),
            StructType::UplinkPortVlanUntrunkedEvent => Ok(from.as_any_box().downcast::<UplinkPortVlanUntrunkedEvent>()?),
            StructType::EnteredMaintenanceModeEvent => Ok(from.as_any_box().downcast::<EnteredMaintenanceModeEvent>()?),
            StructType::EnteredStandbyModeEvent => Ok(from.as_any_box().downcast::<EnteredStandbyModeEvent>()?),
            StructType::DrsEnteredStandbyModeEvent => Ok(from.as_any_box().downcast::<DrsEnteredStandbyModeEvent>()?),
            StructType::EnteringMaintenanceModeEvent => Ok(from.as_any_box().downcast::<EnteringMaintenanceModeEvent>()?),
            StructType::EnteringStandbyModeEvent => Ok(from.as_any_box().downcast::<EnteringStandbyModeEvent>()?),
            StructType::DrsEnteringStandbyModeEvent => Ok(from.as_any_box().downcast::<DrsEnteringStandbyModeEvent>()?),
            StructType::ExitMaintenanceModeEvent => Ok(from.as_any_box().downcast::<ExitMaintenanceModeEvent>()?),
            StructType::ExitStandbyModeFailedEvent => Ok(from.as_any_box().downcast::<ExitStandbyModeFailedEvent>()?),
            StructType::DrsExitStandbyModeFailedEvent => Ok(from.as_any_box().downcast::<DrsExitStandbyModeFailedEvent>()?),
            StructType::ExitedStandbyModeEvent => Ok(from.as_any_box().downcast::<ExitedStandbyModeEvent>()?),
            StructType::DrsExitedStandbyModeEvent => Ok(from.as_any_box().downcast::<DrsExitedStandbyModeEvent>()?),
            StructType::ExitingStandbyModeEvent => Ok(from.as_any_box().downcast::<ExitingStandbyModeEvent>()?),
            StructType::DrsExitingStandbyModeEvent => Ok(from.as_any_box().downcast::<DrsExitingStandbyModeEvent>()?),
            StructType::GhostDvsProxySwitchDetectedEvent => Ok(from.as_any_box().downcast::<GhostDvsProxySwitchDetectedEvent>()?),
            StructType::GhostDvsProxySwitchRemovedEvent => Ok(from.as_any_box().downcast::<GhostDvsProxySwitchRemovedEvent>()?),
            StructType::HostAddFailedEvent => Ok(from.as_any_box().downcast::<HostAddFailedEvent>()?),
            StructType::HostAddedEvent => Ok(from.as_any_box().downcast::<HostAddedEvent>()?),
            StructType::HostAdminDisableEvent => Ok(from.as_any_box().downcast::<HostAdminDisableEvent>()?),
            StructType::HostAdminEnableEvent => Ok(from.as_any_box().downcast::<HostAdminEnableEvent>()?),
            StructType::HostCnxFailedAccountFailedEvent => Ok(from.as_any_box().downcast::<HostCnxFailedAccountFailedEvent>()?),
            StructType::HostCnxFailedAlreadyManagedEvent => Ok(from.as_any_box().downcast::<HostCnxFailedAlreadyManagedEvent>()?),
            StructType::HostCnxFailedBadCcagentEvent => Ok(from.as_any_box().downcast::<HostCnxFailedBadCcagentEvent>()?),
            StructType::HostCnxFailedBadUsernameEvent => Ok(from.as_any_box().downcast::<HostCnxFailedBadUsernameEvent>()?),
            StructType::HostCnxFailedBadVersionEvent => Ok(from.as_any_box().downcast::<HostCnxFailedBadVersionEvent>()?),
            StructType::HostCnxFailedCcagentUpgradeEvent => Ok(from.as_any_box().downcast::<HostCnxFailedCcagentUpgradeEvent>()?),
            StructType::HostCnxFailedEvent => Ok(from.as_any_box().downcast::<HostCnxFailedEvent>()?),
            StructType::HostCnxFailedNetworkErrorEvent => Ok(from.as_any_box().downcast::<HostCnxFailedNetworkErrorEvent>()?),
            StructType::HostCnxFailedNoAccessEvent => Ok(from.as_any_box().downcast::<HostCnxFailedNoAccessEvent>()?),
            StructType::HostCnxFailedNoConnectionEvent => Ok(from.as_any_box().downcast::<HostCnxFailedNoConnectionEvent>()?),
            StructType::HostCnxFailedNoLicenseEvent => Ok(from.as_any_box().downcast::<HostCnxFailedNoLicenseEvent>()?),
            StructType::HostCnxFailedNotFoundEvent => Ok(from.as_any_box().downcast::<HostCnxFailedNotFoundEvent>()?),
            StructType::HostCnxFailedTimeoutEvent => Ok(from.as_any_box().downcast::<HostCnxFailedTimeoutEvent>()?),
            StructType::HostComplianceCheckedEvent => Ok(from.as_any_box().downcast::<HostComplianceCheckedEvent>()?),
            StructType::HostCompliantEvent => Ok(from.as_any_box().downcast::<HostCompliantEvent>()?),
            StructType::HostConfigAppliedEvent => Ok(from.as_any_box().downcast::<HostConfigAppliedEvent>()?),
            StructType::HostConnectedEvent => Ok(from.as_any_box().downcast::<HostConnectedEvent>()?),
            StructType::HostConnectionLostEvent => Ok(from.as_any_box().downcast::<HostConnectionLostEvent>()?),
            StructType::HostDasDisabledEvent => Ok(from.as_any_box().downcast::<HostDasDisabledEvent>()?),
            StructType::HostDasDisablingEvent => Ok(from.as_any_box().downcast::<HostDasDisablingEvent>()?),
            StructType::HostDasEnabledEvent => Ok(from.as_any_box().downcast::<HostDasEnabledEvent>()?),
            StructType::HostDasEnablingEvent => Ok(from.as_any_box().downcast::<HostDasEnablingEvent>()?),
            StructType::HostDasErrorEvent => Ok(from.as_any_box().downcast::<HostDasErrorEvent>()?),
            StructType::HostDasEvent => Ok(from.as_any_box().downcast::<HostDasEvent>()?),
            StructType::HostExtraNetworksEvent => Ok(from.as_any_box().downcast::<HostExtraNetworksEvent>()?),
            StructType::HostIsolationIpPingFailedEvent => Ok(from.as_any_box().downcast::<HostIsolationIpPingFailedEvent>()?),
            StructType::HostMissingNetworksEvent => Ok(from.as_any_box().downcast::<HostMissingNetworksEvent>()?),
            StructType::HostNoAvailableNetworksEvent => Ok(from.as_any_box().downcast::<HostNoAvailableNetworksEvent>()?),
            StructType::HostNoHaEnabledPortGroupsEvent => Ok(from.as_any_box().downcast::<HostNoHaEnabledPortGroupsEvent>()?),
            StructType::HostNoRedundantManagementNetworkEvent => Ok(from.as_any_box().downcast::<HostNoRedundantManagementNetworkEvent>()?),
            StructType::HostNotInClusterEvent => Ok(from.as_any_box().downcast::<HostNotInClusterEvent>()?),
            StructType::HostPrimaryAgentNotShortNameEvent => Ok(from.as_any_box().downcast::<HostPrimaryAgentNotShortNameEvent>()?),
            StructType::HostShortNameInconsistentEvent => Ok(from.as_any_box().downcast::<HostShortNameInconsistentEvent>()?),
            StructType::HostDasOkEvent => Ok(from.as_any_box().downcast::<HostDasOkEvent>()?),
            StructType::HostDisconnectedEvent => Ok(from.as_any_box().downcast::<HostDisconnectedEvent>()?),
            StructType::HostEnableAdminFailedEvent => Ok(from.as_any_box().downcast::<HostEnableAdminFailedEvent>()?),
            StructType::HostGetShortNameFailedEvent => Ok(from.as_any_box().downcast::<HostGetShortNameFailedEvent>()?),
            StructType::HostInAuditModeEvent => Ok(from.as_any_box().downcast::<HostInAuditModeEvent>()?),
            StructType::HostIpChangedEvent => Ok(from.as_any_box().downcast::<HostIpChangedEvent>()?),
            StructType::HostIpInconsistentEvent => Ok(from.as_any_box().downcast::<HostIpInconsistentEvent>()?),
            StructType::HostIpToShortNameFailedEvent => Ok(from.as_any_box().downcast::<HostIpToShortNameFailedEvent>()?),
            StructType::HostNonCompliantEvent => Ok(from.as_any_box().downcast::<HostNonCompliantEvent>()?),
            StructType::HostProfileAppliedEvent => Ok(from.as_any_box().downcast::<HostProfileAppliedEvent>()?),
            StructType::HostReconnectionFailedEvent => Ok(from.as_any_box().downcast::<HostReconnectionFailedEvent>()?),
            StructType::HostRemovedEvent => Ok(from.as_any_box().downcast::<HostRemovedEvent>()?),
            StructType::HostShortNameToIpFailedEvent => Ok(from.as_any_box().downcast::<HostShortNameToIpFailedEvent>()?),
            StructType::HostShutdownEvent => Ok(from.as_any_box().downcast::<HostShutdownEvent>()?),
            StructType::HostSpecificationChangedEvent => Ok(from.as_any_box().downcast::<HostSpecificationChangedEvent>()?),
            StructType::HostSpecificationRequireEvent => Ok(from.as_any_box().downcast::<HostSpecificationRequireEvent>()?),
            StructType::HostSpecificationUpdateEvent => Ok(from.as_any_box().downcast::<HostSpecificationUpdateEvent>()?),
            StructType::HostSubSpecificationDeleteEvent => Ok(from.as_any_box().downcast::<HostSubSpecificationDeleteEvent>()?),
            StructType::HostSubSpecificationUpdateEvent => Ok(from.as_any_box().downcast::<HostSubSpecificationUpdateEvent>()?),
            StructType::HostSyncFailedEvent => Ok(from.as_any_box().downcast::<HostSyncFailedEvent>()?),
            StructType::HostUpgradeFailedEvent => Ok(from.as_any_box().downcast::<HostUpgradeFailedEvent>()?),
            StructType::HostUserWorldSwapNotEnabledEvent => Ok(from.as_any_box().downcast::<HostUserWorldSwapNotEnabledEvent>()?),
            StructType::HostVnicConnectedToCustomizedDvPortEvent => Ok(from.as_any_box().downcast::<HostVnicConnectedToCustomizedDvPortEvent>()?),
            StructType::HostWwnChangedEvent => Ok(from.as_any_box().downcast::<HostWwnChangedEvent>()?),
            StructType::HostWwnConflictEvent => Ok(from.as_any_box().downcast::<HostWwnConflictEvent>()?),
            StructType::LocalDatastoreCreatedEvent => Ok(from.as_any_box().downcast::<LocalDatastoreCreatedEvent>()?),
            StructType::LocalTsmEnabledEvent => Ok(from.as_any_box().downcast::<LocalTsmEnabledEvent>()?),
            StructType::NasDatastoreCreatedEvent => Ok(from.as_any_box().downcast::<NasDatastoreCreatedEvent>()?),
            StructType::NoDatastoresConfiguredEvent => Ok(from.as_any_box().downcast::<NoDatastoresConfiguredEvent>()?),
            StructType::RemoteTsmEnabledEvent => Ok(from.as_any_box().downcast::<RemoteTsmEnabledEvent>()?),
            StructType::TimedOutHostOperationEvent => Ok(from.as_any_box().downcast::<TimedOutHostOperationEvent>()?),
            StructType::UpdatedAgentBeingRestartedEvent => Ok(from.as_any_box().downcast::<UpdatedAgentBeingRestartedEvent>()?),
            StructType::UserAssignedToGroup => Ok(from.as_any_box().downcast::<UserAssignedToGroup>()?),
            StructType::UserPasswordChanged => Ok(from.as_any_box().downcast::<UserPasswordChanged>()?),
            StructType::UserUnassignedFromGroup => Ok(from.as_any_box().downcast::<UserUnassignedFromGroup>()?),
            StructType::VmfsDatastoreCreatedEvent => Ok(from.as_any_box().downcast::<VmfsDatastoreCreatedEvent>()?),
            StructType::VmfsDatastoreExpandedEvent => Ok(from.as_any_box().downcast::<VmfsDatastoreExpandedEvent>()?),
            StructType::VmfsDatastoreExtendedEvent => Ok(from.as_any_box().downcast::<VmfsDatastoreExtendedEvent>()?),
            StructType::VcAgentUninstallFailedEvent => Ok(from.as_any_box().downcast::<VcAgentUninstallFailedEvent>()?),
            StructType::VcAgentUninstalledEvent => Ok(from.as_any_box().downcast::<VcAgentUninstalledEvent>()?),
            StructType::VcAgentUpgradeFailedEvent => Ok(from.as_any_box().downcast::<VcAgentUpgradeFailedEvent>()?),
            StructType::VcAgentUpgradedEvent => Ok(from.as_any_box().downcast::<VcAgentUpgradedEvent>()?),
            StructType::VimAccountPasswordChangedEvent => Ok(from.as_any_box().downcast::<VimAccountPasswordChangedEvent>()?),
            StructType::IScsiBootFailureEvent => Ok(from.as_any_box().downcast::<IScsiBootFailureEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Health check status of an switch is changed.
pub trait DvsHealthStatusChangeEventTrait : super::traits::HostEventTrait {
    /// UUID of the DVS the host is connected to.
    fn get_switch_uuid(&self) -> &str;
    /// Health check status.
    fn get_health_result(&self) -> &Option<Box<dyn super::traits::HostMemberHealthCheckResultTrait>>;
}
impl<'s> serde::Serialize for dyn DvsHealthStatusChangeEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DvsHealthStatusChangeEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DvsHealthStatusChangeEventVisitor)
            }
        }

struct DvsHealthStatusChangeEventVisitor;

impl<'de> de::Visitor<'de> for DvsHealthStatusChangeEventVisitor {
    type Value = Box<dyn DvsHealthStatusChangeEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DvsHealthStatusChangeEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DvsHealthStatusChangeEventTrait for DvsHealthStatusChangeEvent {
    fn get_switch_uuid(&self) -> &str { &self.switch_uuid }
    fn get_health_result(&self) -> &Option<Box<dyn super::traits::HostMemberHealthCheckResultTrait>> { &self.health_result }
}
impl DvsHealthStatusChangeEventTrait for MtuMatchEvent {
    fn get_switch_uuid(&self) -> &str { &self.switch_uuid }
    fn get_health_result(&self) -> &Option<Box<dyn super::traits::HostMemberHealthCheckResultTrait>> { &self.health_result }
}
impl DvsHealthStatusChangeEventTrait for MtuMismatchEvent {
    fn get_switch_uuid(&self) -> &str { &self.switch_uuid }
    fn get_health_result(&self) -> &Option<Box<dyn super::traits::HostMemberHealthCheckResultTrait>> { &self.health_result }
}
impl DvsHealthStatusChangeEventTrait for TeamingMatchEvent {
    fn get_switch_uuid(&self) -> &str { &self.switch_uuid }
    fn get_health_result(&self) -> &Option<Box<dyn super::traits::HostMemberHealthCheckResultTrait>> { &self.health_result }
}
impl DvsHealthStatusChangeEventTrait for TeamingMisMatchEvent {
    fn get_switch_uuid(&self) -> &str { &self.switch_uuid }
    fn get_health_result(&self) -> &Option<Box<dyn super::traits::HostMemberHealthCheckResultTrait>> { &self.health_result }
}
impl DvsHealthStatusChangeEventTrait for UplinkPortMtuNotSupportEvent {
    fn get_switch_uuid(&self) -> &str { &self.switch_uuid }
    fn get_health_result(&self) -> &Option<Box<dyn super::traits::HostMemberHealthCheckResultTrait>> { &self.health_result }
}
impl DvsHealthStatusChangeEventTrait for UplinkPortMtuSupportEvent {
    fn get_switch_uuid(&self) -> &str { &self.switch_uuid }
    fn get_health_result(&self) -> &Option<Box<dyn super::traits::HostMemberHealthCheckResultTrait>> { &self.health_result }
}
impl DvsHealthStatusChangeEventTrait for UplinkPortVlanTrunkedEvent {
    fn get_switch_uuid(&self) -> &str { &self.switch_uuid }
    fn get_health_result(&self) -> &Option<Box<dyn super::traits::HostMemberHealthCheckResultTrait>> { &self.health_result }
}
impl DvsHealthStatusChangeEventTrait for UplinkPortVlanUntrunkedEvent {
    fn get_switch_uuid(&self) -> &str { &self.switch_uuid }
    fn get_health_result(&self) -> &Option<Box<dyn super::traits::HostMemberHealthCheckResultTrait>> { &self.health_result }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DvsHealthStatusChangeEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsHealthStatusChangeEvent => Some(from.as_any_ref().downcast_ref::<DvsHealthStatusChangeEvent>()?),
            StructType::MtuMatchEvent => Some(from.as_any_ref().downcast_ref::<MtuMatchEvent>()?),
            StructType::MtuMismatchEvent => Some(from.as_any_ref().downcast_ref::<MtuMismatchEvent>()?),
            StructType::TeamingMatchEvent => Some(from.as_any_ref().downcast_ref::<TeamingMatchEvent>()?),
            StructType::TeamingMisMatchEvent => Some(from.as_any_ref().downcast_ref::<TeamingMisMatchEvent>()?),
            StructType::UplinkPortMtuNotSupportEvent => Some(from.as_any_ref().downcast_ref::<UplinkPortMtuNotSupportEvent>()?),
            StructType::UplinkPortMtuSupportEvent => Some(from.as_any_ref().downcast_ref::<UplinkPortMtuSupportEvent>()?),
            StructType::UplinkPortVlanTrunkedEvent => Some(from.as_any_ref().downcast_ref::<UplinkPortVlanTrunkedEvent>()?),
            StructType::UplinkPortVlanUntrunkedEvent => Some(from.as_any_ref().downcast_ref::<UplinkPortVlanUntrunkedEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsHealthStatusChangeEvent => Ok(from.as_any_box().downcast::<DvsHealthStatusChangeEvent>()?),
            StructType::MtuMatchEvent => Ok(from.as_any_box().downcast::<MtuMatchEvent>()?),
            StructType::MtuMismatchEvent => Ok(from.as_any_box().downcast::<MtuMismatchEvent>()?),
            StructType::TeamingMatchEvent => Ok(from.as_any_box().downcast::<TeamingMatchEvent>()?),
            StructType::TeamingMisMatchEvent => Ok(from.as_any_box().downcast::<TeamingMisMatchEvent>()?),
            StructType::UplinkPortMtuNotSupportEvent => Ok(from.as_any_box().downcast::<UplinkPortMtuNotSupportEvent>()?),
            StructType::UplinkPortMtuSupportEvent => Ok(from.as_any_box().downcast::<UplinkPortMtuSupportEvent>()?),
            StructType::UplinkPortVlanTrunkedEvent => Ok(from.as_any_box().downcast::<UplinkPortVlanTrunkedEvent>()?),
            StructType::UplinkPortVlanUntrunkedEvent => Ok(from.as_any_box().downcast::<UplinkPortVlanUntrunkedEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This event records that the host has successfully entered
/// standby mode.
/// 
/// A host in this mode has no running virtual machines and no
/// provisioning operations are occurring.
pub trait EnteredStandbyModeEventTrait : super::traits::HostEventTrait {
}
impl<'s> serde::Serialize for dyn EnteredStandbyModeEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn EnteredStandbyModeEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(EnteredStandbyModeEventVisitor)
            }
        }

struct EnteredStandbyModeEventVisitor;

impl<'de> de::Visitor<'de> for EnteredStandbyModeEventVisitor {
    type Value = Box<dyn EnteredStandbyModeEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid EnteredStandbyModeEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl EnteredStandbyModeEventTrait for EnteredStandbyModeEvent {
}
impl EnteredStandbyModeEventTrait for DrsEnteredStandbyModeEvent {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn EnteredStandbyModeEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::EnteredStandbyModeEvent => Some(from.as_any_ref().downcast_ref::<EnteredStandbyModeEvent>()?),
            StructType::DrsEnteredStandbyModeEvent => Some(from.as_any_ref().downcast_ref::<DrsEnteredStandbyModeEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::EnteredStandbyModeEvent => Ok(from.as_any_box().downcast::<EnteredStandbyModeEvent>()?),
            StructType::DrsEnteredStandbyModeEvent => Ok(from.as_any_box().downcast::<DrsEnteredStandbyModeEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This event records that a host has begun the process of entering
/// standby mode.
/// 
/// All virtual machine operations
/// are blocked, except the following:
/// - MigrateVM
/// - PowerOffVM
/// - SuspendVM
/// - ShutdownGuest
/// - StandbyGuest
pub trait EnteringStandbyModeEventTrait : super::traits::HostEventTrait {
}
impl<'s> serde::Serialize for dyn EnteringStandbyModeEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn EnteringStandbyModeEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(EnteringStandbyModeEventVisitor)
            }
        }

struct EnteringStandbyModeEventVisitor;

impl<'de> de::Visitor<'de> for EnteringStandbyModeEventVisitor {
    type Value = Box<dyn EnteringStandbyModeEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid EnteringStandbyModeEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl EnteringStandbyModeEventTrait for EnteringStandbyModeEvent {
}
impl EnteringStandbyModeEventTrait for DrsEnteringStandbyModeEvent {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn EnteringStandbyModeEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::EnteringStandbyModeEvent => Some(from.as_any_ref().downcast_ref::<EnteringStandbyModeEvent>()?),
            StructType::DrsEnteringStandbyModeEvent => Some(from.as_any_ref().downcast_ref::<DrsEnteringStandbyModeEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::EnteringStandbyModeEvent => Ok(from.as_any_box().downcast::<EnteringStandbyModeEvent>()?),
            StructType::DrsEnteringStandbyModeEvent => Ok(from.as_any_box().downcast::<DrsEnteringStandbyModeEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This event records that the host failed to exit standby mode.
pub trait ExitStandbyModeFailedEventTrait : super::traits::HostEventTrait {
}
impl<'s> serde::Serialize for dyn ExitStandbyModeFailedEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ExitStandbyModeFailedEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ExitStandbyModeFailedEventVisitor)
            }
        }

struct ExitStandbyModeFailedEventVisitor;

impl<'de> de::Visitor<'de> for ExitStandbyModeFailedEventVisitor {
    type Value = Box<dyn ExitStandbyModeFailedEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ExitStandbyModeFailedEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ExitStandbyModeFailedEventTrait for ExitStandbyModeFailedEvent {
}
impl ExitStandbyModeFailedEventTrait for DrsExitStandbyModeFailedEvent {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ExitStandbyModeFailedEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ExitStandbyModeFailedEvent => Some(from.as_any_ref().downcast_ref::<ExitStandbyModeFailedEvent>()?),
            StructType::DrsExitStandbyModeFailedEvent => Some(from.as_any_ref().downcast_ref::<DrsExitStandbyModeFailedEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ExitStandbyModeFailedEvent => Ok(from.as_any_box().downcast::<ExitStandbyModeFailedEvent>()?),
            StructType::DrsExitStandbyModeFailedEvent => Ok(from.as_any_box().downcast::<DrsExitStandbyModeFailedEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This event records that the host is no longer in
/// standby mode.
pub trait ExitedStandbyModeEventTrait : super::traits::HostEventTrait {
}
impl<'s> serde::Serialize for dyn ExitedStandbyModeEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ExitedStandbyModeEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ExitedStandbyModeEventVisitor)
            }
        }

struct ExitedStandbyModeEventVisitor;

impl<'de> de::Visitor<'de> for ExitedStandbyModeEventVisitor {
    type Value = Box<dyn ExitedStandbyModeEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ExitedStandbyModeEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ExitedStandbyModeEventTrait for ExitedStandbyModeEvent {
}
impl ExitedStandbyModeEventTrait for DrsExitedStandbyModeEvent {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ExitedStandbyModeEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ExitedStandbyModeEvent => Some(from.as_any_ref().downcast_ref::<ExitedStandbyModeEvent>()?),
            StructType::DrsExitedStandbyModeEvent => Some(from.as_any_ref().downcast_ref::<DrsExitedStandbyModeEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ExitedStandbyModeEvent => Ok(from.as_any_box().downcast::<ExitedStandbyModeEvent>()?),
            StructType::DrsExitedStandbyModeEvent => Ok(from.as_any_box().downcast::<DrsExitedStandbyModeEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This event records that a host has begun the process of
/// exiting standby mode.
pub trait ExitingStandbyModeEventTrait : super::traits::HostEventTrait {
}
impl<'s> serde::Serialize for dyn ExitingStandbyModeEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ExitingStandbyModeEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ExitingStandbyModeEventVisitor)
            }
        }

struct ExitingStandbyModeEventVisitor;

impl<'de> de::Visitor<'de> for ExitingStandbyModeEventVisitor {
    type Value = Box<dyn ExitingStandbyModeEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ExitingStandbyModeEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ExitingStandbyModeEventTrait for ExitingStandbyModeEvent {
}
impl ExitingStandbyModeEventTrait for DrsExitingStandbyModeEvent {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ExitingStandbyModeEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ExitingStandbyModeEvent => Some(from.as_any_ref().downcast_ref::<ExitingStandbyModeEvent>()?),
            StructType::DrsExitingStandbyModeEvent => Some(from.as_any_ref().downcast_ref::<DrsExitingStandbyModeEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ExitingStandbyModeEvent => Ok(from.as_any_box().downcast::<ExitingStandbyModeEvent>()?),
            StructType::DrsExitingStandbyModeEvent => Ok(from.as_any_box().downcast::<DrsExitingStandbyModeEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Top-level event for host DAS events to extend.
pub trait HostDasEventTrait : super::traits::HostEventTrait {
}
impl<'s> serde::Serialize for dyn HostDasEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostDasEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostDasEventVisitor)
            }
        }

struct HostDasEventVisitor;

impl<'de> de::Visitor<'de> for HostDasEventVisitor {
    type Value = Box<dyn HostDasEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostDasEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostDasEventTrait for HostDasEvent {
}
impl HostDasEventTrait for HostExtraNetworksEvent {
}
impl HostDasEventTrait for HostIsolationIpPingFailedEvent {
}
impl HostDasEventTrait for HostMissingNetworksEvent {
}
impl HostDasEventTrait for HostNoAvailableNetworksEvent {
}
impl HostDasEventTrait for HostNoHaEnabledPortGroupsEvent {
}
impl HostDasEventTrait for HostNoRedundantManagementNetworkEvent {
}
impl HostDasEventTrait for HostNotInClusterEvent {
}
impl HostDasEventTrait for HostPrimaryAgentNotShortNameEvent {
}
impl HostDasEventTrait for HostShortNameInconsistentEvent {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostDasEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostDasEvent => Some(from.as_any_ref().downcast_ref::<HostDasEvent>()?),
            StructType::HostExtraNetworksEvent => Some(from.as_any_ref().downcast_ref::<HostExtraNetworksEvent>()?),
            StructType::HostIsolationIpPingFailedEvent => Some(from.as_any_ref().downcast_ref::<HostIsolationIpPingFailedEvent>()?),
            StructType::HostMissingNetworksEvent => Some(from.as_any_ref().downcast_ref::<HostMissingNetworksEvent>()?),
            StructType::HostNoAvailableNetworksEvent => Some(from.as_any_ref().downcast_ref::<HostNoAvailableNetworksEvent>()?),
            StructType::HostNoHaEnabledPortGroupsEvent => Some(from.as_any_ref().downcast_ref::<HostNoHaEnabledPortGroupsEvent>()?),
            StructType::HostNoRedundantManagementNetworkEvent => Some(from.as_any_ref().downcast_ref::<HostNoRedundantManagementNetworkEvent>()?),
            StructType::HostNotInClusterEvent => Some(from.as_any_ref().downcast_ref::<HostNotInClusterEvent>()?),
            StructType::HostPrimaryAgentNotShortNameEvent => Some(from.as_any_ref().downcast_ref::<HostPrimaryAgentNotShortNameEvent>()?),
            StructType::HostShortNameInconsistentEvent => Some(from.as_any_ref().downcast_ref::<HostShortNameInconsistentEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostDasEvent => Ok(from.as_any_box().downcast::<HostDasEvent>()?),
            StructType::HostExtraNetworksEvent => Ok(from.as_any_box().downcast::<HostExtraNetworksEvent>()?),
            StructType::HostIsolationIpPingFailedEvent => Ok(from.as_any_box().downcast::<HostIsolationIpPingFailedEvent>()?),
            StructType::HostMissingNetworksEvent => Ok(from.as_any_box().downcast::<HostMissingNetworksEvent>()?),
            StructType::HostNoAvailableNetworksEvent => Ok(from.as_any_box().downcast::<HostNoAvailableNetworksEvent>()?),
            StructType::HostNoHaEnabledPortGroupsEvent => Ok(from.as_any_box().downcast::<HostNoHaEnabledPortGroupsEvent>()?),
            StructType::HostNoRedundantManagementNetworkEvent => Ok(from.as_any_box().downcast::<HostNoRedundantManagementNetworkEvent>()?),
            StructType::HostNotInClusterEvent => Ok(from.as_any_box().downcast::<HostNotInClusterEvent>()?),
            StructType::HostPrimaryAgentNotShortNameEvent => Ok(from.as_any_box().downcast::<HostPrimaryAgentNotShortNameEvent>()?),
            StructType::HostShortNameInconsistentEvent => Ok(from.as_any_box().downcast::<HostShortNameInconsistentEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This is a base licensing event to group all license events.
pub trait LicenseEventTrait : super::traits::EventTrait {
}
impl<'s> serde::Serialize for dyn LicenseEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn LicenseEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(LicenseEventVisitor)
            }
        }

struct LicenseEventVisitor;

impl<'de> de::Visitor<'de> for LicenseEventVisitor {
    type Value = Box<dyn LicenseEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid LicenseEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl LicenseEventTrait for LicenseEvent {
}
impl LicenseEventTrait for AllVirtualMachinesLicensedEvent {
}
impl LicenseEventTrait for HostInventoryFullEvent {
}
impl LicenseEventTrait for HostLicenseExpiredEvent {
}
impl LicenseEventTrait for IncorrectHostInformationEvent {
}
impl LicenseEventTrait for InvalidEditionEvent {
}
impl LicenseEventTrait for LicenseNonComplianceEvent {
}
impl LicenseEventTrait for LicenseRestrictedEvent {
}
impl LicenseEventTrait for LicenseServerAvailableEvent {
}
impl LicenseEventTrait for LicenseServerUnavailableEvent {
}
impl LicenseEventTrait for NoLicenseEvent {
}
impl LicenseEventTrait for ServerLicenseExpiredEvent {
}
impl LicenseEventTrait for UnlicensedVirtualMachinesEvent {
}
impl LicenseEventTrait for UnlicensedVirtualMachinesFoundEvent {
}
impl LicenseEventTrait for VMotionLicenseExpiredEvent {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn LicenseEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::LicenseEvent => Some(from.as_any_ref().downcast_ref::<LicenseEvent>()?),
            StructType::AllVirtualMachinesLicensedEvent => Some(from.as_any_ref().downcast_ref::<AllVirtualMachinesLicensedEvent>()?),
            StructType::HostInventoryFullEvent => Some(from.as_any_ref().downcast_ref::<HostInventoryFullEvent>()?),
            StructType::HostLicenseExpiredEvent => Some(from.as_any_ref().downcast_ref::<HostLicenseExpiredEvent>()?),
            StructType::IncorrectHostInformationEvent => Some(from.as_any_ref().downcast_ref::<IncorrectHostInformationEvent>()?),
            StructType::InvalidEditionEvent => Some(from.as_any_ref().downcast_ref::<InvalidEditionEvent>()?),
            StructType::LicenseNonComplianceEvent => Some(from.as_any_ref().downcast_ref::<LicenseNonComplianceEvent>()?),
            StructType::LicenseRestrictedEvent => Some(from.as_any_ref().downcast_ref::<LicenseRestrictedEvent>()?),
            StructType::LicenseServerAvailableEvent => Some(from.as_any_ref().downcast_ref::<LicenseServerAvailableEvent>()?),
            StructType::LicenseServerUnavailableEvent => Some(from.as_any_ref().downcast_ref::<LicenseServerUnavailableEvent>()?),
            StructType::NoLicenseEvent => Some(from.as_any_ref().downcast_ref::<NoLicenseEvent>()?),
            StructType::ServerLicenseExpiredEvent => Some(from.as_any_ref().downcast_ref::<ServerLicenseExpiredEvent>()?),
            StructType::UnlicensedVirtualMachinesEvent => Some(from.as_any_ref().downcast_ref::<UnlicensedVirtualMachinesEvent>()?),
            StructType::UnlicensedVirtualMachinesFoundEvent => Some(from.as_any_ref().downcast_ref::<UnlicensedVirtualMachinesFoundEvent>()?),
            StructType::VMotionLicenseExpiredEvent => Some(from.as_any_ref().downcast_ref::<VMotionLicenseExpiredEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::LicenseEvent => Ok(from.as_any_box().downcast::<LicenseEvent>()?),
            StructType::AllVirtualMachinesLicensedEvent => Ok(from.as_any_box().downcast::<AllVirtualMachinesLicensedEvent>()?),
            StructType::HostInventoryFullEvent => Ok(from.as_any_box().downcast::<HostInventoryFullEvent>()?),
            StructType::HostLicenseExpiredEvent => Ok(from.as_any_box().downcast::<HostLicenseExpiredEvent>()?),
            StructType::IncorrectHostInformationEvent => Ok(from.as_any_box().downcast::<IncorrectHostInformationEvent>()?),
            StructType::InvalidEditionEvent => Ok(from.as_any_box().downcast::<InvalidEditionEvent>()?),
            StructType::LicenseNonComplianceEvent => Ok(from.as_any_box().downcast::<LicenseNonComplianceEvent>()?),
            StructType::LicenseRestrictedEvent => Ok(from.as_any_box().downcast::<LicenseRestrictedEvent>()?),
            StructType::LicenseServerAvailableEvent => Ok(from.as_any_box().downcast::<LicenseServerAvailableEvent>()?),
            StructType::LicenseServerUnavailableEvent => Ok(from.as_any_box().downcast::<LicenseServerUnavailableEvent>()?),
            StructType::NoLicenseEvent => Ok(from.as_any_box().downcast::<NoLicenseEvent>()?),
            StructType::ServerLicenseExpiredEvent => Ok(from.as_any_box().downcast::<ServerLicenseExpiredEvent>()?),
            StructType::UnlicensedVirtualMachinesEvent => Ok(from.as_any_box().downcast::<UnlicensedVirtualMachinesEvent>()?),
            StructType::UnlicensedVirtualMachinesFoundEvent => Ok(from.as_any_box().downcast::<UnlicensedVirtualMachinesFoundEvent>()?),
            StructType::VMotionLicenseExpiredEvent => Ok(from.as_any_box().downcast::<VMotionLicenseExpiredEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This event records a Profile specific event.
pub trait ProfileEventTrait : super::traits::EventTrait {
    /// Link to the profile to which this event applies
    fn get_profile(&self) -> &ProfileEventArgument;
}
impl<'s> serde::Serialize for dyn ProfileEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ProfileEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ProfileEventVisitor)
            }
        }

struct ProfileEventVisitor;

impl<'de> de::Visitor<'de> for ProfileEventVisitor {
    type Value = Box<dyn ProfileEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ProfileEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ProfileEventTrait for ProfileEvent {
    fn get_profile(&self) -> &ProfileEventArgument { &self.profile }
}
impl ProfileEventTrait for ProfileAssociatedEvent {
    fn get_profile(&self) -> &ProfileEventArgument { &self.profile }
}
impl ProfileEventTrait for ProfileChangedEvent {
    fn get_profile(&self) -> &ProfileEventArgument { &self.profile }
}
impl ProfileEventTrait for ProfileCreatedEvent {
    fn get_profile(&self) -> &ProfileEventArgument { &self.profile }
}
impl ProfileEventTrait for ProfileDissociatedEvent {
    fn get_profile(&self) -> &ProfileEventArgument { &self.profile }
}
impl ProfileEventTrait for ProfileReferenceHostChangedEvent {
    fn get_profile(&self) -> &ProfileEventArgument { &self.profile }
}
impl ProfileEventTrait for ProfileRemovedEvent {
    fn get_profile(&self) -> &ProfileEventArgument { &self.profile }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ProfileEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ProfileEvent => Some(from.as_any_ref().downcast_ref::<ProfileEvent>()?),
            StructType::ProfileAssociatedEvent => Some(from.as_any_ref().downcast_ref::<ProfileAssociatedEvent>()?),
            StructType::ProfileChangedEvent => Some(from.as_any_ref().downcast_ref::<ProfileChangedEvent>()?),
            StructType::ProfileCreatedEvent => Some(from.as_any_ref().downcast_ref::<ProfileCreatedEvent>()?),
            StructType::ProfileDissociatedEvent => Some(from.as_any_ref().downcast_ref::<ProfileDissociatedEvent>()?),
            StructType::ProfileReferenceHostChangedEvent => Some(from.as_any_ref().downcast_ref::<ProfileReferenceHostChangedEvent>()?),
            StructType::ProfileRemovedEvent => Some(from.as_any_ref().downcast_ref::<ProfileRemovedEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ProfileEvent => Ok(from.as_any_box().downcast::<ProfileEvent>()?),
            StructType::ProfileAssociatedEvent => Ok(from.as_any_box().downcast::<ProfileAssociatedEvent>()?),
            StructType::ProfileChangedEvent => Ok(from.as_any_box().downcast::<ProfileChangedEvent>()?),
            StructType::ProfileCreatedEvent => Ok(from.as_any_box().downcast::<ProfileCreatedEvent>()?),
            StructType::ProfileDissociatedEvent => Ok(from.as_any_box().downcast::<ProfileDissociatedEvent>()?),
            StructType::ProfileReferenceHostChangedEvent => Ok(from.as_any_box().downcast::<ProfileReferenceHostChangedEvent>()?),
            StructType::ProfileRemovedEvent => Ok(from.as_any_box().downcast::<ProfileRemovedEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This event is the base class for all resource pool events.
pub trait ResourcePoolEventTrait : super::traits::EventTrait {
    fn get_resource_pool(&self) -> &ResourcePoolEventArgument;
}
impl<'s> serde::Serialize for dyn ResourcePoolEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ResourcePoolEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ResourcePoolEventVisitor)
            }
        }

struct ResourcePoolEventVisitor;

impl<'de> de::Visitor<'de> for ResourcePoolEventVisitor {
    type Value = Box<dyn ResourcePoolEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ResourcePoolEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ResourcePoolEventTrait for ResourcePoolEvent {
    fn get_resource_pool(&self) -> &ResourcePoolEventArgument { &self.resource_pool }
}
impl ResourcePoolEventTrait for ResourcePoolCreatedEvent {
    fn get_resource_pool(&self) -> &ResourcePoolEventArgument { &self.resource_pool }
}
impl ResourcePoolEventTrait for ResourcePoolDestroyedEvent {
    fn get_resource_pool(&self) -> &ResourcePoolEventArgument { &self.resource_pool }
}
impl ResourcePoolEventTrait for ResourcePoolMovedEvent {
    fn get_resource_pool(&self) -> &ResourcePoolEventArgument { &self.resource_pool }
}
impl ResourcePoolEventTrait for ResourcePoolReconfiguredEvent {
    fn get_resource_pool(&self) -> &ResourcePoolEventArgument { &self.resource_pool }
}
impl ResourcePoolEventTrait for ResourceViolatedEvent {
    fn get_resource_pool(&self) -> &ResourcePoolEventArgument { &self.resource_pool }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ResourcePoolEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ResourcePoolEvent => Some(from.as_any_ref().downcast_ref::<ResourcePoolEvent>()?),
            StructType::ResourcePoolCreatedEvent => Some(from.as_any_ref().downcast_ref::<ResourcePoolCreatedEvent>()?),
            StructType::ResourcePoolDestroyedEvent => Some(from.as_any_ref().downcast_ref::<ResourcePoolDestroyedEvent>()?),
            StructType::ResourcePoolMovedEvent => Some(from.as_any_ref().downcast_ref::<ResourcePoolMovedEvent>()?),
            StructType::ResourcePoolReconfiguredEvent => Some(from.as_any_ref().downcast_ref::<ResourcePoolReconfiguredEvent>()?),
            StructType::ResourceViolatedEvent => Some(from.as_any_ref().downcast_ref::<ResourceViolatedEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ResourcePoolEvent => Ok(from.as_any_box().downcast::<ResourcePoolEvent>()?),
            StructType::ResourcePoolCreatedEvent => Ok(from.as_any_box().downcast::<ResourcePoolCreatedEvent>()?),
            StructType::ResourcePoolDestroyedEvent => Ok(from.as_any_box().downcast::<ResourcePoolDestroyedEvent>()?),
            StructType::ResourcePoolMovedEvent => Ok(from.as_any_box().downcast::<ResourcePoolMovedEvent>()?),
            StructType::ResourcePoolReconfiguredEvent => Ok(from.as_any_box().downcast::<ResourcePoolReconfiguredEvent>()?),
            StructType::ResourceViolatedEvent => Ok(from.as_any_box().downcast::<ResourceViolatedEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// These events are scheduled task events.
pub trait ScheduledTaskEventTrait : super::traits::EventTrait {
    /// The scheduled task object.
    fn get_scheduled_task(&self) -> &ScheduledTaskEventArgument;
    /// The entity on which the scheduled task registered.
    fn get_entity(&self) -> &ManagedEntityEventArgument;
}
impl<'s> serde::Serialize for dyn ScheduledTaskEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ScheduledTaskEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ScheduledTaskEventVisitor)
            }
        }

struct ScheduledTaskEventVisitor;

impl<'de> de::Visitor<'de> for ScheduledTaskEventVisitor {
    type Value = Box<dyn ScheduledTaskEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ScheduledTaskEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ScheduledTaskEventTrait for ScheduledTaskEvent {
    fn get_scheduled_task(&self) -> &ScheduledTaskEventArgument { &self.scheduled_task }
    fn get_entity(&self) -> &ManagedEntityEventArgument { &self.entity }
}
impl ScheduledTaskEventTrait for ScheduledTaskCompletedEvent {
    fn get_scheduled_task(&self) -> &ScheduledTaskEventArgument { &self.scheduled_task }
    fn get_entity(&self) -> &ManagedEntityEventArgument { &self.entity }
}
impl ScheduledTaskEventTrait for ScheduledTaskCreatedEvent {
    fn get_scheduled_task(&self) -> &ScheduledTaskEventArgument { &self.scheduled_task }
    fn get_entity(&self) -> &ManagedEntityEventArgument { &self.entity }
}
impl ScheduledTaskEventTrait for ScheduledTaskEmailCompletedEvent {
    fn get_scheduled_task(&self) -> &ScheduledTaskEventArgument { &self.scheduled_task }
    fn get_entity(&self) -> &ManagedEntityEventArgument { &self.entity }
}
impl ScheduledTaskEventTrait for ScheduledTaskEmailFailedEvent {
    fn get_scheduled_task(&self) -> &ScheduledTaskEventArgument { &self.scheduled_task }
    fn get_entity(&self) -> &ManagedEntityEventArgument { &self.entity }
}
impl ScheduledTaskEventTrait for ScheduledTaskFailedEvent {
    fn get_scheduled_task(&self) -> &ScheduledTaskEventArgument { &self.scheduled_task }
    fn get_entity(&self) -> &ManagedEntityEventArgument { &self.entity }
}
impl ScheduledTaskEventTrait for ScheduledTaskReconfiguredEvent {
    fn get_scheduled_task(&self) -> &ScheduledTaskEventArgument { &self.scheduled_task }
    fn get_entity(&self) -> &ManagedEntityEventArgument { &self.entity }
}
impl ScheduledTaskEventTrait for ScheduledTaskRemovedEvent {
    fn get_scheduled_task(&self) -> &ScheduledTaskEventArgument { &self.scheduled_task }
    fn get_entity(&self) -> &ManagedEntityEventArgument { &self.entity }
}
impl ScheduledTaskEventTrait for ScheduledTaskStartedEvent {
    fn get_scheduled_task(&self) -> &ScheduledTaskEventArgument { &self.scheduled_task }
    fn get_entity(&self) -> &ManagedEntityEventArgument { &self.entity }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ScheduledTaskEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ScheduledTaskEvent => Some(from.as_any_ref().downcast_ref::<ScheduledTaskEvent>()?),
            StructType::ScheduledTaskCompletedEvent => Some(from.as_any_ref().downcast_ref::<ScheduledTaskCompletedEvent>()?),
            StructType::ScheduledTaskCreatedEvent => Some(from.as_any_ref().downcast_ref::<ScheduledTaskCreatedEvent>()?),
            StructType::ScheduledTaskEmailCompletedEvent => Some(from.as_any_ref().downcast_ref::<ScheduledTaskEmailCompletedEvent>()?),
            StructType::ScheduledTaskEmailFailedEvent => Some(from.as_any_ref().downcast_ref::<ScheduledTaskEmailFailedEvent>()?),
            StructType::ScheduledTaskFailedEvent => Some(from.as_any_ref().downcast_ref::<ScheduledTaskFailedEvent>()?),
            StructType::ScheduledTaskReconfiguredEvent => Some(from.as_any_ref().downcast_ref::<ScheduledTaskReconfiguredEvent>()?),
            StructType::ScheduledTaskRemovedEvent => Some(from.as_any_ref().downcast_ref::<ScheduledTaskRemovedEvent>()?),
            StructType::ScheduledTaskStartedEvent => Some(from.as_any_ref().downcast_ref::<ScheduledTaskStartedEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ScheduledTaskEvent => Ok(from.as_any_box().downcast::<ScheduledTaskEvent>()?),
            StructType::ScheduledTaskCompletedEvent => Ok(from.as_any_box().downcast::<ScheduledTaskCompletedEvent>()?),
            StructType::ScheduledTaskCreatedEvent => Ok(from.as_any_box().downcast::<ScheduledTaskCreatedEvent>()?),
            StructType::ScheduledTaskEmailCompletedEvent => Ok(from.as_any_box().downcast::<ScheduledTaskEmailCompletedEvent>()?),
            StructType::ScheduledTaskEmailFailedEvent => Ok(from.as_any_box().downcast::<ScheduledTaskEmailFailedEvent>()?),
            StructType::ScheduledTaskFailedEvent => Ok(from.as_any_box().downcast::<ScheduledTaskFailedEvent>()?),
            StructType::ScheduledTaskReconfiguredEvent => Ok(from.as_any_box().downcast::<ScheduledTaskReconfiguredEvent>()?),
            StructType::ScheduledTaskRemovedEvent => Ok(from.as_any_box().downcast::<ScheduledTaskRemovedEvent>()?),
            StructType::ScheduledTaskStartedEvent => Ok(from.as_any_box().downcast::<ScheduledTaskStartedEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// These are session events.
pub trait SessionEventTrait : super::traits::EventTrait {
}
impl<'s> serde::Serialize for dyn SessionEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn SessionEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(SessionEventVisitor)
            }
        }

struct SessionEventVisitor;

impl<'de> de::Visitor<'de> for SessionEventVisitor {
    type Value = Box<dyn SessionEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid SessionEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl SessionEventTrait for SessionEvent {
}
impl SessionEventTrait for AlreadyAuthenticatedSessionEvent {
}
impl SessionEventTrait for BadUsernameSessionEvent {
}
impl SessionEventTrait for GlobalMessageChangedEvent {
}
impl SessionEventTrait for NoAccessUserEvent {
}
impl SessionEventTrait for ServerStartedSessionEvent {
}
impl SessionEventTrait for SessionTerminatedEvent {
}
impl SessionEventTrait for UserLoginSessionEvent {
}
impl SessionEventTrait for UserLogoutSessionEvent {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn SessionEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::SessionEvent => Some(from.as_any_ref().downcast_ref::<SessionEvent>()?),
            StructType::AlreadyAuthenticatedSessionEvent => Some(from.as_any_ref().downcast_ref::<AlreadyAuthenticatedSessionEvent>()?),
            StructType::BadUsernameSessionEvent => Some(from.as_any_ref().downcast_ref::<BadUsernameSessionEvent>()?),
            StructType::GlobalMessageChangedEvent => Some(from.as_any_ref().downcast_ref::<GlobalMessageChangedEvent>()?),
            StructType::NoAccessUserEvent => Some(from.as_any_ref().downcast_ref::<NoAccessUserEvent>()?),
            StructType::ServerStartedSessionEvent => Some(from.as_any_ref().downcast_ref::<ServerStartedSessionEvent>()?),
            StructType::SessionTerminatedEvent => Some(from.as_any_ref().downcast_ref::<SessionTerminatedEvent>()?),
            StructType::UserLoginSessionEvent => Some(from.as_any_ref().downcast_ref::<UserLoginSessionEvent>()?),
            StructType::UserLogoutSessionEvent => Some(from.as_any_ref().downcast_ref::<UserLogoutSessionEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::SessionEvent => Ok(from.as_any_box().downcast::<SessionEvent>()?),
            StructType::AlreadyAuthenticatedSessionEvent => Ok(from.as_any_box().downcast::<AlreadyAuthenticatedSessionEvent>()?),
            StructType::BadUsernameSessionEvent => Ok(from.as_any_box().downcast::<BadUsernameSessionEvent>()?),
            StructType::GlobalMessageChangedEvent => Ok(from.as_any_box().downcast::<GlobalMessageChangedEvent>()?),
            StructType::NoAccessUserEvent => Ok(from.as_any_box().downcast::<NoAccessUserEvent>()?),
            StructType::ServerStartedSessionEvent => Ok(from.as_any_box().downcast::<ServerStartedSessionEvent>()?),
            StructType::SessionTerminatedEvent => Ok(from.as_any_box().downcast::<SessionTerminatedEvent>()?),
            StructType::UserLoginSessionEvent => Ok(from.as_any_box().downcast::<UserLoginSessionEvent>()?),
            StructType::UserLogoutSessionEvent => Ok(from.as_any_box().downcast::<UserLogoutSessionEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This event records the creation of a Task.
/// 
/// Note that the embedded TaskInfo object is a _snapshot_ of the
/// Task state at the time of its creation, so its state will always be
/// "queued". To find the current status of the task, query for the
/// current state of the Task using the eventChainId in the embedded
/// TaskInfo object.
pub trait TaskEventTrait : super::traits::EventTrait {
    /// The information about the task.
    fn get_info(&self) -> &TaskInfo;
}
impl<'s> serde::Serialize for dyn TaskEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn TaskEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(TaskEventVisitor)
            }
        }

struct TaskEventVisitor;

impl<'de> de::Visitor<'de> for TaskEventVisitor {
    type Value = Box<dyn TaskEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid TaskEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl TaskEventTrait for TaskEvent {
    fn get_info(&self) -> &TaskInfo { &self.info }
}
impl TaskEventTrait for TaskTimeoutEvent {
    fn get_info(&self) -> &TaskInfo { &self.info }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn TaskEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::TaskEvent => Some(from.as_any_ref().downcast_ref::<TaskEvent>()?),
            StructType::TaskTimeoutEvent => Some(from.as_any_ref().downcast_ref::<TaskTimeoutEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::TaskEvent => Ok(from.as_any_box().downcast::<TaskEvent>()?),
            StructType::TaskTimeoutEvent => Ok(from.as_any_box().downcast::<TaskTimeoutEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This event is the base class for all the template upgrade events.
pub trait TemplateUpgradeEventTrait : super::traits::EventTrait {
    fn get_legacy_template(&self) -> &str;
}
impl<'s> serde::Serialize for dyn TemplateUpgradeEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn TemplateUpgradeEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(TemplateUpgradeEventVisitor)
            }
        }

struct TemplateUpgradeEventVisitor;

impl<'de> de::Visitor<'de> for TemplateUpgradeEventVisitor {
    type Value = Box<dyn TemplateUpgradeEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid TemplateUpgradeEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl TemplateUpgradeEventTrait for TemplateUpgradeEvent {
    fn get_legacy_template(&self) -> &str { &self.legacy_template }
}
impl TemplateUpgradeEventTrait for TemplateBeingUpgradedEvent {
    fn get_legacy_template(&self) -> &str { &self.legacy_template }
}
impl TemplateUpgradeEventTrait for TemplateUpgradeFailedEvent {
    fn get_legacy_template(&self) -> &str { &self.legacy_template }
}
impl TemplateUpgradeEventTrait for TemplateUpgradedEvent {
    fn get_legacy_template(&self) -> &str { &self.legacy_template }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn TemplateUpgradeEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::TemplateUpgradeEvent => Some(from.as_any_ref().downcast_ref::<TemplateUpgradeEvent>()?),
            StructType::TemplateBeingUpgradedEvent => Some(from.as_any_ref().downcast_ref::<TemplateBeingUpgradedEvent>()?),
            StructType::TemplateUpgradeFailedEvent => Some(from.as_any_ref().downcast_ref::<TemplateUpgradeFailedEvent>()?),
            StructType::TemplateUpgradedEvent => Some(from.as_any_ref().downcast_ref::<TemplateUpgradedEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::TemplateUpgradeEvent => Ok(from.as_any_box().downcast::<TemplateUpgradeEvent>()?),
            StructType::TemplateBeingUpgradedEvent => Ok(from.as_any_box().downcast::<TemplateBeingUpgradedEvent>()?),
            StructType::TemplateUpgradeFailedEvent => Ok(from.as_any_box().downcast::<TemplateUpgradeFailedEvent>()?),
            StructType::TemplateUpgradedEvent => Ok(from.as_any_box().downcast::<TemplateUpgradedEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// These event types represent events converted from VirtualCenter 1.x.
/// 
/// All upgraded events are converted to string values.
pub trait UpgradeEventTrait : super::traits::EventTrait {
    /// The formatted message from the upgrade.
    fn get_message(&self) -> &str;
}
impl<'s> serde::Serialize for dyn UpgradeEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn UpgradeEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(UpgradeEventVisitor)
            }
        }

struct UpgradeEventVisitor;

impl<'de> de::Visitor<'de> for UpgradeEventVisitor {
    type Value = Box<dyn UpgradeEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid UpgradeEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl UpgradeEventTrait for UpgradeEvent {
    fn get_message(&self) -> &str { &self.message }
}
impl UpgradeEventTrait for ErrorUpgradeEvent {
    fn get_message(&self) -> &str { &self.message }
}
impl UpgradeEventTrait for InfoUpgradeEvent {
    fn get_message(&self) -> &str { &self.message }
}
impl UpgradeEventTrait for UserUpgradeEvent {
    fn get_message(&self) -> &str { &self.message }
}
impl UpgradeEventTrait for WarningUpgradeEvent {
    fn get_message(&self) -> &str { &self.message }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn UpgradeEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::UpgradeEvent => Some(from.as_any_ref().downcast_ref::<UpgradeEvent>()?),
            StructType::ErrorUpgradeEvent => Some(from.as_any_ref().downcast_ref::<ErrorUpgradeEvent>()?),
            StructType::InfoUpgradeEvent => Some(from.as_any_ref().downcast_ref::<InfoUpgradeEvent>()?),
            StructType::UserUpgradeEvent => Some(from.as_any_ref().downcast_ref::<UserUpgradeEvent>()?),
            StructType::WarningUpgradeEvent => Some(from.as_any_ref().downcast_ref::<WarningUpgradeEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::UpgradeEvent => Ok(from.as_any_box().downcast::<UpgradeEvent>()?),
            StructType::ErrorUpgradeEvent => Ok(from.as_any_box().downcast::<ErrorUpgradeEvent>()?),
            StructType::InfoUpgradeEvent => Ok(from.as_any_box().downcast::<InfoUpgradeEvent>()?),
            StructType::UserUpgradeEvent => Ok(from.as_any_box().downcast::<UserUpgradeEvent>()?),
            StructType::WarningUpgradeEvent => Ok(from.as_any_box().downcast::<WarningUpgradeEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// These are virtual machine events.
pub trait VmEventTrait : super::traits::EventTrait {
    /// Indicates whether or not the virtual machine is marked as a template.
    fn get_template(&self) -> bool;
}
impl<'s> serde::Serialize for dyn VmEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VmEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VmEventVisitor)
            }
        }

struct VmEventVisitor;

impl<'de> de::Visitor<'de> for VmEventVisitor {
    type Value = Box<dyn VmEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VmEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VmEventTrait for VmEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for CustomizationEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for CustomizationFailed {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for CustomizationLinuxIdentityFailed {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for CustomizationNetworkSetupFailed {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for CustomizationSysprepFailed {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for CustomizationUnknownFailure {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for CustomizationStartedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for CustomizationSucceeded {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for DrsRuleComplianceEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for DrsRuleViolationEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for DrsSoftRuleViolationEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for MigrationEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for MigrationErrorEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for MigrationHostErrorEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for MigrationHostWarningEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for MigrationResourceErrorEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for MigrationResourceWarningEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for MigrationWarningEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for NoMaintenanceModeDrsRecommendationForVm {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for NotEnoughResourcesToStartVmEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmAcquiredMksTicketEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmAcquiredTicketEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmAutoRenameEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmBeingCreatedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmBeingDeployedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmBeingHotMigratedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmBeingMigratedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmCloneEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmBeingClonedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmBeingClonedNoFolderEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmCloneFailedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmClonedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmConfigMissingEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmConnectedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmCreatedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmDasBeingResetEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmDasBeingResetWithScreenshotEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmDasResetFailedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmDasUpdateErrorEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmDasUpdateOkEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmDateRolledBackEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmDeployFailedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmDeployedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmDisconnectedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmDiscoveredEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmDiskFailedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmEmigratingEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmEndRecordingEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmEndReplayingEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmFailedMigrateEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmFailedRelayoutEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmFailedRelayoutOnVmfs2DatastoreEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmFailedStartingSecondaryEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmFailedToPowerOffEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmFailedToPowerOnEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmFailedToRebootGuestEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmFailedToResetEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmFailedToShutdownGuestEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmFailedToStandbyGuestEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmFailedToSuspendEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmFailedUpdatingSecondaryConfig {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmFailoverFailed {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmFaultToleranceStateChangedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmFaultToleranceTurnedOffEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmFaultToleranceVmTerminatedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmGuestOsCrashedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmGuestRebootEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmGuestShutdownEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmGuestStandbyEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmInstanceUuidAssignedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmInstanceUuidChangedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmInstanceUuidConflictEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmMacAssignedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmMacChangedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmMacConflictEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmMaxFtRestartCountReached {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmMaxRestartCountReached {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmMessageErrorEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmMessageEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmMessageWarningEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmMigratedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for DrsVmMigratedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmNoCompatibleHostForSecondaryEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmNoNetworkAccessEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmOrphanedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmPoweredOffEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmPowerOffOnIsolationEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmShutdownOnIsolationEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmPoweredOnEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for DrsVmPoweredOnEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmRestartedOnAlternateHostEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmPoweringOnWithCustomizedDvPortEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmPrimaryFailoverEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmReconfiguredEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmRegisteredEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmRelayoutSuccessfulEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmRelayoutUpToDateEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmReloadFromPathEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmReloadFromPathFailedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmRelocateSpecEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmBeingRelocatedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmRelocateFailedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmRelocatedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmRemoteConsoleConnectedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmRemoteConsoleDisconnectedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmRemovedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmRenamedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmRequirementsExceedCurrentEvcModeEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmResettingEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmResourcePoolMovedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmResourceReallocatedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmResumingEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmSecondaryAddedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmSecondaryDisabledBySystemEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmSecondaryDisabledEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmSecondaryEnabledEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmSecondaryStartedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmStartRecordingEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmStartReplayingEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmStartingEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmUnsupportedStartingEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmStartingSecondaryEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmStaticMacConflictEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmStoppingEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmSuspendedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmSuspendingEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmTimedoutStartingSecondaryEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmUpgradeCompleteEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmUpgradeFailedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmUpgradingEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmUuidAssignedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmUuidChangedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmUuidConflictEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmWwnAssignedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmWwnChangedEvent {
    fn get_template(&self) -> bool { self.template }
}
impl VmEventTrait for VmWwnConflictEvent {
    fn get_template(&self) -> bool { self.template }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VmEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmEvent => Some(from.as_any_ref().downcast_ref::<VmEvent>()?),
            StructType::CustomizationEvent => Some(from.as_any_ref().downcast_ref::<CustomizationEvent>()?),
            StructType::CustomizationFailed => Some(from.as_any_ref().downcast_ref::<CustomizationFailed>()?),
            StructType::CustomizationLinuxIdentityFailed => Some(from.as_any_ref().downcast_ref::<CustomizationLinuxIdentityFailed>()?),
            StructType::CustomizationNetworkSetupFailed => Some(from.as_any_ref().downcast_ref::<CustomizationNetworkSetupFailed>()?),
            StructType::CustomizationSysprepFailed => Some(from.as_any_ref().downcast_ref::<CustomizationSysprepFailed>()?),
            StructType::CustomizationUnknownFailure => Some(from.as_any_ref().downcast_ref::<CustomizationUnknownFailure>()?),
            StructType::CustomizationStartedEvent => Some(from.as_any_ref().downcast_ref::<CustomizationStartedEvent>()?),
            StructType::CustomizationSucceeded => Some(from.as_any_ref().downcast_ref::<CustomizationSucceeded>()?),
            StructType::DrsRuleComplianceEvent => Some(from.as_any_ref().downcast_ref::<DrsRuleComplianceEvent>()?),
            StructType::DrsRuleViolationEvent => Some(from.as_any_ref().downcast_ref::<DrsRuleViolationEvent>()?),
            StructType::DrsSoftRuleViolationEvent => Some(from.as_any_ref().downcast_ref::<DrsSoftRuleViolationEvent>()?),
            StructType::MigrationEvent => Some(from.as_any_ref().downcast_ref::<MigrationEvent>()?),
            StructType::MigrationErrorEvent => Some(from.as_any_ref().downcast_ref::<MigrationErrorEvent>()?),
            StructType::MigrationHostErrorEvent => Some(from.as_any_ref().downcast_ref::<MigrationHostErrorEvent>()?),
            StructType::MigrationHostWarningEvent => Some(from.as_any_ref().downcast_ref::<MigrationHostWarningEvent>()?),
            StructType::MigrationResourceErrorEvent => Some(from.as_any_ref().downcast_ref::<MigrationResourceErrorEvent>()?),
            StructType::MigrationResourceWarningEvent => Some(from.as_any_ref().downcast_ref::<MigrationResourceWarningEvent>()?),
            StructType::MigrationWarningEvent => Some(from.as_any_ref().downcast_ref::<MigrationWarningEvent>()?),
            StructType::NoMaintenanceModeDrsRecommendationForVm => Some(from.as_any_ref().downcast_ref::<NoMaintenanceModeDrsRecommendationForVm>()?),
            StructType::NotEnoughResourcesToStartVmEvent => Some(from.as_any_ref().downcast_ref::<NotEnoughResourcesToStartVmEvent>()?),
            StructType::VmAcquiredMksTicketEvent => Some(from.as_any_ref().downcast_ref::<VmAcquiredMksTicketEvent>()?),
            StructType::VmAcquiredTicketEvent => Some(from.as_any_ref().downcast_ref::<VmAcquiredTicketEvent>()?),
            StructType::VmAutoRenameEvent => Some(from.as_any_ref().downcast_ref::<VmAutoRenameEvent>()?),
            StructType::VmBeingCreatedEvent => Some(from.as_any_ref().downcast_ref::<VmBeingCreatedEvent>()?),
            StructType::VmBeingDeployedEvent => Some(from.as_any_ref().downcast_ref::<VmBeingDeployedEvent>()?),
            StructType::VmBeingHotMigratedEvent => Some(from.as_any_ref().downcast_ref::<VmBeingHotMigratedEvent>()?),
            StructType::VmBeingMigratedEvent => Some(from.as_any_ref().downcast_ref::<VmBeingMigratedEvent>()?),
            StructType::VmCloneEvent => Some(from.as_any_ref().downcast_ref::<VmCloneEvent>()?),
            StructType::VmBeingClonedEvent => Some(from.as_any_ref().downcast_ref::<VmBeingClonedEvent>()?),
            StructType::VmBeingClonedNoFolderEvent => Some(from.as_any_ref().downcast_ref::<VmBeingClonedNoFolderEvent>()?),
            StructType::VmCloneFailedEvent => Some(from.as_any_ref().downcast_ref::<VmCloneFailedEvent>()?),
            StructType::VmClonedEvent => Some(from.as_any_ref().downcast_ref::<VmClonedEvent>()?),
            StructType::VmConfigMissingEvent => Some(from.as_any_ref().downcast_ref::<VmConfigMissingEvent>()?),
            StructType::VmConnectedEvent => Some(from.as_any_ref().downcast_ref::<VmConnectedEvent>()?),
            StructType::VmCreatedEvent => Some(from.as_any_ref().downcast_ref::<VmCreatedEvent>()?),
            StructType::VmDasBeingResetEvent => Some(from.as_any_ref().downcast_ref::<VmDasBeingResetEvent>()?),
            StructType::VmDasBeingResetWithScreenshotEvent => Some(from.as_any_ref().downcast_ref::<VmDasBeingResetWithScreenshotEvent>()?),
            StructType::VmDasResetFailedEvent => Some(from.as_any_ref().downcast_ref::<VmDasResetFailedEvent>()?),
            StructType::VmDasUpdateErrorEvent => Some(from.as_any_ref().downcast_ref::<VmDasUpdateErrorEvent>()?),
            StructType::VmDasUpdateOkEvent => Some(from.as_any_ref().downcast_ref::<VmDasUpdateOkEvent>()?),
            StructType::VmDateRolledBackEvent => Some(from.as_any_ref().downcast_ref::<VmDateRolledBackEvent>()?),
            StructType::VmDeployFailedEvent => Some(from.as_any_ref().downcast_ref::<VmDeployFailedEvent>()?),
            StructType::VmDeployedEvent => Some(from.as_any_ref().downcast_ref::<VmDeployedEvent>()?),
            StructType::VmDisconnectedEvent => Some(from.as_any_ref().downcast_ref::<VmDisconnectedEvent>()?),
            StructType::VmDiscoveredEvent => Some(from.as_any_ref().downcast_ref::<VmDiscoveredEvent>()?),
            StructType::VmDiskFailedEvent => Some(from.as_any_ref().downcast_ref::<VmDiskFailedEvent>()?),
            StructType::VmEmigratingEvent => Some(from.as_any_ref().downcast_ref::<VmEmigratingEvent>()?),
            StructType::VmEndRecordingEvent => Some(from.as_any_ref().downcast_ref::<VmEndRecordingEvent>()?),
            StructType::VmEndReplayingEvent => Some(from.as_any_ref().downcast_ref::<VmEndReplayingEvent>()?),
            StructType::VmFailedMigrateEvent => Some(from.as_any_ref().downcast_ref::<VmFailedMigrateEvent>()?),
            StructType::VmFailedRelayoutEvent => Some(from.as_any_ref().downcast_ref::<VmFailedRelayoutEvent>()?),
            StructType::VmFailedRelayoutOnVmfs2DatastoreEvent => Some(from.as_any_ref().downcast_ref::<VmFailedRelayoutOnVmfs2DatastoreEvent>()?),
            StructType::VmFailedStartingSecondaryEvent => Some(from.as_any_ref().downcast_ref::<VmFailedStartingSecondaryEvent>()?),
            StructType::VmFailedToPowerOffEvent => Some(from.as_any_ref().downcast_ref::<VmFailedToPowerOffEvent>()?),
            StructType::VmFailedToPowerOnEvent => Some(from.as_any_ref().downcast_ref::<VmFailedToPowerOnEvent>()?),
            StructType::VmFailedToRebootGuestEvent => Some(from.as_any_ref().downcast_ref::<VmFailedToRebootGuestEvent>()?),
            StructType::VmFailedToResetEvent => Some(from.as_any_ref().downcast_ref::<VmFailedToResetEvent>()?),
            StructType::VmFailedToShutdownGuestEvent => Some(from.as_any_ref().downcast_ref::<VmFailedToShutdownGuestEvent>()?),
            StructType::VmFailedToStandbyGuestEvent => Some(from.as_any_ref().downcast_ref::<VmFailedToStandbyGuestEvent>()?),
            StructType::VmFailedToSuspendEvent => Some(from.as_any_ref().downcast_ref::<VmFailedToSuspendEvent>()?),
            StructType::VmFailedUpdatingSecondaryConfig => Some(from.as_any_ref().downcast_ref::<VmFailedUpdatingSecondaryConfig>()?),
            StructType::VmFailoverFailed => Some(from.as_any_ref().downcast_ref::<VmFailoverFailed>()?),
            StructType::VmFaultToleranceStateChangedEvent => Some(from.as_any_ref().downcast_ref::<VmFaultToleranceStateChangedEvent>()?),
            StructType::VmFaultToleranceTurnedOffEvent => Some(from.as_any_ref().downcast_ref::<VmFaultToleranceTurnedOffEvent>()?),
            StructType::VmFaultToleranceVmTerminatedEvent => Some(from.as_any_ref().downcast_ref::<VmFaultToleranceVmTerminatedEvent>()?),
            StructType::VmGuestOsCrashedEvent => Some(from.as_any_ref().downcast_ref::<VmGuestOsCrashedEvent>()?),
            StructType::VmGuestRebootEvent => Some(from.as_any_ref().downcast_ref::<VmGuestRebootEvent>()?),
            StructType::VmGuestShutdownEvent => Some(from.as_any_ref().downcast_ref::<VmGuestShutdownEvent>()?),
            StructType::VmGuestStandbyEvent => Some(from.as_any_ref().downcast_ref::<VmGuestStandbyEvent>()?),
            StructType::VmInstanceUuidAssignedEvent => Some(from.as_any_ref().downcast_ref::<VmInstanceUuidAssignedEvent>()?),
            StructType::VmInstanceUuidChangedEvent => Some(from.as_any_ref().downcast_ref::<VmInstanceUuidChangedEvent>()?),
            StructType::VmInstanceUuidConflictEvent => Some(from.as_any_ref().downcast_ref::<VmInstanceUuidConflictEvent>()?),
            StructType::VmMacAssignedEvent => Some(from.as_any_ref().downcast_ref::<VmMacAssignedEvent>()?),
            StructType::VmMacChangedEvent => Some(from.as_any_ref().downcast_ref::<VmMacChangedEvent>()?),
            StructType::VmMacConflictEvent => Some(from.as_any_ref().downcast_ref::<VmMacConflictEvent>()?),
            StructType::VmMaxFtRestartCountReached => Some(from.as_any_ref().downcast_ref::<VmMaxFtRestartCountReached>()?),
            StructType::VmMaxRestartCountReached => Some(from.as_any_ref().downcast_ref::<VmMaxRestartCountReached>()?),
            StructType::VmMessageErrorEvent => Some(from.as_any_ref().downcast_ref::<VmMessageErrorEvent>()?),
            StructType::VmMessageEvent => Some(from.as_any_ref().downcast_ref::<VmMessageEvent>()?),
            StructType::VmMessageWarningEvent => Some(from.as_any_ref().downcast_ref::<VmMessageWarningEvent>()?),
            StructType::VmMigratedEvent => Some(from.as_any_ref().downcast_ref::<VmMigratedEvent>()?),
            StructType::DrsVmMigratedEvent => Some(from.as_any_ref().downcast_ref::<DrsVmMigratedEvent>()?),
            StructType::VmNoCompatibleHostForSecondaryEvent => Some(from.as_any_ref().downcast_ref::<VmNoCompatibleHostForSecondaryEvent>()?),
            StructType::VmNoNetworkAccessEvent => Some(from.as_any_ref().downcast_ref::<VmNoNetworkAccessEvent>()?),
            StructType::VmOrphanedEvent => Some(from.as_any_ref().downcast_ref::<VmOrphanedEvent>()?),
            StructType::VmPoweredOffEvent => Some(from.as_any_ref().downcast_ref::<VmPoweredOffEvent>()?),
            StructType::VmPowerOffOnIsolationEvent => Some(from.as_any_ref().downcast_ref::<VmPowerOffOnIsolationEvent>()?),
            StructType::VmShutdownOnIsolationEvent => Some(from.as_any_ref().downcast_ref::<VmShutdownOnIsolationEvent>()?),
            StructType::VmPoweredOnEvent => Some(from.as_any_ref().downcast_ref::<VmPoweredOnEvent>()?),
            StructType::DrsVmPoweredOnEvent => Some(from.as_any_ref().downcast_ref::<DrsVmPoweredOnEvent>()?),
            StructType::VmRestartedOnAlternateHostEvent => Some(from.as_any_ref().downcast_ref::<VmRestartedOnAlternateHostEvent>()?),
            StructType::VmPoweringOnWithCustomizedDvPortEvent => Some(from.as_any_ref().downcast_ref::<VmPoweringOnWithCustomizedDvPortEvent>()?),
            StructType::VmPrimaryFailoverEvent => Some(from.as_any_ref().downcast_ref::<VmPrimaryFailoverEvent>()?),
            StructType::VmReconfiguredEvent => Some(from.as_any_ref().downcast_ref::<VmReconfiguredEvent>()?),
            StructType::VmRegisteredEvent => Some(from.as_any_ref().downcast_ref::<VmRegisteredEvent>()?),
            StructType::VmRelayoutSuccessfulEvent => Some(from.as_any_ref().downcast_ref::<VmRelayoutSuccessfulEvent>()?),
            StructType::VmRelayoutUpToDateEvent => Some(from.as_any_ref().downcast_ref::<VmRelayoutUpToDateEvent>()?),
            StructType::VmReloadFromPathEvent => Some(from.as_any_ref().downcast_ref::<VmReloadFromPathEvent>()?),
            StructType::VmReloadFromPathFailedEvent => Some(from.as_any_ref().downcast_ref::<VmReloadFromPathFailedEvent>()?),
            StructType::VmRelocateSpecEvent => Some(from.as_any_ref().downcast_ref::<VmRelocateSpecEvent>()?),
            StructType::VmBeingRelocatedEvent => Some(from.as_any_ref().downcast_ref::<VmBeingRelocatedEvent>()?),
            StructType::VmRelocateFailedEvent => Some(from.as_any_ref().downcast_ref::<VmRelocateFailedEvent>()?),
            StructType::VmRelocatedEvent => Some(from.as_any_ref().downcast_ref::<VmRelocatedEvent>()?),
            StructType::VmRemoteConsoleConnectedEvent => Some(from.as_any_ref().downcast_ref::<VmRemoteConsoleConnectedEvent>()?),
            StructType::VmRemoteConsoleDisconnectedEvent => Some(from.as_any_ref().downcast_ref::<VmRemoteConsoleDisconnectedEvent>()?),
            StructType::VmRemovedEvent => Some(from.as_any_ref().downcast_ref::<VmRemovedEvent>()?),
            StructType::VmRenamedEvent => Some(from.as_any_ref().downcast_ref::<VmRenamedEvent>()?),
            StructType::VmRequirementsExceedCurrentEvcModeEvent => Some(from.as_any_ref().downcast_ref::<VmRequirementsExceedCurrentEvcModeEvent>()?),
            StructType::VmResettingEvent => Some(from.as_any_ref().downcast_ref::<VmResettingEvent>()?),
            StructType::VmResourcePoolMovedEvent => Some(from.as_any_ref().downcast_ref::<VmResourcePoolMovedEvent>()?),
            StructType::VmResourceReallocatedEvent => Some(from.as_any_ref().downcast_ref::<VmResourceReallocatedEvent>()?),
            StructType::VmResumingEvent => Some(from.as_any_ref().downcast_ref::<VmResumingEvent>()?),
            StructType::VmSecondaryAddedEvent => Some(from.as_any_ref().downcast_ref::<VmSecondaryAddedEvent>()?),
            StructType::VmSecondaryDisabledBySystemEvent => Some(from.as_any_ref().downcast_ref::<VmSecondaryDisabledBySystemEvent>()?),
            StructType::VmSecondaryDisabledEvent => Some(from.as_any_ref().downcast_ref::<VmSecondaryDisabledEvent>()?),
            StructType::VmSecondaryEnabledEvent => Some(from.as_any_ref().downcast_ref::<VmSecondaryEnabledEvent>()?),
            StructType::VmSecondaryStartedEvent => Some(from.as_any_ref().downcast_ref::<VmSecondaryStartedEvent>()?),
            StructType::VmStartRecordingEvent => Some(from.as_any_ref().downcast_ref::<VmStartRecordingEvent>()?),
            StructType::VmStartReplayingEvent => Some(from.as_any_ref().downcast_ref::<VmStartReplayingEvent>()?),
            StructType::VmStartingEvent => Some(from.as_any_ref().downcast_ref::<VmStartingEvent>()?),
            StructType::VmUnsupportedStartingEvent => Some(from.as_any_ref().downcast_ref::<VmUnsupportedStartingEvent>()?),
            StructType::VmStartingSecondaryEvent => Some(from.as_any_ref().downcast_ref::<VmStartingSecondaryEvent>()?),
            StructType::VmStaticMacConflictEvent => Some(from.as_any_ref().downcast_ref::<VmStaticMacConflictEvent>()?),
            StructType::VmStoppingEvent => Some(from.as_any_ref().downcast_ref::<VmStoppingEvent>()?),
            StructType::VmSuspendedEvent => Some(from.as_any_ref().downcast_ref::<VmSuspendedEvent>()?),
            StructType::VmSuspendingEvent => Some(from.as_any_ref().downcast_ref::<VmSuspendingEvent>()?),
            StructType::VmTimedoutStartingSecondaryEvent => Some(from.as_any_ref().downcast_ref::<VmTimedoutStartingSecondaryEvent>()?),
            StructType::VmUpgradeCompleteEvent => Some(from.as_any_ref().downcast_ref::<VmUpgradeCompleteEvent>()?),
            StructType::VmUpgradeFailedEvent => Some(from.as_any_ref().downcast_ref::<VmUpgradeFailedEvent>()?),
            StructType::VmUpgradingEvent => Some(from.as_any_ref().downcast_ref::<VmUpgradingEvent>()?),
            StructType::VmUuidAssignedEvent => Some(from.as_any_ref().downcast_ref::<VmUuidAssignedEvent>()?),
            StructType::VmUuidChangedEvent => Some(from.as_any_ref().downcast_ref::<VmUuidChangedEvent>()?),
            StructType::VmUuidConflictEvent => Some(from.as_any_ref().downcast_ref::<VmUuidConflictEvent>()?),
            StructType::VmWwnAssignedEvent => Some(from.as_any_ref().downcast_ref::<VmWwnAssignedEvent>()?),
            StructType::VmWwnChangedEvent => Some(from.as_any_ref().downcast_ref::<VmWwnChangedEvent>()?),
            StructType::VmWwnConflictEvent => Some(from.as_any_ref().downcast_ref::<VmWwnConflictEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmEvent => Ok(from.as_any_box().downcast::<VmEvent>()?),
            StructType::CustomizationEvent => Ok(from.as_any_box().downcast::<CustomizationEvent>()?),
            StructType::CustomizationFailed => Ok(from.as_any_box().downcast::<CustomizationFailed>()?),
            StructType::CustomizationLinuxIdentityFailed => Ok(from.as_any_box().downcast::<CustomizationLinuxIdentityFailed>()?),
            StructType::CustomizationNetworkSetupFailed => Ok(from.as_any_box().downcast::<CustomizationNetworkSetupFailed>()?),
            StructType::CustomizationSysprepFailed => Ok(from.as_any_box().downcast::<CustomizationSysprepFailed>()?),
            StructType::CustomizationUnknownFailure => Ok(from.as_any_box().downcast::<CustomizationUnknownFailure>()?),
            StructType::CustomizationStartedEvent => Ok(from.as_any_box().downcast::<CustomizationStartedEvent>()?),
            StructType::CustomizationSucceeded => Ok(from.as_any_box().downcast::<CustomizationSucceeded>()?),
            StructType::DrsRuleComplianceEvent => Ok(from.as_any_box().downcast::<DrsRuleComplianceEvent>()?),
            StructType::DrsRuleViolationEvent => Ok(from.as_any_box().downcast::<DrsRuleViolationEvent>()?),
            StructType::DrsSoftRuleViolationEvent => Ok(from.as_any_box().downcast::<DrsSoftRuleViolationEvent>()?),
            StructType::MigrationEvent => Ok(from.as_any_box().downcast::<MigrationEvent>()?),
            StructType::MigrationErrorEvent => Ok(from.as_any_box().downcast::<MigrationErrorEvent>()?),
            StructType::MigrationHostErrorEvent => Ok(from.as_any_box().downcast::<MigrationHostErrorEvent>()?),
            StructType::MigrationHostWarningEvent => Ok(from.as_any_box().downcast::<MigrationHostWarningEvent>()?),
            StructType::MigrationResourceErrorEvent => Ok(from.as_any_box().downcast::<MigrationResourceErrorEvent>()?),
            StructType::MigrationResourceWarningEvent => Ok(from.as_any_box().downcast::<MigrationResourceWarningEvent>()?),
            StructType::MigrationWarningEvent => Ok(from.as_any_box().downcast::<MigrationWarningEvent>()?),
            StructType::NoMaintenanceModeDrsRecommendationForVm => Ok(from.as_any_box().downcast::<NoMaintenanceModeDrsRecommendationForVm>()?),
            StructType::NotEnoughResourcesToStartVmEvent => Ok(from.as_any_box().downcast::<NotEnoughResourcesToStartVmEvent>()?),
            StructType::VmAcquiredMksTicketEvent => Ok(from.as_any_box().downcast::<VmAcquiredMksTicketEvent>()?),
            StructType::VmAcquiredTicketEvent => Ok(from.as_any_box().downcast::<VmAcquiredTicketEvent>()?),
            StructType::VmAutoRenameEvent => Ok(from.as_any_box().downcast::<VmAutoRenameEvent>()?),
            StructType::VmBeingCreatedEvent => Ok(from.as_any_box().downcast::<VmBeingCreatedEvent>()?),
            StructType::VmBeingDeployedEvent => Ok(from.as_any_box().downcast::<VmBeingDeployedEvent>()?),
            StructType::VmBeingHotMigratedEvent => Ok(from.as_any_box().downcast::<VmBeingHotMigratedEvent>()?),
            StructType::VmBeingMigratedEvent => Ok(from.as_any_box().downcast::<VmBeingMigratedEvent>()?),
            StructType::VmCloneEvent => Ok(from.as_any_box().downcast::<VmCloneEvent>()?),
            StructType::VmBeingClonedEvent => Ok(from.as_any_box().downcast::<VmBeingClonedEvent>()?),
            StructType::VmBeingClonedNoFolderEvent => Ok(from.as_any_box().downcast::<VmBeingClonedNoFolderEvent>()?),
            StructType::VmCloneFailedEvent => Ok(from.as_any_box().downcast::<VmCloneFailedEvent>()?),
            StructType::VmClonedEvent => Ok(from.as_any_box().downcast::<VmClonedEvent>()?),
            StructType::VmConfigMissingEvent => Ok(from.as_any_box().downcast::<VmConfigMissingEvent>()?),
            StructType::VmConnectedEvent => Ok(from.as_any_box().downcast::<VmConnectedEvent>()?),
            StructType::VmCreatedEvent => Ok(from.as_any_box().downcast::<VmCreatedEvent>()?),
            StructType::VmDasBeingResetEvent => Ok(from.as_any_box().downcast::<VmDasBeingResetEvent>()?),
            StructType::VmDasBeingResetWithScreenshotEvent => Ok(from.as_any_box().downcast::<VmDasBeingResetWithScreenshotEvent>()?),
            StructType::VmDasResetFailedEvent => Ok(from.as_any_box().downcast::<VmDasResetFailedEvent>()?),
            StructType::VmDasUpdateErrorEvent => Ok(from.as_any_box().downcast::<VmDasUpdateErrorEvent>()?),
            StructType::VmDasUpdateOkEvent => Ok(from.as_any_box().downcast::<VmDasUpdateOkEvent>()?),
            StructType::VmDateRolledBackEvent => Ok(from.as_any_box().downcast::<VmDateRolledBackEvent>()?),
            StructType::VmDeployFailedEvent => Ok(from.as_any_box().downcast::<VmDeployFailedEvent>()?),
            StructType::VmDeployedEvent => Ok(from.as_any_box().downcast::<VmDeployedEvent>()?),
            StructType::VmDisconnectedEvent => Ok(from.as_any_box().downcast::<VmDisconnectedEvent>()?),
            StructType::VmDiscoveredEvent => Ok(from.as_any_box().downcast::<VmDiscoveredEvent>()?),
            StructType::VmDiskFailedEvent => Ok(from.as_any_box().downcast::<VmDiskFailedEvent>()?),
            StructType::VmEmigratingEvent => Ok(from.as_any_box().downcast::<VmEmigratingEvent>()?),
            StructType::VmEndRecordingEvent => Ok(from.as_any_box().downcast::<VmEndRecordingEvent>()?),
            StructType::VmEndReplayingEvent => Ok(from.as_any_box().downcast::<VmEndReplayingEvent>()?),
            StructType::VmFailedMigrateEvent => Ok(from.as_any_box().downcast::<VmFailedMigrateEvent>()?),
            StructType::VmFailedRelayoutEvent => Ok(from.as_any_box().downcast::<VmFailedRelayoutEvent>()?),
            StructType::VmFailedRelayoutOnVmfs2DatastoreEvent => Ok(from.as_any_box().downcast::<VmFailedRelayoutOnVmfs2DatastoreEvent>()?),
            StructType::VmFailedStartingSecondaryEvent => Ok(from.as_any_box().downcast::<VmFailedStartingSecondaryEvent>()?),
            StructType::VmFailedToPowerOffEvent => Ok(from.as_any_box().downcast::<VmFailedToPowerOffEvent>()?),
            StructType::VmFailedToPowerOnEvent => Ok(from.as_any_box().downcast::<VmFailedToPowerOnEvent>()?),
            StructType::VmFailedToRebootGuestEvent => Ok(from.as_any_box().downcast::<VmFailedToRebootGuestEvent>()?),
            StructType::VmFailedToResetEvent => Ok(from.as_any_box().downcast::<VmFailedToResetEvent>()?),
            StructType::VmFailedToShutdownGuestEvent => Ok(from.as_any_box().downcast::<VmFailedToShutdownGuestEvent>()?),
            StructType::VmFailedToStandbyGuestEvent => Ok(from.as_any_box().downcast::<VmFailedToStandbyGuestEvent>()?),
            StructType::VmFailedToSuspendEvent => Ok(from.as_any_box().downcast::<VmFailedToSuspendEvent>()?),
            StructType::VmFailedUpdatingSecondaryConfig => Ok(from.as_any_box().downcast::<VmFailedUpdatingSecondaryConfig>()?),
            StructType::VmFailoverFailed => Ok(from.as_any_box().downcast::<VmFailoverFailed>()?),
            StructType::VmFaultToleranceStateChangedEvent => Ok(from.as_any_box().downcast::<VmFaultToleranceStateChangedEvent>()?),
            StructType::VmFaultToleranceTurnedOffEvent => Ok(from.as_any_box().downcast::<VmFaultToleranceTurnedOffEvent>()?),
            StructType::VmFaultToleranceVmTerminatedEvent => Ok(from.as_any_box().downcast::<VmFaultToleranceVmTerminatedEvent>()?),
            StructType::VmGuestOsCrashedEvent => Ok(from.as_any_box().downcast::<VmGuestOsCrashedEvent>()?),
            StructType::VmGuestRebootEvent => Ok(from.as_any_box().downcast::<VmGuestRebootEvent>()?),
            StructType::VmGuestShutdownEvent => Ok(from.as_any_box().downcast::<VmGuestShutdownEvent>()?),
            StructType::VmGuestStandbyEvent => Ok(from.as_any_box().downcast::<VmGuestStandbyEvent>()?),
            StructType::VmInstanceUuidAssignedEvent => Ok(from.as_any_box().downcast::<VmInstanceUuidAssignedEvent>()?),
            StructType::VmInstanceUuidChangedEvent => Ok(from.as_any_box().downcast::<VmInstanceUuidChangedEvent>()?),
            StructType::VmInstanceUuidConflictEvent => Ok(from.as_any_box().downcast::<VmInstanceUuidConflictEvent>()?),
            StructType::VmMacAssignedEvent => Ok(from.as_any_box().downcast::<VmMacAssignedEvent>()?),
            StructType::VmMacChangedEvent => Ok(from.as_any_box().downcast::<VmMacChangedEvent>()?),
            StructType::VmMacConflictEvent => Ok(from.as_any_box().downcast::<VmMacConflictEvent>()?),
            StructType::VmMaxFtRestartCountReached => Ok(from.as_any_box().downcast::<VmMaxFtRestartCountReached>()?),
            StructType::VmMaxRestartCountReached => Ok(from.as_any_box().downcast::<VmMaxRestartCountReached>()?),
            StructType::VmMessageErrorEvent => Ok(from.as_any_box().downcast::<VmMessageErrorEvent>()?),
            StructType::VmMessageEvent => Ok(from.as_any_box().downcast::<VmMessageEvent>()?),
            StructType::VmMessageWarningEvent => Ok(from.as_any_box().downcast::<VmMessageWarningEvent>()?),
            StructType::VmMigratedEvent => Ok(from.as_any_box().downcast::<VmMigratedEvent>()?),
            StructType::DrsVmMigratedEvent => Ok(from.as_any_box().downcast::<DrsVmMigratedEvent>()?),
            StructType::VmNoCompatibleHostForSecondaryEvent => Ok(from.as_any_box().downcast::<VmNoCompatibleHostForSecondaryEvent>()?),
            StructType::VmNoNetworkAccessEvent => Ok(from.as_any_box().downcast::<VmNoNetworkAccessEvent>()?),
            StructType::VmOrphanedEvent => Ok(from.as_any_box().downcast::<VmOrphanedEvent>()?),
            StructType::VmPoweredOffEvent => Ok(from.as_any_box().downcast::<VmPoweredOffEvent>()?),
            StructType::VmPowerOffOnIsolationEvent => Ok(from.as_any_box().downcast::<VmPowerOffOnIsolationEvent>()?),
            StructType::VmShutdownOnIsolationEvent => Ok(from.as_any_box().downcast::<VmShutdownOnIsolationEvent>()?),
            StructType::VmPoweredOnEvent => Ok(from.as_any_box().downcast::<VmPoweredOnEvent>()?),
            StructType::DrsVmPoweredOnEvent => Ok(from.as_any_box().downcast::<DrsVmPoweredOnEvent>()?),
            StructType::VmRestartedOnAlternateHostEvent => Ok(from.as_any_box().downcast::<VmRestartedOnAlternateHostEvent>()?),
            StructType::VmPoweringOnWithCustomizedDvPortEvent => Ok(from.as_any_box().downcast::<VmPoweringOnWithCustomizedDvPortEvent>()?),
            StructType::VmPrimaryFailoverEvent => Ok(from.as_any_box().downcast::<VmPrimaryFailoverEvent>()?),
            StructType::VmReconfiguredEvent => Ok(from.as_any_box().downcast::<VmReconfiguredEvent>()?),
            StructType::VmRegisteredEvent => Ok(from.as_any_box().downcast::<VmRegisteredEvent>()?),
            StructType::VmRelayoutSuccessfulEvent => Ok(from.as_any_box().downcast::<VmRelayoutSuccessfulEvent>()?),
            StructType::VmRelayoutUpToDateEvent => Ok(from.as_any_box().downcast::<VmRelayoutUpToDateEvent>()?),
            StructType::VmReloadFromPathEvent => Ok(from.as_any_box().downcast::<VmReloadFromPathEvent>()?),
            StructType::VmReloadFromPathFailedEvent => Ok(from.as_any_box().downcast::<VmReloadFromPathFailedEvent>()?),
            StructType::VmRelocateSpecEvent => Ok(from.as_any_box().downcast::<VmRelocateSpecEvent>()?),
            StructType::VmBeingRelocatedEvent => Ok(from.as_any_box().downcast::<VmBeingRelocatedEvent>()?),
            StructType::VmRelocateFailedEvent => Ok(from.as_any_box().downcast::<VmRelocateFailedEvent>()?),
            StructType::VmRelocatedEvent => Ok(from.as_any_box().downcast::<VmRelocatedEvent>()?),
            StructType::VmRemoteConsoleConnectedEvent => Ok(from.as_any_box().downcast::<VmRemoteConsoleConnectedEvent>()?),
            StructType::VmRemoteConsoleDisconnectedEvent => Ok(from.as_any_box().downcast::<VmRemoteConsoleDisconnectedEvent>()?),
            StructType::VmRemovedEvent => Ok(from.as_any_box().downcast::<VmRemovedEvent>()?),
            StructType::VmRenamedEvent => Ok(from.as_any_box().downcast::<VmRenamedEvent>()?),
            StructType::VmRequirementsExceedCurrentEvcModeEvent => Ok(from.as_any_box().downcast::<VmRequirementsExceedCurrentEvcModeEvent>()?),
            StructType::VmResettingEvent => Ok(from.as_any_box().downcast::<VmResettingEvent>()?),
            StructType::VmResourcePoolMovedEvent => Ok(from.as_any_box().downcast::<VmResourcePoolMovedEvent>()?),
            StructType::VmResourceReallocatedEvent => Ok(from.as_any_box().downcast::<VmResourceReallocatedEvent>()?),
            StructType::VmResumingEvent => Ok(from.as_any_box().downcast::<VmResumingEvent>()?),
            StructType::VmSecondaryAddedEvent => Ok(from.as_any_box().downcast::<VmSecondaryAddedEvent>()?),
            StructType::VmSecondaryDisabledBySystemEvent => Ok(from.as_any_box().downcast::<VmSecondaryDisabledBySystemEvent>()?),
            StructType::VmSecondaryDisabledEvent => Ok(from.as_any_box().downcast::<VmSecondaryDisabledEvent>()?),
            StructType::VmSecondaryEnabledEvent => Ok(from.as_any_box().downcast::<VmSecondaryEnabledEvent>()?),
            StructType::VmSecondaryStartedEvent => Ok(from.as_any_box().downcast::<VmSecondaryStartedEvent>()?),
            StructType::VmStartRecordingEvent => Ok(from.as_any_box().downcast::<VmStartRecordingEvent>()?),
            StructType::VmStartReplayingEvent => Ok(from.as_any_box().downcast::<VmStartReplayingEvent>()?),
            StructType::VmStartingEvent => Ok(from.as_any_box().downcast::<VmStartingEvent>()?),
            StructType::VmUnsupportedStartingEvent => Ok(from.as_any_box().downcast::<VmUnsupportedStartingEvent>()?),
            StructType::VmStartingSecondaryEvent => Ok(from.as_any_box().downcast::<VmStartingSecondaryEvent>()?),
            StructType::VmStaticMacConflictEvent => Ok(from.as_any_box().downcast::<VmStaticMacConflictEvent>()?),
            StructType::VmStoppingEvent => Ok(from.as_any_box().downcast::<VmStoppingEvent>()?),
            StructType::VmSuspendedEvent => Ok(from.as_any_box().downcast::<VmSuspendedEvent>()?),
            StructType::VmSuspendingEvent => Ok(from.as_any_box().downcast::<VmSuspendingEvent>()?),
            StructType::VmTimedoutStartingSecondaryEvent => Ok(from.as_any_box().downcast::<VmTimedoutStartingSecondaryEvent>()?),
            StructType::VmUpgradeCompleteEvent => Ok(from.as_any_box().downcast::<VmUpgradeCompleteEvent>()?),
            StructType::VmUpgradeFailedEvent => Ok(from.as_any_box().downcast::<VmUpgradeFailedEvent>()?),
            StructType::VmUpgradingEvent => Ok(from.as_any_box().downcast::<VmUpgradingEvent>()?),
            StructType::VmUuidAssignedEvent => Ok(from.as_any_box().downcast::<VmUuidAssignedEvent>()?),
            StructType::VmUuidChangedEvent => Ok(from.as_any_box().downcast::<VmUuidChangedEvent>()?),
            StructType::VmUuidConflictEvent => Ok(from.as_any_box().downcast::<VmUuidConflictEvent>()?),
            StructType::VmWwnAssignedEvent => Ok(from.as_any_box().downcast::<VmWwnAssignedEvent>()?),
            StructType::VmWwnChangedEvent => Ok(from.as_any_box().downcast::<VmWwnChangedEvent>()?),
            StructType::VmWwnConflictEvent => Ok(from.as_any_box().downcast::<VmWwnConflictEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base for customization events.
pub trait CustomizationEventTrait : super::traits::VmEventTrait {
    /// The location of the in-guest customization log which will contain
    /// details of the customization operation.
    fn get_log_location(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn CustomizationEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn CustomizationEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(CustomizationEventVisitor)
            }
        }

struct CustomizationEventVisitor;

impl<'de> de::Visitor<'de> for CustomizationEventVisitor {
    type Value = Box<dyn CustomizationEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid CustomizationEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl CustomizationEventTrait for CustomizationEvent {
    fn get_log_location(&self) -> &Option<String> { &self.log_location }
}
impl CustomizationEventTrait for CustomizationFailed {
    fn get_log_location(&self) -> &Option<String> { &self.log_location }
}
impl CustomizationEventTrait for CustomizationLinuxIdentityFailed {
    fn get_log_location(&self) -> &Option<String> { &self.log_location }
}
impl CustomizationEventTrait for CustomizationNetworkSetupFailed {
    fn get_log_location(&self) -> &Option<String> { &self.log_location }
}
impl CustomizationEventTrait for CustomizationSysprepFailed {
    fn get_log_location(&self) -> &Option<String> { &self.log_location }
}
impl CustomizationEventTrait for CustomizationUnknownFailure {
    fn get_log_location(&self) -> &Option<String> { &self.log_location }
}
impl CustomizationEventTrait for CustomizationStartedEvent {
    fn get_log_location(&self) -> &Option<String> { &self.log_location }
}
impl CustomizationEventTrait for CustomizationSucceeded {
    fn get_log_location(&self) -> &Option<String> { &self.log_location }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn CustomizationEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::CustomizationEvent => Some(from.as_any_ref().downcast_ref::<CustomizationEvent>()?),
            StructType::CustomizationFailed => Some(from.as_any_ref().downcast_ref::<CustomizationFailed>()?),
            StructType::CustomizationLinuxIdentityFailed => Some(from.as_any_ref().downcast_ref::<CustomizationLinuxIdentityFailed>()?),
            StructType::CustomizationNetworkSetupFailed => Some(from.as_any_ref().downcast_ref::<CustomizationNetworkSetupFailed>()?),
            StructType::CustomizationSysprepFailed => Some(from.as_any_ref().downcast_ref::<CustomizationSysprepFailed>()?),
            StructType::CustomizationUnknownFailure => Some(from.as_any_ref().downcast_ref::<CustomizationUnknownFailure>()?),
            StructType::CustomizationStartedEvent => Some(from.as_any_ref().downcast_ref::<CustomizationStartedEvent>()?),
            StructType::CustomizationSucceeded => Some(from.as_any_ref().downcast_ref::<CustomizationSucceeded>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::CustomizationEvent => Ok(from.as_any_box().downcast::<CustomizationEvent>()?),
            StructType::CustomizationFailed => Ok(from.as_any_box().downcast::<CustomizationFailed>()?),
            StructType::CustomizationLinuxIdentityFailed => Ok(from.as_any_box().downcast::<CustomizationLinuxIdentityFailed>()?),
            StructType::CustomizationNetworkSetupFailed => Ok(from.as_any_box().downcast::<CustomizationNetworkSetupFailed>()?),
            StructType::CustomizationSysprepFailed => Ok(from.as_any_box().downcast::<CustomizationSysprepFailed>()?),
            StructType::CustomizationUnknownFailure => Ok(from.as_any_box().downcast::<CustomizationUnknownFailure>()?),
            StructType::CustomizationStartedEvent => Ok(from.as_any_box().downcast::<CustomizationStartedEvent>()?),
            StructType::CustomizationSucceeded => Ok(from.as_any_box().downcast::<CustomizationSucceeded>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The customization sequence in the guest failed.
pub trait CustomizationFailedTrait : super::traits::CustomizationEventTrait {
    /// Reason why the customization failed @see CustomizationFailed.ReasonCode .
    fn get_reason(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn CustomizationFailedTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn CustomizationFailedTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(CustomizationFailedVisitor)
            }
        }

struct CustomizationFailedVisitor;

impl<'de> de::Visitor<'de> for CustomizationFailedVisitor {
    type Value = Box<dyn CustomizationFailedTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid CustomizationFailedTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl CustomizationFailedTrait for CustomizationFailed {
    fn get_reason(&self) -> &Option<String> { &self.reason }
}
impl CustomizationFailedTrait for CustomizationLinuxIdentityFailed {
    fn get_reason(&self) -> &Option<String> { &self.reason }
}
impl CustomizationFailedTrait for CustomizationNetworkSetupFailed {
    fn get_reason(&self) -> &Option<String> { &self.reason }
}
impl CustomizationFailedTrait for CustomizationSysprepFailed {
    fn get_reason(&self) -> &Option<String> { &self.reason }
}
impl CustomizationFailedTrait for CustomizationUnknownFailure {
    fn get_reason(&self) -> &Option<String> { &self.reason }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn CustomizationFailedTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::CustomizationFailed => Some(from.as_any_ref().downcast_ref::<CustomizationFailed>()?),
            StructType::CustomizationLinuxIdentityFailed => Some(from.as_any_ref().downcast_ref::<CustomizationLinuxIdentityFailed>()?),
            StructType::CustomizationNetworkSetupFailed => Some(from.as_any_ref().downcast_ref::<CustomizationNetworkSetupFailed>()?),
            StructType::CustomizationSysprepFailed => Some(from.as_any_ref().downcast_ref::<CustomizationSysprepFailed>()?),
            StructType::CustomizationUnknownFailure => Some(from.as_any_ref().downcast_ref::<CustomizationUnknownFailure>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::CustomizationFailed => Ok(from.as_any_box().downcast::<CustomizationFailed>()?),
            StructType::CustomizationLinuxIdentityFailed => Ok(from.as_any_box().downcast::<CustomizationLinuxIdentityFailed>()?),
            StructType::CustomizationNetworkSetupFailed => Ok(from.as_any_box().downcast::<CustomizationNetworkSetupFailed>()?),
            StructType::CustomizationSysprepFailed => Ok(from.as_any_box().downcast::<CustomizationSysprepFailed>()?),
            StructType::CustomizationUnknownFailure => Ok(from.as_any_box().downcast::<CustomizationUnknownFailure>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// These are events used to describe migration warning and errors
pub trait MigrationEventTrait : super::traits::VmEventTrait {
    /// The fault that describes the migration issue.
    /// 
    /// This is typically either a
    /// MigrationFault or a VmConfigFault.
    fn get_fault(&self) -> &Box<dyn super::traits::MethodFaultTrait>;
}
impl<'s> serde::Serialize for dyn MigrationEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn MigrationEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(MigrationEventVisitor)
            }
        }

struct MigrationEventVisitor;

impl<'de> de::Visitor<'de> for MigrationEventVisitor {
    type Value = Box<dyn MigrationEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid MigrationEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl MigrationEventTrait for MigrationEvent {
    fn get_fault(&self) -> &Box<dyn super::traits::MethodFaultTrait> { &self.fault }
}
impl MigrationEventTrait for MigrationErrorEvent {
    fn get_fault(&self) -> &Box<dyn super::traits::MethodFaultTrait> { &self.fault }
}
impl MigrationEventTrait for MigrationHostErrorEvent {
    fn get_fault(&self) -> &Box<dyn super::traits::MethodFaultTrait> { &self.fault }
}
impl MigrationEventTrait for MigrationHostWarningEvent {
    fn get_fault(&self) -> &Box<dyn super::traits::MethodFaultTrait> { &self.fault }
}
impl MigrationEventTrait for MigrationResourceErrorEvent {
    fn get_fault(&self) -> &Box<dyn super::traits::MethodFaultTrait> { &self.fault }
}
impl MigrationEventTrait for MigrationResourceWarningEvent {
    fn get_fault(&self) -> &Box<dyn super::traits::MethodFaultTrait> { &self.fault }
}
impl MigrationEventTrait for MigrationWarningEvent {
    fn get_fault(&self) -> &Box<dyn super::traits::MethodFaultTrait> { &self.fault }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn MigrationEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::MigrationEvent => Some(from.as_any_ref().downcast_ref::<MigrationEvent>()?),
            StructType::MigrationErrorEvent => Some(from.as_any_ref().downcast_ref::<MigrationErrorEvent>()?),
            StructType::MigrationHostErrorEvent => Some(from.as_any_ref().downcast_ref::<MigrationHostErrorEvent>()?),
            StructType::MigrationHostWarningEvent => Some(from.as_any_ref().downcast_ref::<MigrationHostWarningEvent>()?),
            StructType::MigrationResourceErrorEvent => Some(from.as_any_ref().downcast_ref::<MigrationResourceErrorEvent>()?),
            StructType::MigrationResourceWarningEvent => Some(from.as_any_ref().downcast_ref::<MigrationResourceWarningEvent>()?),
            StructType::MigrationWarningEvent => Some(from.as_any_ref().downcast_ref::<MigrationWarningEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::MigrationEvent => Ok(from.as_any_box().downcast::<MigrationEvent>()?),
            StructType::MigrationErrorEvent => Ok(from.as_any_box().downcast::<MigrationErrorEvent>()?),
            StructType::MigrationHostErrorEvent => Ok(from.as_any_box().downcast::<MigrationHostErrorEvent>()?),
            StructType::MigrationHostWarningEvent => Ok(from.as_any_box().downcast::<MigrationHostWarningEvent>()?),
            StructType::MigrationResourceErrorEvent => Ok(from.as_any_box().downcast::<MigrationResourceErrorEvent>()?),
            StructType::MigrationResourceWarningEvent => Ok(from.as_any_box().downcast::<MigrationResourceWarningEvent>()?),
            StructType::MigrationWarningEvent => Ok(from.as_any_box().downcast::<MigrationWarningEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The is the base event for all clone operations.
pub trait VmCloneEventTrait : super::traits::VmEventTrait {
}
impl<'s> serde::Serialize for dyn VmCloneEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VmCloneEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VmCloneEventVisitor)
            }
        }

struct VmCloneEventVisitor;

impl<'de> de::Visitor<'de> for VmCloneEventVisitor {
    type Value = Box<dyn VmCloneEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VmCloneEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VmCloneEventTrait for VmCloneEvent {
}
impl VmCloneEventTrait for VmBeingClonedEvent {
}
impl VmCloneEventTrait for VmBeingClonedNoFolderEvent {
}
impl VmCloneEventTrait for VmCloneFailedEvent {
}
impl VmCloneEventTrait for VmClonedEvent {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VmCloneEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmCloneEvent => Some(from.as_any_ref().downcast_ref::<VmCloneEvent>()?),
            StructType::VmBeingClonedEvent => Some(from.as_any_ref().downcast_ref::<VmBeingClonedEvent>()?),
            StructType::VmBeingClonedNoFolderEvent => Some(from.as_any_ref().downcast_ref::<VmBeingClonedNoFolderEvent>()?),
            StructType::VmCloneFailedEvent => Some(from.as_any_ref().downcast_ref::<VmCloneFailedEvent>()?),
            StructType::VmClonedEvent => Some(from.as_any_ref().downcast_ref::<VmClonedEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmCloneEvent => Ok(from.as_any_box().downcast::<VmCloneEvent>()?),
            StructType::VmBeingClonedEvent => Ok(from.as_any_box().downcast::<VmBeingClonedEvent>()?),
            StructType::VmBeingClonedNoFolderEvent => Ok(from.as_any_box().downcast::<VmBeingClonedNoFolderEvent>()?),
            StructType::VmCloneFailedEvent => Ok(from.as_any_box().downcast::<VmCloneFailedEvent>()?),
            StructType::VmClonedEvent => Ok(from.as_any_box().downcast::<VmClonedEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This event records when a virtual machine is reset by
/// HA VM Health Monitoring on hosts that do not support the
/// create screenshot api or if the createscreenshot api fails.
pub trait VmDasBeingResetEventTrait : super::traits::VmEventTrait {
    /// The reason why this vm is being reset
    fn get_reason(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn VmDasBeingResetEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VmDasBeingResetEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VmDasBeingResetEventVisitor)
            }
        }

struct VmDasBeingResetEventVisitor;

impl<'de> de::Visitor<'de> for VmDasBeingResetEventVisitor {
    type Value = Box<dyn VmDasBeingResetEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VmDasBeingResetEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VmDasBeingResetEventTrait for VmDasBeingResetEvent {
    fn get_reason(&self) -> &Option<String> { &self.reason }
}
impl VmDasBeingResetEventTrait for VmDasBeingResetWithScreenshotEvent {
    fn get_reason(&self) -> &Option<String> { &self.reason }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VmDasBeingResetEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmDasBeingResetEvent => Some(from.as_any_ref().downcast_ref::<VmDasBeingResetEvent>()?),
            StructType::VmDasBeingResetWithScreenshotEvent => Some(from.as_any_ref().downcast_ref::<VmDasBeingResetWithScreenshotEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmDasBeingResetEvent => Ok(from.as_any_box().downcast::<VmDasBeingResetEvent>()?),
            StructType::VmDasBeingResetWithScreenshotEvent => Ok(from.as_any_box().downcast::<VmDasBeingResetWithScreenshotEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This event records a virtual machine migration.
pub trait VmMigratedEventTrait : super::traits::VmEventTrait {
    /// The source host.
    /// 
    /// (Because this is after a successful migration,
    /// the destination host is recorded in the inherited "host" property.)
    fn get_source_host(&self) -> &HostEventArgument;
    /// The source datacenter
    fn get_source_datacenter(&self) -> &Option<DatacenterEventArgument>;
    /// The source primary datastore
    fn get_source_datastore(&self) -> &Option<DatastoreEventArgument>;
}
impl<'s> serde::Serialize for dyn VmMigratedEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VmMigratedEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VmMigratedEventVisitor)
            }
        }

struct VmMigratedEventVisitor;

impl<'de> de::Visitor<'de> for VmMigratedEventVisitor {
    type Value = Box<dyn VmMigratedEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VmMigratedEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VmMigratedEventTrait for VmMigratedEvent {
    fn get_source_host(&self) -> &HostEventArgument { &self.source_host }
    fn get_source_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.source_datacenter }
    fn get_source_datastore(&self) -> &Option<DatastoreEventArgument> { &self.source_datastore }
}
impl VmMigratedEventTrait for DrsVmMigratedEvent {
    fn get_source_host(&self) -> &HostEventArgument { &self.source_host }
    fn get_source_datacenter(&self) -> &Option<DatacenterEventArgument> { &self.source_datacenter }
    fn get_source_datastore(&self) -> &Option<DatastoreEventArgument> { &self.source_datastore }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VmMigratedEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmMigratedEvent => Some(from.as_any_ref().downcast_ref::<VmMigratedEvent>()?),
            StructType::DrsVmMigratedEvent => Some(from.as_any_ref().downcast_ref::<DrsVmMigratedEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmMigratedEvent => Ok(from.as_any_box().downcast::<VmMigratedEvent>()?),
            StructType::DrsVmMigratedEvent => Ok(from.as_any_box().downcast::<DrsVmMigratedEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This event records when a virtual machine finished powering off.
pub trait VmPoweredOffEventTrait : super::traits::VmEventTrait {
}
impl<'s> serde::Serialize for dyn VmPoweredOffEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VmPoweredOffEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VmPoweredOffEventVisitor)
            }
        }

struct VmPoweredOffEventVisitor;

impl<'de> de::Visitor<'de> for VmPoweredOffEventVisitor {
    type Value = Box<dyn VmPoweredOffEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VmPoweredOffEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VmPoweredOffEventTrait for VmPoweredOffEvent {
}
impl VmPoweredOffEventTrait for VmPowerOffOnIsolationEvent {
}
impl VmPoweredOffEventTrait for VmShutdownOnIsolationEvent {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VmPoweredOffEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmPoweredOffEvent => Some(from.as_any_ref().downcast_ref::<VmPoweredOffEvent>()?),
            StructType::VmPowerOffOnIsolationEvent => Some(from.as_any_ref().downcast_ref::<VmPowerOffOnIsolationEvent>()?),
            StructType::VmShutdownOnIsolationEvent => Some(from.as_any_ref().downcast_ref::<VmShutdownOnIsolationEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmPoweredOffEvent => Ok(from.as_any_box().downcast::<VmPoweredOffEvent>()?),
            StructType::VmPowerOffOnIsolationEvent => Ok(from.as_any_box().downcast::<VmPowerOffOnIsolationEvent>()?),
            StructType::VmShutdownOnIsolationEvent => Ok(from.as_any_box().downcast::<VmShutdownOnIsolationEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This event records when a virtual machine finished powering on.
pub trait VmPoweredOnEventTrait : super::traits::VmEventTrait {
}
impl<'s> serde::Serialize for dyn VmPoweredOnEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VmPoweredOnEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VmPoweredOnEventVisitor)
            }
        }

struct VmPoweredOnEventVisitor;

impl<'de> de::Visitor<'de> for VmPoweredOnEventVisitor {
    type Value = Box<dyn VmPoweredOnEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VmPoweredOnEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VmPoweredOnEventTrait for VmPoweredOnEvent {
}
impl VmPoweredOnEventTrait for DrsVmPoweredOnEvent {
}
impl VmPoweredOnEventTrait for VmRestartedOnAlternateHostEvent {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VmPoweredOnEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmPoweredOnEvent => Some(from.as_any_ref().downcast_ref::<VmPoweredOnEvent>()?),
            StructType::DrsVmPoweredOnEvent => Some(from.as_any_ref().downcast_ref::<DrsVmPoweredOnEvent>()?),
            StructType::VmRestartedOnAlternateHostEvent => Some(from.as_any_ref().downcast_ref::<VmRestartedOnAlternateHostEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmPoweredOnEvent => Ok(from.as_any_box().downcast::<VmPoweredOnEvent>()?),
            StructType::DrsVmPoweredOnEvent => Ok(from.as_any_box().downcast::<DrsVmPoweredOnEvent>()?),
            StructType::VmRestartedOnAlternateHostEvent => Ok(from.as_any_box().downcast::<VmRestartedOnAlternateHostEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This event is the base event for relocate and clone base events.
pub trait VmRelocateSpecEventTrait : super::traits::VmEventTrait {
}
impl<'s> serde::Serialize for dyn VmRelocateSpecEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VmRelocateSpecEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VmRelocateSpecEventVisitor)
            }
        }

struct VmRelocateSpecEventVisitor;

impl<'de> de::Visitor<'de> for VmRelocateSpecEventVisitor {
    type Value = Box<dyn VmRelocateSpecEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VmRelocateSpecEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VmRelocateSpecEventTrait for VmRelocateSpecEvent {
}
impl VmRelocateSpecEventTrait for VmBeingRelocatedEvent {
}
impl VmRelocateSpecEventTrait for VmRelocateFailedEvent {
}
impl VmRelocateSpecEventTrait for VmRelocatedEvent {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VmRelocateSpecEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmRelocateSpecEvent => Some(from.as_any_ref().downcast_ref::<VmRelocateSpecEvent>()?),
            StructType::VmBeingRelocatedEvent => Some(from.as_any_ref().downcast_ref::<VmBeingRelocatedEvent>()?),
            StructType::VmRelocateFailedEvent => Some(from.as_any_ref().downcast_ref::<VmRelocateFailedEvent>()?),
            StructType::VmRelocatedEvent => Some(from.as_any_ref().downcast_ref::<VmRelocatedEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmRelocateSpecEvent => Ok(from.as_any_box().downcast::<VmRelocateSpecEvent>()?),
            StructType::VmBeingRelocatedEvent => Ok(from.as_any_box().downcast::<VmBeingRelocatedEvent>()?),
            StructType::VmRelocateFailedEvent => Ok(from.as_any_box().downcast::<VmRelocateFailedEvent>()?),
            StructType::VmRelocatedEvent => Ok(from.as_any_box().downcast::<VmRelocatedEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This event records a virtual machine powering on.
pub trait VmStartingEventTrait : super::traits::VmEventTrait {
}
impl<'s> serde::Serialize for dyn VmStartingEventTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VmStartingEventTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VmStartingEventVisitor)
            }
        }

struct VmStartingEventVisitor;

impl<'de> de::Visitor<'de> for VmStartingEventVisitor {
    type Value = Box<dyn VmStartingEventTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VmStartingEventTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VmStartingEventTrait for VmStartingEvent {
}
impl VmStartingEventTrait for VmUnsupportedStartingEvent {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VmStartingEventTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmStartingEvent => Some(from.as_any_ref().downcast_ref::<VmStartingEvent>()?),
            StructType::VmUnsupportedStartingEvent => Some(from.as_any_ref().downcast_ref::<VmUnsupportedStartingEvent>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmStartingEvent => Ok(from.as_any_box().downcast::<VmStartingEvent>()?),
            StructType::VmUnsupportedStartingEvent => Ok(from.as_any_box().downcast::<VmUnsupportedStartingEvent>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This is the base type for event argument types.
/// 
/// Event argument objects, which inherit from a common subtype,
/// are used to manage supplementary properties of different kinds
/// of event objects.
pub trait EventArgumentTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn EventArgumentTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn EventArgumentTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(EventArgumentVisitor)
            }
        }

struct EventArgumentVisitor;

impl<'de> de::Visitor<'de> for EventArgumentVisitor {
    type Value = Box<dyn EventArgumentTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid EventArgumentTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl EventArgumentTrait for EventArgument {
}
impl EventArgumentTrait for EntityEventArgument {
}
impl EventArgumentTrait for AlarmEventArgument {
}
impl EventArgumentTrait for ComputeResourceEventArgument {
}
impl EventArgumentTrait for DatacenterEventArgument {
}
impl EventArgumentTrait for DatastoreEventArgument {
}
impl EventArgumentTrait for DvsEventArgument {
}
impl EventArgumentTrait for FolderEventArgument {
}
impl EventArgumentTrait for HostEventArgument {
}
impl EventArgumentTrait for ManagedEntityEventArgument {
}
impl EventArgumentTrait for NetworkEventArgument {
}
impl EventArgumentTrait for ResourcePoolEventArgument {
}
impl EventArgumentTrait for ScheduledTaskEventArgument {
}
impl EventArgumentTrait for VmEventArgument {
}
impl EventArgumentTrait for ProfileEventArgument {
}
impl EventArgumentTrait for RoleEventArgument {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn EventArgumentTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::EventArgument => Some(from.as_any_ref().downcast_ref::<EventArgument>()?),
            StructType::EntityEventArgument => Some(from.as_any_ref().downcast_ref::<EntityEventArgument>()?),
            StructType::AlarmEventArgument => Some(from.as_any_ref().downcast_ref::<AlarmEventArgument>()?),
            StructType::ComputeResourceEventArgument => Some(from.as_any_ref().downcast_ref::<ComputeResourceEventArgument>()?),
            StructType::DatacenterEventArgument => Some(from.as_any_ref().downcast_ref::<DatacenterEventArgument>()?),
            StructType::DatastoreEventArgument => Some(from.as_any_ref().downcast_ref::<DatastoreEventArgument>()?),
            StructType::DvsEventArgument => Some(from.as_any_ref().downcast_ref::<DvsEventArgument>()?),
            StructType::FolderEventArgument => Some(from.as_any_ref().downcast_ref::<FolderEventArgument>()?),
            StructType::HostEventArgument => Some(from.as_any_ref().downcast_ref::<HostEventArgument>()?),
            StructType::ManagedEntityEventArgument => Some(from.as_any_ref().downcast_ref::<ManagedEntityEventArgument>()?),
            StructType::NetworkEventArgument => Some(from.as_any_ref().downcast_ref::<NetworkEventArgument>()?),
            StructType::ResourcePoolEventArgument => Some(from.as_any_ref().downcast_ref::<ResourcePoolEventArgument>()?),
            StructType::ScheduledTaskEventArgument => Some(from.as_any_ref().downcast_ref::<ScheduledTaskEventArgument>()?),
            StructType::VmEventArgument => Some(from.as_any_ref().downcast_ref::<VmEventArgument>()?),
            StructType::ProfileEventArgument => Some(from.as_any_ref().downcast_ref::<ProfileEventArgument>()?),
            StructType::RoleEventArgument => Some(from.as_any_ref().downcast_ref::<RoleEventArgument>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::EventArgument => Ok(from.as_any_box().downcast::<EventArgument>()?),
            StructType::EntityEventArgument => Ok(from.as_any_box().downcast::<EntityEventArgument>()?),
            StructType::AlarmEventArgument => Ok(from.as_any_box().downcast::<AlarmEventArgument>()?),
            StructType::ComputeResourceEventArgument => Ok(from.as_any_box().downcast::<ComputeResourceEventArgument>()?),
            StructType::DatacenterEventArgument => Ok(from.as_any_box().downcast::<DatacenterEventArgument>()?),
            StructType::DatastoreEventArgument => Ok(from.as_any_box().downcast::<DatastoreEventArgument>()?),
            StructType::DvsEventArgument => Ok(from.as_any_box().downcast::<DvsEventArgument>()?),
            StructType::FolderEventArgument => Ok(from.as_any_box().downcast::<FolderEventArgument>()?),
            StructType::HostEventArgument => Ok(from.as_any_box().downcast::<HostEventArgument>()?),
            StructType::ManagedEntityEventArgument => Ok(from.as_any_box().downcast::<ManagedEntityEventArgument>()?),
            StructType::NetworkEventArgument => Ok(from.as_any_box().downcast::<NetworkEventArgument>()?),
            StructType::ResourcePoolEventArgument => Ok(from.as_any_box().downcast::<ResourcePoolEventArgument>()?),
            StructType::ScheduledTaskEventArgument => Ok(from.as_any_box().downcast::<ScheduledTaskEventArgument>()?),
            StructType::VmEventArgument => Ok(from.as_any_box().downcast::<VmEventArgument>()?),
            StructType::ProfileEventArgument => Ok(from.as_any_box().downcast::<ProfileEventArgument>()?),
            StructType::RoleEventArgument => Ok(from.as_any_box().downcast::<RoleEventArgument>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The event argument is a managed entity object.
/// 
/// Subclasses of this type distinguish the different managed entities
/// referenced in event objects.
pub trait EntityEventArgumentTrait : super::traits::EventArgumentTrait {
    /// Name of the entity, including its full path from the root of the inventory.
    fn get_name(&self) -> &str;
}
impl<'s> serde::Serialize for dyn EntityEventArgumentTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn EntityEventArgumentTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(EntityEventArgumentVisitor)
            }
        }

struct EntityEventArgumentVisitor;

impl<'de> de::Visitor<'de> for EntityEventArgumentVisitor {
    type Value = Box<dyn EntityEventArgumentTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid EntityEventArgumentTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl EntityEventArgumentTrait for EntityEventArgument {
    fn get_name(&self) -> &str { &self.name }
}
impl EntityEventArgumentTrait for AlarmEventArgument {
    fn get_name(&self) -> &str { &self.name }
}
impl EntityEventArgumentTrait for ComputeResourceEventArgument {
    fn get_name(&self) -> &str { &self.name }
}
impl EntityEventArgumentTrait for DatacenterEventArgument {
    fn get_name(&self) -> &str { &self.name }
}
impl EntityEventArgumentTrait for DatastoreEventArgument {
    fn get_name(&self) -> &str { &self.name }
}
impl EntityEventArgumentTrait for DvsEventArgument {
    fn get_name(&self) -> &str { &self.name }
}
impl EntityEventArgumentTrait for FolderEventArgument {
    fn get_name(&self) -> &str { &self.name }
}
impl EntityEventArgumentTrait for HostEventArgument {
    fn get_name(&self) -> &str { &self.name }
}
impl EntityEventArgumentTrait for ManagedEntityEventArgument {
    fn get_name(&self) -> &str { &self.name }
}
impl EntityEventArgumentTrait for NetworkEventArgument {
    fn get_name(&self) -> &str { &self.name }
}
impl EntityEventArgumentTrait for ResourcePoolEventArgument {
    fn get_name(&self) -> &str { &self.name }
}
impl EntityEventArgumentTrait for ScheduledTaskEventArgument {
    fn get_name(&self) -> &str { &self.name }
}
impl EntityEventArgumentTrait for VmEventArgument {
    fn get_name(&self) -> &str { &self.name }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn EntityEventArgumentTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::EntityEventArgument => Some(from.as_any_ref().downcast_ref::<EntityEventArgument>()?),
            StructType::AlarmEventArgument => Some(from.as_any_ref().downcast_ref::<AlarmEventArgument>()?),
            StructType::ComputeResourceEventArgument => Some(from.as_any_ref().downcast_ref::<ComputeResourceEventArgument>()?),
            StructType::DatacenterEventArgument => Some(from.as_any_ref().downcast_ref::<DatacenterEventArgument>()?),
            StructType::DatastoreEventArgument => Some(from.as_any_ref().downcast_ref::<DatastoreEventArgument>()?),
            StructType::DvsEventArgument => Some(from.as_any_ref().downcast_ref::<DvsEventArgument>()?),
            StructType::FolderEventArgument => Some(from.as_any_ref().downcast_ref::<FolderEventArgument>()?),
            StructType::HostEventArgument => Some(from.as_any_ref().downcast_ref::<HostEventArgument>()?),
            StructType::ManagedEntityEventArgument => Some(from.as_any_ref().downcast_ref::<ManagedEntityEventArgument>()?),
            StructType::NetworkEventArgument => Some(from.as_any_ref().downcast_ref::<NetworkEventArgument>()?),
            StructType::ResourcePoolEventArgument => Some(from.as_any_ref().downcast_ref::<ResourcePoolEventArgument>()?),
            StructType::ScheduledTaskEventArgument => Some(from.as_any_ref().downcast_ref::<ScheduledTaskEventArgument>()?),
            StructType::VmEventArgument => Some(from.as_any_ref().downcast_ref::<VmEventArgument>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::EntityEventArgument => Ok(from.as_any_box().downcast::<EntityEventArgument>()?),
            StructType::AlarmEventArgument => Ok(from.as_any_box().downcast::<AlarmEventArgument>()?),
            StructType::ComputeResourceEventArgument => Ok(from.as_any_box().downcast::<ComputeResourceEventArgument>()?),
            StructType::DatacenterEventArgument => Ok(from.as_any_box().downcast::<DatacenterEventArgument>()?),
            StructType::DatastoreEventArgument => Ok(from.as_any_box().downcast::<DatastoreEventArgument>()?),
            StructType::DvsEventArgument => Ok(from.as_any_box().downcast::<DvsEventArgument>()?),
            StructType::FolderEventArgument => Ok(from.as_any_box().downcast::<FolderEventArgument>()?),
            StructType::HostEventArgument => Ok(from.as_any_box().downcast::<HostEventArgument>()?),
            StructType::ManagedEntityEventArgument => Ok(from.as_any_box().downcast::<ManagedEntityEventArgument>()?),
            StructType::NetworkEventArgument => Ok(from.as_any_box().downcast::<NetworkEventArgument>()?),
            StructType::ResourcePoolEventArgument => Ok(from.as_any_box().downcast::<ResourcePoolEventArgument>()?),
            StructType::ScheduledTaskEventArgument => Ok(from.as_any_box().downcast::<ScheduledTaskEventArgument>()?),
            StructType::VmEventArgument => Ok(from.as_any_box().downcast::<VmEventArgument>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *HostAuthenticationStoreInfo* base class defines status information
/// for local and host Active Directory authentication.
pub trait HostAuthenticationStoreInfoTrait : super::traits::DataObjectTrait {
    /// Indicates whether the authentication store is configured.
    /// - Host Active Directory authentication - <code>enabled</code>
    ///   is <code>True</code> if the host is a member of a domain.
    /// - Local authentication - <code>enabled</code> is always <code>True</code>.
    fn get_enabled(&self) -> bool;
}
impl<'s> serde::Serialize for dyn HostAuthenticationStoreInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostAuthenticationStoreInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostAuthenticationStoreInfoVisitor)
            }
        }

struct HostAuthenticationStoreInfoVisitor;

impl<'de> de::Visitor<'de> for HostAuthenticationStoreInfoVisitor {
    type Value = Box<dyn HostAuthenticationStoreInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostAuthenticationStoreInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostAuthenticationStoreInfoTrait for HostAuthenticationStoreInfo {
    fn get_enabled(&self) -> bool { self.enabled }
}
impl HostAuthenticationStoreInfoTrait for HostDirectoryStoreInfo {
    fn get_enabled(&self) -> bool { self.enabled }
}
impl HostAuthenticationStoreInfoTrait for HostActiveDirectoryInfo {
    fn get_enabled(&self) -> bool { self.enabled }
}
impl HostAuthenticationStoreInfoTrait for HostLocalAuthenticationInfo {
    fn get_enabled(&self) -> bool { self.enabled }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostAuthenticationStoreInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostAuthenticationStoreInfo => Some(from.as_any_ref().downcast_ref::<HostAuthenticationStoreInfo>()?),
            StructType::HostDirectoryStoreInfo => Some(from.as_any_ref().downcast_ref::<HostDirectoryStoreInfo>()?),
            StructType::HostActiveDirectoryInfo => Some(from.as_any_ref().downcast_ref::<HostActiveDirectoryInfo>()?),
            StructType::HostLocalAuthenticationInfo => Some(from.as_any_ref().downcast_ref::<HostLocalAuthenticationInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostAuthenticationStoreInfo => Ok(from.as_any_box().downcast::<HostAuthenticationStoreInfo>()?),
            StructType::HostDirectoryStoreInfo => Ok(from.as_any_box().downcast::<HostDirectoryStoreInfo>()?),
            StructType::HostActiveDirectoryInfo => Ok(from.as_any_box().downcast::<HostActiveDirectoryInfo>()?),
            StructType::HostLocalAuthenticationInfo => Ok(from.as_any_box().downcast::<HostLocalAuthenticationInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// *HostDirectoryStoreInfo* is a base class for objects that
/// provide information about directory-based authentication stores.
pub trait HostDirectoryStoreInfoTrait : super::traits::HostAuthenticationStoreInfoTrait {
}
impl<'s> serde::Serialize for dyn HostDirectoryStoreInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostDirectoryStoreInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostDirectoryStoreInfoVisitor)
            }
        }

struct HostDirectoryStoreInfoVisitor;

impl<'de> de::Visitor<'de> for HostDirectoryStoreInfoVisitor {
    type Value = Box<dyn HostDirectoryStoreInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostDirectoryStoreInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostDirectoryStoreInfoTrait for HostDirectoryStoreInfo {
}
impl HostDirectoryStoreInfoTrait for HostActiveDirectoryInfo {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostDirectoryStoreInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostDirectoryStoreInfo => Some(from.as_any_ref().downcast_ref::<HostDirectoryStoreInfo>()?),
            StructType::HostActiveDirectoryInfo => Some(from.as_any_ref().downcast_ref::<HostActiveDirectoryInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostDirectoryStoreInfo => Ok(from.as_any_box().downcast::<HostDirectoryStoreInfo>()?),
            StructType::HostActiveDirectoryInfo => Ok(from.as_any_box().downcast::<HostActiveDirectoryInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The base data object type for information about datastores on the host.
pub trait HostDatastoreConnectInfoTrait : super::traits::DataObjectTrait {
    /// Basic datastore information.
    /// 
    /// The managed object reference is not set.
    fn get_summary(&self) -> &DatastoreSummary;
}
impl<'s> serde::Serialize for dyn HostDatastoreConnectInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostDatastoreConnectInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostDatastoreConnectInfoVisitor)
            }
        }

struct HostDatastoreConnectInfoVisitor;

impl<'de> de::Visitor<'de> for HostDatastoreConnectInfoVisitor {
    type Value = Box<dyn HostDatastoreConnectInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostDatastoreConnectInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostDatastoreConnectInfoTrait for HostDatastoreConnectInfo {
    fn get_summary(&self) -> &DatastoreSummary { &self.summary }
}
impl HostDatastoreConnectInfoTrait for HostDatastoreExistsConnectInfo {
    fn get_summary(&self) -> &DatastoreSummary { &self.summary }
}
impl HostDatastoreConnectInfoTrait for HostDatastoreNameConflictConnectInfo {
    fn get_summary(&self) -> &DatastoreSummary { &self.summary }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostDatastoreConnectInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostDatastoreConnectInfo => Some(from.as_any_ref().downcast_ref::<HostDatastoreConnectInfo>()?),
            StructType::HostDatastoreExistsConnectInfo => Some(from.as_any_ref().downcast_ref::<HostDatastoreExistsConnectInfo>()?),
            StructType::HostDatastoreNameConflictConnectInfo => Some(from.as_any_ref().downcast_ref::<HostDatastoreNameConflictConnectInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostDatastoreConnectInfo => Ok(from.as_any_box().downcast::<HostDatastoreConnectInfo>()?),
            StructType::HostDatastoreExistsConnectInfo => Ok(from.as_any_box().downcast::<HostDatastoreExistsConnectInfo>()?),
            StructType::HostDatastoreNameConflictConnectInfo => Ok(from.as_any_box().downcast::<HostDatastoreNameConflictConnectInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The base data object type for information about networks on the host.
pub trait HostConnectInfoNetworkInfoTrait : super::traits::DataObjectTrait {
    /// Basic network information, such as network name.
    /// 
    /// The managed object reference
    /// is not set.
    fn get_summary(&self) -> &Box<dyn super::traits::NetworkSummaryTrait>;
}
impl<'s> serde::Serialize for dyn HostConnectInfoNetworkInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostConnectInfoNetworkInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostConnectInfoNetworkInfoVisitor)
            }
        }

struct HostConnectInfoNetworkInfoVisitor;

impl<'de> de::Visitor<'de> for HostConnectInfoNetworkInfoVisitor {
    type Value = Box<dyn HostConnectInfoNetworkInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostConnectInfoNetworkInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostConnectInfoNetworkInfoTrait for HostConnectInfoNetworkInfo {
    fn get_summary(&self) -> &Box<dyn super::traits::NetworkSummaryTrait> { &self.summary }
}
impl HostConnectInfoNetworkInfoTrait for HostNewNetworkConnectInfo {
    fn get_summary(&self) -> &Box<dyn super::traits::NetworkSummaryTrait> { &self.summary }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostConnectInfoNetworkInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostConnectInfoNetworkInfo => Some(from.as_any_ref().downcast_ref::<HostConnectInfoNetworkInfo>()?),
            StructType::HostNewNetworkConnectInfo => Some(from.as_any_ref().downcast_ref::<HostNewNetworkConnectInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostConnectInfoNetworkInfo => Ok(from.as_any_box().downcast::<HostConnectInfoNetworkInfo>()?),
            StructType::HostNewNetworkConnectInfo => Ok(from.as_any_box().downcast::<HostNewNetworkConnectInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// DataTransportConnectionInfo contains common information about data transport
/// connections on a host.
/// 
/// ***Since:*** vSphere API Release 7.0.3.0
pub trait HostDataTransportConnectionInfoTrait : super::traits::DataObjectTrait {
    /// Static memory consumption by a connection in bytes like buffer sizes, heap sizes, etc.
    fn get_static_memory_consumed(&self) -> i64;
}
impl<'s> serde::Serialize for dyn HostDataTransportConnectionInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostDataTransportConnectionInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostDataTransportConnectionInfoVisitor)
            }
        }

struct HostDataTransportConnectionInfoVisitor;

impl<'de> de::Visitor<'de> for HostDataTransportConnectionInfoVisitor {
    type Value = Box<dyn HostDataTransportConnectionInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostDataTransportConnectionInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostDataTransportConnectionInfoTrait for HostDataTransportConnectionInfo {
    fn get_static_memory_consumed(&self) -> i64 { self.static_memory_consumed }
}
impl HostDataTransportConnectionInfoTrait for HostNfcConnectionInfo {
    fn get_static_memory_consumed(&self) -> i64 { self.static_memory_consumed }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostDataTransportConnectionInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostDataTransportConnectionInfo => Some(from.as_any_ref().downcast_ref::<HostDataTransportConnectionInfo>()?),
            StructType::HostNfcConnectionInfo => Some(from.as_any_ref().downcast_ref::<HostNfcConnectionInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostDataTransportConnectionInfo => Ok(from.as_any_box().downcast::<HostDataTransportConnectionInfo>()?),
            StructType::HostNfcConnectionInfo => Ok(from.as_any_box().downcast::<HostNfcConnectionInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type contains rudimentary information about a file in a
/// datastore.
/// 
/// The information here is not meant to cover all information in
/// traditional file systems, but rather to provide sufficient information for files
/// that are associated with virtual machines. Derived types describe the known file
/// types for a datastore.
pub trait FileInfoTrait : super::traits::DataObjectTrait {
    /// The path relative to the folder path in the search results.
    fn get_path(&self) -> &str;
    /// User friendly name.
    fn get_friendly_name(&self) -> &Option<String>;
    /// The size of the file in bytes.
    fn get_file_size(&self) -> Option<i64>;
    /// The last date and time the file was modified.
    fn get_modification(&self) -> &Option<String>;
    /// The user name of the owner of the file.
    fn get_owner(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn FileInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn FileInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(FileInfoVisitor)
            }
        }

struct FileInfoVisitor;

impl<'de> de::Visitor<'de> for FileInfoVisitor {
    type Value = Box<dyn FileInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid FileInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl FileInfoTrait for FileInfo {
    fn get_path(&self) -> &str { &self.path }
    fn get_friendly_name(&self) -> &Option<String> { &self.friendly_name }
    fn get_file_size(&self) -> Option<i64> { self.file_size }
    fn get_modification(&self) -> &Option<String> { &self.modification }
    fn get_owner(&self) -> &Option<String> { &self.owner }
}
impl FileInfoTrait for FloppyImageFileInfo {
    fn get_path(&self) -> &str { &self.path }
    fn get_friendly_name(&self) -> &Option<String> { &self.friendly_name }
    fn get_file_size(&self) -> Option<i64> { self.file_size }
    fn get_modification(&self) -> &Option<String> { &self.modification }
    fn get_owner(&self) -> &Option<String> { &self.owner }
}
impl FileInfoTrait for FolderFileInfo {
    fn get_path(&self) -> &str { &self.path }
    fn get_friendly_name(&self) -> &Option<String> { &self.friendly_name }
    fn get_file_size(&self) -> Option<i64> { self.file_size }
    fn get_modification(&self) -> &Option<String> { &self.modification }
    fn get_owner(&self) -> &Option<String> { &self.owner }
}
impl FileInfoTrait for IsoImageFileInfo {
    fn get_path(&self) -> &str { &self.path }
    fn get_friendly_name(&self) -> &Option<String> { &self.friendly_name }
    fn get_file_size(&self) -> Option<i64> { self.file_size }
    fn get_modification(&self) -> &Option<String> { &self.modification }
    fn get_owner(&self) -> &Option<String> { &self.owner }
}
impl FileInfoTrait for VmConfigFileInfo {
    fn get_path(&self) -> &str { &self.path }
    fn get_friendly_name(&self) -> &Option<String> { &self.friendly_name }
    fn get_file_size(&self) -> Option<i64> { self.file_size }
    fn get_modification(&self) -> &Option<String> { &self.modification }
    fn get_owner(&self) -> &Option<String> { &self.owner }
}
impl FileInfoTrait for TemplateConfigFileInfo {
    fn get_path(&self) -> &str { &self.path }
    fn get_friendly_name(&self) -> &Option<String> { &self.friendly_name }
    fn get_file_size(&self) -> Option<i64> { self.file_size }
    fn get_modification(&self) -> &Option<String> { &self.modification }
    fn get_owner(&self) -> &Option<String> { &self.owner }
}
impl FileInfoTrait for VmDiskFileInfo {
    fn get_path(&self) -> &str { &self.path }
    fn get_friendly_name(&self) -> &Option<String> { &self.friendly_name }
    fn get_file_size(&self) -> Option<i64> { self.file_size }
    fn get_modification(&self) -> &Option<String> { &self.modification }
    fn get_owner(&self) -> &Option<String> { &self.owner }
}
impl FileInfoTrait for VmLogFileInfo {
    fn get_path(&self) -> &str { &self.path }
    fn get_friendly_name(&self) -> &Option<String> { &self.friendly_name }
    fn get_file_size(&self) -> Option<i64> { self.file_size }
    fn get_modification(&self) -> &Option<String> { &self.modification }
    fn get_owner(&self) -> &Option<String> { &self.owner }
}
impl FileInfoTrait for VmNvramFileInfo {
    fn get_path(&self) -> &str { &self.path }
    fn get_friendly_name(&self) -> &Option<String> { &self.friendly_name }
    fn get_file_size(&self) -> Option<i64> { self.file_size }
    fn get_modification(&self) -> &Option<String> { &self.modification }
    fn get_owner(&self) -> &Option<String> { &self.owner }
}
impl FileInfoTrait for VmSnapshotFileInfo {
    fn get_path(&self) -> &str { &self.path }
    fn get_friendly_name(&self) -> &Option<String> { &self.friendly_name }
    fn get_file_size(&self) -> Option<i64> { self.file_size }
    fn get_modification(&self) -> &Option<String> { &self.modification }
    fn get_owner(&self) -> &Option<String> { &self.owner }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn FileInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::FileInfo => Some(from.as_any_ref().downcast_ref::<FileInfo>()?),
            StructType::FloppyImageFileInfo => Some(from.as_any_ref().downcast_ref::<FloppyImageFileInfo>()?),
            StructType::FolderFileInfo => Some(from.as_any_ref().downcast_ref::<FolderFileInfo>()?),
            StructType::IsoImageFileInfo => Some(from.as_any_ref().downcast_ref::<IsoImageFileInfo>()?),
            StructType::VmConfigFileInfo => Some(from.as_any_ref().downcast_ref::<VmConfigFileInfo>()?),
            StructType::TemplateConfigFileInfo => Some(from.as_any_ref().downcast_ref::<TemplateConfigFileInfo>()?),
            StructType::VmDiskFileInfo => Some(from.as_any_ref().downcast_ref::<VmDiskFileInfo>()?),
            StructType::VmLogFileInfo => Some(from.as_any_ref().downcast_ref::<VmLogFileInfo>()?),
            StructType::VmNvramFileInfo => Some(from.as_any_ref().downcast_ref::<VmNvramFileInfo>()?),
            StructType::VmSnapshotFileInfo => Some(from.as_any_ref().downcast_ref::<VmSnapshotFileInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::FileInfo => Ok(from.as_any_box().downcast::<FileInfo>()?),
            StructType::FloppyImageFileInfo => Ok(from.as_any_box().downcast::<FloppyImageFileInfo>()?),
            StructType::FolderFileInfo => Ok(from.as_any_box().downcast::<FolderFileInfo>()?),
            StructType::IsoImageFileInfo => Ok(from.as_any_box().downcast::<IsoImageFileInfo>()?),
            StructType::VmConfigFileInfo => Ok(from.as_any_box().downcast::<VmConfigFileInfo>()?),
            StructType::TemplateConfigFileInfo => Ok(from.as_any_box().downcast::<TemplateConfigFileInfo>()?),
            StructType::VmDiskFileInfo => Ok(from.as_any_box().downcast::<VmDiskFileInfo>()?),
            StructType::VmLogFileInfo => Ok(from.as_any_box().downcast::<VmLogFileInfo>()?),
            StructType::VmNvramFileInfo => Ok(from.as_any_box().downcast::<VmNvramFileInfo>()?),
            StructType::VmSnapshotFileInfo => Ok(from.as_any_box().downcast::<VmSnapshotFileInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type describes a virtual machine configuration file.
pub trait VmConfigFileInfoTrait : super::traits::FileInfoTrait {
    fn get_config_version(&self) -> Option<i32>;
    /// The encryption information of the virtual machine
    /// configuration file.
    /// 
    /// If encryption was selected in VmConfigFileQueryFlags then this
    /// field is always set. Inspect the VmConfigEncryptionInfo to
    /// determine if the virtual machine configuration file is encrypted.
    fn get_encryption(&self) -> &Option<VmConfigFileEncryptionInfo>;
}
impl<'s> serde::Serialize for dyn VmConfigFileInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VmConfigFileInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VmConfigFileInfoVisitor)
            }
        }

struct VmConfigFileInfoVisitor;

impl<'de> de::Visitor<'de> for VmConfigFileInfoVisitor {
    type Value = Box<dyn VmConfigFileInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VmConfigFileInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VmConfigFileInfoTrait for VmConfigFileInfo {
    fn get_config_version(&self) -> Option<i32> { self.config_version }
    fn get_encryption(&self) -> &Option<VmConfigFileEncryptionInfo> { &self.encryption }
}
impl VmConfigFileInfoTrait for TemplateConfigFileInfo {
    fn get_config_version(&self) -> Option<i32> { self.config_version }
    fn get_encryption(&self) -> &Option<VmConfigFileEncryptionInfo> { &self.encryption }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VmConfigFileInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmConfigFileInfo => Some(from.as_any_ref().downcast_ref::<VmConfigFileInfo>()?),
            StructType::TemplateConfigFileInfo => Some(from.as_any_ref().downcast_ref::<TemplateConfigFileInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmConfigFileInfo => Ok(from.as_any_box().downcast::<VmConfigFileInfo>()?),
            StructType::TemplateConfigFileInfo => Ok(from.as_any_box().downcast::<TemplateConfigFileInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The data object type that describes the base query specification.
/// 
/// Contains query
/// filters and details that apply to every file. Querying only file details generally
/// does not require opening files and so is an efficient query. Derived types add
/// query parameters specific to the type of file.
pub trait FileQueryTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn FileQueryTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn FileQueryTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(FileQueryVisitor)
            }
        }

struct FileQueryVisitor;

impl<'de> de::Visitor<'de> for FileQueryVisitor {
    type Value = Box<dyn FileQueryTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid FileQueryTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl FileQueryTrait for FileQuery {
}
impl FileQueryTrait for FloppyImageFileQuery {
}
impl FileQueryTrait for FolderFileQuery {
}
impl FileQueryTrait for IsoImageFileQuery {
}
impl FileQueryTrait for VmConfigFileQuery {
}
impl FileQueryTrait for TemplateConfigFileQuery {
}
impl FileQueryTrait for VmDiskFileQuery {
}
impl FileQueryTrait for VmLogFileQuery {
}
impl FileQueryTrait for VmNvramFileQuery {
}
impl FileQueryTrait for VmSnapshotFileQuery {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn FileQueryTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::FileQuery => Some(from.as_any_ref().downcast_ref::<FileQuery>()?),
            StructType::FloppyImageFileQuery => Some(from.as_any_ref().downcast_ref::<FloppyImageFileQuery>()?),
            StructType::FolderFileQuery => Some(from.as_any_ref().downcast_ref::<FolderFileQuery>()?),
            StructType::IsoImageFileQuery => Some(from.as_any_ref().downcast_ref::<IsoImageFileQuery>()?),
            StructType::VmConfigFileQuery => Some(from.as_any_ref().downcast_ref::<VmConfigFileQuery>()?),
            StructType::TemplateConfigFileQuery => Some(from.as_any_ref().downcast_ref::<TemplateConfigFileQuery>()?),
            StructType::VmDiskFileQuery => Some(from.as_any_ref().downcast_ref::<VmDiskFileQuery>()?),
            StructType::VmLogFileQuery => Some(from.as_any_ref().downcast_ref::<VmLogFileQuery>()?),
            StructType::VmNvramFileQuery => Some(from.as_any_ref().downcast_ref::<VmNvramFileQuery>()?),
            StructType::VmSnapshotFileQuery => Some(from.as_any_ref().downcast_ref::<VmSnapshotFileQuery>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::FileQuery => Ok(from.as_any_box().downcast::<FileQuery>()?),
            StructType::FloppyImageFileQuery => Ok(from.as_any_box().downcast::<FloppyImageFileQuery>()?),
            StructType::FolderFileQuery => Ok(from.as_any_box().downcast::<FolderFileQuery>()?),
            StructType::IsoImageFileQuery => Ok(from.as_any_box().downcast::<IsoImageFileQuery>()?),
            StructType::VmConfigFileQuery => Ok(from.as_any_box().downcast::<VmConfigFileQuery>()?),
            StructType::TemplateConfigFileQuery => Ok(from.as_any_box().downcast::<TemplateConfigFileQuery>()?),
            StructType::VmDiskFileQuery => Ok(from.as_any_box().downcast::<VmDiskFileQuery>()?),
            StructType::VmLogFileQuery => Ok(from.as_any_box().downcast::<VmLogFileQuery>()?),
            StructType::VmNvramFileQuery => Ok(from.as_any_box().downcast::<VmNvramFileQuery>()?),
            StructType::VmSnapshotFileQuery => Ok(from.as_any_box().downcast::<VmSnapshotFileQuery>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type describes query specification for the virtual machine
/// configuration file.
pub trait VmConfigFileQueryTrait : super::traits::FileQueryTrait {
    /// The filter specification for the virtual machine configuration file query.
    fn get_filter(&self) -> &Option<VmConfigFileQueryFilter>;
    /// The details specification for the virtual machine configuration file query.
    fn get_details(&self) -> &Option<VmConfigFileQueryFlags>;
}
impl<'s> serde::Serialize for dyn VmConfigFileQueryTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VmConfigFileQueryTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VmConfigFileQueryVisitor)
            }
        }

struct VmConfigFileQueryVisitor;

impl<'de> de::Visitor<'de> for VmConfigFileQueryVisitor {
    type Value = Box<dyn VmConfigFileQueryTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VmConfigFileQueryTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VmConfigFileQueryTrait for VmConfigFileQuery {
    fn get_filter(&self) -> &Option<VmConfigFileQueryFilter> { &self.filter }
    fn get_details(&self) -> &Option<VmConfigFileQueryFlags> { &self.details }
}
impl VmConfigFileQueryTrait for TemplateConfigFileQuery {
    fn get_filter(&self) -> &Option<VmConfigFileQueryFilter> { &self.filter }
    fn get_details(&self) -> &Option<VmConfigFileQueryFlags> { &self.details }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VmConfigFileQueryTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmConfigFileQuery => Some(from.as_any_ref().downcast_ref::<VmConfigFileQuery>()?),
            StructType::TemplateConfigFileQuery => Some(from.as_any_ref().downcast_ref::<TemplateConfigFileQuery>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmConfigFileQuery => Ok(from.as_any_box().downcast::<VmConfigFileQuery>()?),
            StructType::TemplateConfigFileQuery => Ok(from.as_any_box().downcast::<TemplateConfigFileQuery>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type defines a device on the host.
pub trait HostDeviceTrait : super::traits::DataObjectTrait {
    /// The name of the device on the host.
    /// 
    /// For example,
    /// /dev/cdrom or \\\\serverX\\device\_name.
    fn get_device_name(&self) -> &str;
    /// Device type when available:
    /// floppy, mouse, cdrom, disk, scsi device, or adapter.
    fn get_device_type(&self) -> &str;
}
impl<'s> serde::Serialize for dyn HostDeviceTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostDeviceTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostDeviceVisitor)
            }
        }

struct HostDeviceVisitor;

impl<'de> de::Visitor<'de> for HostDeviceVisitor {
    type Value = Box<dyn HostDeviceTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostDeviceTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostDeviceTrait for HostDevice {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_device_type(&self) -> &str { &self.device_type }
}
impl HostDeviceTrait for ScsiLun {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_device_type(&self) -> &str { &self.device_type }
}
impl HostDeviceTrait for HostScsiDisk {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_device_type(&self) -> &str { &self.device_type }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostDeviceTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostDevice => Some(from.as_any_ref().downcast_ref::<HostDevice>()?),
            StructType::ScsiLun => Some(from.as_any_ref().downcast_ref::<ScsiLun>()?),
            StructType::HostScsiDisk => Some(from.as_any_ref().downcast_ref::<HostScsiDisk>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostDevice => Ok(from.as_any_box().downcast::<HostDevice>()?),
            StructType::ScsiLun => Ok(from.as_any_box().downcast::<ScsiLun>()?),
            StructType::HostScsiDisk => Ok(from.as_any_box().downcast::<HostScsiDisk>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *ScsiLun* data object describes a SCSI logical unit.
/// 
/// A SCSI logical unit is a host device that an ESX Server or virtual machine
/// can use for I/O operations.
/// 
/// An ESX Server creates SCSI logical unit objects to represent
/// devices in the host configuration. (See the definition of
/// *ScsiLunType_enum* for a list of the supported device types.)
/// The vSphere API uses one of two object types to represent a SCSI
/// logical unit, depending on the device type.
/// - Disks containing file system volumes or parts of volumes for hosts
///   or raw disks for virtual machines. To represent disks, the ESX Server
///   creates a *HostScsiDisk* object, which inherits properties from
///   the *ScsiLun* base class.
/// - Other SCSI devices, for example SCSI passthrough devices
///   for virtual machines. To represent one of these devices,
///   the ESX Server creates a *ScsiLun* object.
///   
/// When the Server creates a *HostScsiDisk* or *ScsiLun* object,
/// it specifies a valid device name and type:
/// - *HostDevice.deviceName* - A string representing the name of the device
///   that is meaningful to the host. The following are some examples of
///   device names.  
///   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>/dev/cdrom</code>  
///   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>/vmkdev/vmhba0:0:1:0</code>  
///   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>PhysicalDrive0</code>
/// - *HostDevice.deviceType* - A string describing the type of device.
///   The following are some examples of device types.  
///   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>scsi-cdrom</code>  
///   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>scsi-tape</code>  
///   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>scsi-disk</code>  
///   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>scsi-processor</code>  
///   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>scsi-unknown</code>
pub trait ScsiLunTrait : super::traits::HostDeviceTrait {
    /// Linkable identifier
    fn get_key(&self) -> &Option<String>;
    /// Universally unique identifier for the LUN used to identify ScsiLun across
    /// multiple servers.
    /// 
    /// This identifier can be used to identify analogous objects in other views
    /// such as *HostMultipathInfoLogicalUnit* and *HostScsiTopologyLun*.
    /// 
    /// See also *HostMultipathInfoLogicalUnit*, *HostScsiTopologyLun*.
    fn get_uuid(&self) -> &str;
    /// List of descriptors that can be used to identify the LUN object.
    /// 
    /// The
    /// uuid will also appear as a descriptor.
    /// 
    /// The id field in the descriptor is a string that can be used to correlate
    /// the ScsiLun across multiple servers. A ScsiLun may have multiple
    /// descriptors. The choice and order of these descriptors may be different
    /// on different servers.
    /// 
    /// Not all descriptors are suitable for correlation. Some descriptors are
    /// only sufficient to identify the ScsiLun within a single host. Each
    /// descriptor contains a quality property that indicates whether or not
    /// the descriptor is suitable for correlation.
    fn get_descriptor(&self) -> &Option<Vec<ScsiLunDescriptor>>;
    /// Canonical name of the SCSI logical unit.
    /// 
    /// Disk partition or extent identifiers refer to this name when
    /// referring to a disk. Use this property to correlate a partition
    /// or extent to a specific SCSI disk.
    /// 
    /// See also *HostScsiDiskPartition.diskName*.
    fn get_canonical_name(&self) -> &Option<String>;
    /// User configurable display name of the SCSI logical unit.
    /// 
    /// A default
    /// display name will be used if available. If the display name is not
    /// supported, it will be unset. The display name does not have to be
    /// unique but it is recommended that it be unique.
    fn get_display_name(&self) -> &Option<String>;
    /// The type of SCSI device.
    /// 
    /// Must be one of the values of
    /// *ScsiLunType_enum*.
    fn get_lun_type(&self) -> &str;
    /// The vendor of the SCSI device.
    fn get_vendor(&self) -> &Option<String>;
    /// The model number of the SCSI device.
    fn get_model(&self) -> &Option<String>;
    /// The revision of the SCSI device.
    fn get_revision(&self) -> &Option<String>;
    /// The SCSI level of the SCSI device.
    fn get_scsi_level(&self) -> Option<i32>;
    /// The serial number of the SCSI device.
    /// 
    /// For a device that is SCSI-3 compliant, this property is derived
    /// from page 80h of the Vital Product Data (VPD), as defined by the
    /// SCSI-3 Primary Commands (SPC-3) spec. Not all SCSI-3 compliant
    /// devices provide this information. For devices that are not
    /// SCSI-3 compliant, this property is not defined.
    fn get_serial_number(&self) -> &Option<String>;
    /// The durable name of the SCSI device.
    /// 
    /// For a SCSI-3 compliant device this property is derived from the
    /// payloads of pages 80h and 83h of the Vital Product Data (VPD) as
    /// defined by the T10 and SMI standards. For devices that do not provide
    /// this information, this property is not defined.
    fn get_durable_name(&self) -> &Option<ScsiLunDurableName>;
    /// Alternate durable names.
    /// 
    /// Records all available durable names derived from page 80h of the Vital
    /// Product Data (VPD) and the Identification Vital Product Data (VPD) page
    /// 83h as defined by the SCSI-3 Primary Commands. For devices that are not
    /// SCSI-3 compliant this property is not defined.
    fn get_alternate_name(&self) -> &Option<Vec<ScsiLunDurableName>>;
    /// Standard Inquiry payload.
    /// 
    /// For a SCSI-3 compliant device this property is derived from the
    /// standard inquiry data. For devices that are not SCSI-3 compliant this
    /// property is not defined.
    fn get_standard_inquiry(&self) -> &Option<Vec<i8>>;
    /// The queue depth of SCSI device.
    fn get_queue_depth(&self) -> Option<i32>;
    /// The operational states of the LUN.
    /// 
    /// When more than one item is present in the array, the first state
    /// should be considered the primary state. For example, a LUN may
    /// be "ok" and "degraded" indicating I/O is still possible to the LUN, but
    /// it is operating in a degraded mode.
    /// 
    /// See also *ScsiLunState_enum*.
    fn get_operational_state(&self) -> &Vec<String>;
    /// Capabilities of SCSI device.
    fn get_capabilities(&self) -> &Option<ScsiLunCapabilities>;
    /// vStorage hardware acceleration support status.
    /// 
    /// This property
    /// represents storage acceleration provided by the SCSI logical unit.
    /// See *ScsiLunVStorageSupportStatus_enum* for valid values.
    /// 
    /// If a storage device supports hardware acceleration,
    /// the ESX host can offload specific virtual machine management
    /// operations to the storage device. With hardware assistance,
    /// the host performs storage operations faster and consumes
    /// less CPU, memory, and storage fabric bandwidth.
    /// 
    /// For vSphere 4.0 or earlier hosts, this value will be unset.
    fn get_v_storage_support(&self) -> &Option<String>;
    /// Indicates that this SCSI LUN is protocol endpoint.
    /// 
    /// This
    /// property will be populated if and only if host supports
    /// VirtualVolume based Datastore. Check the host capability
    /// *HostCapability.virtualVolumeDatastoreSupported*.
    /// See *HostProtocolEndpoint*.
    fn get_protocol_endpoint(&self) -> Option<bool>;
    /// Indicates the state of a perennially reserved flag for a LUN.
    /// 
    /// If
    /// set for Raw Device Mapped (RDM) LUNs, the host startup or LUN rescan
    /// take comparatively shorter duration than when it is unset.
    fn get_perennially_reserved(&self) -> Option<bool>;
    /// Indicates if LUN has the prequisite properties to enable Clustered Vmdk
    /// feature once formatted into VMFS Datastore.
    fn get_clustered_vmdk_supported(&self) -> Option<bool>;
    /// Indicates the current device protocol.
    /// 
    /// Application protocol for a device which is set based on input
    /// from vmkctl storage control plane. Must be one of the values of
    /// *DeviceProtocol_enum*.
    /// 
    /// ***Since:*** vSphere API Release 8.0.1.0
    fn get_application_protocol(&self) -> &Option<String>;
    /// Indicates whether namespace is dispersed.
    /// 
    /// Set to true when the namespace of LUN is dispersed.
    /// 
    /// ***Since:*** vSphere API Release 8.0.1.0
    fn get_dispersed_ns(&self) -> Option<bool>;
}
impl<'s> serde::Serialize for dyn ScsiLunTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ScsiLunTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ScsiLunVisitor)
            }
        }

struct ScsiLunVisitor;

impl<'de> de::Visitor<'de> for ScsiLunVisitor {
    type Value = Box<dyn ScsiLunTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ScsiLunTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ScsiLunTrait for ScsiLun {
    fn get_key(&self) -> &Option<String> { &self.key }
    fn get_uuid(&self) -> &str { &self.uuid }
    fn get_descriptor(&self) -> &Option<Vec<ScsiLunDescriptor>> { &self.descriptor }
    fn get_canonical_name(&self) -> &Option<String> { &self.canonical_name }
    fn get_display_name(&self) -> &Option<String> { &self.display_name }
    fn get_lun_type(&self) -> &str { &self.lun_type }
    fn get_vendor(&self) -> &Option<String> { &self.vendor }
    fn get_model(&self) -> &Option<String> { &self.model }
    fn get_revision(&self) -> &Option<String> { &self.revision }
    fn get_scsi_level(&self) -> Option<i32> { self.scsi_level }
    fn get_serial_number(&self) -> &Option<String> { &self.serial_number }
    fn get_durable_name(&self) -> &Option<ScsiLunDurableName> { &self.durable_name }
    fn get_alternate_name(&self) -> &Option<Vec<ScsiLunDurableName>> { &self.alternate_name }
    fn get_standard_inquiry(&self) -> &Option<Vec<i8>> { &self.standard_inquiry }
    fn get_queue_depth(&self) -> Option<i32> { self.queue_depth }
    fn get_operational_state(&self) -> &Vec<String> { &self.operational_state }
    fn get_capabilities(&self) -> &Option<ScsiLunCapabilities> { &self.capabilities }
    fn get_v_storage_support(&self) -> &Option<String> { &self.v_storage_support }
    fn get_protocol_endpoint(&self) -> Option<bool> { self.protocol_endpoint }
    fn get_perennially_reserved(&self) -> Option<bool> { self.perennially_reserved }
    fn get_clustered_vmdk_supported(&self) -> Option<bool> { self.clustered_vmdk_supported }
    fn get_application_protocol(&self) -> &Option<String> { &self.application_protocol }
    fn get_dispersed_ns(&self) -> Option<bool> { self.dispersed_ns }
}
impl ScsiLunTrait for HostScsiDisk {
    fn get_key(&self) -> &Option<String> { &self.key }
    fn get_uuid(&self) -> &str { &self.uuid }
    fn get_descriptor(&self) -> &Option<Vec<ScsiLunDescriptor>> { &self.descriptor }
    fn get_canonical_name(&self) -> &Option<String> { &self.canonical_name }
    fn get_display_name(&self) -> &Option<String> { &self.display_name }
    fn get_lun_type(&self) -> &str { &self.lun_type }
    fn get_vendor(&self) -> &Option<String> { &self.vendor }
    fn get_model(&self) -> &Option<String> { &self.model }
    fn get_revision(&self) -> &Option<String> { &self.revision }
    fn get_scsi_level(&self) -> Option<i32> { self.scsi_level }
    fn get_serial_number(&self) -> &Option<String> { &self.serial_number }
    fn get_durable_name(&self) -> &Option<ScsiLunDurableName> { &self.durable_name }
    fn get_alternate_name(&self) -> &Option<Vec<ScsiLunDurableName>> { &self.alternate_name }
    fn get_standard_inquiry(&self) -> &Option<Vec<i8>> { &self.standard_inquiry }
    fn get_queue_depth(&self) -> Option<i32> { self.queue_depth }
    fn get_operational_state(&self) -> &Vec<String> { &self.operational_state }
    fn get_capabilities(&self) -> &Option<ScsiLunCapabilities> { &self.capabilities }
    fn get_v_storage_support(&self) -> &Option<String> { &self.v_storage_support }
    fn get_protocol_endpoint(&self) -> Option<bool> { self.protocol_endpoint }
    fn get_perennially_reserved(&self) -> Option<bool> { self.perennially_reserved }
    fn get_clustered_vmdk_supported(&self) -> Option<bool> { self.clustered_vmdk_supported }
    fn get_application_protocol(&self) -> &Option<String> { &self.application_protocol }
    fn get_dispersed_ns(&self) -> Option<bool> { self.dispersed_ns }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ScsiLunTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ScsiLun => Some(from.as_any_ref().downcast_ref::<ScsiLun>()?),
            StructType::HostScsiDisk => Some(from.as_any_ref().downcast_ref::<HostScsiDisk>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ScsiLun => Ok(from.as_any_box().downcast::<ScsiLun>()?),
            StructType::HostScsiDisk => Ok(from.as_any_box().downcast::<HostScsiDisk>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type describes the digest information
pub trait HostDigestInfoTrait : super::traits::DataObjectTrait {
    /// Method in which the digest value is calculated.
    /// 
    /// The set of possible
    /// values is described in *HostDigestInfoDigestMethodType_enum*.
    fn get_digest_method(&self) -> &str;
    /// The variable length byte array containing the digest value calculated by
    /// the specified digestMethod.
    fn get_digest_value(&self) -> &Vec<i8>;
    /// The name of the object from which this digest value is calcaulated.
    fn get_object_name(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn HostDigestInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostDigestInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostDigestInfoVisitor)
            }
        }

struct HostDigestInfoVisitor;

impl<'de> de::Visitor<'de> for HostDigestInfoVisitor {
    type Value = Box<dyn HostDigestInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostDigestInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostDigestInfoTrait for HostDigestInfo {
    fn get_digest_method(&self) -> &str { &self.digest_method }
    fn get_digest_value(&self) -> &Vec<i8> { &self.digest_value }
    fn get_object_name(&self) -> &Option<String> { &self.object_name }
}
impl HostDigestInfoTrait for HostTpmDigestInfo {
    fn get_digest_method(&self) -> &str { &self.digest_method }
    fn get_digest_value(&self) -> &Vec<i8> { &self.digest_value }
    fn get_object_name(&self) -> &Option<String> { &self.object_name }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostDigestInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostDigestInfo => Some(from.as_any_ref().downcast_ref::<HostDigestInfo>()?),
            StructType::HostTpmDigestInfo => Some(from.as_any_ref().downcast_ref::<HostTpmDigestInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostDigestInfo => Ok(from.as_any_box().downcast::<HostDigestInfo>()?),
            StructType::HostTpmDigestInfo => Ok(from.as_any_box().downcast::<HostTpmDigestInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type describes the DNS configuration.
/// 
/// All IPv4 addresses, subnet addresses, and netmasks are specified using
/// dotted decimal notation. For example, "192.0.2.1".
/// IPv6 addresses are 128-bit addresses represented as
/// eight fields of up to four hexadecimal digits.
/// A colon separates each field (:). For example,
/// 2001:DB8:101::230:6eff:fe04:d9ff. The address can also consist of the
/// symbol '::' to represent multiple 16-bit groups of
/// contiguous 0's only once in an address as described in RFC 2373.
pub trait HostDnsConfigTrait : super::traits::DataObjectTrait {
    /// The flag to indicate whether or not DHCP (dynamic host control
    /// protocol) is used to determine DNS configuration automatically.
    fn get_dhcp(&self) -> bool;
    /// If DHCP is enabled, the DHCP DNS of the vmkernel nic will override
    /// the system's DNS.
    /// 
    /// This field applies to both IPv4 and IPv6 DNS settings
    /// if *ipv6VirtualNicDevice*
    /// is unset, otherwise it is applicable only for IPv4 setting.
    /// This field is ignored if DHCP is disabled by the
    /// *dhcp* property.
    fn get_virtual_nic_device(&self) -> &Option<String>;
    /// If DHCP is enabled, the IPv6 DHCP DNS of the vmkernel nic will override
    /// the system's IPv6 DNS.
    /// 
    /// This field is ignored if DHCP is disabled by the
    /// *dhcp* property.
    fn get_ipv_6_virtual_nic_device(&self) -> &Option<String>;
    /// The host name portion of DNS name.
    /// 
    /// For example, "esx01".
    /// 
    /// **Note**: When DHCP is not enabled, the property can be set
    /// explicitly. When DHCP is enabled, the property reflects the current
    /// DNS configuration, but cannot be set.
    /// The hostName can't have character '.' in it when set explicitly.
    fn get_host_name(&self) -> &str;
    /// The domain name portion of the DNS name.
    /// 
    /// For example, "vmware.com".
    /// 
    /// **Note**: When DHCP is not enabled, the property can be set
    /// explicitly. When DHCP is enabled, the property reflects the current
    /// DNS configuration, but cannot be set.
    fn get_domain_name(&self) -> &str;
    /// The IP addresses of the DNS servers, placed in order of preference.
    /// 
    /// **Note**: When DHCP is not enabled, the property can be set
    /// explicitly. When DHCP is enabled, the property reflects the current
    /// DNS configuration, but cannot be set.
    fn get_address(&self) -> &Option<Vec<String>>;
    /// The domain in which to search for hosts, placed in order of preference.
    /// 
    /// **Note**: When DHCP is not enabled, the property can be set
    /// explicitly. When DHCP is enabled, the property reflects the current
    /// DNS configuration, but cannot be set.
    fn get_search_domain(&self) -> &Option<Vec<String>>;
}
impl<'s> serde::Serialize for dyn HostDnsConfigTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostDnsConfigTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostDnsConfigVisitor)
            }
        }

struct HostDnsConfigVisitor;

impl<'de> de::Visitor<'de> for HostDnsConfigVisitor {
    type Value = Box<dyn HostDnsConfigTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostDnsConfigTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostDnsConfigTrait for HostDnsConfig {
    fn get_dhcp(&self) -> bool { self.dhcp }
    fn get_virtual_nic_device(&self) -> &Option<String> { &self.virtual_nic_device }
    fn get_ipv_6_virtual_nic_device(&self) -> &Option<String> { &self.ipv_6_virtual_nic_device }
    fn get_host_name(&self) -> &str { &self.host_name }
    fn get_domain_name(&self) -> &str { &self.domain_name }
    fn get_address(&self) -> &Option<Vec<String>> { &self.address }
    fn get_search_domain(&self) -> &Option<Vec<String>> { &self.search_domain }
}
impl HostDnsConfigTrait for HostDnsConfigSpec {
    fn get_dhcp(&self) -> bool { self.dhcp }
    fn get_virtual_nic_device(&self) -> &Option<String> { &self.virtual_nic_device }
    fn get_ipv_6_virtual_nic_device(&self) -> &Option<String> { &self.ipv_6_virtual_nic_device }
    fn get_host_name(&self) -> &str { &self.host_name }
    fn get_domain_name(&self) -> &str { &self.domain_name }
    fn get_address(&self) -> &Option<Vec<String>> { &self.address }
    fn get_search_domain(&self) -> &Option<Vec<String>> { &self.search_domain }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostDnsConfigTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostDnsConfig => Some(from.as_any_ref().downcast_ref::<HostDnsConfig>()?),
            StructType::HostDnsConfigSpec => Some(from.as_any_ref().downcast_ref::<HostDnsConfigSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostDnsConfig => Ok(from.as_any_box().downcast::<HostDnsConfig>()?),
            StructType::HostDnsConfigSpec => Ok(from.as_any_box().downcast::<HostDnsConfigSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Detailed information about a file system.
/// 
/// This is a base type for derived types
/// that have more specific details about specific filesystem types.
/// 
/// Typically a FileSystem is exposed as a datatore
/// 
/// See also *DatastoreInfo*, *HostVmfsVolume*, *HostNasVolume*, *HostVffsVolume*, *HostLocalFileSystemVolume*
/// 
/// However, a FileSystemVolume need not be exposed a datastore., *HostVfatVolume*.
pub trait HostFileSystemVolumeTrait : super::traits::DataObjectTrait {
    /// FileSystemType of this particular file system
    /// See *HostFileSystemVolumeFileSystemType_enum*
    fn get_type(&self) -> &str;
    /// Name of the file system volume.
    fn get_name(&self) -> &str;
    /// The capacity of the file system volume, in bytes.
    fn get_capacity(&self) -> i64;
}
impl<'s> serde::Serialize for dyn HostFileSystemVolumeTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostFileSystemVolumeTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostFileSystemVolumeVisitor)
            }
        }

struct HostFileSystemVolumeVisitor;

impl<'de> de::Visitor<'de> for HostFileSystemVolumeVisitor {
    type Value = Box<dyn HostFileSystemVolumeTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostFileSystemVolumeTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostFileSystemVolumeTrait for HostFileSystemVolume {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_name(&self) -> &str { &self.name }
    fn get_capacity(&self) -> i64 { self.capacity }
}
impl HostFileSystemVolumeTrait for HostLocalFileSystemVolume {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_name(&self) -> &str { &self.name }
    fn get_capacity(&self) -> i64 { self.capacity }
}
impl HostFileSystemVolumeTrait for HostNasVolume {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_name(&self) -> &str { &self.name }
    fn get_capacity(&self) -> i64 { self.capacity }
}
impl HostFileSystemVolumeTrait for HostPMemVolume {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_name(&self) -> &str { &self.name }
    fn get_capacity(&self) -> i64 { self.capacity }
}
impl HostFileSystemVolumeTrait for HostVfatVolume {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_name(&self) -> &str { &self.name }
    fn get_capacity(&self) -> i64 { self.capacity }
}
impl HostFileSystemVolumeTrait for HostVffsVolume {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_name(&self) -> &str { &self.name }
    fn get_capacity(&self) -> i64 { self.capacity }
}
impl HostFileSystemVolumeTrait for HostVmfsVolume {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_name(&self) -> &str { &self.name }
    fn get_capacity(&self) -> i64 { self.capacity }
}
impl HostFileSystemVolumeTrait for HostVvolVolume {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_name(&self) -> &str { &self.name }
    fn get_capacity(&self) -> i64 { self.capacity }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostFileSystemVolumeTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostFileSystemVolume => Some(from.as_any_ref().downcast_ref::<HostFileSystemVolume>()?),
            StructType::HostLocalFileSystemVolume => Some(from.as_any_ref().downcast_ref::<HostLocalFileSystemVolume>()?),
            StructType::HostNasVolume => Some(from.as_any_ref().downcast_ref::<HostNasVolume>()?),
            StructType::HostPMemVolume => Some(from.as_any_ref().downcast_ref::<HostPMemVolume>()?),
            StructType::HostVfatVolume => Some(from.as_any_ref().downcast_ref::<HostVfatVolume>()?),
            StructType::HostVffsVolume => Some(from.as_any_ref().downcast_ref::<HostVffsVolume>()?),
            StructType::HostVmfsVolume => Some(from.as_any_ref().downcast_ref::<HostVmfsVolume>()?),
            StructType::HostVvolVolume => Some(from.as_any_ref().downcast_ref::<HostVvolVolume>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostFileSystemVolume => Ok(from.as_any_box().downcast::<HostFileSystemVolume>()?),
            StructType::HostLocalFileSystemVolume => Ok(from.as_any_box().downcast::<HostLocalFileSystemVolume>()?),
            StructType::HostNasVolume => Ok(from.as_any_box().downcast::<HostNasVolume>()?),
            StructType::HostPMemVolume => Ok(from.as_any_box().downcast::<HostPMemVolume>()?),
            StructType::HostVfatVolume => Ok(from.as_any_box().downcast::<HostVfatVolume>()?),
            StructType::HostVffsVolume => Ok(from.as_any_box().downcast::<HostVffsVolume>()?),
            StructType::HostVmfsVolume => Ok(from.as_any_box().downcast::<HostVmfsVolume>()?),
            StructType::HostVvolVolume => Ok(from.as_any_box().downcast::<HostVvolVolume>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Data object describing the operational status of a physical
/// element.
pub trait HostHardwareElementInfoTrait : super::traits::DataObjectTrait {
    /// The name of the physical element
    fn get_name(&self) -> &str;
    /// The operational status of the physical element.
    /// 
    /// The status is one of
    /// the values specified in HostHardwareElementStatus.
    /// 
    /// See also *HostHardwareElementStatus_enum*.
    fn get_status(&self) -> &Box<dyn super::traits::ElementDescriptionTrait>;
}
impl<'s> serde::Serialize for dyn HostHardwareElementInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostHardwareElementInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostHardwareElementInfoVisitor)
            }
        }

struct HostHardwareElementInfoVisitor;

impl<'de> de::Visitor<'de> for HostHardwareElementInfoVisitor {
    type Value = Box<dyn HostHardwareElementInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostHardwareElementInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostHardwareElementInfoTrait for HostHardwareElementInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_status(&self) -> &Box<dyn super::traits::ElementDescriptionTrait> { &self.status }
}
impl HostHardwareElementInfoTrait for DpuStatusInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_status(&self) -> &Box<dyn super::traits::ElementDescriptionTrait> { &self.status }
}
impl HostHardwareElementInfoTrait for HostStorageElementInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_status(&self) -> &Box<dyn super::traits::ElementDescriptionTrait> { &self.status }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostHardwareElementInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostHardwareElementInfo => Some(from.as_any_ref().downcast_ref::<HostHardwareElementInfo>()?),
            StructType::DpuStatusInfo => Some(from.as_any_ref().downcast_ref::<DpuStatusInfo>()?),
            StructType::HostStorageElementInfo => Some(from.as_any_ref().downcast_ref::<HostStorageElementInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostHardwareElementInfo => Ok(from.as_any_box().downcast::<HostHardwareElementInfo>()?),
            StructType::DpuStatusInfo => Ok(from.as_any_box().downcast::<DpuStatusInfo>()?),
            StructType::HostStorageElementInfo => Ok(from.as_any_box().downcast::<HostStorageElementInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// A data object which specifies the parameters needed
/// to create a software host bus adapter of a specific kind.
/// 
/// ***Since:*** vSphere API Release 7.0.3.0
pub trait HostHbaCreateSpecTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn HostHbaCreateSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostHbaCreateSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostHbaCreateSpecVisitor)
            }
        }

struct HostHbaCreateSpecVisitor;

impl<'de> de::Visitor<'de> for HostHbaCreateSpecVisitor {
    type Value = Box<dyn HostHbaCreateSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostHbaCreateSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostHbaCreateSpecTrait for HostHbaCreateSpec {
}
impl HostHbaCreateSpecTrait for HostTcpHbaCreateSpec {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostHbaCreateSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostHbaCreateSpec => Some(from.as_any_ref().downcast_ref::<HostHbaCreateSpec>()?),
            StructType::HostTcpHbaCreateSpec => Some(from.as_any_ref().downcast_ref::<HostTcpHbaCreateSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostHbaCreateSpec => Ok(from.as_any_box().downcast::<HostHbaCreateSpec>()?),
            StructType::HostTcpHbaCreateSpec => Ok(from.as_any_box().downcast::<HostTcpHbaCreateSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type describes the bus adapter for
/// the host.
/// 
/// A host bus adapter (HBA) is a hardware
/// or software adapter that connects the host to storage devices.
pub trait HostHostBusAdapterTrait : super::traits::DataObjectTrait {
    /// The linkable identifier.
    fn get_key(&self) -> &Option<String>;
    /// The device name of host bus adapter.
    fn get_device(&self) -> &str;
    /// The host bus number.
    fn get_bus(&self) -> i32;
    /// The operational status of the adapter.
    /// 
    /// Valid values include "online",
    /// "offline", "unbound", and "unknown".
    fn get_status(&self) -> &str;
    /// The model name of the host bus adapter.
    fn get_model(&self) -> &str;
    /// The name of the driver.
    fn get_driver(&self) -> &Option<String>;
    /// The Peripheral Connect Interface (PCI) ID of the device
    /// representing the host bus adapter.
    fn get_pci(&self) -> &Option<String>;
    /// The type of protocol supported by the host bus adapter.
    /// 
    /// The list of supported values is described in
    /// *HostStorageProtocol_enum*.
    /// When unset, a default value of "scsi" is assumed.
    fn get_storage_protocol(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn HostHostBusAdapterTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostHostBusAdapterTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostHostBusAdapterVisitor)
            }
        }

struct HostHostBusAdapterVisitor;

impl<'de> de::Visitor<'de> for HostHostBusAdapterVisitor {
    type Value = Box<dyn HostHostBusAdapterTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostHostBusAdapterTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostHostBusAdapterTrait for HostHostBusAdapter {
    fn get_key(&self) -> &Option<String> { &self.key }
    fn get_device(&self) -> &str { &self.device }
    fn get_bus(&self) -> i32 { self.bus }
    fn get_status(&self) -> &str { &self.status }
    fn get_model(&self) -> &str { &self.model }
    fn get_driver(&self) -> &Option<String> { &self.driver }
    fn get_pci(&self) -> &Option<String> { &self.pci }
    fn get_storage_protocol(&self) -> &Option<String> { &self.storage_protocol }
}
impl HostHostBusAdapterTrait for HostBlockHba {
    fn get_key(&self) -> &Option<String> { &self.key }
    fn get_device(&self) -> &str { &self.device }
    fn get_bus(&self) -> i32 { self.bus }
    fn get_status(&self) -> &str { &self.status }
    fn get_model(&self) -> &str { &self.model }
    fn get_driver(&self) -> &Option<String> { &self.driver }
    fn get_pci(&self) -> &Option<String> { &self.pci }
    fn get_storage_protocol(&self) -> &Option<String> { &self.storage_protocol }
}
impl HostHostBusAdapterTrait for HostFibreChannelHba {
    fn get_key(&self) -> &Option<String> { &self.key }
    fn get_device(&self) -> &str { &self.device }
    fn get_bus(&self) -> i32 { self.bus }
    fn get_status(&self) -> &str { &self.status }
    fn get_model(&self) -> &str { &self.model }
    fn get_driver(&self) -> &Option<String> { &self.driver }
    fn get_pci(&self) -> &Option<String> { &self.pci }
    fn get_storage_protocol(&self) -> &Option<String> { &self.storage_protocol }
}
impl HostHostBusAdapterTrait for HostFibreChannelOverEthernetHba {
    fn get_key(&self) -> &Option<String> { &self.key }
    fn get_device(&self) -> &str { &self.device }
    fn get_bus(&self) -> i32 { self.bus }
    fn get_status(&self) -> &str { &self.status }
    fn get_model(&self) -> &str { &self.model }
    fn get_driver(&self) -> &Option<String> { &self.driver }
    fn get_pci(&self) -> &Option<String> { &self.pci }
    fn get_storage_protocol(&self) -> &Option<String> { &self.storage_protocol }
}
impl HostHostBusAdapterTrait for HostInternetScsiHba {
    fn get_key(&self) -> &Option<String> { &self.key }
    fn get_device(&self) -> &str { &self.device }
    fn get_bus(&self) -> i32 { self.bus }
    fn get_status(&self) -> &str { &self.status }
    fn get_model(&self) -> &str { &self.model }
    fn get_driver(&self) -> &Option<String> { &self.driver }
    fn get_pci(&self) -> &Option<String> { &self.pci }
    fn get_storage_protocol(&self) -> &Option<String> { &self.storage_protocol }
}
impl HostHostBusAdapterTrait for HostParallelScsiHba {
    fn get_key(&self) -> &Option<String> { &self.key }
    fn get_device(&self) -> &str { &self.device }
    fn get_bus(&self) -> i32 { self.bus }
    fn get_status(&self) -> &str { &self.status }
    fn get_model(&self) -> &str { &self.model }
    fn get_driver(&self) -> &Option<String> { &self.driver }
    fn get_pci(&self) -> &Option<String> { &self.pci }
    fn get_storage_protocol(&self) -> &Option<String> { &self.storage_protocol }
}
impl HostHostBusAdapterTrait for HostPcieHba {
    fn get_key(&self) -> &Option<String> { &self.key }
    fn get_device(&self) -> &str { &self.device }
    fn get_bus(&self) -> i32 { self.bus }
    fn get_status(&self) -> &str { &self.status }
    fn get_model(&self) -> &str { &self.model }
    fn get_driver(&self) -> &Option<String> { &self.driver }
    fn get_pci(&self) -> &Option<String> { &self.pci }
    fn get_storage_protocol(&self) -> &Option<String> { &self.storage_protocol }
}
impl HostHostBusAdapterTrait for HostRdmaHba {
    fn get_key(&self) -> &Option<String> { &self.key }
    fn get_device(&self) -> &str { &self.device }
    fn get_bus(&self) -> i32 { self.bus }
    fn get_status(&self) -> &str { &self.status }
    fn get_model(&self) -> &str { &self.model }
    fn get_driver(&self) -> &Option<String> { &self.driver }
    fn get_pci(&self) -> &Option<String> { &self.pci }
    fn get_storage_protocol(&self) -> &Option<String> { &self.storage_protocol }
}
impl HostHostBusAdapterTrait for HostSerialAttachedHba {
    fn get_key(&self) -> &Option<String> { &self.key }
    fn get_device(&self) -> &str { &self.device }
    fn get_bus(&self) -> i32 { self.bus }
    fn get_status(&self) -> &str { &self.status }
    fn get_model(&self) -> &str { &self.model }
    fn get_driver(&self) -> &Option<String> { &self.driver }
    fn get_pci(&self) -> &Option<String> { &self.pci }
    fn get_storage_protocol(&self) -> &Option<String> { &self.storage_protocol }
}
impl HostHostBusAdapterTrait for HostTcpHba {
    fn get_key(&self) -> &Option<String> { &self.key }
    fn get_device(&self) -> &str { &self.device }
    fn get_bus(&self) -> i32 { self.bus }
    fn get_status(&self) -> &str { &self.status }
    fn get_model(&self) -> &str { &self.model }
    fn get_driver(&self) -> &Option<String> { &self.driver }
    fn get_pci(&self) -> &Option<String> { &self.pci }
    fn get_storage_protocol(&self) -> &Option<String> { &self.storage_protocol }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostHostBusAdapterTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostHostBusAdapter => Some(from.as_any_ref().downcast_ref::<HostHostBusAdapter>()?),
            StructType::HostBlockHba => Some(from.as_any_ref().downcast_ref::<HostBlockHba>()?),
            StructType::HostFibreChannelHba => Some(from.as_any_ref().downcast_ref::<HostFibreChannelHba>()?),
            StructType::HostFibreChannelOverEthernetHba => Some(from.as_any_ref().downcast_ref::<HostFibreChannelOverEthernetHba>()?),
            StructType::HostInternetScsiHba => Some(from.as_any_ref().downcast_ref::<HostInternetScsiHba>()?),
            StructType::HostParallelScsiHba => Some(from.as_any_ref().downcast_ref::<HostParallelScsiHba>()?),
            StructType::HostPcieHba => Some(from.as_any_ref().downcast_ref::<HostPcieHba>()?),
            StructType::HostRdmaHba => Some(from.as_any_ref().downcast_ref::<HostRdmaHba>()?),
            StructType::HostSerialAttachedHba => Some(from.as_any_ref().downcast_ref::<HostSerialAttachedHba>()?),
            StructType::HostTcpHba => Some(from.as_any_ref().downcast_ref::<HostTcpHba>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostHostBusAdapter => Ok(from.as_any_box().downcast::<HostHostBusAdapter>()?),
            StructType::HostBlockHba => Ok(from.as_any_box().downcast::<HostBlockHba>()?),
            StructType::HostFibreChannelHba => Ok(from.as_any_box().downcast::<HostFibreChannelHba>()?),
            StructType::HostFibreChannelOverEthernetHba => Ok(from.as_any_box().downcast::<HostFibreChannelOverEthernetHba>()?),
            StructType::HostInternetScsiHba => Ok(from.as_any_box().downcast::<HostInternetScsiHba>()?),
            StructType::HostParallelScsiHba => Ok(from.as_any_box().downcast::<HostParallelScsiHba>()?),
            StructType::HostPcieHba => Ok(from.as_any_box().downcast::<HostPcieHba>()?),
            StructType::HostRdmaHba => Ok(from.as_any_box().downcast::<HostRdmaHba>()?),
            StructType::HostSerialAttachedHba => Ok(from.as_any_box().downcast::<HostSerialAttachedHba>()?),
            StructType::HostTcpHba => Ok(from.as_any_box().downcast::<HostTcpHba>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type describes the Fibre Channel host bus adapter.
pub trait HostFibreChannelHbaTrait : super::traits::HostHostBusAdapterTrait {
    /// The world wide port name for the adapter.
    fn get_port_world_wide_name(&self) -> i64;
    /// The world wide node name for the adapter.
    fn get_node_world_wide_name(&self) -> i64;
    /// The type of the fiber channel port.
    fn get_port_type(&self) -> &super::enums::FibreChannelPortTypeEnum;
    /// The current operating speed of the adapter in
    /// bits per second.
    fn get_speed(&self) -> i64;
}
impl<'s> serde::Serialize for dyn HostFibreChannelHbaTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostFibreChannelHbaTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostFibreChannelHbaVisitor)
            }
        }

struct HostFibreChannelHbaVisitor;

impl<'de> de::Visitor<'de> for HostFibreChannelHbaVisitor {
    type Value = Box<dyn HostFibreChannelHbaTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostFibreChannelHbaTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostFibreChannelHbaTrait for HostFibreChannelHba {
    fn get_port_world_wide_name(&self) -> i64 { self.port_world_wide_name }
    fn get_node_world_wide_name(&self) -> i64 { self.node_world_wide_name }
    fn get_port_type(&self) -> &super::enums::FibreChannelPortTypeEnum { &self.port_type }
    fn get_speed(&self) -> i64 { self.speed }
}
impl HostFibreChannelHbaTrait for HostFibreChannelOverEthernetHba {
    fn get_port_world_wide_name(&self) -> i64 { self.port_world_wide_name }
    fn get_node_world_wide_name(&self) -> i64 { self.node_world_wide_name }
    fn get_port_type(&self) -> &super::enums::FibreChannelPortTypeEnum { &self.port_type }
    fn get_speed(&self) -> i64 { self.speed }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostFibreChannelHbaTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostFibreChannelHba => Some(from.as_any_ref().downcast_ref::<HostFibreChannelHba>()?),
            StructType::HostFibreChannelOverEthernetHba => Some(from.as_any_ref().downcast_ref::<HostFibreChannelOverEthernetHba>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostFibreChannelHba => Ok(from.as_any_box().downcast::<HostFibreChannelHba>()?),
            StructType::HostFibreChannelOverEthernetHba => Ok(from.as_any_box().downcast::<HostFibreChannelOverEthernetHba>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// IP Route Configuration.
/// 
/// All IPv4 addresses, subnet addresses, and
/// netmasks are specified as strings using dotted decimal notation.
/// For example, "192.0.2.1".
/// IPv6 addresses are 128-bit addresses represented
/// as eight fields of up to four hexadecimal digits. A colon separates each
/// field (:). For example, 2001:DB8:101::230:6eff:fe04:d9ff. The address can
/// also consist of symbol '::' to represent multiple 16-bit groups of
/// contiguous 0's only once in an address as described in RFC 2373.
pub trait HostIpRouteConfigTrait : super::traits::DataObjectTrait {
    /// The default gateway address.
    fn get_default_gateway(&self) -> &Option<String>;
    /// The gateway device.
    /// 
    /// This applies to service console gateway only, it
    /// is ignored otherwise.
    fn get_gateway_device(&self) -> &Option<String>;
    /// The default ipv6 gateway address
    fn get_ip_v_6_default_gateway(&self) -> &Option<String>;
    /// The ipv6 gateway device.
    /// 
    /// This applies to service console gateway only, it
    fn get_ip_v_6_gateway_device(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn HostIpRouteConfigTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostIpRouteConfigTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostIpRouteConfigVisitor)
            }
        }

struct HostIpRouteConfigVisitor;

impl<'de> de::Visitor<'de> for HostIpRouteConfigVisitor {
    type Value = Box<dyn HostIpRouteConfigTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostIpRouteConfigTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostIpRouteConfigTrait for HostIpRouteConfig {
    fn get_default_gateway(&self) -> &Option<String> { &self.default_gateway }
    fn get_gateway_device(&self) -> &Option<String> { &self.gateway_device }
    fn get_ip_v_6_default_gateway(&self) -> &Option<String> { &self.ip_v_6_default_gateway }
    fn get_ip_v_6_gateway_device(&self) -> &Option<String> { &self.ip_v_6_gateway_device }
}
impl HostIpRouteConfigTrait for HostIpRouteConfigSpec {
    fn get_default_gateway(&self) -> &Option<String> { &self.default_gateway }
    fn get_gateway_device(&self) -> &Option<String> { &self.gateway_device }
    fn get_ip_v_6_default_gateway(&self) -> &Option<String> { &self.ip_v_6_default_gateway }
    fn get_ip_v_6_gateway_device(&self) -> &Option<String> { &self.ip_v_6_gateway_device }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostIpRouteConfigTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostIpRouteConfig => Some(from.as_any_ref().downcast_ref::<HostIpRouteConfig>()?),
            StructType::HostIpRouteConfigSpec => Some(from.as_any_ref().downcast_ref::<HostIpRouteConfigSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostIpRouteConfig => Ok(from.as_any_box().downcast::<HostIpRouteConfig>()?),
            StructType::HostIpRouteConfigSpec => Ok(from.as_any_box().downcast::<HostIpRouteConfigSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type contains common parameters
/// for local account creation.
/// 
/// The password and description properties
/// are not supported for group accounts on POSIX hosts.
pub trait HostAccountSpecTrait : super::traits::DataObjectTrait {
    /// The ID of the specified account.
    fn get_id(&self) -> &str;
    /// The password for a user or group.
    fn get_password(&self) -> &Option<String>;
    /// The description of the specified account.
    fn get_description(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn HostAccountSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostAccountSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostAccountSpecVisitor)
            }
        }

struct HostAccountSpecVisitor;

impl<'de> de::Visitor<'de> for HostAccountSpecVisitor {
    type Value = Box<dyn HostAccountSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostAccountSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostAccountSpecTrait for HostAccountSpec {
    fn get_id(&self) -> &str { &self.id }
    fn get_password(&self) -> &Option<String> { &self.password }
    fn get_description(&self) -> &Option<String> { &self.description }
}
impl HostAccountSpecTrait for HostPosixAccountSpec {
    fn get_id(&self) -> &str { &self.id }
    fn get_password(&self) -> &Option<String> { &self.password }
    fn get_description(&self) -> &Option<String> { &self.description }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostAccountSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostAccountSpec => Some(from.as_any_ref().downcast_ref::<HostAccountSpec>()?),
            StructType::HostPosixAccountSpec => Some(from.as_any_ref().downcast_ref::<HostPosixAccountSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostAccountSpec => Ok(from.as_any_box().downcast::<HostAccountSpec>()?),
            StructType::HostPosixAccountSpec => Ok(from.as_any_box().downcast::<HostPosixAccountSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *HostMultipathInfoLogicalUnitPolicy* data object
/// describes a path selection policy for a device.
/// 
/// This policy determines
/// how paths should be utilized when accessing a device.
pub trait HostMultipathInfoLogicalUnitPolicyTrait : super::traits::DataObjectTrait {
    /// String representing the path selection policy for a device.
    /// 
    /// Use one of the following
    /// strings:
    /// For NMP plugin
    /// - <code>VMW\_PSP\_FIXED</code> - Use a preferred path whenever possible.
    /// - <code>VMW\_PSP\_RR</code> - Load balance.
    /// - <code>VMW\_PSP\_MRU</code> - Use the most recently used path.
    ///   
    /// For HPP plugin
    /// - <code>FIXED</code> - Use a preferred path whenever possible.
    /// - <code>LB-RR</code> - Load Balance - round robin.
    /// - <code>LB-IOPS</code> - Load Balance - iops.
    /// - <code>LB-BYTES</code> - Load Balance - bytes.
    /// - <code>LB--Latency</code> - Load balance - least latency.
    ///   
    /// You can also use the
    /// *HostStorageSystem.QueryPathSelectionPolicyOptions* method
    /// to retrieve the set of valid strings.
    /// Use the key from the resulting structure
    /// *HostPathSelectionPolicyOption*.
    fn get_policy(&self) -> &str;
}
impl<'s> serde::Serialize for dyn HostMultipathInfoLogicalUnitPolicyTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostMultipathInfoLogicalUnitPolicyTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostMultipathInfoLogicalUnitPolicyVisitor)
            }
        }

struct HostMultipathInfoLogicalUnitPolicyVisitor;

impl<'de> de::Visitor<'de> for HostMultipathInfoLogicalUnitPolicyVisitor {
    type Value = Box<dyn HostMultipathInfoLogicalUnitPolicyTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostMultipathInfoLogicalUnitPolicyTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostMultipathInfoLogicalUnitPolicyTrait for HostMultipathInfoLogicalUnitPolicy {
    fn get_policy(&self) -> &str { &self.policy }
}
impl HostMultipathInfoLogicalUnitPolicyTrait for HostMultipathInfoFixedLogicalUnitPolicy {
    fn get_policy(&self) -> &str { &self.policy }
}
impl HostMultipathInfoLogicalUnitPolicyTrait for HostMultipathInfoHppLogicalUnitPolicy {
    fn get_policy(&self) -> &str { &self.policy }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostMultipathInfoLogicalUnitPolicyTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostMultipathInfoLogicalUnitPolicy => Some(from.as_any_ref().downcast_ref::<HostMultipathInfoLogicalUnitPolicy>()?),
            StructType::HostMultipathInfoFixedLogicalUnitPolicy => Some(from.as_any_ref().downcast_ref::<HostMultipathInfoFixedLogicalUnitPolicy>()?),
            StructType::HostMultipathInfoHppLogicalUnitPolicy => Some(from.as_any_ref().downcast_ref::<HostMultipathInfoHppLogicalUnitPolicy>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostMultipathInfoLogicalUnitPolicy => Ok(from.as_any_box().downcast::<HostMultipathInfoLogicalUnitPolicy>()?),
            StructType::HostMultipathInfoFixedLogicalUnitPolicy => Ok(from.as_any_box().downcast::<HostMultipathInfoFixedLogicalUnitPolicy>()?),
            StructType::HostMultipathInfoHppLogicalUnitPolicy => Ok(from.as_any_box().downcast::<HostMultipathInfoHppLogicalUnitPolicy>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Specifies the main parameters needed when connecting to
/// an NVMe over Fabrics controller or Discovery Service.
pub trait HostNvmeSpecTrait : super::traits::DataObjectTrait {
    /// The device name of the NVME over Fabrics host bus adapter.
    fn get_hba_name(&self) -> &str;
    /// Transport specific information necessary to connect to the controller.
    fn get_transport_parameters(&self) -> &Box<dyn super::traits::HostNvmeTransportParametersTrait>;
}
impl<'s> serde::Serialize for dyn HostNvmeSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostNvmeSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostNvmeSpecVisitor)
            }
        }

struct HostNvmeSpecVisitor;

impl<'de> de::Visitor<'de> for HostNvmeSpecVisitor {
    type Value = Box<dyn HostNvmeSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostNvmeSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostNvmeSpecTrait for HostNvmeSpec {
    fn get_hba_name(&self) -> &str { &self.hba_name }
    fn get_transport_parameters(&self) -> &Box<dyn super::traits::HostNvmeTransportParametersTrait> { &self.transport_parameters }
}
impl HostNvmeSpecTrait for HostNvmeConnectSpec {
    fn get_hba_name(&self) -> &str { &self.hba_name }
    fn get_transport_parameters(&self) -> &Box<dyn super::traits::HostNvmeTransportParametersTrait> { &self.transport_parameters }
}
impl HostNvmeSpecTrait for HostNvmeDiscoverSpec {
    fn get_hba_name(&self) -> &str { &self.hba_name }
    fn get_transport_parameters(&self) -> &Box<dyn super::traits::HostNvmeTransportParametersTrait> { &self.transport_parameters }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostNvmeSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostNvmeSpec => Some(from.as_any_ref().downcast_ref::<HostNvmeSpec>()?),
            StructType::HostNvmeConnectSpec => Some(from.as_any_ref().downcast_ref::<HostNvmeConnectSpec>()?),
            StructType::HostNvmeDiscoverSpec => Some(from.as_any_ref().downcast_ref::<HostNvmeDiscoverSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostNvmeSpec => Ok(from.as_any_box().downcast::<HostNvmeSpec>()?),
            StructType::HostNvmeConnectSpec => Ok(from.as_any_box().downcast::<HostNvmeConnectSpec>()?),
            StructType::HostNvmeDiscoverSpec => Ok(from.as_any_box().downcast::<HostNvmeDiscoverSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object represents the transport specific parameters
/// necessary to establish an NVM Express over Fabrics connection.
/// 
/// For some further information, see:
/// - "NVM Express over Fabrics 1.0", Section 1.5.7, "Connection"
pub trait HostNvmeTransportParametersTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn HostNvmeTransportParametersTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostNvmeTransportParametersTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostNvmeTransportParametersVisitor)
            }
        }

struct HostNvmeTransportParametersVisitor;

impl<'de> de::Visitor<'de> for HostNvmeTransportParametersVisitor {
    type Value = Box<dyn HostNvmeTransportParametersTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostNvmeTransportParametersTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostNvmeTransportParametersTrait for HostNvmeTransportParameters {
}
impl HostNvmeTransportParametersTrait for HostNvmeOpaqueTransportParameters {
}
impl HostNvmeTransportParametersTrait for HostNvmeOverFibreChannelParameters {
}
impl HostNvmeTransportParametersTrait for HostNvmeOverRdmaParameters {
}
impl HostNvmeTransportParametersTrait for HostNvmeOverTcpParameters {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostNvmeTransportParametersTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostNvmeTransportParameters => Some(from.as_any_ref().downcast_ref::<HostNvmeTransportParameters>()?),
            StructType::HostNvmeOpaqueTransportParameters => Some(from.as_any_ref().downcast_ref::<HostNvmeOpaqueTransportParameters>()?),
            StructType::HostNvmeOverFibreChannelParameters => Some(from.as_any_ref().downcast_ref::<HostNvmeOverFibreChannelParameters>()?),
            StructType::HostNvmeOverRdmaParameters => Some(from.as_any_ref().downcast_ref::<HostNvmeOverRdmaParameters>()?),
            StructType::HostNvmeOverTcpParameters => Some(from.as_any_ref().downcast_ref::<HostNvmeOverTcpParameters>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostNvmeTransportParameters => Ok(from.as_any_box().downcast::<HostNvmeTransportParameters>()?),
            StructType::HostNvmeOpaqueTransportParameters => Ok(from.as_any_box().downcast::<HostNvmeOpaqueTransportParameters>()?),
            StructType::HostNvmeOverFibreChannelParameters => Ok(from.as_any_box().downcast::<HostNvmeOverFibreChannelParameters>()?),
            StructType::HostNvmeOverRdmaParameters => Ok(from.as_any_box().downcast::<HostNvmeOverRdmaParameters>()?),
            StructType::HostNvmeOverTcpParameters => Ok(from.as_any_box().downcast::<HostNvmeOverTcpParameters>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object provides information about the state of PciPassthru
/// for all pci devices.
pub trait HostPciPassthruConfigTrait : super::traits::DataObjectTrait {
    /// The name ID of this PCI, composed of "bus:slot.function".
    fn get_id(&self) -> &str;
    /// Whether passThru has been configured for this device
    fn get_passthru_enabled(&self) -> bool;
    /// Whether the passThru config should take effect without rebooting ESX.
    /// 
    /// When unset, the behavior will be determined automatically
    /// based on *HostCapability.deviceRebindWithoutRebootSupported*.
    /// If the configuration can be applied immediately, it
    /// will be, otherwise the changes will take effect after reboot.
    fn get_apply_now(&self) -> Option<bool>;
    /// The hardware label of the this PCI device.
    /// 
    /// ***Since:*** vSphere API Release 7.0.2.0
    fn get_hardware_label(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn HostPciPassthruConfigTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostPciPassthruConfigTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostPciPassthruConfigVisitor)
            }
        }

struct HostPciPassthruConfigVisitor;

impl<'de> de::Visitor<'de> for HostPciPassthruConfigVisitor {
    type Value = Box<dyn HostPciPassthruConfigTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostPciPassthruConfigTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostPciPassthruConfigTrait for HostPciPassthruConfig {
    fn get_id(&self) -> &str { &self.id }
    fn get_passthru_enabled(&self) -> bool { self.passthru_enabled }
    fn get_apply_now(&self) -> Option<bool> { self.apply_now }
    fn get_hardware_label(&self) -> &Option<String> { &self.hardware_label }
}
impl HostPciPassthruConfigTrait for HostSriovConfig {
    fn get_id(&self) -> &str { &self.id }
    fn get_passthru_enabled(&self) -> bool { self.passthru_enabled }
    fn get_apply_now(&self) -> Option<bool> { self.apply_now }
    fn get_hardware_label(&self) -> &Option<String> { &self.hardware_label }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostPciPassthruConfigTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostPciPassthruConfig => Some(from.as_any_ref().downcast_ref::<HostPciPassthruConfig>()?),
            StructType::HostSriovConfig => Some(from.as_any_ref().downcast_ref::<HostSriovConfig>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostPciPassthruConfig => Ok(from.as_any_box().downcast::<HostPciPassthruConfig>()?),
            StructType::HostSriovConfig => Ok(from.as_any_box().downcast::<HostSriovConfig>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object provides information about the state of PciPassthru
/// for all pci devices.
pub trait HostPciPassthruInfoTrait : super::traits::DataObjectTrait {
    /// The name ID of this PCI, composed of "bus:slot.function".
    fn get_id(&self) -> &str;
    /// Device which needs to be unclaimed by vmkernel (may be bridge)
    fn get_dependent_device(&self) -> &str;
    /// Whether passThru has been configured by the user
    fn get_passthru_enabled(&self) -> bool;
    /// Whether passThru is even possible for this device (decided by vmkctl)
    fn get_passthru_capable(&self) -> bool;
    /// Whether passThru is active for this device (meaning enabled + rebooted)
    fn get_passthru_active(&self) -> bool;
    /// The hardware label of this PCI device.
    /// 
    /// ***Since:*** vSphere API Release 7.0.2.0
    fn get_hardware_label(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn HostPciPassthruInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostPciPassthruInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostPciPassthruInfoVisitor)
            }
        }

struct HostPciPassthruInfoVisitor;

impl<'de> de::Visitor<'de> for HostPciPassthruInfoVisitor {
    type Value = Box<dyn HostPciPassthruInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostPciPassthruInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostPciPassthruInfoTrait for HostPciPassthruInfo {
    fn get_id(&self) -> &str { &self.id }
    fn get_dependent_device(&self) -> &str { &self.dependent_device }
    fn get_passthru_enabled(&self) -> bool { self.passthru_enabled }
    fn get_passthru_capable(&self) -> bool { self.passthru_capable }
    fn get_passthru_active(&self) -> bool { self.passthru_active }
    fn get_hardware_label(&self) -> &Option<String> { &self.hardware_label }
}
impl HostPciPassthruInfoTrait for HostSriovInfo {
    fn get_id(&self) -> &str { &self.id }
    fn get_dependent_device(&self) -> &str { &self.dependent_device }
    fn get_passthru_enabled(&self) -> bool { self.passthru_enabled }
    fn get_passthru_capable(&self) -> bool { self.passthru_capable }
    fn get_passthru_active(&self) -> bool { self.passthru_active }
    fn get_hardware_label(&self) -> &Option<String> { &self.hardware_label }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostPciPassthruInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostPciPassthruInfo => Some(from.as_any_ref().downcast_ref::<HostPciPassthruInfo>()?),
            StructType::HostSriovInfo => Some(from.as_any_ref().downcast_ref::<HostSriovInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostPciPassthruInfo => Ok(from.as_any_box().downcast::<HostPciPassthruInfo>()?),
            StructType::HostSriovInfo => Ok(from.as_any_box().downcast::<HostSriovInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type describes each network of a physical
/// network adapter's network hint.
pub trait PhysicalNicHintTrait : super::traits::DataObjectTrait {
    /// The optional VLAN Id of the network.
    fn get_vlan_id(&self) -> Option<i32>;
}
impl<'s> serde::Serialize for dyn PhysicalNicHintTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn PhysicalNicHintTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(PhysicalNicHintVisitor)
            }
        }

struct PhysicalNicHintVisitor;

impl<'de> de::Visitor<'de> for PhysicalNicHintVisitor {
    type Value = Box<dyn PhysicalNicHintTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid PhysicalNicHintTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl PhysicalNicHintTrait for PhysicalNicHint {
    fn get_vlan_id(&self) -> Option<i32> { self.vlan_id }
}
impl PhysicalNicHintTrait for PhysicalNicIpHint {
    fn get_vlan_id(&self) -> Option<i32> { self.vlan_id }
}
impl PhysicalNicHintTrait for PhysicalNicNameHint {
    fn get_vlan_id(&self) -> Option<i32> { self.vlan_id }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn PhysicalNicHintTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::PhysicalNicHint => Some(from.as_any_ref().downcast_ref::<PhysicalNicHint>()?),
            StructType::PhysicalNicIpHint => Some(from.as_any_ref().downcast_ref::<PhysicalNicIpHint>()?),
            StructType::PhysicalNicNameHint => Some(from.as_any_ref().downcast_ref::<PhysicalNicNameHint>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::PhysicalNicHint => Ok(from.as_any_box().downcast::<PhysicalNicHint>()?),
            StructType::PhysicalNicIpHint => Ok(from.as_any_box().downcast::<PhysicalNicIpHint>()?),
            StructType::PhysicalNicNameHint => Ok(from.as_any_box().downcast::<PhysicalNicNameHint>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object represents the physical
/// backing of an RDMA device.
pub trait HostRdmaDeviceBackingTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn HostRdmaDeviceBackingTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostRdmaDeviceBackingTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostRdmaDeviceBackingVisitor)
            }
        }

struct HostRdmaDeviceBackingVisitor;

impl<'de> de::Visitor<'de> for HostRdmaDeviceBackingVisitor {
    type Value = Box<dyn HostRdmaDeviceBackingTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostRdmaDeviceBackingTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostRdmaDeviceBackingTrait for HostRdmaDeviceBacking {
}
impl HostRdmaDeviceBackingTrait for HostRdmaDevicePnicBacking {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostRdmaDeviceBackingTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostRdmaDeviceBacking => Some(from.as_any_ref().downcast_ref::<HostRdmaDeviceBacking>()?),
            StructType::HostRdmaDevicePnicBacking => Some(from.as_any_ref().downcast_ref::<HostRdmaDevicePnicBacking>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostRdmaDeviceBacking => Ok(from.as_any_box().downcast::<HostRdmaDeviceBacking>()?),
            StructType::HostRdmaDevicePnicBacking => Ok(from.as_any_box().downcast::<HostRdmaDevicePnicBacking>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
pub trait HostSriovDevicePoolInfoTrait : super::traits::DataObjectTrait {
    fn get_key(&self) -> &str;
}
impl<'s> serde::Serialize for dyn HostSriovDevicePoolInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostSriovDevicePoolInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostSriovDevicePoolInfoVisitor)
            }
        }

struct HostSriovDevicePoolInfoVisitor;

impl<'de> de::Visitor<'de> for HostSriovDevicePoolInfoVisitor {
    type Value = Box<dyn HostSriovDevicePoolInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostSriovDevicePoolInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostSriovDevicePoolInfoTrait for HostSriovDevicePoolInfo {
    fn get_key(&self) -> &str { &self.key }
}
impl HostSriovDevicePoolInfoTrait for HostSriovNetworkDevicePoolInfo {
    fn get_key(&self) -> &str { &self.key }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostSriovDevicePoolInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostSriovDevicePoolInfo => Some(from.as_any_ref().downcast_ref::<HostSriovDevicePoolInfo>()?),
            StructType::HostSriovNetworkDevicePoolInfo => Some(from.as_any_ref().downcast_ref::<HostSriovNetworkDevicePoolInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostSriovDevicePoolInfo => Ok(from.as_any_box().downcast::<HostSriovDevicePoolInfo>()?),
            StructType::HostSriovNetworkDevicePoolInfo => Ok(from.as_any_box().downcast::<HostSriovNetworkDevicePoolInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class for all system swap options.
/// 
/// This class is not supposed to be used directly.  
/// These values are to be used in a *SystemSwapConfiguration.option*
/// array.
pub trait HostSystemSwapConfigurationSystemSwapOptionTrait : super::traits::DataObjectTrait {
    /// Specifies the order the options are preferred among each other.
    /// 
    /// The lower the value the more important.
    fn get_key(&self) -> i32;
}
impl<'s> serde::Serialize for dyn HostSystemSwapConfigurationSystemSwapOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostSystemSwapConfigurationSystemSwapOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostSystemSwapConfigurationSystemSwapOptionVisitor)
            }
        }

struct HostSystemSwapConfigurationSystemSwapOptionVisitor;

impl<'de> de::Visitor<'de> for HostSystemSwapConfigurationSystemSwapOptionVisitor {
    type Value = Box<dyn HostSystemSwapConfigurationSystemSwapOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostSystemSwapConfigurationSystemSwapOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostSystemSwapConfigurationSystemSwapOptionTrait for HostSystemSwapConfigurationSystemSwapOption {
    fn get_key(&self) -> i32 { self.key }
}
impl HostSystemSwapConfigurationSystemSwapOptionTrait for HostSystemSwapConfigurationDatastoreOption {
    fn get_key(&self) -> i32 { self.key }
}
impl HostSystemSwapConfigurationSystemSwapOptionTrait for HostSystemSwapConfigurationDisabledOption {
    fn get_key(&self) -> i32 { self.key }
}
impl HostSystemSwapConfigurationSystemSwapOptionTrait for HostSystemSwapConfigurationHostCacheOption {
    fn get_key(&self) -> i32 { self.key }
}
impl HostSystemSwapConfigurationSystemSwapOptionTrait for HostSystemSwapConfigurationHostLocalSwapOption {
    fn get_key(&self) -> i32 { self.key }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostSystemSwapConfigurationSystemSwapOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostSystemSwapConfigurationSystemSwapOption => Some(from.as_any_ref().downcast_ref::<HostSystemSwapConfigurationSystemSwapOption>()?),
            StructType::HostSystemSwapConfigurationDatastoreOption => Some(from.as_any_ref().downcast_ref::<HostSystemSwapConfigurationDatastoreOption>()?),
            StructType::HostSystemSwapConfigurationDisabledOption => Some(from.as_any_ref().downcast_ref::<HostSystemSwapConfigurationDisabledOption>()?),
            StructType::HostSystemSwapConfigurationHostCacheOption => Some(from.as_any_ref().downcast_ref::<HostSystemSwapConfigurationHostCacheOption>()?),
            StructType::HostSystemSwapConfigurationHostLocalSwapOption => Some(from.as_any_ref().downcast_ref::<HostSystemSwapConfigurationHostLocalSwapOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostSystemSwapConfigurationSystemSwapOption => Ok(from.as_any_box().downcast::<HostSystemSwapConfigurationSystemSwapOption>()?),
            StructType::HostSystemSwapConfigurationDatastoreOption => Ok(from.as_any_box().downcast::<HostSystemSwapConfigurationDatastoreOption>()?),
            StructType::HostSystemSwapConfigurationDisabledOption => Ok(from.as_any_box().downcast::<HostSystemSwapConfigurationDisabledOption>()?),
            StructType::HostSystemSwapConfigurationHostCacheOption => Ok(from.as_any_box().downcast::<HostSystemSwapConfigurationHostCacheOption>()?),
            StructType::HostSystemSwapConfigurationHostLocalSwapOption => Ok(from.as_any_box().downcast::<HostSystemSwapConfigurationHostLocalSwapOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Transport information about a SCSI target.
pub trait HostTargetTransportTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn HostTargetTransportTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostTargetTransportTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostTargetTransportVisitor)
            }
        }

struct HostTargetTransportVisitor;

impl<'de> de::Visitor<'de> for HostTargetTransportVisitor {
    type Value = Box<dyn HostTargetTransportTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostTargetTransportTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostTargetTransportTrait for HostTargetTransport {
}
impl HostTargetTransportTrait for HostBlockAdapterTargetTransport {
}
impl HostTargetTransportTrait for HostFibreChannelTargetTransport {
}
impl HostTargetTransportTrait for HostFibreChannelOverEthernetTargetTransport {
}
impl HostTargetTransportTrait for HostInternetScsiTargetTransport {
}
impl HostTargetTransportTrait for HostParallelScsiTargetTransport {
}
impl HostTargetTransportTrait for HostPcieTargetTransport {
}
impl HostTargetTransportTrait for HostRdmaTargetTransport {
}
impl HostTargetTransportTrait for HostSerialAttachedTargetTransport {
}
impl HostTargetTransportTrait for HostTcpTargetTransport {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostTargetTransportTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostTargetTransport => Some(from.as_any_ref().downcast_ref::<HostTargetTransport>()?),
            StructType::HostBlockAdapterTargetTransport => Some(from.as_any_ref().downcast_ref::<HostBlockAdapterTargetTransport>()?),
            StructType::HostFibreChannelTargetTransport => Some(from.as_any_ref().downcast_ref::<HostFibreChannelTargetTransport>()?),
            StructType::HostFibreChannelOverEthernetTargetTransport => Some(from.as_any_ref().downcast_ref::<HostFibreChannelOverEthernetTargetTransport>()?),
            StructType::HostInternetScsiTargetTransport => Some(from.as_any_ref().downcast_ref::<HostInternetScsiTargetTransport>()?),
            StructType::HostParallelScsiTargetTransport => Some(from.as_any_ref().downcast_ref::<HostParallelScsiTargetTransport>()?),
            StructType::HostPcieTargetTransport => Some(from.as_any_ref().downcast_ref::<HostPcieTargetTransport>()?),
            StructType::HostRdmaTargetTransport => Some(from.as_any_ref().downcast_ref::<HostRdmaTargetTransport>()?),
            StructType::HostSerialAttachedTargetTransport => Some(from.as_any_ref().downcast_ref::<HostSerialAttachedTargetTransport>()?),
            StructType::HostTcpTargetTransport => Some(from.as_any_ref().downcast_ref::<HostTcpTargetTransport>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostTargetTransport => Ok(from.as_any_box().downcast::<HostTargetTransport>()?),
            StructType::HostBlockAdapterTargetTransport => Ok(from.as_any_box().downcast::<HostBlockAdapterTargetTransport>()?),
            StructType::HostFibreChannelTargetTransport => Ok(from.as_any_box().downcast::<HostFibreChannelTargetTransport>()?),
            StructType::HostFibreChannelOverEthernetTargetTransport => Ok(from.as_any_box().downcast::<HostFibreChannelOverEthernetTargetTransport>()?),
            StructType::HostInternetScsiTargetTransport => Ok(from.as_any_box().downcast::<HostInternetScsiTargetTransport>()?),
            StructType::HostParallelScsiTargetTransport => Ok(from.as_any_box().downcast::<HostParallelScsiTargetTransport>()?),
            StructType::HostPcieTargetTransport => Ok(from.as_any_box().downcast::<HostPcieTargetTransport>()?),
            StructType::HostRdmaTargetTransport => Ok(from.as_any_box().downcast::<HostRdmaTargetTransport>()?),
            StructType::HostSerialAttachedTargetTransport => Ok(from.as_any_box().downcast::<HostSerialAttachedTargetTransport>()?),
            StructType::HostTcpTargetTransport => Ok(from.as_any_box().downcast::<HostTcpTargetTransport>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Fibre Channel transport information about a SCSI target.
pub trait HostFibreChannelTargetTransportTrait : super::traits::HostTargetTransportTrait {
    /// The world wide port name of the target.
    fn get_port_world_wide_name(&self) -> i64;
    /// The world wide node name of the target.
    fn get_node_world_wide_name(&self) -> i64;
}
impl<'s> serde::Serialize for dyn HostFibreChannelTargetTransportTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostFibreChannelTargetTransportTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostFibreChannelTargetTransportVisitor)
            }
        }

struct HostFibreChannelTargetTransportVisitor;

impl<'de> de::Visitor<'de> for HostFibreChannelTargetTransportVisitor {
    type Value = Box<dyn HostFibreChannelTargetTransportTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostFibreChannelTargetTransportTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostFibreChannelTargetTransportTrait for HostFibreChannelTargetTransport {
    fn get_port_world_wide_name(&self) -> i64 { self.port_world_wide_name }
    fn get_node_world_wide_name(&self) -> i64 { self.node_world_wide_name }
}
impl HostFibreChannelTargetTransportTrait for HostFibreChannelOverEthernetTargetTransport {
    fn get_port_world_wide_name(&self) -> i64 { self.port_world_wide_name }
    fn get_node_world_wide_name(&self) -> i64 { self.node_world_wide_name }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostFibreChannelTargetTransportTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostFibreChannelTargetTransport => Some(from.as_any_ref().downcast_ref::<HostFibreChannelTargetTransport>()?),
            StructType::HostFibreChannelOverEthernetTargetTransport => Some(from.as_any_ref().downcast_ref::<HostFibreChannelOverEthernetTargetTransport>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostFibreChannelTargetTransport => Ok(from.as_any_box().downcast::<HostFibreChannelTargetTransport>()?),
            StructType::HostFibreChannelOverEthernetTargetTransport => Ok(from.as_any_box().downcast::<HostFibreChannelOverEthernetTargetTransport>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This is a base data object for describing an event generated by
/// Trusted Platform Module (TPM).
/// 
/// It contains parameters common to
/// all TPM event types.
pub trait HostTpmEventDetailsTrait : super::traits::DataObjectTrait {
    /// Value of the Platform Configuration Register (PCR) for this event.
    fn get_data_hash(&self) -> &Vec<i8>;
    /// Method in which the digest hash is calculated.
    /// 
    /// The set of possible
    /// values is described in *HostDigestInfoDigestMethodType_enum*.
    fn get_data_hash_method(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn HostTpmEventDetailsTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostTpmEventDetailsTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostTpmEventDetailsVisitor)
            }
        }

struct HostTpmEventDetailsVisitor;

impl<'de> de::Visitor<'de> for HostTpmEventDetailsVisitor {
    type Value = Box<dyn HostTpmEventDetailsTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostTpmEventDetailsTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostTpmEventDetailsTrait for HostTpmEventDetails {
    fn get_data_hash(&self) -> &Vec<i8> { &self.data_hash }
    fn get_data_hash_method(&self) -> &Option<String> { &self.data_hash_method }
}
impl HostTpmEventDetailsTrait for HostTpmBootCompleteEventDetails {
    fn get_data_hash(&self) -> &Vec<i8> { &self.data_hash }
    fn get_data_hash_method(&self) -> &Option<String> { &self.data_hash_method }
}
impl HostTpmEventDetailsTrait for HostTpmBootSecurityOptionEventDetails {
    fn get_data_hash(&self) -> &Vec<i8> { &self.data_hash }
    fn get_data_hash_method(&self) -> &Option<String> { &self.data_hash_method }
}
impl HostTpmEventDetailsTrait for HostTpmNvTagEventDetails {
    fn get_data_hash(&self) -> &Vec<i8> { &self.data_hash }
    fn get_data_hash_method(&self) -> &Option<String> { &self.data_hash_method }
}
impl HostTpmEventDetailsTrait for HostTpmSignerEventDetails {
    fn get_data_hash(&self) -> &Vec<i8> { &self.data_hash }
    fn get_data_hash_method(&self) -> &Option<String> { &self.data_hash_method }
}
impl HostTpmEventDetailsTrait for HostTpmCommandEventDetails {
    fn get_data_hash(&self) -> &Vec<i8> { &self.data_hash }
    fn get_data_hash_method(&self) -> &Option<String> { &self.data_hash_method }
}
impl HostTpmEventDetailsTrait for HostTpmOptionEventDetails {
    fn get_data_hash(&self) -> &Vec<i8> { &self.data_hash }
    fn get_data_hash_method(&self) -> &Option<String> { &self.data_hash_method }
}
impl HostTpmEventDetailsTrait for HostTpmSoftwareComponentEventDetails {
    fn get_data_hash(&self) -> &Vec<i8> { &self.data_hash }
    fn get_data_hash_method(&self) -> &Option<String> { &self.data_hash_method }
}
impl HostTpmEventDetailsTrait for HostTpmVersionEventDetails {
    fn get_data_hash(&self) -> &Vec<i8> { &self.data_hash }
    fn get_data_hash_method(&self) -> &Option<String> { &self.data_hash_method }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostTpmEventDetailsTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostTpmEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmEventDetails>()?),
            StructType::HostTpmBootCompleteEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmBootCompleteEventDetails>()?),
            StructType::HostTpmBootSecurityOptionEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmBootSecurityOptionEventDetails>()?),
            StructType::HostTpmNvTagEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmNvTagEventDetails>()?),
            StructType::HostTpmSignerEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmSignerEventDetails>()?),
            StructType::HostTpmCommandEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmCommandEventDetails>()?),
            StructType::HostTpmOptionEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmOptionEventDetails>()?),
            StructType::HostTpmSoftwareComponentEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmSoftwareComponentEventDetails>()?),
            StructType::HostTpmVersionEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmVersionEventDetails>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostTpmEventDetails => Ok(from.as_any_box().downcast::<HostTpmEventDetails>()?),
            StructType::HostTpmBootCompleteEventDetails => Ok(from.as_any_box().downcast::<HostTpmBootCompleteEventDetails>()?),
            StructType::HostTpmBootSecurityOptionEventDetails => Ok(from.as_any_box().downcast::<HostTpmBootSecurityOptionEventDetails>()?),
            StructType::HostTpmNvTagEventDetails => Ok(from.as_any_box().downcast::<HostTpmNvTagEventDetails>()?),
            StructType::HostTpmSignerEventDetails => Ok(from.as_any_box().downcast::<HostTpmSignerEventDetails>()?),
            StructType::HostTpmCommandEventDetails => Ok(from.as_any_box().downcast::<HostTpmCommandEventDetails>()?),
            StructType::HostTpmOptionEventDetails => Ok(from.as_any_box().downcast::<HostTpmOptionEventDetails>()?),
            StructType::HostTpmSoftwareComponentEventDetails => Ok(from.as_any_box().downcast::<HostTpmSoftwareComponentEventDetails>()?),
            StructType::HostTpmVersionEventDetails => Ok(from.as_any_box().downcast::<HostTpmVersionEventDetails>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Details of a Trusted Platform Module (TPM) event recording kernel security
/// option passed at boot time and currently in effect.
/// 
/// This event type exists to simplify parsing of the security-related information
/// by internal and third-party solutions. Each boot option may be passed to kernel
/// multiple times and/or in different forms. Replicating the parsing logic of the
/// kernel would be neither convinient, nor secure for the client applications.
/// 
/// Each instance of this event reports details of a single security-related
/// boot option, as set in the kernel.
pub trait HostTpmBootSecurityOptionEventDetailsTrait : super::traits::HostTpmEventDetailsTrait {
    /// Security-related options string, reflecting the state of an option set
    /// in the kernel.
    /// 
    /// This string is in the form of a KEY=VALUE pair.
    fn get_boot_security_option(&self) -> &str;
}
impl<'s> serde::Serialize for dyn HostTpmBootSecurityOptionEventDetailsTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostTpmBootSecurityOptionEventDetailsTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostTpmBootSecurityOptionEventDetailsVisitor)
            }
        }

struct HostTpmBootSecurityOptionEventDetailsVisitor;

impl<'de> de::Visitor<'de> for HostTpmBootSecurityOptionEventDetailsVisitor {
    type Value = Box<dyn HostTpmBootSecurityOptionEventDetailsTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostTpmBootSecurityOptionEventDetailsTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostTpmBootSecurityOptionEventDetailsTrait for HostTpmBootSecurityOptionEventDetails {
    fn get_boot_security_option(&self) -> &str { &self.boot_security_option }
}
impl HostTpmBootSecurityOptionEventDetailsTrait for HostTpmNvTagEventDetails {
    fn get_boot_security_option(&self) -> &str { &self.boot_security_option }
}
impl HostTpmBootSecurityOptionEventDetailsTrait for HostTpmSignerEventDetails {
    fn get_boot_security_option(&self) -> &str { &self.boot_security_option }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostTpmBootSecurityOptionEventDetailsTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostTpmBootSecurityOptionEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmBootSecurityOptionEventDetails>()?),
            StructType::HostTpmNvTagEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmNvTagEventDetails>()?),
            StructType::HostTpmSignerEventDetails => Some(from.as_any_ref().downcast_ref::<HostTpmSignerEventDetails>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostTpmBootSecurityOptionEventDetails => Ok(from.as_any_box().downcast::<HostTpmBootSecurityOptionEventDetails>()?),
            StructType::HostTpmNvTagEventDetails => Ok(from.as_any_box().downcast::<HostTpmNvTagEventDetails>()?),
            StructType::HostTpmSignerEventDetails => Ok(from.as_any_box().downcast::<HostTpmSignerEventDetails>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// A bridge connects a virtual switch to a physical network adapter.
/// 
/// There are multiple types of bridges.
pub trait HostVirtualSwitchBridgeTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn HostVirtualSwitchBridgeTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostVirtualSwitchBridgeTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostVirtualSwitchBridgeVisitor)
            }
        }

struct HostVirtualSwitchBridgeVisitor;

impl<'de> de::Visitor<'de> for HostVirtualSwitchBridgeVisitor {
    type Value = Box<dyn HostVirtualSwitchBridgeTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostVirtualSwitchBridgeTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostVirtualSwitchBridgeTrait for HostVirtualSwitchBridge {
}
impl HostVirtualSwitchBridgeTrait for HostVirtualSwitchAutoBridge {
}
impl HostVirtualSwitchBridgeTrait for HostVirtualSwitchBondBridge {
}
impl HostVirtualSwitchBridgeTrait for HostVirtualSwitchSimpleBridge {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostVirtualSwitchBridgeTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostVirtualSwitchBridge => Some(from.as_any_ref().downcast_ref::<HostVirtualSwitchBridge>()?),
            StructType::HostVirtualSwitchAutoBridge => Some(from.as_any_ref().downcast_ref::<HostVirtualSwitchAutoBridge>()?),
            StructType::HostVirtualSwitchBondBridge => Some(from.as_any_ref().downcast_ref::<HostVirtualSwitchBondBridge>()?),
            StructType::HostVirtualSwitchSimpleBridge => Some(from.as_any_ref().downcast_ref::<HostVirtualSwitchSimpleBridge>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostVirtualSwitchBridge => Ok(from.as_any_box().downcast::<HostVirtualSwitchBridge>()?),
            StructType::HostVirtualSwitchAutoBridge => Ok(from.as_any_box().downcast::<HostVirtualSwitchAutoBridge>()?),
            StructType::HostVirtualSwitchBondBridge => Ok(from.as_any_box().downcast::<HostVirtualSwitchBondBridge>()?),
            StructType::HostVirtualSwitchSimpleBridge => Ok(from.as_any_box().downcast::<HostVirtualSwitchSimpleBridge>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class that describes a VMFS datastore provisioning option.
pub trait VmfsDatastoreBaseOptionTrait : super::traits::DataObjectTrait {
    /// The partition table layout that the disk will have if this
    /// provisioning option is selected.
    /// 
    /// In releases after vSphere API 5.0, vSphere Servers might not
    /// generate property collector update notifications for this property.
    /// To obtain the latest value of the property, you can use
    /// PropertyCollector methods RetrievePropertiesEx or WaitForUpdatesEx.
    /// If you use the PropertyCollector.WaitForUpdatesEx method, specify
    /// an empty string for the version parameter.
    /// Since this property is on a DataObject, an update returned by WaitForUpdatesEx may
    /// contain values for this property when some other property on the DataObject changes.
    /// If this update is a result of a call to WaitForUpdatesEx with a non-empty
    /// version parameter, the value for this property may not be current.
    fn get_layout(&self) -> &HostDiskPartitionLayout;
    /// Indicates whether selecting this option will change the partition
    /// format type on the disk.
    /// 
    /// See also *HostDiskPartitionInfoPartitionFormat_enum*.
    fn get_partition_format_change(&self) -> Option<bool>;
}
impl<'s> serde::Serialize for dyn VmfsDatastoreBaseOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VmfsDatastoreBaseOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VmfsDatastoreBaseOptionVisitor)
            }
        }

struct VmfsDatastoreBaseOptionVisitor;

impl<'de> de::Visitor<'de> for VmfsDatastoreBaseOptionVisitor {
    type Value = Box<dyn VmfsDatastoreBaseOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VmfsDatastoreBaseOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VmfsDatastoreBaseOptionTrait for VmfsDatastoreBaseOption {
    fn get_layout(&self) -> &HostDiskPartitionLayout { &self.layout }
    fn get_partition_format_change(&self) -> Option<bool> { self.partition_format_change }
}
impl VmfsDatastoreBaseOptionTrait for VmfsDatastoreMultipleExtentOption {
    fn get_layout(&self) -> &HostDiskPartitionLayout { &self.layout }
    fn get_partition_format_change(&self) -> Option<bool> { self.partition_format_change }
}
impl VmfsDatastoreBaseOptionTrait for VmfsDatastoreSingleExtentOption {
    fn get_layout(&self) -> &HostDiskPartitionLayout { &self.layout }
    fn get_partition_format_change(&self) -> Option<bool> { self.partition_format_change }
}
impl VmfsDatastoreBaseOptionTrait for VmfsDatastoreAllExtentOption {
    fn get_layout(&self) -> &HostDiskPartitionLayout { &self.layout }
    fn get_partition_format_change(&self) -> Option<bool> { self.partition_format_change }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VmfsDatastoreBaseOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmfsDatastoreBaseOption => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreBaseOption>()?),
            StructType::VmfsDatastoreMultipleExtentOption => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreMultipleExtentOption>()?),
            StructType::VmfsDatastoreSingleExtentOption => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreSingleExtentOption>()?),
            StructType::VmfsDatastoreAllExtentOption => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreAllExtentOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmfsDatastoreBaseOption => Ok(from.as_any_box().downcast::<VmfsDatastoreBaseOption>()?),
            StructType::VmfsDatastoreMultipleExtentOption => Ok(from.as_any_box().downcast::<VmfsDatastoreMultipleExtentOption>()?),
            StructType::VmfsDatastoreSingleExtentOption => Ok(from.as_any_box().downcast::<VmfsDatastoreSingleExtentOption>()?),
            StructType::VmfsDatastoreAllExtentOption => Ok(from.as_any_box().downcast::<VmfsDatastoreAllExtentOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Datastore addition policy to use a single extent on the disk for a VMFS
/// datastore.
/// 
/// A single extent implies that one disk partition will be
/// created on the disk for creating or increasing the capacity of a VMFS datastore.
pub trait VmfsDatastoreSingleExtentOptionTrait : super::traits::VmfsDatastoreBaseOptionTrait {
    /// The block range to be used as an extent in a VMFS datastore.
    fn get_vmfs_extent(&self) -> &HostDiskPartitionBlockRange;
}
impl<'s> serde::Serialize for dyn VmfsDatastoreSingleExtentOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VmfsDatastoreSingleExtentOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VmfsDatastoreSingleExtentOptionVisitor)
            }
        }

struct VmfsDatastoreSingleExtentOptionVisitor;

impl<'de> de::Visitor<'de> for VmfsDatastoreSingleExtentOptionVisitor {
    type Value = Box<dyn VmfsDatastoreSingleExtentOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VmfsDatastoreSingleExtentOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VmfsDatastoreSingleExtentOptionTrait for VmfsDatastoreSingleExtentOption {
    fn get_vmfs_extent(&self) -> &HostDiskPartitionBlockRange { &self.vmfs_extent }
}
impl VmfsDatastoreSingleExtentOptionTrait for VmfsDatastoreAllExtentOption {
    fn get_vmfs_extent(&self) -> &HostDiskPartitionBlockRange { &self.vmfs_extent }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VmfsDatastoreSingleExtentOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmfsDatastoreSingleExtentOption => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreSingleExtentOption>()?),
            StructType::VmfsDatastoreAllExtentOption => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreAllExtentOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmfsDatastoreSingleExtentOption => Ok(from.as_any_box().downcast::<VmfsDatastoreSingleExtentOption>()?),
            StructType::VmfsDatastoreAllExtentOption => Ok(from.as_any_box().downcast::<VmfsDatastoreAllExtentOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class for VMFS datastore addition specification.
/// 
/// Used as a generic
/// way to point to one of the creation specifications that can be used to
/// apply a specification to effect the creation or extension of a VMFS
/// datastore.
pub trait VmfsDatastoreSpecTrait : super::traits::DataObjectTrait {
    /// The UUID of the SCSI disk on which the VMFS datastore is located.
    /// 
    /// See also *HostScsiDisk*, *ScsiLun.uuid*.
    fn get_disk_uuid(&self) -> &str;
}
impl<'s> serde::Serialize for dyn VmfsDatastoreSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VmfsDatastoreSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VmfsDatastoreSpecVisitor)
            }
        }

struct VmfsDatastoreSpecVisitor;

impl<'de> de::Visitor<'de> for VmfsDatastoreSpecVisitor {
    type Value = Box<dyn VmfsDatastoreSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VmfsDatastoreSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VmfsDatastoreSpecTrait for VmfsDatastoreSpec {
    fn get_disk_uuid(&self) -> &str { &self.disk_uuid }
}
impl VmfsDatastoreSpecTrait for VmfsDatastoreCreateSpec {
    fn get_disk_uuid(&self) -> &str { &self.disk_uuid }
}
impl VmfsDatastoreSpecTrait for VmfsDatastoreExpandSpec {
    fn get_disk_uuid(&self) -> &str { &self.disk_uuid }
}
impl VmfsDatastoreSpecTrait for VmfsDatastoreExtendSpec {
    fn get_disk_uuid(&self) -> &str { &self.disk_uuid }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VmfsDatastoreSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmfsDatastoreSpec => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreSpec>()?),
            StructType::VmfsDatastoreCreateSpec => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreCreateSpec>()?),
            StructType::VmfsDatastoreExpandSpec => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreExpandSpec>()?),
            StructType::VmfsDatastoreExtendSpec => Some(from.as_any_ref().downcast_ref::<VmfsDatastoreExtendSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmfsDatastoreSpec => Ok(from.as_any_box().downcast::<VmfsDatastoreSpec>()?),
            StructType::VmfsDatastoreCreateSpec => Ok(from.as_any_box().downcast::<VmfsDatastoreCreateSpec>()?),
            StructType::VmfsDatastoreExpandSpec => Ok(from.as_any_box().downcast::<VmfsDatastoreExpandSpec>()?),
            StructType::VmfsDatastoreExtendSpec => Ok(from.as_any_box().downcast::<VmfsDatastoreExtendSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type describes the NetBIOS configuration of
/// an operating system.
pub trait NetBiosConfigInfoTrait : super::traits::DataObjectTrait {
    /// NetBIOS configuration mode.
    /// 
    /// The supported values are described by
    /// *NetBIOSConfigInfoMode_enum*.
    fn get_mode(&self) -> &str;
}
impl<'s> serde::Serialize for dyn NetBiosConfigInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn NetBiosConfigInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(NetBiosConfigInfoVisitor)
            }
        }

struct NetBiosConfigInfoVisitor;

impl<'de> de::Visitor<'de> for NetBiosConfigInfoVisitor {
    type Value = Box<dyn NetBiosConfigInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid NetBiosConfigInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl NetBiosConfigInfoTrait for NetBiosConfigInfo {
    fn get_mode(&self) -> &str { &self.mode }
}
impl NetBiosConfigInfoTrait for WinNetBiosConfigInfo {
    fn get_mode(&self) -> &str { &self.mode }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn NetBiosConfigInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::NetBiosConfigInfo => Some(from.as_any_ref().downcast_ref::<NetBiosConfigInfo>()?),
            StructType::WinNetBiosConfigInfo => Some(from.as_any_ref().downcast_ref::<WinNetBiosConfigInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::NetBiosConfigInfo => Ok(from.as_any_box().downcast::<NetBiosConfigInfo>()?),
            StructType::WinNetBiosConfigInfo => Ok(from.as_any_box().downcast::<WinNetBiosConfigInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// An ArrayUpdateSpec data object type is a common superclass
/// for supporting incremental updates to arrays.
/// 
/// The common code pattern is:
/// 
///          class MyTypeSpec extrends ArrayUpdateSpec {
///                MyTypeInfo info;
///          }
/// The ArrayUpdateSpec contains the following:
/// - **operation**: the type of operation being performed.
/// - **removeKey**: In the case of a remove operation, the
///   key value that identifies the array to be removed.
pub trait ArrayUpdateSpecTrait : super::traits::DataObjectTrait {
    /// The type of operation being performed on the specified virtual device.
    fn get_operation(&self) -> &super::enums::ArrayUpdateOperationEnum;
    /// Key for the element to be removed.
    /// 
    /// Only used if the operation
    /// is "remove".
    fn get_remove_key(&self) -> &Option<VimAny>;
}
impl<'s> serde::Serialize for dyn ArrayUpdateSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ArrayUpdateSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ArrayUpdateSpecVisitor)
            }
        }

struct ArrayUpdateSpecVisitor;

impl<'de> de::Visitor<'de> for ArrayUpdateSpecVisitor {
    type Value = Box<dyn ArrayUpdateSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ArrayUpdateSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ArrayUpdateSpecTrait for ArrayUpdateSpec {
    fn get_operation(&self) -> &super::enums::ArrayUpdateOperationEnum { &self.operation }
    fn get_remove_key(&self) -> &Option<VimAny> { &self.remove_key }
}
impl ArrayUpdateSpecTrait for ClusterDasVmConfigSpec {
    fn get_operation(&self) -> &super::enums::ArrayUpdateOperationEnum { &self.operation }
    fn get_remove_key(&self) -> &Option<VimAny> { &self.remove_key }
}
impl ArrayUpdateSpecTrait for ClusterDatastoreUpdateSpec {
    fn get_operation(&self) -> &super::enums::ArrayUpdateOperationEnum { &self.operation }
    fn get_remove_key(&self) -> &Option<VimAny> { &self.remove_key }
}
impl ArrayUpdateSpecTrait for ClusterDpmHostConfigSpec {
    fn get_operation(&self) -> &super::enums::ArrayUpdateOperationEnum { &self.operation }
    fn get_remove_key(&self) -> &Option<VimAny> { &self.remove_key }
}
impl ArrayUpdateSpecTrait for ClusterDrsVmConfigSpec {
    fn get_operation(&self) -> &super::enums::ArrayUpdateOperationEnum { &self.operation }
    fn get_remove_key(&self) -> &Option<VimAny> { &self.remove_key }
}
impl ArrayUpdateSpecTrait for ClusterGroupSpec {
    fn get_operation(&self) -> &super::enums::ArrayUpdateOperationEnum { &self.operation }
    fn get_remove_key(&self) -> &Option<VimAny> { &self.remove_key }
}
impl ArrayUpdateSpecTrait for ClusterPreemptibleVmPairSpec {
    fn get_operation(&self) -> &super::enums::ArrayUpdateOperationEnum { &self.operation }
    fn get_remove_key(&self) -> &Option<VimAny> { &self.remove_key }
}
impl ArrayUpdateSpecTrait for ClusterRuleSpec {
    fn get_operation(&self) -> &super::enums::ArrayUpdateOperationEnum { &self.operation }
    fn get_remove_key(&self) -> &Option<VimAny> { &self.remove_key }
}
impl ArrayUpdateSpecTrait for ClusterTagCategoryUpdateSpec {
    fn get_operation(&self) -> &super::enums::ArrayUpdateOperationEnum { &self.operation }
    fn get_remove_key(&self) -> &Option<VimAny> { &self.remove_key }
}
impl ArrayUpdateSpecTrait for ClusterVmOrchestrationSpec {
    fn get_operation(&self) -> &super::enums::ArrayUpdateOperationEnum { &self.operation }
    fn get_remove_key(&self) -> &Option<VimAny> { &self.remove_key }
}
impl ArrayUpdateSpecTrait for StorageDrsOptionSpec {
    fn get_operation(&self) -> &super::enums::ArrayUpdateOperationEnum { &self.operation }
    fn get_remove_key(&self) -> &Option<VimAny> { &self.remove_key }
}
impl ArrayUpdateSpecTrait for StorageDrsVmConfigSpec {
    fn get_operation(&self) -> &super::enums::ArrayUpdateOperationEnum { &self.operation }
    fn get_remove_key(&self) -> &Option<VimAny> { &self.remove_key }
}
impl ArrayUpdateSpecTrait for VAppOvfSectionSpec {
    fn get_operation(&self) -> &super::enums::ArrayUpdateOperationEnum { &self.operation }
    fn get_remove_key(&self) -> &Option<VimAny> { &self.remove_key }
}
impl ArrayUpdateSpecTrait for VAppProductSpec {
    fn get_operation(&self) -> &super::enums::ArrayUpdateOperationEnum { &self.operation }
    fn get_remove_key(&self) -> &Option<VimAny> { &self.remove_key }
}
impl ArrayUpdateSpecTrait for VAppPropertySpec {
    fn get_operation(&self) -> &super::enums::ArrayUpdateOperationEnum { &self.operation }
    fn get_remove_key(&self) -> &Option<VimAny> { &self.remove_key }
}
impl ArrayUpdateSpecTrait for VirtualMachineCpuIdInfoSpec {
    fn get_operation(&self) -> &super::enums::ArrayUpdateOperationEnum { &self.operation }
    fn get_remove_key(&self) -> &Option<VimAny> { &self.remove_key }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ArrayUpdateSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ArrayUpdateSpec => Some(from.as_any_ref().downcast_ref::<ArrayUpdateSpec>()?),
            StructType::ClusterDasVmConfigSpec => Some(from.as_any_ref().downcast_ref::<ClusterDasVmConfigSpec>()?),
            StructType::ClusterDatastoreUpdateSpec => Some(from.as_any_ref().downcast_ref::<ClusterDatastoreUpdateSpec>()?),
            StructType::ClusterDpmHostConfigSpec => Some(from.as_any_ref().downcast_ref::<ClusterDpmHostConfigSpec>()?),
            StructType::ClusterDrsVmConfigSpec => Some(from.as_any_ref().downcast_ref::<ClusterDrsVmConfigSpec>()?),
            StructType::ClusterGroupSpec => Some(from.as_any_ref().downcast_ref::<ClusterGroupSpec>()?),
            StructType::ClusterPreemptibleVmPairSpec => Some(from.as_any_ref().downcast_ref::<ClusterPreemptibleVmPairSpec>()?),
            StructType::ClusterRuleSpec => Some(from.as_any_ref().downcast_ref::<ClusterRuleSpec>()?),
            StructType::ClusterTagCategoryUpdateSpec => Some(from.as_any_ref().downcast_ref::<ClusterTagCategoryUpdateSpec>()?),
            StructType::ClusterVmOrchestrationSpec => Some(from.as_any_ref().downcast_ref::<ClusterVmOrchestrationSpec>()?),
            StructType::StorageDrsOptionSpec => Some(from.as_any_ref().downcast_ref::<StorageDrsOptionSpec>()?),
            StructType::StorageDrsVmConfigSpec => Some(from.as_any_ref().downcast_ref::<StorageDrsVmConfigSpec>()?),
            StructType::VAppOvfSectionSpec => Some(from.as_any_ref().downcast_ref::<VAppOvfSectionSpec>()?),
            StructType::VAppProductSpec => Some(from.as_any_ref().downcast_ref::<VAppProductSpec>()?),
            StructType::VAppPropertySpec => Some(from.as_any_ref().downcast_ref::<VAppPropertySpec>()?),
            StructType::VirtualMachineCpuIdInfoSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineCpuIdInfoSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ArrayUpdateSpec => Ok(from.as_any_box().downcast::<ArrayUpdateSpec>()?),
            StructType::ClusterDasVmConfigSpec => Ok(from.as_any_box().downcast::<ClusterDasVmConfigSpec>()?),
            StructType::ClusterDatastoreUpdateSpec => Ok(from.as_any_box().downcast::<ClusterDatastoreUpdateSpec>()?),
            StructType::ClusterDpmHostConfigSpec => Ok(from.as_any_box().downcast::<ClusterDpmHostConfigSpec>()?),
            StructType::ClusterDrsVmConfigSpec => Ok(from.as_any_box().downcast::<ClusterDrsVmConfigSpec>()?),
            StructType::ClusterGroupSpec => Ok(from.as_any_box().downcast::<ClusterGroupSpec>()?),
            StructType::ClusterPreemptibleVmPairSpec => Ok(from.as_any_box().downcast::<ClusterPreemptibleVmPairSpec>()?),
            StructType::ClusterRuleSpec => Ok(from.as_any_box().downcast::<ClusterRuleSpec>()?),
            StructType::ClusterTagCategoryUpdateSpec => Ok(from.as_any_box().downcast::<ClusterTagCategoryUpdateSpec>()?),
            StructType::ClusterVmOrchestrationSpec => Ok(from.as_any_box().downcast::<ClusterVmOrchestrationSpec>()?),
            StructType::StorageDrsOptionSpec => Ok(from.as_any_box().downcast::<StorageDrsOptionSpec>()?),
            StructType::StorageDrsVmConfigSpec => Ok(from.as_any_box().downcast::<StorageDrsVmConfigSpec>()?),
            StructType::VAppOvfSectionSpec => Ok(from.as_any_box().downcast::<VAppOvfSectionSpec>()?),
            StructType::VAppProductSpec => Ok(from.as_any_box().downcast::<VAppProductSpec>()?),
            StructType::VAppPropertySpec => Ok(from.as_any_box().downcast::<VAppPropertySpec>()?),
            StructType::VirtualMachineCpuIdInfoSpec => Ok(from.as_any_box().downcast::<VirtualMachineCpuIdInfoSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The base data object type for all options.
pub trait OptionTypeTrait : super::traits::DataObjectTrait {
    /// The flag to indicate whether or not a user
    /// can modify a value belonging to this option type.
    /// 
    /// If
    /// the flag is not set, the value can be modified.
    fn get_value_is_readonly(&self) -> Option<bool>;
}
impl<'s> serde::Serialize for dyn OptionTypeTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn OptionTypeTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(OptionTypeVisitor)
            }
        }

struct OptionTypeVisitor;

impl<'de> de::Visitor<'de> for OptionTypeVisitor {
    type Value = Box<dyn OptionTypeTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid OptionTypeTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl OptionTypeTrait for OptionType {
    fn get_value_is_readonly(&self) -> Option<bool> { self.value_is_readonly }
}
impl OptionTypeTrait for BoolOption {
    fn get_value_is_readonly(&self) -> Option<bool> { self.value_is_readonly }
}
impl OptionTypeTrait for ChoiceOption {
    fn get_value_is_readonly(&self) -> Option<bool> { self.value_is_readonly }
}
impl OptionTypeTrait for FloatOption {
    fn get_value_is_readonly(&self) -> Option<bool> { self.value_is_readonly }
}
impl OptionTypeTrait for IntOption {
    fn get_value_is_readonly(&self) -> Option<bool> { self.value_is_readonly }
}
impl OptionTypeTrait for LongOption {
    fn get_value_is_readonly(&self) -> Option<bool> { self.value_is_readonly }
}
impl OptionTypeTrait for StringOption {
    fn get_value_is_readonly(&self) -> Option<bool> { self.value_is_readonly }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn OptionTypeTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::OptionType => Some(from.as_any_ref().downcast_ref::<OptionType>()?),
            StructType::BoolOption => Some(from.as_any_ref().downcast_ref::<BoolOption>()?),
            StructType::ChoiceOption => Some(from.as_any_ref().downcast_ref::<ChoiceOption>()?),
            StructType::FloatOption => Some(from.as_any_ref().downcast_ref::<FloatOption>()?),
            StructType::IntOption => Some(from.as_any_ref().downcast_ref::<IntOption>()?),
            StructType::LongOption => Some(from.as_any_ref().downcast_ref::<LongOption>()?),
            StructType::StringOption => Some(from.as_any_ref().downcast_ref::<StringOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::OptionType => Ok(from.as_any_box().downcast::<OptionType>()?),
            StructType::BoolOption => Ok(from.as_any_box().downcast::<BoolOption>()?),
            StructType::ChoiceOption => Ok(from.as_any_box().downcast::<ChoiceOption>()?),
            StructType::FloatOption => Ok(from.as_any_box().downcast::<FloatOption>()?),
            StructType::IntOption => Ok(from.as_any_box().downcast::<IntOption>()?),
            StructType::LongOption => Ok(from.as_any_box().downcast::<LongOption>()?),
            StructType::StringOption => Ok(from.as_any_box().downcast::<StringOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Describes the key/value pair of a configured option.
pub trait OptionValueTrait : super::traits::DataObjectTrait {
    /// The name of the option using dot notation to reflect the
    /// option's position in a hierarchy.
    /// 
    /// For example, you might
    /// have an option called "Ethernet" and another option that is
    /// a child of that called "Connection". In this case, the key
    /// for the latter could be defined as "Ethernet.Connection"
    fn get_key(&self) -> &str;
    /// The value of the option.
    /// 
    /// The Any data object type enables you to
    /// define any value for the option. Typically, however, the value
    /// of an option is of type String or Integer.
    fn get_value(&self) -> &Option<VimAny>;
}
impl<'s> serde::Serialize for dyn OptionValueTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn OptionValueTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(OptionValueVisitor)
            }
        }

struct OptionValueVisitor;

impl<'de> de::Visitor<'de> for OptionValueVisitor {
    type Value = Box<dyn OptionValueTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid OptionValueTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl OptionValueTrait for OptionValue {
    fn get_key(&self) -> &str { &self.key }
    fn get_value(&self) -> &Option<VimAny> { &self.value }
}
impl OptionValueTrait for HostInternetScsiHbaParamValue {
    fn get_key(&self) -> &str { &self.key }
    fn get_value(&self) -> &Option<VimAny> { &self.value }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn OptionValueTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::OptionValue => Some(from.as_any_ref().downcast_ref::<OptionValue>()?),
            StructType::HostInternetScsiHbaParamValue => Some(from.as_any_ref().downcast_ref::<HostInternetScsiHbaParamValue>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::OptionValue => Ok(from.as_any_box().downcast::<OptionValue>()?),
            StructType::HostInternetScsiHbaParamValue => Ok(from.as_any_box().downcast::<HostInternetScsiHbaParamValue>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *ApplyProfile* data object is the base class for all data objects
/// that define profile configuration data.
/// 
/// <code>ApplyProfile</code> defines ESX configuration data storage and it
/// supports recursive profile definition for the profile plug-in architecture.
pub trait ApplyProfileTrait : super::traits::DataObjectTrait {
    /// Indicates whether the profile is enabled.
    fn get_enabled(&self) -> bool;
    /// The list of policies comprising the profile.
    /// 
    /// A *ProfilePolicy*
    /// stores one or more configuration data values in a *PolicyOption*.
    /// The policy option is one of the configuration options from the
    /// *ProfilePolicyMetadata*.*ProfilePolicyMetadata.possibleOption*
    /// list.
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>>;
    /// Identifies the profile type.
    fn get_profile_type_name(&self) -> &Option<String>;
    /// Profile engine version.
    fn get_profile_version(&self) -> &Option<String>;
    /// List of subprofiles for this profile.
    /// 
    /// This list can change depending on which profile plug-ins are available in the system.
    /// Subprofiles can be nested to arbitrary depths to represent host capabilities.
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>>;
    /// Indicates whether this profile is marked as "favorite".
    fn get_favorite(&self) -> Option<bool>;
    /// Indicates whether this profile is marked as to-be-merged.
    fn get_to_be_merged(&self) -> Option<bool>;
    /// Indicates whether the selected array elements, with the current
    /// as one of them, replace the profile array in the target host
    /// profile.
    fn get_to_replace_with(&self) -> Option<bool>;
    /// Indicates whether this profile is marked as to-be-deleted.
    fn get_to_be_deleted(&self) -> Option<bool>;
    /// Indicates that the member variable <code>enabled</code> of this profile
    /// will be copied from source profile to target profiles at host profile
    /// composition.
    fn get_copy_enable_status(&self) -> Option<bool>;
    /// Indicates whether this profile will be displayed or not.
    fn get_hidden(&self) -> Option<bool>;
}
impl<'s> serde::Serialize for dyn ApplyProfileTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ApplyProfileTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ApplyProfileVisitor)
            }
        }

struct ApplyProfileVisitor;

impl<'de> de::Visitor<'de> for ApplyProfileVisitor {
    type Value = Box<dyn ApplyProfileTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ApplyProfileTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ApplyProfileTrait for ApplyProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for ProfileApplyProfileElement {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for ActiveDirectoryProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for AuthenticationProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for DateTimeProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for DvsProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for DvsVNicProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for DvsHostVNicProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for DvsServiceConsoleVNicProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for FirewallProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for FirewallProfileRulesetProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for HostApplyProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for HostMemoryProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for IpAddressProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for IpRouteProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for NasStorageProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for NetStackInstanceProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for NetworkPolicyProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for NetworkProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for NetworkProfileDnsConfigProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for NsxHostVNicProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for OpaqueSwitchProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for OptionProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for PermissionProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for PhysicalNicProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for PnicUplinkProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for PortGroupProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for HostPortGroupProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for ServiceConsolePortGroupProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for VmPortGroupProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for VirtualSwitchSelectionProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for VlanProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for SecurityProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for ServiceProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for StaticRouteProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for StorageProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for UserGroupProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for UserProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for VirtualSwitchProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for LinkProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl ApplyProfileTrait for NumPortsProfile {
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_policy(&self) -> &Option<Vec<ProfilePolicy>> { &self.policy }
    fn get_profile_type_name(&self) -> &Option<String> { &self.profile_type_name }
    fn get_profile_version(&self) -> &Option<String> { &self.profile_version }
    fn get_property(&self) -> &Option<Vec<ProfileApplyProfileProperty>> { &self.property }
    fn get_favorite(&self) -> Option<bool> { self.favorite }
    fn get_to_be_merged(&self) -> Option<bool> { self.to_be_merged }
    fn get_to_replace_with(&self) -> Option<bool> { self.to_replace_with }
    fn get_to_be_deleted(&self) -> Option<bool> { self.to_be_deleted }
    fn get_copy_enable_status(&self) -> Option<bool> { self.copy_enable_status }
    fn get_hidden(&self) -> Option<bool> { self.hidden }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ApplyProfileTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ApplyProfile => Some(from.as_any_ref().downcast_ref::<ApplyProfile>()?),
            StructType::ProfileApplyProfileElement => Some(from.as_any_ref().downcast_ref::<ProfileApplyProfileElement>()?),
            StructType::ActiveDirectoryProfile => Some(from.as_any_ref().downcast_ref::<ActiveDirectoryProfile>()?),
            StructType::AuthenticationProfile => Some(from.as_any_ref().downcast_ref::<AuthenticationProfile>()?),
            StructType::DateTimeProfile => Some(from.as_any_ref().downcast_ref::<DateTimeProfile>()?),
            StructType::DvsProfile => Some(from.as_any_ref().downcast_ref::<DvsProfile>()?),
            StructType::DvsVNicProfile => Some(from.as_any_ref().downcast_ref::<DvsVNicProfile>()?),
            StructType::DvsHostVNicProfile => Some(from.as_any_ref().downcast_ref::<DvsHostVNicProfile>()?),
            StructType::DvsServiceConsoleVNicProfile => Some(from.as_any_ref().downcast_ref::<DvsServiceConsoleVNicProfile>()?),
            StructType::FirewallProfile => Some(from.as_any_ref().downcast_ref::<FirewallProfile>()?),
            StructType::FirewallProfileRulesetProfile => Some(from.as_any_ref().downcast_ref::<FirewallProfileRulesetProfile>()?),
            StructType::HostApplyProfile => Some(from.as_any_ref().downcast_ref::<HostApplyProfile>()?),
            StructType::HostMemoryProfile => Some(from.as_any_ref().downcast_ref::<HostMemoryProfile>()?),
            StructType::IpAddressProfile => Some(from.as_any_ref().downcast_ref::<IpAddressProfile>()?),
            StructType::IpRouteProfile => Some(from.as_any_ref().downcast_ref::<IpRouteProfile>()?),
            StructType::NasStorageProfile => Some(from.as_any_ref().downcast_ref::<NasStorageProfile>()?),
            StructType::NetStackInstanceProfile => Some(from.as_any_ref().downcast_ref::<NetStackInstanceProfile>()?),
            StructType::NetworkPolicyProfile => Some(from.as_any_ref().downcast_ref::<NetworkPolicyProfile>()?),
            StructType::NetworkProfile => Some(from.as_any_ref().downcast_ref::<NetworkProfile>()?),
            StructType::NetworkProfileDnsConfigProfile => Some(from.as_any_ref().downcast_ref::<NetworkProfileDnsConfigProfile>()?),
            StructType::NsxHostVNicProfile => Some(from.as_any_ref().downcast_ref::<NsxHostVNicProfile>()?),
            StructType::OpaqueSwitchProfile => Some(from.as_any_ref().downcast_ref::<OpaqueSwitchProfile>()?),
            StructType::OptionProfile => Some(from.as_any_ref().downcast_ref::<OptionProfile>()?),
            StructType::PermissionProfile => Some(from.as_any_ref().downcast_ref::<PermissionProfile>()?),
            StructType::PhysicalNicProfile => Some(from.as_any_ref().downcast_ref::<PhysicalNicProfile>()?),
            StructType::PnicUplinkProfile => Some(from.as_any_ref().downcast_ref::<PnicUplinkProfile>()?),
            StructType::PortGroupProfile => Some(from.as_any_ref().downcast_ref::<PortGroupProfile>()?),
            StructType::HostPortGroupProfile => Some(from.as_any_ref().downcast_ref::<HostPortGroupProfile>()?),
            StructType::ServiceConsolePortGroupProfile => Some(from.as_any_ref().downcast_ref::<ServiceConsolePortGroupProfile>()?),
            StructType::VmPortGroupProfile => Some(from.as_any_ref().downcast_ref::<VmPortGroupProfile>()?),
            StructType::VirtualSwitchSelectionProfile => Some(from.as_any_ref().downcast_ref::<VirtualSwitchSelectionProfile>()?),
            StructType::VlanProfile => Some(from.as_any_ref().downcast_ref::<VlanProfile>()?),
            StructType::SecurityProfile => Some(from.as_any_ref().downcast_ref::<SecurityProfile>()?),
            StructType::ServiceProfile => Some(from.as_any_ref().downcast_ref::<ServiceProfile>()?),
            StructType::StaticRouteProfile => Some(from.as_any_ref().downcast_ref::<StaticRouteProfile>()?),
            StructType::StorageProfile => Some(from.as_any_ref().downcast_ref::<StorageProfile>()?),
            StructType::UserGroupProfile => Some(from.as_any_ref().downcast_ref::<UserGroupProfile>()?),
            StructType::UserProfile => Some(from.as_any_ref().downcast_ref::<UserProfile>()?),
            StructType::VirtualSwitchProfile => Some(from.as_any_ref().downcast_ref::<VirtualSwitchProfile>()?),
            StructType::LinkProfile => Some(from.as_any_ref().downcast_ref::<LinkProfile>()?),
            StructType::NumPortsProfile => Some(from.as_any_ref().downcast_ref::<NumPortsProfile>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ApplyProfile => Ok(from.as_any_box().downcast::<ApplyProfile>()?),
            StructType::ProfileApplyProfileElement => Ok(from.as_any_box().downcast::<ProfileApplyProfileElement>()?),
            StructType::ActiveDirectoryProfile => Ok(from.as_any_box().downcast::<ActiveDirectoryProfile>()?),
            StructType::AuthenticationProfile => Ok(from.as_any_box().downcast::<AuthenticationProfile>()?),
            StructType::DateTimeProfile => Ok(from.as_any_box().downcast::<DateTimeProfile>()?),
            StructType::DvsProfile => Ok(from.as_any_box().downcast::<DvsProfile>()?),
            StructType::DvsVNicProfile => Ok(from.as_any_box().downcast::<DvsVNicProfile>()?),
            StructType::DvsHostVNicProfile => Ok(from.as_any_box().downcast::<DvsHostVNicProfile>()?),
            StructType::DvsServiceConsoleVNicProfile => Ok(from.as_any_box().downcast::<DvsServiceConsoleVNicProfile>()?),
            StructType::FirewallProfile => Ok(from.as_any_box().downcast::<FirewallProfile>()?),
            StructType::FirewallProfileRulesetProfile => Ok(from.as_any_box().downcast::<FirewallProfileRulesetProfile>()?),
            StructType::HostApplyProfile => Ok(from.as_any_box().downcast::<HostApplyProfile>()?),
            StructType::HostMemoryProfile => Ok(from.as_any_box().downcast::<HostMemoryProfile>()?),
            StructType::IpAddressProfile => Ok(from.as_any_box().downcast::<IpAddressProfile>()?),
            StructType::IpRouteProfile => Ok(from.as_any_box().downcast::<IpRouteProfile>()?),
            StructType::NasStorageProfile => Ok(from.as_any_box().downcast::<NasStorageProfile>()?),
            StructType::NetStackInstanceProfile => Ok(from.as_any_box().downcast::<NetStackInstanceProfile>()?),
            StructType::NetworkPolicyProfile => Ok(from.as_any_box().downcast::<NetworkPolicyProfile>()?),
            StructType::NetworkProfile => Ok(from.as_any_box().downcast::<NetworkProfile>()?),
            StructType::NetworkProfileDnsConfigProfile => Ok(from.as_any_box().downcast::<NetworkProfileDnsConfigProfile>()?),
            StructType::NsxHostVNicProfile => Ok(from.as_any_box().downcast::<NsxHostVNicProfile>()?),
            StructType::OpaqueSwitchProfile => Ok(from.as_any_box().downcast::<OpaqueSwitchProfile>()?),
            StructType::OptionProfile => Ok(from.as_any_box().downcast::<OptionProfile>()?),
            StructType::PermissionProfile => Ok(from.as_any_box().downcast::<PermissionProfile>()?),
            StructType::PhysicalNicProfile => Ok(from.as_any_box().downcast::<PhysicalNicProfile>()?),
            StructType::PnicUplinkProfile => Ok(from.as_any_box().downcast::<PnicUplinkProfile>()?),
            StructType::PortGroupProfile => Ok(from.as_any_box().downcast::<PortGroupProfile>()?),
            StructType::HostPortGroupProfile => Ok(from.as_any_box().downcast::<HostPortGroupProfile>()?),
            StructType::ServiceConsolePortGroupProfile => Ok(from.as_any_box().downcast::<ServiceConsolePortGroupProfile>()?),
            StructType::VmPortGroupProfile => Ok(from.as_any_box().downcast::<VmPortGroupProfile>()?),
            StructType::VirtualSwitchSelectionProfile => Ok(from.as_any_box().downcast::<VirtualSwitchSelectionProfile>()?),
            StructType::VlanProfile => Ok(from.as_any_box().downcast::<VlanProfile>()?),
            StructType::SecurityProfile => Ok(from.as_any_box().downcast::<SecurityProfile>()?),
            StructType::ServiceProfile => Ok(from.as_any_box().downcast::<ServiceProfile>()?),
            StructType::StaticRouteProfile => Ok(from.as_any_box().downcast::<StaticRouteProfile>()?),
            StructType::StorageProfile => Ok(from.as_any_box().downcast::<StorageProfile>()?),
            StructType::UserGroupProfile => Ok(from.as_any_box().downcast::<UserGroupProfile>()?),
            StructType::UserProfile => Ok(from.as_any_box().downcast::<UserProfile>()?),
            StructType::VirtualSwitchProfile => Ok(from.as_any_box().downcast::<VirtualSwitchProfile>()?),
            StructType::LinkProfile => Ok(from.as_any_box().downcast::<LinkProfile>()?),
            StructType::NumPortsProfile => Ok(from.as_any_box().downcast::<NumPortsProfile>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *DvsVNicProfile* data object is the base object
/// for host and service console Virtual NIC subprofiles.
/// 
/// If a profile plug-in defines additional policies or subprofiles, use the
/// *ApplyProfile.policy* or *ApplyProfile.property*
/// list to access the configuration data.
pub trait DvsVNicProfileTrait : super::traits::ApplyProfileTrait {
    /// Linkable identifier.
    fn get_key(&self) -> &str;
    /// IP address for the Virtual NIC belonging to a distributed virtual switch.
    fn get_ip_config(&self) -> &IpAddressProfile;
}
impl<'s> serde::Serialize for dyn DvsVNicProfileTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DvsVNicProfileTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DvsVNicProfileVisitor)
            }
        }

struct DvsVNicProfileVisitor;

impl<'de> de::Visitor<'de> for DvsVNicProfileVisitor {
    type Value = Box<dyn DvsVNicProfileTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DvsVNicProfileTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DvsVNicProfileTrait for DvsVNicProfile {
    fn get_key(&self) -> &str { &self.key }
    fn get_ip_config(&self) -> &IpAddressProfile { &self.ip_config }
}
impl DvsVNicProfileTrait for DvsHostVNicProfile {
    fn get_key(&self) -> &str { &self.key }
    fn get_ip_config(&self) -> &IpAddressProfile { &self.ip_config }
}
impl DvsVNicProfileTrait for DvsServiceConsoleVNicProfile {
    fn get_key(&self) -> &str { &self.key }
    fn get_ip_config(&self) -> &IpAddressProfile { &self.ip_config }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DvsVNicProfileTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsVNicProfile => Some(from.as_any_ref().downcast_ref::<DvsVNicProfile>()?),
            StructType::DvsHostVNicProfile => Some(from.as_any_ref().downcast_ref::<DvsHostVNicProfile>()?),
            StructType::DvsServiceConsoleVNicProfile => Some(from.as_any_ref().downcast_ref::<DvsServiceConsoleVNicProfile>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsVNicProfile => Ok(from.as_any_box().downcast::<DvsVNicProfile>()?),
            StructType::DvsHostVNicProfile => Ok(from.as_any_box().downcast::<DvsHostVNicProfile>()?),
            StructType::DvsServiceConsoleVNicProfile => Ok(from.as_any_box().downcast::<DvsServiceConsoleVNicProfile>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// *PortGroupProfile* is the base class for the different port group
/// subprofile objects.
pub trait PortGroupProfileTrait : super::traits::ApplyProfileTrait {
    /// Linkable identifier.
    fn get_key(&self) -> &str;
    /// Name of the portgroup.
    fn get_name(&self) -> &str;
    /// VLAN identifier for the port group.
    fn get_vlan(&self) -> &VlanProfile;
    /// Virtual switch to which the port group is connected.
    fn get_vswitch(&self) -> &VirtualSwitchSelectionProfile;
    /// The network policy/policies applicable on the port group.
    fn get_network_policy(&self) -> &NetworkPolicyProfile;
}
impl<'s> serde::Serialize for dyn PortGroupProfileTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn PortGroupProfileTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(PortGroupProfileVisitor)
            }
        }

struct PortGroupProfileVisitor;

impl<'de> de::Visitor<'de> for PortGroupProfileVisitor {
    type Value = Box<dyn PortGroupProfileTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid PortGroupProfileTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl PortGroupProfileTrait for PortGroupProfile {
    fn get_key(&self) -> &str { &self.key }
    fn get_name(&self) -> &str { &self.name }
    fn get_vlan(&self) -> &VlanProfile { &self.vlan }
    fn get_vswitch(&self) -> &VirtualSwitchSelectionProfile { &self.vswitch }
    fn get_network_policy(&self) -> &NetworkPolicyProfile { &self.network_policy }
}
impl PortGroupProfileTrait for HostPortGroupProfile {
    fn get_key(&self) -> &str { &self.key }
    fn get_name(&self) -> &str { &self.name }
    fn get_vlan(&self) -> &VlanProfile { &self.vlan }
    fn get_vswitch(&self) -> &VirtualSwitchSelectionProfile { &self.vswitch }
    fn get_network_policy(&self) -> &NetworkPolicyProfile { &self.network_policy }
}
impl PortGroupProfileTrait for ServiceConsolePortGroupProfile {
    fn get_key(&self) -> &str { &self.key }
    fn get_name(&self) -> &str { &self.name }
    fn get_vlan(&self) -> &VlanProfile { &self.vlan }
    fn get_vswitch(&self) -> &VirtualSwitchSelectionProfile { &self.vswitch }
    fn get_network_policy(&self) -> &NetworkPolicyProfile { &self.network_policy }
}
impl PortGroupProfileTrait for VmPortGroupProfile {
    fn get_key(&self) -> &str { &self.key }
    fn get_name(&self) -> &str { &self.name }
    fn get_vlan(&self) -> &VlanProfile { &self.vlan }
    fn get_vswitch(&self) -> &VirtualSwitchSelectionProfile { &self.vswitch }
    fn get_network_policy(&self) -> &NetworkPolicyProfile { &self.network_policy }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn PortGroupProfileTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::PortGroupProfile => Some(from.as_any_ref().downcast_ref::<PortGroupProfile>()?),
            StructType::HostPortGroupProfile => Some(from.as_any_ref().downcast_ref::<HostPortGroupProfile>()?),
            StructType::ServiceConsolePortGroupProfile => Some(from.as_any_ref().downcast_ref::<ServiceConsolePortGroupProfile>()?),
            StructType::VmPortGroupProfile => Some(from.as_any_ref().downcast_ref::<VmPortGroupProfile>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::PortGroupProfile => Ok(from.as_any_box().downcast::<PortGroupProfile>()?),
            StructType::HostPortGroupProfile => Ok(from.as_any_box().downcast::<HostPortGroupProfile>()?),
            StructType::ServiceConsolePortGroupProfile => Ok(from.as_any_box().downcast::<ServiceConsolePortGroupProfile>()?),
            StructType::VmPortGroupProfile => Ok(from.as_any_box().downcast::<VmPortGroupProfile>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
pub trait ProfileExpressionTrait : super::traits::DataObjectTrait {
    /// Identifier of this expression.
    /// 
    /// The id has to be unique within a Profile.
    /// The id can be used as a key while building composite expressions.
    fn get_id(&self) -> &str;
    /// User visible display name
    fn get_display_name(&self) -> &str;
    /// Flag indicating if the condition of the expression should be negated.
    /// 
    /// e.g: conditions like VSwitch0 has vmnic0 connected to it can be turned into
    /// VSwitch0 doesn't have vmnic0 connected to it.
    fn get_negated(&self) -> bool;
}
impl<'s> serde::Serialize for dyn ProfileExpressionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ProfileExpressionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ProfileExpressionVisitor)
            }
        }

struct ProfileExpressionVisitor;

impl<'de> de::Visitor<'de> for ProfileExpressionVisitor {
    type Value = Box<dyn ProfileExpressionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ProfileExpressionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ProfileExpressionTrait for ProfileExpression {
    fn get_id(&self) -> &str { &self.id }
    fn get_display_name(&self) -> &str { &self.display_name }
    fn get_negated(&self) -> bool { self.negated }
}
impl ProfileExpressionTrait for ProfileCompositeExpression {
    fn get_id(&self) -> &str { &self.id }
    fn get_display_name(&self) -> &str { &self.display_name }
    fn get_negated(&self) -> bool { self.negated }
}
impl ProfileExpressionTrait for ProfileSimpleExpression {
    fn get_id(&self) -> &str { &self.id }
    fn get_display_name(&self) -> &str { &self.display_name }
    fn get_negated(&self) -> bool { self.negated }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ProfileExpressionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ProfileExpression => Some(from.as_any_ref().downcast_ref::<ProfileExpression>()?),
            StructType::ProfileCompositeExpression => Some(from.as_any_ref().downcast_ref::<ProfileCompositeExpression>()?),
            StructType::ProfileSimpleExpression => Some(from.as_any_ref().downcast_ref::<ProfileSimpleExpression>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ProfileExpression => Ok(from.as_any_box().downcast::<ProfileExpression>()?),
            StructType::ProfileCompositeExpression => Ok(from.as_any_box().downcast::<ProfileCompositeExpression>()?),
            StructType::ProfileSimpleExpression => Ok(from.as_any_box().downcast::<ProfileSimpleExpression>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *PolicyOption* data object represents one or more configuration
/// values.
/// 
/// A policy option is one of the configuration options from the
/// *ProfilePolicyMetadata*.*ProfilePolicyMetadata.possibleOption*
/// list.
pub trait PolicyOptionTrait : super::traits::DataObjectTrait {
    /// Identifier for the policy option.
    /// 
    /// This value matches one of the
    /// keys from the list of possible options in the policy metadata
    /// (*ProfilePolicyMetadata*.*ProfilePolicyMetadata.possibleOption*\[\].*ProfilePolicyOptionMetadata.id*.*ElementDescription.key*).
    fn get_id(&self) -> &str;
    /// Parameters for the policy option.
    /// 
    /// This list must include all parameters that are not marked as optional
    /// in the policy option metadata parameter list
    /// (*ProfilePolicyMetadata*.*ProfilePolicyMetadata.possibleOption*\[\].*ProfilePolicyOptionMetadata.parameter*\[\].*ProfileParameterMetadata.optional*).
    fn get_parameter(&self) -> &Option<Vec<KeyAnyValue>>;
}
impl<'s> serde::Serialize for dyn PolicyOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn PolicyOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(PolicyOptionVisitor)
            }
        }

struct PolicyOptionVisitor;

impl<'de> de::Visitor<'de> for PolicyOptionVisitor {
    type Value = Box<dyn PolicyOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid PolicyOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl PolicyOptionTrait for PolicyOption {
    fn get_id(&self) -> &str { &self.id }
    fn get_parameter(&self) -> &Option<Vec<KeyAnyValue>> { &self.parameter }
}
impl PolicyOptionTrait for CompositePolicyOption {
    fn get_id(&self) -> &str { &self.id }
    fn get_parameter(&self) -> &Option<Vec<KeyAnyValue>> { &self.parameter }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn PolicyOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::PolicyOption => Some(from.as_any_ref().downcast_ref::<PolicyOption>()?),
            StructType::CompositePolicyOption => Some(from.as_any_ref().downcast_ref::<CompositePolicyOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::PolicyOption => Ok(from.as_any_box().downcast::<PolicyOption>()?),
            StructType::CompositePolicyOption => Ok(from.as_any_box().downcast::<CompositePolicyOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *ProfilePolicyOptionMetadata* data object contains the metadata information
/// for a *PolicyOption*.
pub trait ProfilePolicyOptionMetadataTrait : super::traits::DataObjectTrait {
    /// Identifier for the policy option.
    /// - The <code>id.key</code> value
    ///   (*ExtendedElementDescription*.*ElementDescription.key*)
    ///   identifies the policy option type.
    /// - The <code>id.label</code> property
    ///   (*ExtendedElementDescription*.*Description.label*)
    ///   contains a brief localizable message describing the policy option.
    /// - The <code>id.summary</code> property
    ///   (*ExtendedElementDescription*.*Description.summary*)
    ///   contains a localizable summary of the policy option.
    ///   Summary information can contain embedded variable names which can
    ///   be replaced with values from the <code>parameter</code> property.
    fn get_id(&self) -> &ExtendedElementDescription;
    /// Metadata about the parameters for the policy option.
    fn get_parameter(&self) -> &Option<Vec<ProfileParameterMetadata>>;
}
impl<'s> serde::Serialize for dyn ProfilePolicyOptionMetadataTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ProfilePolicyOptionMetadataTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ProfilePolicyOptionMetadataVisitor)
            }
        }

struct ProfilePolicyOptionMetadataVisitor;

impl<'de> de::Visitor<'de> for ProfilePolicyOptionMetadataVisitor {
    type Value = Box<dyn ProfilePolicyOptionMetadataTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ProfilePolicyOptionMetadataTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ProfilePolicyOptionMetadataTrait for ProfilePolicyOptionMetadata {
    fn get_id(&self) -> &ExtendedElementDescription { &self.id }
    fn get_parameter(&self) -> &Option<Vec<ProfileParameterMetadata>> { &self.parameter }
}
impl ProfilePolicyOptionMetadataTrait for ProfileCompositePolicyOptionMetadata {
    fn get_id(&self) -> &ExtendedElementDescription { &self.id }
    fn get_parameter(&self) -> &Option<Vec<ProfileParameterMetadata>> { &self.parameter }
}
impl ProfilePolicyOptionMetadataTrait for UserInputRequiredParameterMetadata {
    fn get_id(&self) -> &ExtendedElementDescription { &self.id }
    fn get_parameter(&self) -> &Option<Vec<ProfileParameterMetadata>> { &self.parameter }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ProfilePolicyOptionMetadataTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ProfilePolicyOptionMetadata => Some(from.as_any_ref().downcast_ref::<ProfilePolicyOptionMetadata>()?),
            StructType::ProfileCompositePolicyOptionMetadata => Some(from.as_any_ref().downcast_ref::<ProfileCompositePolicyOptionMetadata>()?),
            StructType::UserInputRequiredParameterMetadata => Some(from.as_any_ref().downcast_ref::<UserInputRequiredParameterMetadata>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ProfilePolicyOptionMetadata => Ok(from.as_any_box().downcast::<ProfilePolicyOptionMetadata>()?),
            StructType::ProfileCompositePolicyOptionMetadata => Ok(from.as_any_box().downcast::<ProfileCompositePolicyOptionMetadata>()?),
            StructType::UserInputRequiredParameterMetadata => Ok(from.as_any_box().downcast::<UserInputRequiredParameterMetadata>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
pub trait ProfileConfigInfoTrait : super::traits::DataObjectTrait {
    /// Name of the profile
    fn get_name(&self) -> &str;
    /// User Provided description of the profile
    fn get_annotation(&self) -> &Option<String>;
    /// Flag indicating if the Profile is enabled
    fn get_enabled(&self) -> bool;
}
impl<'s> serde::Serialize for dyn ProfileConfigInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ProfileConfigInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ProfileConfigInfoVisitor)
            }
        }

struct ProfileConfigInfoVisitor;

impl<'de> de::Visitor<'de> for ProfileConfigInfoVisitor {
    type Value = Box<dyn ProfileConfigInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ProfileConfigInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ProfileConfigInfoTrait for ProfileConfigInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_annotation(&self) -> &Option<String> { &self.annotation }
    fn get_enabled(&self) -> bool { self.enabled }
}
impl ProfileConfigInfoTrait for ClusterProfileConfigInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_annotation(&self) -> &Option<String> { &self.annotation }
    fn get_enabled(&self) -> bool { self.enabled }
}
impl ProfileConfigInfoTrait for HostProfileConfigInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_annotation(&self) -> &Option<String> { &self.annotation }
    fn get_enabled(&self) -> bool { self.enabled }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ProfileConfigInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ProfileConfigInfo => Some(from.as_any_ref().downcast_ref::<ProfileConfigInfo>()?),
            StructType::ClusterProfileConfigInfo => Some(from.as_any_ref().downcast_ref::<ClusterProfileConfigInfo>()?),
            StructType::HostProfileConfigInfo => Some(from.as_any_ref().downcast_ref::<HostProfileConfigInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ProfileConfigInfo => Ok(from.as_any_box().downcast::<ProfileConfigInfo>()?),
            StructType::ClusterProfileConfigInfo => Ok(from.as_any_box().downcast::<ClusterProfileConfigInfo>()?),
            StructType::HostProfileConfigInfo => Ok(from.as_any_box().downcast::<HostProfileConfigInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Specification describing the parameters during Profile creation
pub trait ProfileCreateSpecTrait : super::traits::DataObjectTrait {
    /// Name of the profile
    fn get_name(&self) -> &Option<String>;
    /// User Provided description of the profile
    fn get_annotation(&self) -> &Option<String>;
    /// Flag indicating if the Profile is enabled
    fn get_enabled(&self) -> Option<bool>;
}
impl<'s> serde::Serialize for dyn ProfileCreateSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ProfileCreateSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ProfileCreateSpecVisitor)
            }
        }

struct ProfileCreateSpecVisitor;

impl<'de> de::Visitor<'de> for ProfileCreateSpecVisitor {
    type Value = Box<dyn ProfileCreateSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ProfileCreateSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ProfileCreateSpecTrait for ProfileCreateSpec {
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_annotation(&self) -> &Option<String> { &self.annotation }
    fn get_enabled(&self) -> Option<bool> { self.enabled }
}
impl ProfileCreateSpecTrait for ProfileSerializedCreateSpec {
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_annotation(&self) -> &Option<String> { &self.annotation }
    fn get_enabled(&self) -> Option<bool> { self.enabled }
}
impl ProfileCreateSpecTrait for HostProfileSerializedHostProfileSpec {
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_annotation(&self) -> &Option<String> { &self.annotation }
    fn get_enabled(&self) -> Option<bool> { self.enabled }
}
impl ProfileCreateSpecTrait for ClusterProfileCreateSpec {
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_annotation(&self) -> &Option<String> { &self.annotation }
    fn get_enabled(&self) -> Option<bool> { self.enabled }
}
impl ProfileCreateSpecTrait for ClusterProfileConfigSpec {
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_annotation(&self) -> &Option<String> { &self.annotation }
    fn get_enabled(&self) -> Option<bool> { self.enabled }
}
impl ProfileCreateSpecTrait for ClusterProfileCompleteConfigSpec {
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_annotation(&self) -> &Option<String> { &self.annotation }
    fn get_enabled(&self) -> Option<bool> { self.enabled }
}
impl ProfileCreateSpecTrait for ClusterProfileConfigServiceCreateSpec {
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_annotation(&self) -> &Option<String> { &self.annotation }
    fn get_enabled(&self) -> Option<bool> { self.enabled }
}
impl ProfileCreateSpecTrait for HostProfileConfigSpec {
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_annotation(&self) -> &Option<String> { &self.annotation }
    fn get_enabled(&self) -> Option<bool> { self.enabled }
}
impl ProfileCreateSpecTrait for HostProfileCompleteConfigSpec {
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_annotation(&self) -> &Option<String> { &self.annotation }
    fn get_enabled(&self) -> Option<bool> { self.enabled }
}
impl ProfileCreateSpecTrait for HostProfileHostBasedConfigSpec {
    fn get_name(&self) -> &Option<String> { &self.name }
    fn get_annotation(&self) -> &Option<String> { &self.annotation }
    fn get_enabled(&self) -> Option<bool> { self.enabled }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ProfileCreateSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ProfileCreateSpec => Some(from.as_any_ref().downcast_ref::<ProfileCreateSpec>()?),
            StructType::ProfileSerializedCreateSpec => Some(from.as_any_ref().downcast_ref::<ProfileSerializedCreateSpec>()?),
            StructType::HostProfileSerializedHostProfileSpec => Some(from.as_any_ref().downcast_ref::<HostProfileSerializedHostProfileSpec>()?),
            StructType::ClusterProfileCreateSpec => Some(from.as_any_ref().downcast_ref::<ClusterProfileCreateSpec>()?),
            StructType::ClusterProfileConfigSpec => Some(from.as_any_ref().downcast_ref::<ClusterProfileConfigSpec>()?),
            StructType::ClusterProfileCompleteConfigSpec => Some(from.as_any_ref().downcast_ref::<ClusterProfileCompleteConfigSpec>()?),
            StructType::ClusterProfileConfigServiceCreateSpec => Some(from.as_any_ref().downcast_ref::<ClusterProfileConfigServiceCreateSpec>()?),
            StructType::HostProfileConfigSpec => Some(from.as_any_ref().downcast_ref::<HostProfileConfigSpec>()?),
            StructType::HostProfileCompleteConfigSpec => Some(from.as_any_ref().downcast_ref::<HostProfileCompleteConfigSpec>()?),
            StructType::HostProfileHostBasedConfigSpec => Some(from.as_any_ref().downcast_ref::<HostProfileHostBasedConfigSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ProfileCreateSpec => Ok(from.as_any_box().downcast::<ProfileCreateSpec>()?),
            StructType::ProfileSerializedCreateSpec => Ok(from.as_any_box().downcast::<ProfileSerializedCreateSpec>()?),
            StructType::HostProfileSerializedHostProfileSpec => Ok(from.as_any_box().downcast::<HostProfileSerializedHostProfileSpec>()?),
            StructType::ClusterProfileCreateSpec => Ok(from.as_any_box().downcast::<ClusterProfileCreateSpec>()?),
            StructType::ClusterProfileConfigSpec => Ok(from.as_any_box().downcast::<ClusterProfileConfigSpec>()?),
            StructType::ClusterProfileCompleteConfigSpec => Ok(from.as_any_box().downcast::<ClusterProfileCompleteConfigSpec>()?),
            StructType::ClusterProfileConfigServiceCreateSpec => Ok(from.as_any_box().downcast::<ClusterProfileConfigServiceCreateSpec>()?),
            StructType::HostProfileConfigSpec => Ok(from.as_any_box().downcast::<HostProfileConfigSpec>()?),
            StructType::HostProfileCompleteConfigSpec => Ok(from.as_any_box().downcast::<HostProfileCompleteConfigSpec>()?),
            StructType::HostProfileHostBasedConfigSpec => Ok(from.as_any_box().downcast::<HostProfileHostBasedConfigSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *ProfileSerializedCreateSpec* data object
/// defines a string that contains a serialized representation of a host profile.
pub trait ProfileSerializedCreateSpecTrait : super::traits::ProfileCreateSpecTrait {
    /// Representation of the profile in the string form.
    fn get_profile_config_string(&self) -> &str;
}
impl<'s> serde::Serialize for dyn ProfileSerializedCreateSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ProfileSerializedCreateSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ProfileSerializedCreateSpecVisitor)
            }
        }

struct ProfileSerializedCreateSpecVisitor;

impl<'de> de::Visitor<'de> for ProfileSerializedCreateSpecVisitor {
    type Value = Box<dyn ProfileSerializedCreateSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ProfileSerializedCreateSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ProfileSerializedCreateSpecTrait for ProfileSerializedCreateSpec {
    fn get_profile_config_string(&self) -> &str { &self.profile_config_string }
}
impl ProfileSerializedCreateSpecTrait for HostProfileSerializedHostProfileSpec {
    fn get_profile_config_string(&self) -> &str { &self.profile_config_string }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ProfileSerializedCreateSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ProfileSerializedCreateSpec => Some(from.as_any_ref().downcast_ref::<ProfileSerializedCreateSpec>()?),
            StructType::HostProfileSerializedHostProfileSpec => Some(from.as_any_ref().downcast_ref::<HostProfileSerializedHostProfileSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ProfileSerializedCreateSpec => Ok(from.as_any_box().downcast::<ProfileSerializedCreateSpec>()?),
            StructType::HostProfileSerializedHostProfileSpec => Ok(from.as_any_box().downcast::<HostProfileSerializedHostProfileSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class for Cluster CreateSpecs
pub trait ClusterProfileCreateSpecTrait : super::traits::ProfileCreateSpecTrait {
}
impl<'s> serde::Serialize for dyn ClusterProfileCreateSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ClusterProfileCreateSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ClusterProfileCreateSpecVisitor)
            }
        }

struct ClusterProfileCreateSpecVisitor;

impl<'de> de::Visitor<'de> for ClusterProfileCreateSpecVisitor {
    type Value = Box<dyn ClusterProfileCreateSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ClusterProfileCreateSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ClusterProfileCreateSpecTrait for ClusterProfileCreateSpec {
}
impl ClusterProfileCreateSpecTrait for ClusterProfileConfigSpec {
}
impl ClusterProfileCreateSpecTrait for ClusterProfileCompleteConfigSpec {
}
impl ClusterProfileCreateSpecTrait for ClusterProfileConfigServiceCreateSpec {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ClusterProfileCreateSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterProfileCreateSpec => Some(from.as_any_ref().downcast_ref::<ClusterProfileCreateSpec>()?),
            StructType::ClusterProfileConfigSpec => Some(from.as_any_ref().downcast_ref::<ClusterProfileConfigSpec>()?),
            StructType::ClusterProfileCompleteConfigSpec => Some(from.as_any_ref().downcast_ref::<ClusterProfileCompleteConfigSpec>()?),
            StructType::ClusterProfileConfigServiceCreateSpec => Some(from.as_any_ref().downcast_ref::<ClusterProfileConfigServiceCreateSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterProfileCreateSpec => Ok(from.as_any_box().downcast::<ClusterProfileCreateSpec>()?),
            StructType::ClusterProfileConfigSpec => Ok(from.as_any_box().downcast::<ClusterProfileConfigSpec>()?),
            StructType::ClusterProfileCompleteConfigSpec => Ok(from.as_any_box().downcast::<ClusterProfileCompleteConfigSpec>()?),
            StructType::ClusterProfileConfigServiceCreateSpec => Ok(from.as_any_box().downcast::<ClusterProfileConfigServiceCreateSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// DataObject which is a baseclass for other configuration
/// specifications.
pub trait ClusterProfileConfigSpecTrait : super::traits::ClusterProfileCreateSpecTrait {
}
impl<'s> serde::Serialize for dyn ClusterProfileConfigSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ClusterProfileConfigSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ClusterProfileConfigSpecVisitor)
            }
        }

struct ClusterProfileConfigSpecVisitor;

impl<'de> de::Visitor<'de> for ClusterProfileConfigSpecVisitor {
    type Value = Box<dyn ClusterProfileConfigSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ClusterProfileConfigSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ClusterProfileConfigSpecTrait for ClusterProfileConfigSpec {
}
impl ClusterProfileConfigSpecTrait for ClusterProfileCompleteConfigSpec {
}
impl ClusterProfileConfigSpecTrait for ClusterProfileConfigServiceCreateSpec {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ClusterProfileConfigSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterProfileConfigSpec => Some(from.as_any_ref().downcast_ref::<ClusterProfileConfigSpec>()?),
            StructType::ClusterProfileCompleteConfigSpec => Some(from.as_any_ref().downcast_ref::<ClusterProfileCompleteConfigSpec>()?),
            StructType::ClusterProfileConfigServiceCreateSpec => Some(from.as_any_ref().downcast_ref::<ClusterProfileConfigServiceCreateSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ClusterProfileConfigSpec => Ok(from.as_any_box().downcast::<ClusterProfileConfigSpec>()?),
            StructType::ClusterProfileCompleteConfigSpec => Ok(from.as_any_box().downcast::<ClusterProfileCompleteConfigSpec>()?),
            StructType::ClusterProfileConfigServiceCreateSpec => Ok(from.as_any_box().downcast::<ClusterProfileConfigServiceCreateSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// *HostProfileConfigSpec* is the base data object
/// for all *HostProfile* configuration specifications.
pub trait HostProfileConfigSpecTrait : super::traits::ProfileCreateSpecTrait {
}
impl<'s> serde::Serialize for dyn HostProfileConfigSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostProfileConfigSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostProfileConfigSpecVisitor)
            }
        }

struct HostProfileConfigSpecVisitor;

impl<'de> de::Visitor<'de> for HostProfileConfigSpecVisitor {
    type Value = Box<dyn HostProfileConfigSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostProfileConfigSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostProfileConfigSpecTrait for HostProfileConfigSpec {
}
impl HostProfileConfigSpecTrait for HostProfileCompleteConfigSpec {
}
impl HostProfileConfigSpecTrait for HostProfileHostBasedConfigSpec {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostProfileConfigSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostProfileConfigSpec => Some(from.as_any_ref().downcast_ref::<HostProfileConfigSpec>()?),
            StructType::HostProfileCompleteConfigSpec => Some(from.as_any_ref().downcast_ref::<HostProfileCompleteConfigSpec>()?),
            StructType::HostProfileHostBasedConfigSpec => Some(from.as_any_ref().downcast_ref::<HostProfileHostBasedConfigSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostProfileConfigSpec => Ok(from.as_any_box().downcast::<HostProfileConfigSpec>()?),
            StructType::HostProfileCompleteConfigSpec => Ok(from.as_any_box().downcast::<HostProfileCompleteConfigSpec>()?),
            StructType::HostProfileHostBasedConfigSpec => Ok(from.as_any_box().downcast::<HostProfileHostBasedConfigSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *ProfileExecuteResult* data object contains the results from a
/// *HostProfile*.*HostProfile.ExecuteHostProfile*
/// operation.
pub trait ProfileExecuteResultTrait : super::traits::DataObjectTrait {
    /// Status of the profile execution operation.
    /// 
    /// The value is a string that contains
    /// one of the *ProfileExecuteResultStatus_enum* enumerations.
    fn get_status(&self) -> &str;
    /// Host configuration specification.
    /// 
    /// This data is valid only if
    /// the <code>status</code> value is <code>success</code>.
    /// See *ProfileExecuteResultStatus_enum*.
    /// 
    /// Use this data object when you apply the configuration
    /// to a host. See the <code>configSpec</code> parameter to the
    /// *HostProfileManager*.*HostProfileManager.ApplyHostConfig_Task*
    /// method.
    fn get_config_spec(&self) -> &Option<HostConfigSpec>;
    /// List of property paths.
    /// 
    /// Each path identifies a policy that does not apply
    /// to this host. For example, if the precheck policies for a port group are not satisfied,
    /// the port group will not be created when you apply the profile to the host.
    /// Based on this information, the client might not display that part of the profile tree.
    fn get_inapplicable_path(&self) -> &Option<Vec<String>>;
    /// List that describes the required input for host configuration and identifies
    /// any policy options that still require parameter data.
    /// 
    /// Each entry in the list
    /// specifies the path to a policy and a parameter list. If the call to
    /// *HostProfile.ExecuteHostProfile* includes deferred parameters,
    /// the <code>requireInput</code> entries
    /// (<code>requireInput\[\].</code>*ProfileDeferredPolicyOptionParameter.parameter*\[\])
    /// will be populated with the parameter data that was passed to the execute method.
    /// For policies that still require input data, the parameter list in the corresponding
    /// entry will be null.
    /// 
    /// A vSphere client that displays a GUI can use this information to show the host-specific
    /// configuration policy options. The client can highlight required input fields
    /// and ask the user for data in increments instead of collecting all of the input at once.
    /// For example, in the first pass, the client collects a minimum of user input and
    /// sends that to the Server. The Server evaluates the profile and might decide to
    /// invalidate a particular part of the subtree or enable a new
    /// subtree in the profile. This would result in a new set of invalid paths
    /// (*ProfileExecuteResult.inapplicablePath*\[\]) and
    /// required input property paths
    /// (*ProfileDeferredPolicyOptionParameter*.*ProfileDeferredPolicyOptionParameter.inputPath*).
    /// The client can make a series of calls to the method until it achieves a success status.
    /// 
    /// When *HostProfile.ExecuteHostProfile* returns a success status,
    /// the <code>requireInput</code> list contains the complete list of parameters,
    /// consisting of the following data:
    /// - Deferred parameter values resolved through successive calls to
    ///   *HostProfile.ExecuteHostProfile*.
    /// - Default parameter values from the host configuration.
    /// - User-specified values that override the defaults.
    ///   
    /// You can specify the returned <code>requireInput</code> list in the
    /// <code>userInput</code> parameter to the
    /// *HostProfileManager*.*HostProfileManager.ApplyHostConfig_Task*
    /// method. The Server will use the list to update the *AnswerFile*
    /// associated with the host.
    fn get_require_input(&self) -> &Option<Vec<ProfileDeferredPolicyOptionParameter>>;
    /// List of errors that were encountered during execute.
    /// 
    /// This field will be set if status is set to error.
    fn get_error(&self) -> &Option<Vec<ProfileExecuteError>>;
}
impl<'s> serde::Serialize for dyn ProfileExecuteResultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ProfileExecuteResultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ProfileExecuteResultVisitor)
            }
        }

struct ProfileExecuteResultVisitor;

impl<'de> de::Visitor<'de> for ProfileExecuteResultVisitor {
    type Value = Box<dyn ProfileExecuteResultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ProfileExecuteResultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ProfileExecuteResultTrait for ProfileExecuteResult {
    fn get_status(&self) -> &str { &self.status }
    fn get_config_spec(&self) -> &Option<HostConfigSpec> { &self.config_spec }
    fn get_inapplicable_path(&self) -> &Option<Vec<String>> { &self.inapplicable_path }
    fn get_require_input(&self) -> &Option<Vec<ProfileDeferredPolicyOptionParameter>> { &self.require_input }
    fn get_error(&self) -> &Option<Vec<ProfileExecuteError>> { &self.error }
}
impl ProfileExecuteResultTrait for ApplyHostProfileConfigurationSpec {
    fn get_status(&self) -> &str { &self.status }
    fn get_config_spec(&self) -> &Option<HostConfigSpec> { &self.config_spec }
    fn get_inapplicable_path(&self) -> &Option<Vec<String>> { &self.inapplicable_path }
    fn get_require_input(&self) -> &Option<Vec<ProfileDeferredPolicyOptionParameter>> { &self.require_input }
    fn get_error(&self) -> &Option<Vec<ProfileExecuteError>> { &self.error }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ProfileExecuteResultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ProfileExecuteResult => Some(from.as_any_ref().downcast_ref::<ProfileExecuteResult>()?),
            StructType::ApplyHostProfileConfigurationSpec => Some(from.as_any_ref().downcast_ref::<ApplyHostProfileConfigurationSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ProfileExecuteResult => Ok(from.as_any_box().downcast::<ProfileExecuteResult>()?),
            StructType::ApplyHostProfileConfigurationSpec => Ok(from.as_any_box().downcast::<ApplyHostProfileConfigurationSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class for host-specific answer file options.
pub trait AnswerFileCreateSpecTrait : super::traits::DataObjectTrait {
    /// If "false", then the answer file will be saved without being validated.
    /// 
    /// The default if not specified is "true".
    /// This option should be used with caution, since the resulting answer
    /// file will not be checked for errors.
    fn get_validating(&self) -> Option<bool>;
}
impl<'s> serde::Serialize for dyn AnswerFileCreateSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn AnswerFileCreateSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(AnswerFileCreateSpecVisitor)
            }
        }

struct AnswerFileCreateSpecVisitor;

impl<'de> de::Visitor<'de> for AnswerFileCreateSpecVisitor {
    type Value = Box<dyn AnswerFileCreateSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid AnswerFileCreateSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl AnswerFileCreateSpecTrait for AnswerFileCreateSpec {
    fn get_validating(&self) -> Option<bool> { self.validating }
}
impl AnswerFileCreateSpecTrait for AnswerFileOptionsCreateSpec {
    fn get_validating(&self) -> Option<bool> { self.validating }
}
impl AnswerFileCreateSpecTrait for AnswerFileSerializedCreateSpec {
    fn get_validating(&self) -> Option<bool> { self.validating }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn AnswerFileCreateSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::AnswerFileCreateSpec => Some(from.as_any_ref().downcast_ref::<AnswerFileCreateSpec>()?),
            StructType::AnswerFileOptionsCreateSpec => Some(from.as_any_ref().downcast_ref::<AnswerFileOptionsCreateSpec>()?),
            StructType::AnswerFileSerializedCreateSpec => Some(from.as_any_ref().downcast_ref::<AnswerFileSerializedCreateSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::AnswerFileCreateSpec => Ok(from.as_any_box().downcast::<AnswerFileCreateSpec>()?),
            StructType::AnswerFileOptionsCreateSpec => Ok(from.as_any_box().downcast::<AnswerFileOptionsCreateSpec>()?),
            StructType::AnswerFileSerializedCreateSpec => Ok(from.as_any_box().downcast::<AnswerFileSerializedCreateSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Data type used to contain a representation of host or cluster customization
/// data in a *HostProfilesCustomizationData* object.
/// 
/// Subclasses of this must be defined to provide host or cluster customization
/// data in specific formats.
pub trait HostProfilesEntityCustomizationsTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn HostProfilesEntityCustomizationsTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostProfilesEntityCustomizationsTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostProfilesEntityCustomizationsVisitor)
            }
        }

struct HostProfilesEntityCustomizationsVisitor;

impl<'de> de::Visitor<'de> for HostProfilesEntityCustomizationsVisitor {
    type Value = Box<dyn HostProfilesEntityCustomizationsTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostProfilesEntityCustomizationsTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostProfilesEntityCustomizationsTrait for HostProfilesEntityCustomizations {
}
impl HostProfilesEntityCustomizationsTrait for StructuredCustomizations {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostProfilesEntityCustomizationsTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostProfilesEntityCustomizations => Some(from.as_any_ref().downcast_ref::<HostProfilesEntityCustomizations>()?),
            StructType::StructuredCustomizations => Some(from.as_any_ref().downcast_ref::<StructuredCustomizations>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostProfilesEntityCustomizations => Ok(from.as_any_box().downcast::<HostProfilesEntityCustomizations>()?),
            StructType::StructuredCustomizations => Ok(from.as_any_box().downcast::<StructuredCustomizations>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Parameters for scheduled task creation.
pub trait ScheduledTaskSpecTrait : super::traits::DataObjectTrait {
    /// Name of the scheduled task.
    fn get_name(&self) -> &str;
    /// Description of the scheduled task.
    fn get_description(&self) -> &str;
    /// Flag to indicate whether the scheduled task is enabled or disabled.
    fn get_enabled(&self) -> bool;
    /// The time scheduler that determines when the scheduled task runs.
    fn get_scheduler(&self) -> &Box<dyn super::traits::TaskSchedulerTrait>;
    /// The action of the scheduled task, to be done when the scheduled task runs.
    fn get_action(&self) -> &Box<dyn super::traits::ActionTrait>;
    /// The email notification.
    /// 
    /// If not set, this property is set to empty string, indicating no notification.
    fn get_notification(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn ScheduledTaskSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ScheduledTaskSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ScheduledTaskSpecVisitor)
            }
        }

struct ScheduledTaskSpecVisitor;

impl<'de> de::Visitor<'de> for ScheduledTaskSpecVisitor {
    type Value = Box<dyn ScheduledTaskSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ScheduledTaskSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ScheduledTaskSpecTrait for ScheduledTaskSpec {
    fn get_name(&self) -> &str { &self.name }
    fn get_description(&self) -> &str { &self.description }
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_scheduler(&self) -> &Box<dyn super::traits::TaskSchedulerTrait> { &self.scheduler }
    fn get_action(&self) -> &Box<dyn super::traits::ActionTrait> { &self.action }
    fn get_notification(&self) -> &Option<String> { &self.notification }
}
impl ScheduledTaskSpecTrait for ScheduledTaskInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_description(&self) -> &str { &self.description }
    fn get_enabled(&self) -> bool { self.enabled }
    fn get_scheduler(&self) -> &Box<dyn super::traits::TaskSchedulerTrait> { &self.scheduler }
    fn get_action(&self) -> &Box<dyn super::traits::ActionTrait> { &self.action }
    fn get_notification(&self) -> &Option<String> { &self.notification }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ScheduledTaskSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ScheduledTaskSpec => Some(from.as_any_ref().downcast_ref::<ScheduledTaskSpec>()?),
            StructType::ScheduledTaskInfo => Some(from.as_any_ref().downcast_ref::<ScheduledTaskInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ScheduledTaskSpec => Ok(from.as_any_box().downcast::<ScheduledTaskSpec>()?),
            StructType::ScheduledTaskInfo => Ok(from.as_any_box().downcast::<ScheduledTaskInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *TaskScheduler* data object is the base type for the scheduler objects.
/// 
/// The hierarchy of scheduler objects is as follows:
/// 
///         TaskScheduler
///             *AfterStartupTaskScheduler*
///             *OnceTaskScheduler*
///             *RecurrentTaskScheduler*
///                 *HourlyTaskScheduler*
///                     *DailyTaskScheduler*
///                         *WeeklyTaskScheduler*
///                         *MonthlyTaskScheduler*
///                             *MonthlyByDayTaskScheduler*
///                             *MonthlyByWeekdayTaskScheduler*
/// 
/// Use a scheduler object to set the time(s) for task execution.
/// You can use two scheduling modes - single execution or
/// recurring execution:
/// - Use the *AfterStartupTaskScheduler* or the *OnceTaskScheduler*
///   to schedule a single instance of task execution.
/// - Use one of the recurrent task schedulers to schedule
///   hourly, daily, weekly, or monthly task execution.
///   
/// After you have established the task timing, use the scheduler
/// object for the *ScheduledTaskSpec*
/// *ScheduledTaskSpec.scheduler* property value.
pub trait TaskSchedulerTrait : super::traits::DataObjectTrait {
    /// The time that the schedule for the task takes effect.
    /// 
    /// Task activation is distinct from task execution.
    /// When you activate a task, its schedule starts,
    /// and when the next execution time occurs, the task will run.
    /// If you do not set activeTime, the activation time defaults to
    /// the time that you create the scheduled task.
    fn get_active_time(&self) -> &Option<String>;
    /// The time the schedule for the task expires.
    /// 
    /// If you do not set expireTime, the schedule does not expire.
    fn get_expire_time(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn TaskSchedulerTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn TaskSchedulerTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(TaskSchedulerVisitor)
            }
        }

struct TaskSchedulerVisitor;

impl<'de> de::Visitor<'de> for TaskSchedulerVisitor {
    type Value = Box<dyn TaskSchedulerTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid TaskSchedulerTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl TaskSchedulerTrait for TaskScheduler {
    fn get_active_time(&self) -> &Option<String> { &self.active_time }
    fn get_expire_time(&self) -> &Option<String> { &self.expire_time }
}
impl TaskSchedulerTrait for AfterStartupTaskScheduler {
    fn get_active_time(&self) -> &Option<String> { &self.active_time }
    fn get_expire_time(&self) -> &Option<String> { &self.expire_time }
}
impl TaskSchedulerTrait for OnceTaskScheduler {
    fn get_active_time(&self) -> &Option<String> { &self.active_time }
    fn get_expire_time(&self) -> &Option<String> { &self.expire_time }
}
impl TaskSchedulerTrait for RecurrentTaskScheduler {
    fn get_active_time(&self) -> &Option<String> { &self.active_time }
    fn get_expire_time(&self) -> &Option<String> { &self.expire_time }
}
impl TaskSchedulerTrait for HourlyTaskScheduler {
    fn get_active_time(&self) -> &Option<String> { &self.active_time }
    fn get_expire_time(&self) -> &Option<String> { &self.expire_time }
}
impl TaskSchedulerTrait for DailyTaskScheduler {
    fn get_active_time(&self) -> &Option<String> { &self.active_time }
    fn get_expire_time(&self) -> &Option<String> { &self.expire_time }
}
impl TaskSchedulerTrait for MonthlyTaskScheduler {
    fn get_active_time(&self) -> &Option<String> { &self.active_time }
    fn get_expire_time(&self) -> &Option<String> { &self.expire_time }
}
impl TaskSchedulerTrait for MonthlyByDayTaskScheduler {
    fn get_active_time(&self) -> &Option<String> { &self.active_time }
    fn get_expire_time(&self) -> &Option<String> { &self.expire_time }
}
impl TaskSchedulerTrait for MonthlyByWeekdayTaskScheduler {
    fn get_active_time(&self) -> &Option<String> { &self.active_time }
    fn get_expire_time(&self) -> &Option<String> { &self.expire_time }
}
impl TaskSchedulerTrait for WeeklyTaskScheduler {
    fn get_active_time(&self) -> &Option<String> { &self.active_time }
    fn get_expire_time(&self) -> &Option<String> { &self.expire_time }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn TaskSchedulerTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::TaskScheduler => Some(from.as_any_ref().downcast_ref::<TaskScheduler>()?),
            StructType::AfterStartupTaskScheduler => Some(from.as_any_ref().downcast_ref::<AfterStartupTaskScheduler>()?),
            StructType::OnceTaskScheduler => Some(from.as_any_ref().downcast_ref::<OnceTaskScheduler>()?),
            StructType::RecurrentTaskScheduler => Some(from.as_any_ref().downcast_ref::<RecurrentTaskScheduler>()?),
            StructType::HourlyTaskScheduler => Some(from.as_any_ref().downcast_ref::<HourlyTaskScheduler>()?),
            StructType::DailyTaskScheduler => Some(from.as_any_ref().downcast_ref::<DailyTaskScheduler>()?),
            StructType::MonthlyTaskScheduler => Some(from.as_any_ref().downcast_ref::<MonthlyTaskScheduler>()?),
            StructType::MonthlyByDayTaskScheduler => Some(from.as_any_ref().downcast_ref::<MonthlyByDayTaskScheduler>()?),
            StructType::MonthlyByWeekdayTaskScheduler => Some(from.as_any_ref().downcast_ref::<MonthlyByWeekdayTaskScheduler>()?),
            StructType::WeeklyTaskScheduler => Some(from.as_any_ref().downcast_ref::<WeeklyTaskScheduler>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::TaskScheduler => Ok(from.as_any_box().downcast::<TaskScheduler>()?),
            StructType::AfterStartupTaskScheduler => Ok(from.as_any_box().downcast::<AfterStartupTaskScheduler>()?),
            StructType::OnceTaskScheduler => Ok(from.as_any_box().downcast::<OnceTaskScheduler>()?),
            StructType::RecurrentTaskScheduler => Ok(from.as_any_box().downcast::<RecurrentTaskScheduler>()?),
            StructType::HourlyTaskScheduler => Ok(from.as_any_box().downcast::<HourlyTaskScheduler>()?),
            StructType::DailyTaskScheduler => Ok(from.as_any_box().downcast::<DailyTaskScheduler>()?),
            StructType::MonthlyTaskScheduler => Ok(from.as_any_box().downcast::<MonthlyTaskScheduler>()?),
            StructType::MonthlyByDayTaskScheduler => Ok(from.as_any_box().downcast::<MonthlyByDayTaskScheduler>()?),
            StructType::MonthlyByWeekdayTaskScheduler => Ok(from.as_any_box().downcast::<MonthlyByWeekdayTaskScheduler>()?),
            StructType::WeeklyTaskScheduler => Ok(from.as_any_box().downcast::<WeeklyTaskScheduler>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *RecurrentTaskScheduler* data object is the base type for
/// the hierarchy that includes hourly, daily, weekly, and monthly task schedulers.
pub trait RecurrentTaskSchedulerTrait : super::traits::TaskSchedulerTrait {
    /// How often to run the scheduled task.
    /// 
    /// The value must be greater than
    /// or equal to 1 and less than 1000. The default value is 1.
    /// The interval acts as a multiplier for the unit of time associated
    /// with a particular scheduler (hours, days, weeks, or months).
    /// For example, setting the *HourlyTaskScheduler* interval
    /// to 4 causes the task to run every 4 hours.
    fn get_interval(&self) -> i32;
}
impl<'s> serde::Serialize for dyn RecurrentTaskSchedulerTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn RecurrentTaskSchedulerTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(RecurrentTaskSchedulerVisitor)
            }
        }

struct RecurrentTaskSchedulerVisitor;

impl<'de> de::Visitor<'de> for RecurrentTaskSchedulerVisitor {
    type Value = Box<dyn RecurrentTaskSchedulerTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid RecurrentTaskSchedulerTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl RecurrentTaskSchedulerTrait for RecurrentTaskScheduler {
    fn get_interval(&self) -> i32 { self.interval }
}
impl RecurrentTaskSchedulerTrait for HourlyTaskScheduler {
    fn get_interval(&self) -> i32 { self.interval }
}
impl RecurrentTaskSchedulerTrait for DailyTaskScheduler {
    fn get_interval(&self) -> i32 { self.interval }
}
impl RecurrentTaskSchedulerTrait for MonthlyTaskScheduler {
    fn get_interval(&self) -> i32 { self.interval }
}
impl RecurrentTaskSchedulerTrait for MonthlyByDayTaskScheduler {
    fn get_interval(&self) -> i32 { self.interval }
}
impl RecurrentTaskSchedulerTrait for MonthlyByWeekdayTaskScheduler {
    fn get_interval(&self) -> i32 { self.interval }
}
impl RecurrentTaskSchedulerTrait for WeeklyTaskScheduler {
    fn get_interval(&self) -> i32 { self.interval }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn RecurrentTaskSchedulerTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::RecurrentTaskScheduler => Some(from.as_any_ref().downcast_ref::<RecurrentTaskScheduler>()?),
            StructType::HourlyTaskScheduler => Some(from.as_any_ref().downcast_ref::<HourlyTaskScheduler>()?),
            StructType::DailyTaskScheduler => Some(from.as_any_ref().downcast_ref::<DailyTaskScheduler>()?),
            StructType::MonthlyTaskScheduler => Some(from.as_any_ref().downcast_ref::<MonthlyTaskScheduler>()?),
            StructType::MonthlyByDayTaskScheduler => Some(from.as_any_ref().downcast_ref::<MonthlyByDayTaskScheduler>()?),
            StructType::MonthlyByWeekdayTaskScheduler => Some(from.as_any_ref().downcast_ref::<MonthlyByWeekdayTaskScheduler>()?),
            StructType::WeeklyTaskScheduler => Some(from.as_any_ref().downcast_ref::<WeeklyTaskScheduler>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::RecurrentTaskScheduler => Ok(from.as_any_box().downcast::<RecurrentTaskScheduler>()?),
            StructType::HourlyTaskScheduler => Ok(from.as_any_box().downcast::<HourlyTaskScheduler>()?),
            StructType::DailyTaskScheduler => Ok(from.as_any_box().downcast::<DailyTaskScheduler>()?),
            StructType::MonthlyTaskScheduler => Ok(from.as_any_box().downcast::<MonthlyTaskScheduler>()?),
            StructType::MonthlyByDayTaskScheduler => Ok(from.as_any_box().downcast::<MonthlyByDayTaskScheduler>()?),
            StructType::MonthlyByWeekdayTaskScheduler => Ok(from.as_any_box().downcast::<MonthlyByWeekdayTaskScheduler>()?),
            StructType::WeeklyTaskScheduler => Ok(from.as_any_box().downcast::<WeeklyTaskScheduler>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *HourlyTaskScheduler* data object sets the time for hourly
/// task execution.
/// 
/// By default, the scheduled task will run once every hour,
/// at the specified minute.
/// 
/// If you set the interval to a value greater than 1, the task will
/// execute at the specified hourly interval. (For example, an interval
/// of 2 will cause the task to execute at the specified minute every 2 hours.)
pub trait HourlyTaskSchedulerTrait : super::traits::RecurrentTaskSchedulerTrait {
    /// The minute at which the *RecurrentTaskScheduler* runs
    /// the task.
    /// 
    /// Specify the minute value as a UTC (Coordinated Universal Time)
    /// value in the range 0 to 59.
    /// 
    /// For vCenter 2.x and prior releases, use the server's local time.
    /// For example, use Australia Northern Territory (UTC +9:30) or Indian (UTC +5:30)
    /// time values, rather than a UTC value.
    fn get_minute(&self) -> i32;
}
impl<'s> serde::Serialize for dyn HourlyTaskSchedulerTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HourlyTaskSchedulerTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HourlyTaskSchedulerVisitor)
            }
        }

struct HourlyTaskSchedulerVisitor;

impl<'de> de::Visitor<'de> for HourlyTaskSchedulerVisitor {
    type Value = Box<dyn HourlyTaskSchedulerTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HourlyTaskSchedulerTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HourlyTaskSchedulerTrait for HourlyTaskScheduler {
    fn get_minute(&self) -> i32 { self.minute }
}
impl HourlyTaskSchedulerTrait for DailyTaskScheduler {
    fn get_minute(&self) -> i32 { self.minute }
}
impl HourlyTaskSchedulerTrait for MonthlyTaskScheduler {
    fn get_minute(&self) -> i32 { self.minute }
}
impl HourlyTaskSchedulerTrait for MonthlyByDayTaskScheduler {
    fn get_minute(&self) -> i32 { self.minute }
}
impl HourlyTaskSchedulerTrait for MonthlyByWeekdayTaskScheduler {
    fn get_minute(&self) -> i32 { self.minute }
}
impl HourlyTaskSchedulerTrait for WeeklyTaskScheduler {
    fn get_minute(&self) -> i32 { self.minute }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HourlyTaskSchedulerTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HourlyTaskScheduler => Some(from.as_any_ref().downcast_ref::<HourlyTaskScheduler>()?),
            StructType::DailyTaskScheduler => Some(from.as_any_ref().downcast_ref::<DailyTaskScheduler>()?),
            StructType::MonthlyTaskScheduler => Some(from.as_any_ref().downcast_ref::<MonthlyTaskScheduler>()?),
            StructType::MonthlyByDayTaskScheduler => Some(from.as_any_ref().downcast_ref::<MonthlyByDayTaskScheduler>()?),
            StructType::MonthlyByWeekdayTaskScheduler => Some(from.as_any_ref().downcast_ref::<MonthlyByWeekdayTaskScheduler>()?),
            StructType::WeeklyTaskScheduler => Some(from.as_any_ref().downcast_ref::<WeeklyTaskScheduler>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HourlyTaskScheduler => Ok(from.as_any_box().downcast::<HourlyTaskScheduler>()?),
            StructType::DailyTaskScheduler => Ok(from.as_any_box().downcast::<DailyTaskScheduler>()?),
            StructType::MonthlyTaskScheduler => Ok(from.as_any_box().downcast::<MonthlyTaskScheduler>()?),
            StructType::MonthlyByDayTaskScheduler => Ok(from.as_any_box().downcast::<MonthlyByDayTaskScheduler>()?),
            StructType::MonthlyByWeekdayTaskScheduler => Ok(from.as_any_box().downcast::<MonthlyByWeekdayTaskScheduler>()?),
            StructType::WeeklyTaskScheduler => Ok(from.as_any_box().downcast::<WeeklyTaskScheduler>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *DailyTaskScheduler* data object sets the time for daily
/// task execution.
/// 
/// You set the hour and the inherited minute
/// property to complete the schedule. By default, the scheduled task
/// will run once every day at the specified hour and minute.
/// 
/// If you set the interval to a value greater than 1, the task will
/// execute at the specified daily interval. (For example, an interval
/// of 2 will cause the task to execute at the specified hour and minute
/// every 2 days.)
pub trait DailyTaskSchedulerTrait : super::traits::HourlyTaskSchedulerTrait {
    /// The hour at which the *RecurrentTaskScheduler* runs the task.
    /// 
    /// Use UTC (Coordinated Universal Time) values in the range
    /// 0 to 23, where 0 = 12:00 a.m. (UTC) and 12 = 12:00 p.m. (UTC).
    /// 
    /// For vCenter 2.x and prior releases, use the server's local time.
    /// For example, use Eastern Standard Time (EST) or Pacific Daylight Time (PDT),
    /// rather than UTC.
    fn get_hour(&self) -> i32;
}
impl<'s> serde::Serialize for dyn DailyTaskSchedulerTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DailyTaskSchedulerTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DailyTaskSchedulerVisitor)
            }
        }

struct DailyTaskSchedulerVisitor;

impl<'de> de::Visitor<'de> for DailyTaskSchedulerVisitor {
    type Value = Box<dyn DailyTaskSchedulerTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DailyTaskSchedulerTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DailyTaskSchedulerTrait for DailyTaskScheduler {
    fn get_hour(&self) -> i32 { self.hour }
}
impl DailyTaskSchedulerTrait for MonthlyTaskScheduler {
    fn get_hour(&self) -> i32 { self.hour }
}
impl DailyTaskSchedulerTrait for MonthlyByDayTaskScheduler {
    fn get_hour(&self) -> i32 { self.hour }
}
impl DailyTaskSchedulerTrait for MonthlyByWeekdayTaskScheduler {
    fn get_hour(&self) -> i32 { self.hour }
}
impl DailyTaskSchedulerTrait for WeeklyTaskScheduler {
    fn get_hour(&self) -> i32 { self.hour }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DailyTaskSchedulerTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DailyTaskScheduler => Some(from.as_any_ref().downcast_ref::<DailyTaskScheduler>()?),
            StructType::MonthlyTaskScheduler => Some(from.as_any_ref().downcast_ref::<MonthlyTaskScheduler>()?),
            StructType::MonthlyByDayTaskScheduler => Some(from.as_any_ref().downcast_ref::<MonthlyByDayTaskScheduler>()?),
            StructType::MonthlyByWeekdayTaskScheduler => Some(from.as_any_ref().downcast_ref::<MonthlyByWeekdayTaskScheduler>()?),
            StructType::WeeklyTaskScheduler => Some(from.as_any_ref().downcast_ref::<WeeklyTaskScheduler>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DailyTaskScheduler => Ok(from.as_any_box().downcast::<DailyTaskScheduler>()?),
            StructType::MonthlyTaskScheduler => Ok(from.as_any_box().downcast::<MonthlyTaskScheduler>()?),
            StructType::MonthlyByDayTaskScheduler => Ok(from.as_any_box().downcast::<MonthlyByDayTaskScheduler>()?),
            StructType::MonthlyByWeekdayTaskScheduler => Ok(from.as_any_box().downcast::<MonthlyByWeekdayTaskScheduler>()?),
            StructType::WeeklyTaskScheduler => Ok(from.as_any_box().downcast::<WeeklyTaskScheduler>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *MonthlyTaskScheduler* data object is the base type for
/// the monthly schedulers (*MonthlyByDayTaskScheduler* and
/// *MonthlyByWeekdayTaskScheduler*).
pub trait MonthlyTaskSchedulerTrait : super::traits::DailyTaskSchedulerTrait {
}
impl<'s> serde::Serialize for dyn MonthlyTaskSchedulerTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn MonthlyTaskSchedulerTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(MonthlyTaskSchedulerVisitor)
            }
        }

struct MonthlyTaskSchedulerVisitor;

impl<'de> de::Visitor<'de> for MonthlyTaskSchedulerVisitor {
    type Value = Box<dyn MonthlyTaskSchedulerTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid MonthlyTaskSchedulerTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl MonthlyTaskSchedulerTrait for MonthlyTaskScheduler {
}
impl MonthlyTaskSchedulerTrait for MonthlyByDayTaskScheduler {
}
impl MonthlyTaskSchedulerTrait for MonthlyByWeekdayTaskScheduler {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn MonthlyTaskSchedulerTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::MonthlyTaskScheduler => Some(from.as_any_ref().downcast_ref::<MonthlyTaskScheduler>()?),
            StructType::MonthlyByDayTaskScheduler => Some(from.as_any_ref().downcast_ref::<MonthlyByDayTaskScheduler>()?),
            StructType::MonthlyByWeekdayTaskScheduler => Some(from.as_any_ref().downcast_ref::<MonthlyByWeekdayTaskScheduler>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::MonthlyTaskScheduler => Ok(from.as_any_box().downcast::<MonthlyTaskScheduler>()?),
            StructType::MonthlyByDayTaskScheduler => Ok(from.as_any_box().downcast::<MonthlyByDayTaskScheduler>()?),
            StructType::MonthlyByWeekdayTaskScheduler => Ok(from.as_any_box().downcast::<MonthlyByWeekdayTaskScheduler>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// VM Configuration.
pub trait VmConfigInfoTrait : super::traits::DataObjectTrait {
    /// Information about the package content.
    fn get_product(&self) -> &Option<Vec<VAppProductInfo>>;
    /// List of properties
    fn get_property(&self) -> &Option<Vec<VAppPropertyInfo>>;
    /// IP assignment policy and DHCP support configuration.
    fn get_ip_assignment(&self) -> &VAppIpAssignmentInfo;
    /// End User Liceses Agreements.
    fn get_eula(&self) -> &Option<Vec<String>>;
    /// List of uninterpreted OVF meta-data sections.
    fn get_ovf_section(&self) -> &Option<Vec<VAppOvfSectionInfo>>;
    /// List the transports to use for properties.
    /// 
    /// Supported values are: iso and
    /// com.vmware.guestInfo.
    fn get_ovf_environment_transport(&self) -> &Option<Vec<String>>;
    /// Specifies whether the VM needs an initial boot before the deployment is complete.
    /// 
    /// Not relevant for vApps. This means that the value is always false when reading the
    /// configuration and is ignored when setting the configuration.
    /// 
    /// If a vApp requires an install boot (because one of its VMs does), this is visible
    /// on the *VirtualAppSummary.installBootRequired* field of the vApp.
    fn get_install_boot_required(&self) -> bool;
    /// Specifies the delay in seconds to wait for the VM to power off after the initial
    /// boot (used only if installBootRequired is true).
    /// 
    /// A value of 0 means wait forever.
    /// 
    /// Not relevant for vApps. This means that the value is always false when reading the
    /// configuration and is ignored when setting the configuration.
    fn get_install_boot_stop_delay(&self) -> i32;
}
impl<'s> serde::Serialize for dyn VmConfigInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VmConfigInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VmConfigInfoVisitor)
            }
        }

struct VmConfigInfoVisitor;

impl<'de> de::Visitor<'de> for VmConfigInfoVisitor {
    type Value = Box<dyn VmConfigInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VmConfigInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VmConfigInfoTrait for VmConfigInfo {
    fn get_product(&self) -> &Option<Vec<VAppProductInfo>> { &self.product }
    fn get_property(&self) -> &Option<Vec<VAppPropertyInfo>> { &self.property }
    fn get_ip_assignment(&self) -> &VAppIpAssignmentInfo { &self.ip_assignment }
    fn get_eula(&self) -> &Option<Vec<String>> { &self.eula }
    fn get_ovf_section(&self) -> &Option<Vec<VAppOvfSectionInfo>> { &self.ovf_section }
    fn get_ovf_environment_transport(&self) -> &Option<Vec<String>> { &self.ovf_environment_transport }
    fn get_install_boot_required(&self) -> bool { self.install_boot_required }
    fn get_install_boot_stop_delay(&self) -> i32 { self.install_boot_stop_delay }
}
impl VmConfigInfoTrait for VAppConfigInfo {
    fn get_product(&self) -> &Option<Vec<VAppProductInfo>> { &self.product }
    fn get_property(&self) -> &Option<Vec<VAppPropertyInfo>> { &self.property }
    fn get_ip_assignment(&self) -> &VAppIpAssignmentInfo { &self.ip_assignment }
    fn get_eula(&self) -> &Option<Vec<String>> { &self.eula }
    fn get_ovf_section(&self) -> &Option<Vec<VAppOvfSectionInfo>> { &self.ovf_section }
    fn get_ovf_environment_transport(&self) -> &Option<Vec<String>> { &self.ovf_environment_transport }
    fn get_install_boot_required(&self) -> bool { self.install_boot_required }
    fn get_install_boot_stop_delay(&self) -> i32 { self.install_boot_stop_delay }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VmConfigInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmConfigInfo => Some(from.as_any_ref().downcast_ref::<VmConfigInfo>()?),
            StructType::VAppConfigInfo => Some(from.as_any_ref().downcast_ref::<VAppConfigInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmConfigInfo => Ok(from.as_any_box().downcast::<VmConfigInfo>()?),
            StructType::VAppConfigInfo => Ok(from.as_any_box().downcast::<VAppConfigInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// vApp related configuration of a VM.
pub trait VmConfigSpecTrait : super::traits::DataObjectTrait {
    /// Information about the product.
    /// 
    /// Reconfigure privilege: VApp.ApplicationConfig
    fn get_product(&self) -> &Option<Vec<VAppProductSpec>>;
    /// List of properties.
    /// 
    /// Adding and editing properties requires various privileges depending on which fields
    /// are affected. See *VAppPropertyInfo* for details.
    /// 
    /// Deleting properties requires the privilege VApp.ApplicationConfig.
    fn get_property(&self) -> &Option<Vec<VAppPropertySpec>>;
    /// IP assignment policy and DHCP support configuration.
    /// 
    /// Reconfigure privilege: See *VAppIPAssignmentInfo*
    fn get_ip_assignment(&self) -> &Option<VAppIpAssignmentInfo>;
    /// End User Liceses Agreements.
    /// 
    /// If this list is set, it replaces all exiting licenses. An empty list will not
    /// make any changes to installed licenses. A list with a single element {""} will
    /// remove all licenses and leave an empty list.
    /// 
    /// Reconfigure privilege: VApp.ApplicationConfig
    fn get_eula(&self) -> &Option<Vec<String>>;
    /// List of uninterpreted OVF meta-data sections.
    /// 
    /// Reconfigure privilege: VApp.ApplicationConfig
    fn get_ovf_section(&self) -> &Option<Vec<VAppOvfSectionSpec>>;
    /// List the transports to use for properties.
    /// 
    /// Supported values are: iso and
    /// com.vmware.guestInfo.
    /// 
    /// If this list is set, it replaces all exiting entries. An empty list will not make
    /// any changes. A list with a single element {""} will clear the list of transports.
    /// 
    /// Reconfigure privilege: VApp.ApplicationConfig
    fn get_ovf_environment_transport(&self) -> &Option<Vec<String>>;
    /// If this is on a VirtualMachine object, it specifies whether the VM needs an
    /// initial boot before the deployment is complete.
    /// 
    /// If this is on a vApp object,
    /// it indicates than one or more VMs needs an initial reboot. This flag is
    /// automatically reset once the reboot has happened.
    /// 
    /// Reconfigure privilege: VApp.ApplicationConfig
    fn get_install_boot_required(&self) -> Option<bool>;
    /// Specifies the delay in seconds to wait for the VM to power off after the initial
    /// boot (used only if installBootRequired is true).
    /// 
    /// A value of 0 means wait forever.
    /// 
    /// Reconfigure privilege: VApp.ApplicationConfig
    fn get_install_boot_stop_delay(&self) -> Option<i32>;
}
impl<'s> serde::Serialize for dyn VmConfigSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VmConfigSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VmConfigSpecVisitor)
            }
        }

struct VmConfigSpecVisitor;

impl<'de> de::Visitor<'de> for VmConfigSpecVisitor {
    type Value = Box<dyn VmConfigSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VmConfigSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VmConfigSpecTrait for VmConfigSpec {
    fn get_product(&self) -> &Option<Vec<VAppProductSpec>> { &self.product }
    fn get_property(&self) -> &Option<Vec<VAppPropertySpec>> { &self.property }
    fn get_ip_assignment(&self) -> &Option<VAppIpAssignmentInfo> { &self.ip_assignment }
    fn get_eula(&self) -> &Option<Vec<String>> { &self.eula }
    fn get_ovf_section(&self) -> &Option<Vec<VAppOvfSectionSpec>> { &self.ovf_section }
    fn get_ovf_environment_transport(&self) -> &Option<Vec<String>> { &self.ovf_environment_transport }
    fn get_install_boot_required(&self) -> Option<bool> { self.install_boot_required }
    fn get_install_boot_stop_delay(&self) -> Option<i32> { self.install_boot_stop_delay }
}
impl VmConfigSpecTrait for VAppConfigSpec {
    fn get_product(&self) -> &Option<Vec<VAppProductSpec>> { &self.product }
    fn get_property(&self) -> &Option<Vec<VAppPropertySpec>> { &self.property }
    fn get_ip_assignment(&self) -> &Option<VAppIpAssignmentInfo> { &self.ip_assignment }
    fn get_eula(&self) -> &Option<Vec<String>> { &self.eula }
    fn get_ovf_section(&self) -> &Option<Vec<VAppOvfSectionSpec>> { &self.ovf_section }
    fn get_ovf_environment_transport(&self) -> &Option<Vec<String>> { &self.ovf_environment_transport }
    fn get_install_boot_required(&self) -> Option<bool> { self.install_boot_required }
    fn get_install_boot_stop_delay(&self) -> Option<i32> { self.install_boot_stop_delay }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VmConfigSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmConfigSpec => Some(from.as_any_ref().downcast_ref::<VmConfigSpec>()?),
            StructType::VAppConfigSpec => Some(from.as_any_ref().downcast_ref::<VAppConfigSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmConfigSpec => Ok(from.as_any_box().downcast::<VmConfigSpec>()?),
            StructType::VAppConfigSpec => Ok(from.as_any_box().downcast::<VAppConfigSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The NodeDeploymentSpec class defines location
/// specification of the nodes the VCHA Cluster along with Management
/// vCenter Server information that manages node VM.
pub trait NodeDeploymentSpecTrait : super::traits::DataObjectTrait {
    /// ESX host on which the VM is to be deployed.
    /// 
    /// For behavior when an esxHost is not specified,
    /// 
    /// See also *VirtualMachineRelocateSpec.host*.
    /// 
    /// Refers instance of *HostSystem*.
    fn get_esx_host(&self) -> &Option<ManagedObjectReference>;
    /// Datastore used for deploying the VM.
    /// 
    /// For behavior when a datastore is not specified,
    /// 
    /// See also *VirtualMachineRelocateSpec.datastore*.
    /// 
    /// Refers instance of *Datastore*.
    fn get_datastore(&self) -> &Option<ManagedObjectReference>;
    /// Name of the portgroup that is associated with the public IP address
    /// where clients connect to vCenter Server.
    /// 
    /// If a portgroup is not
    /// specified same portgroup present on source is used to deploy the VM
    /// with an assumption that portgroup is present on destination.
    /// 
    /// Refers instance of *Network*.
    fn get_public_network_port_group(&self) -> &Option<ManagedObjectReference>;
    /// Name of the portgroup that is associated with the VCHA Cluster IP
    /// address where clients connect to vCenter Server.
    /// 
    /// If a portgroup is not
    /// specified same portgroup present on source is used to deploy the VM
    /// with an assumption that portgroup is present on destination.
    /// 
    /// Refers instance of *Network*.
    fn get_cluster_network_port_group(&self) -> &Option<ManagedObjectReference>;
    /// Folder in which the VM is to be created.
    /// 
    /// Refers instance of *Folder*.
    fn get_folder(&self) -> &ManagedObjectReference;
    /// ResourcePool that will be used to deploy this node.
    /// 
    /// If the ResourcePool is not specified, the root resource pool for the
    /// host will be used.
    /// 
    /// Refers instance of *ResourcePool*.
    fn get_resource_pool(&self) -> &Option<ManagedObjectReference>;
    /// Management vCenter Server managing this VM.
    /// 
    /// If the managementVc is not specified, managementVc specified as
    /// part of SourceNodeSpec is used.
    fn get_management_vc(&self) -> &Option<ServiceLocator>;
    /// nodeName here refers to a name that will be assigned to the VM to which
    /// this node will be deployed to.
    fn get_node_name(&self) -> &str;
    /// VCHA Cluster network configuration of the node.
    /// 
    /// All cluster communication (state replication, heartbeat,
    /// cluster messages) happens over this network.
    fn get_ip_settings(&self) -> &CustomizationIpSettings;
}
impl<'s> serde::Serialize for dyn NodeDeploymentSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn NodeDeploymentSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(NodeDeploymentSpecVisitor)
            }
        }

struct NodeDeploymentSpecVisitor;

impl<'de> de::Visitor<'de> for NodeDeploymentSpecVisitor {
    type Value = Box<dyn NodeDeploymentSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid NodeDeploymentSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl NodeDeploymentSpecTrait for NodeDeploymentSpec {
    fn get_esx_host(&self) -> &Option<ManagedObjectReference> { &self.esx_host }
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
    fn get_public_network_port_group(&self) -> &Option<ManagedObjectReference> { &self.public_network_port_group }
    fn get_cluster_network_port_group(&self) -> &Option<ManagedObjectReference> { &self.cluster_network_port_group }
    fn get_folder(&self) -> &ManagedObjectReference { &self.folder }
    fn get_resource_pool(&self) -> &Option<ManagedObjectReference> { &self.resource_pool }
    fn get_management_vc(&self) -> &Option<ServiceLocator> { &self.management_vc }
    fn get_node_name(&self) -> &str { &self.node_name }
    fn get_ip_settings(&self) -> &CustomizationIpSettings { &self.ip_settings }
}
impl NodeDeploymentSpecTrait for PassiveNodeDeploymentSpec {
    fn get_esx_host(&self) -> &Option<ManagedObjectReference> { &self.esx_host }
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
    fn get_public_network_port_group(&self) -> &Option<ManagedObjectReference> { &self.public_network_port_group }
    fn get_cluster_network_port_group(&self) -> &Option<ManagedObjectReference> { &self.cluster_network_port_group }
    fn get_folder(&self) -> &ManagedObjectReference { &self.folder }
    fn get_resource_pool(&self) -> &Option<ManagedObjectReference> { &self.resource_pool }
    fn get_management_vc(&self) -> &Option<ServiceLocator> { &self.management_vc }
    fn get_node_name(&self) -> &str { &self.node_name }
    fn get_ip_settings(&self) -> &CustomizationIpSettings { &self.ip_settings }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn NodeDeploymentSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::NodeDeploymentSpec => Some(from.as_any_ref().downcast_ref::<NodeDeploymentSpec>()?),
            StructType::PassiveNodeDeploymentSpec => Some(from.as_any_ref().downcast_ref::<PassiveNodeDeploymentSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::NodeDeploymentSpec => Ok(from.as_any_box().downcast::<NodeDeploymentSpec>()?),
            StructType::PassiveNodeDeploymentSpec => Ok(from.as_any_box().downcast::<PassiveNodeDeploymentSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The NodeNetworkSpec class defines network specification of a node
/// in the VCHA Cluster.
pub trait NodeNetworkSpecTrait : super::traits::DataObjectTrait {
    /// VCHA Cluster network configuration of the node.
    /// 
    /// All cluster communication (state replication, heartbeat,
    /// cluster messages) happens over this network.
    fn get_ip_settings(&self) -> &CustomizationIpSettings;
}
impl<'s> serde::Serialize for dyn NodeNetworkSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn NodeNetworkSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(NodeNetworkSpecVisitor)
            }
        }

struct NodeNetworkSpecVisitor;

impl<'de> de::Visitor<'de> for NodeNetworkSpecVisitor {
    type Value = Box<dyn NodeNetworkSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid NodeNetworkSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl NodeNetworkSpecTrait for NodeNetworkSpec {
    fn get_ip_settings(&self) -> &CustomizationIpSettings { &self.ip_settings }
}
impl NodeNetworkSpecTrait for PassiveNodeNetworkSpec {
    fn get_ip_settings(&self) -> &CustomizationIpSettings { &self.ip_settings }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn NodeNetworkSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::NodeNetworkSpec => Some(from.as_any_ref().downcast_ref::<NodeNetworkSpec>()?),
            StructType::PassiveNodeNetworkSpec => Some(from.as_any_ref().downcast_ref::<PassiveNodeNetworkSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::NodeNetworkSpec => Ok(from.as_any_box().downcast::<NodeNetworkSpec>()?),
            StructType::PassiveNodeNetworkSpec => Ok(from.as_any_box().downcast::<PassiveNodeNetworkSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The BaseIndependentFilterSpec is base class for two different types
/// of independent filter specs *VirtualMachineIndependentFilterSpec*
/// and *VirtualMachineEmptyIndependentFilterSpec* which are used to specify
/// independent filters to be attached/removed on VMs virtual disk.
/// 
/// ***Since:*** vSphere API Release 7.0.2.1
pub trait VirtualMachineBaseIndependentFilterSpecTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn VirtualMachineBaseIndependentFilterSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualMachineBaseIndependentFilterSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualMachineBaseIndependentFilterSpecVisitor)
            }
        }

struct VirtualMachineBaseIndependentFilterSpecVisitor;

impl<'de> de::Visitor<'de> for VirtualMachineBaseIndependentFilterSpecVisitor {
    type Value = Box<dyn VirtualMachineBaseIndependentFilterSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualMachineBaseIndependentFilterSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualMachineBaseIndependentFilterSpecTrait for VirtualMachineBaseIndependentFilterSpec {
}
impl VirtualMachineBaseIndependentFilterSpecTrait for VirtualMachineEmptyIndependentFilterSpec {
}
impl VirtualMachineBaseIndependentFilterSpecTrait for VirtualMachineIndependentFilterSpec {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualMachineBaseIndependentFilterSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineBaseIndependentFilterSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineBaseIndependentFilterSpec>()?),
            StructType::VirtualMachineEmptyIndependentFilterSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineEmptyIndependentFilterSpec>()?),
            StructType::VirtualMachineIndependentFilterSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineIndependentFilterSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineBaseIndependentFilterSpec => Ok(from.as_any_box().downcast::<VirtualMachineBaseIndependentFilterSpec>()?),
            StructType::VirtualMachineEmptyIndependentFilterSpec => Ok(from.as_any_box().downcast::<VirtualMachineEmptyIndependentFilterSpec>()?),
            StructType::VirtualMachineIndependentFilterSpec => Ok(from.as_any_box().downcast::<VirtualMachineIndependentFilterSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Bootable device.
pub trait VirtualMachineBootOptionsBootableDeviceTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn VirtualMachineBootOptionsBootableDeviceTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualMachineBootOptionsBootableDeviceTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualMachineBootOptionsBootableDeviceVisitor)
            }
        }

struct VirtualMachineBootOptionsBootableDeviceVisitor;

impl<'de> de::Visitor<'de> for VirtualMachineBootOptionsBootableDeviceVisitor {
    type Value = Box<dyn VirtualMachineBootOptionsBootableDeviceTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualMachineBootOptionsBootableDeviceTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualMachineBootOptionsBootableDeviceTrait for VirtualMachineBootOptionsBootableDevice {
}
impl VirtualMachineBootOptionsBootableDeviceTrait for VirtualMachineBootOptionsBootableCdromDevice {
}
impl VirtualMachineBootOptionsBootableDeviceTrait for VirtualMachineBootOptionsBootableDiskDevice {
}
impl VirtualMachineBootOptionsBootableDeviceTrait for VirtualMachineBootOptionsBootableEthernetDevice {
}
impl VirtualMachineBootOptionsBootableDeviceTrait for VirtualMachineBootOptionsBootableFloppyDevice {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualMachineBootOptionsBootableDeviceTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineBootOptionsBootableDevice => Some(from.as_any_ref().downcast_ref::<VirtualMachineBootOptionsBootableDevice>()?),
            StructType::VirtualMachineBootOptionsBootableCdromDevice => Some(from.as_any_ref().downcast_ref::<VirtualMachineBootOptionsBootableCdromDevice>()?),
            StructType::VirtualMachineBootOptionsBootableDiskDevice => Some(from.as_any_ref().downcast_ref::<VirtualMachineBootOptionsBootableDiskDevice>()?),
            StructType::VirtualMachineBootOptionsBootableEthernetDevice => Some(from.as_any_ref().downcast_ref::<VirtualMachineBootOptionsBootableEthernetDevice>()?),
            StructType::VirtualMachineBootOptionsBootableFloppyDevice => Some(from.as_any_ref().downcast_ref::<VirtualMachineBootOptionsBootableFloppyDevice>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineBootOptionsBootableDevice => Ok(from.as_any_box().downcast::<VirtualMachineBootOptionsBootableDevice>()?),
            StructType::VirtualMachineBootOptionsBootableCdromDevice => Ok(from.as_any_box().downcast::<VirtualMachineBootOptionsBootableCdromDevice>()?),
            StructType::VirtualMachineBootOptionsBootableDiskDevice => Ok(from.as_any_box().downcast::<VirtualMachineBootOptionsBootableDiskDevice>()?),
            StructType::VirtualMachineBootOptionsBootableEthernetDevice => Ok(from.as_any_box().downcast::<VirtualMachineBootOptionsBootableEthernetDevice>()?),
            StructType::VirtualMachineBootOptionsBootableFloppyDevice => Ok(from.as_any_box().downcast::<VirtualMachineBootOptionsBootableFloppyDevice>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Runtime state of a device.
/// 
/// Subclassed for information that is specific
/// to certain device types.
pub trait VirtualMachineDeviceRuntimeInfoDeviceRuntimeStateTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn VirtualMachineDeviceRuntimeInfoDeviceRuntimeStateTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualMachineDeviceRuntimeInfoDeviceRuntimeStateTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualMachineDeviceRuntimeInfoDeviceRuntimeStateVisitor)
            }
        }

struct VirtualMachineDeviceRuntimeInfoDeviceRuntimeStateVisitor;

impl<'de> de::Visitor<'de> for VirtualMachineDeviceRuntimeInfoDeviceRuntimeStateVisitor {
    type Value = Box<dyn VirtualMachineDeviceRuntimeInfoDeviceRuntimeStateTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualMachineDeviceRuntimeInfoDeviceRuntimeStateTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualMachineDeviceRuntimeInfoDeviceRuntimeStateTrait for VirtualMachineDeviceRuntimeInfoDeviceRuntimeState {
}
impl VirtualMachineDeviceRuntimeInfoDeviceRuntimeStateTrait for VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualMachineDeviceRuntimeInfoDeviceRuntimeStateTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineDeviceRuntimeInfoDeviceRuntimeState => Some(from.as_any_ref().downcast_ref::<VirtualMachineDeviceRuntimeInfoDeviceRuntimeState>()?),
            StructType::VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState => Some(from.as_any_ref().downcast_ref::<VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineDeviceRuntimeInfoDeviceRuntimeState => Ok(from.as_any_box().downcast::<VirtualMachineDeviceRuntimeInfoDeviceRuntimeState>()?),
            StructType::VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState => Ok(from.as_any_box().downcast::<VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// FaultToleranceConfigInfo is a data object type containing Fault Tolerance
/// settings for this virtual machine.
/// 
/// role, instanceUuids and configPaths contain information about the
/// whole fault tolerance group.
pub trait FaultToleranceConfigInfoTrait : super::traits::DataObjectTrait {
    /// The index of the current VM in instanceUuids array starting from 1, so
    /// 1 means that it is the primary VM.
    fn get_role(&self) -> i32;
    /// The instanceUuid of all the VMs in this fault tolerance group.
    /// 
    /// The
    /// first element is the instanceUuid of the primary VM.
    fn get_instance_uuids(&self) -> &Vec<String>;
    /// The configuration file path for all the VMs in this fault tolerance
    /// group.
    fn get_config_paths(&self) -> &Vec<String>;
    /// Indicates whether a secondary VM is orphaned (no longer associated with
    /// the primary VM).
    fn get_orphaned(&self) -> Option<bool>;
}
impl<'s> serde::Serialize for dyn FaultToleranceConfigInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn FaultToleranceConfigInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(FaultToleranceConfigInfoVisitor)
            }
        }

struct FaultToleranceConfigInfoVisitor;

impl<'de> de::Visitor<'de> for FaultToleranceConfigInfoVisitor {
    type Value = Box<dyn FaultToleranceConfigInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid FaultToleranceConfigInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl FaultToleranceConfigInfoTrait for FaultToleranceConfigInfo {
    fn get_role(&self) -> i32 { self.role }
    fn get_instance_uuids(&self) -> &Vec<String> { &self.instance_uuids }
    fn get_config_paths(&self) -> &Vec<String> { &self.config_paths }
    fn get_orphaned(&self) -> Option<bool> { self.orphaned }
}
impl FaultToleranceConfigInfoTrait for FaultTolerancePrimaryConfigInfo {
    fn get_role(&self) -> i32 { self.role }
    fn get_instance_uuids(&self) -> &Vec<String> { &self.instance_uuids }
    fn get_config_paths(&self) -> &Vec<String> { &self.config_paths }
    fn get_orphaned(&self) -> Option<bool> { self.orphaned }
}
impl FaultToleranceConfigInfoTrait for FaultToleranceSecondaryConfigInfo {
    fn get_role(&self) -> i32 { self.role }
    fn get_instance_uuids(&self) -> &Vec<String> { &self.instance_uuids }
    fn get_config_paths(&self) -> &Vec<String> { &self.config_paths }
    fn get_orphaned(&self) -> Option<bool> { self.orphaned }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn FaultToleranceConfigInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::FaultToleranceConfigInfo => Some(from.as_any_ref().downcast_ref::<FaultToleranceConfigInfo>()?),
            StructType::FaultTolerancePrimaryConfigInfo => Some(from.as_any_ref().downcast_ref::<FaultTolerancePrimaryConfigInfo>()?),
            StructType::FaultToleranceSecondaryConfigInfo => Some(from.as_any_ref().downcast_ref::<FaultToleranceSecondaryConfigInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::FaultToleranceConfigInfo => Ok(from.as_any_box().downcast::<FaultToleranceConfigInfo>()?),
            StructType::FaultTolerancePrimaryConfigInfo => Ok(from.as_any_box().downcast::<FaultTolerancePrimaryConfigInfo>()?),
            StructType::FaultToleranceSecondaryConfigInfo => Ok(from.as_any_box().downcast::<FaultToleranceSecondaryConfigInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type encapsulates configuration settings
/// when creating a virtual machine quiesced snapshot.
pub trait VirtualMachineGuestQuiesceSpecTrait : super::traits::DataObjectTrait {
    /// The property to indicate maximum time in minutes for snapshot operation
    /// to be performed on the virtual machine.
    /// 
    /// The timeout can not be less than 5 minutes or more than 240 minutes.
    fn get_timeout(&self) -> Option<i32>;
}
impl<'s> serde::Serialize for dyn VirtualMachineGuestQuiesceSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualMachineGuestQuiesceSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualMachineGuestQuiesceSpecVisitor)
            }
        }

struct VirtualMachineGuestQuiesceSpecVisitor;

impl<'de> de::Visitor<'de> for VirtualMachineGuestQuiesceSpecVisitor {
    type Value = Box<dyn VirtualMachineGuestQuiesceSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualMachineGuestQuiesceSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualMachineGuestQuiesceSpecTrait for VirtualMachineGuestQuiesceSpec {
    fn get_timeout(&self) -> Option<i32> { self.timeout }
}
impl VirtualMachineGuestQuiesceSpecTrait for VirtualMachineWindowsQuiesceSpec {
    fn get_timeout(&self) -> Option<i32> { self.timeout }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualMachineGuestQuiesceSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineGuestQuiesceSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineGuestQuiesceSpec>()?),
            StructType::VirtualMachineWindowsQuiesceSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineWindowsQuiesceSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineGuestQuiesceSpec => Ok(from.as_any_box().downcast::<VirtualMachineGuestQuiesceSpec>()?),
            StructType::VirtualMachineWindowsQuiesceSpec => Ok(from.as_any_box().downcast::<VirtualMachineWindowsQuiesceSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The ProfileSpec data object is used to specify the Storage Policy to be
/// associated with a Virtual Machine Home or a Virtual Disk.
pub trait VirtualMachineProfileSpecTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn VirtualMachineProfileSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualMachineProfileSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualMachineProfileSpecVisitor)
            }
        }

struct VirtualMachineProfileSpecVisitor;

impl<'de> de::Visitor<'de> for VirtualMachineProfileSpecVisitor {
    type Value = Box<dyn VirtualMachineProfileSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualMachineProfileSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualMachineProfileSpecTrait for VirtualMachineProfileSpec {
}
impl VirtualMachineProfileSpecTrait for VirtualMachineDefaultProfileSpec {
}
impl VirtualMachineProfileSpecTrait for VirtualMachineDefinedProfileSpec {
}
impl VirtualMachineProfileSpecTrait for VirtualMachineEmptyProfileSpec {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualMachineProfileSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineProfileSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineProfileSpec>()?),
            StructType::VirtualMachineDefaultProfileSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineDefaultProfileSpec>()?),
            StructType::VirtualMachineDefinedProfileSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineDefinedProfileSpec>()?),
            StructType::VirtualMachineEmptyProfileSpec => Some(from.as_any_ref().downcast_ref::<VirtualMachineEmptyProfileSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineProfileSpec => Ok(from.as_any_box().downcast::<VirtualMachineProfileSpec>()?),
            StructType::VirtualMachineDefaultProfileSpec => Ok(from.as_any_box().downcast::<VirtualMachineDefaultProfileSpec>()?),
            StructType::VirtualMachineDefinedProfileSpec => Ok(from.as_any_box().downcast::<VirtualMachineDefinedProfileSpec>()?),
            StructType::VirtualMachineEmptyProfileSpec => Ok(from.as_any_box().downcast::<VirtualMachineEmptyProfileSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
pub trait VirtualMachineSriovDevicePoolInfoTrait : super::traits::DataObjectTrait {
    /// To be used for extending to other device types
    fn get_key(&self) -> &str;
}
impl<'s> serde::Serialize for dyn VirtualMachineSriovDevicePoolInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualMachineSriovDevicePoolInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualMachineSriovDevicePoolInfoVisitor)
            }
        }

struct VirtualMachineSriovDevicePoolInfoVisitor;

impl<'de> de::Visitor<'de> for VirtualMachineSriovDevicePoolInfoVisitor {
    type Value = Box<dyn VirtualMachineSriovDevicePoolInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualMachineSriovDevicePoolInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualMachineSriovDevicePoolInfoTrait for VirtualMachineSriovDevicePoolInfo {
    fn get_key(&self) -> &str { &self.key }
}
impl VirtualMachineSriovDevicePoolInfoTrait for VirtualMachineSriovNetworkDevicePoolInfo {
    fn get_key(&self) -> &str { &self.key }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualMachineSriovDevicePoolInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineSriovDevicePoolInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineSriovDevicePoolInfo>()?),
            StructType::VirtualMachineSriovNetworkDevicePoolInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineSriovNetworkDevicePoolInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineSriovDevicePoolInfo => Ok(from.as_any_box().downcast::<VirtualMachineSriovDevicePoolInfo>()?),
            StructType::VirtualMachineSriovNetworkDevicePoolInfo => Ok(from.as_any_box().downcast::<VirtualMachineSriovNetworkDevicePoolInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The TargetInfo specified a value that can be used in the device backings to
/// connect the virtual machine to a physical (or logical) host device.
pub trait VirtualMachineTargetInfoTrait : super::traits::DataObjectTrait {
    /// The identification of the endpoint on the host.
    /// 
    /// The format of this depends
    /// on the kind of virtual device this endpoints is used for. For example,
    /// for a VirtualEthernetCard this would be a networkname, and for a VirtualCDROM
    /// it would be a device name.
    fn get_name(&self) -> &str;
    /// List of configurations that this device is available for.
    /// 
    /// This is only filled
    /// out if more than one configuration is requested.
    fn get_configuration_tag(&self) -> &Option<Vec<String>>;
}
impl<'s> serde::Serialize for dyn VirtualMachineTargetInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualMachineTargetInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualMachineTargetInfoVisitor)
            }
        }

struct VirtualMachineTargetInfoVisitor;

impl<'de> de::Visitor<'de> for VirtualMachineTargetInfoVisitor {
    type Value = Box<dyn VirtualMachineTargetInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualMachineTargetInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualMachineTargetInfoTrait for VirtualMachineTargetInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineCdromInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineDatastoreInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineDiskDeviceInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineIdeDiskDeviceInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineScsiDiskDeviceInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineDynamicPassthroughInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineFloppyInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineNetworkInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for OpaqueNetworkTargetInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineParallelInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachinePciPassthroughInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineSriovInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachinePciSharedGpuPassthroughInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachinePrecisionClockInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineScsiPassthroughInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineSerialInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineSgxTargetInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineSoundInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineUsbInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineVFlashModuleInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineVMotionStunTimeInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineVendorDeviceGroupInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineVgpuDeviceInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl VirtualMachineTargetInfoTrait for VirtualMachineVgpuProfileInfo {
    fn get_name(&self) -> &str { &self.name }
    fn get_configuration_tag(&self) -> &Option<Vec<String>> { &self.configuration_tag }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualMachineTargetInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineTargetInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineTargetInfo>()?),
            StructType::VirtualMachineCdromInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineCdromInfo>()?),
            StructType::VirtualMachineDatastoreInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineDatastoreInfo>()?),
            StructType::VirtualMachineDiskDeviceInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineDiskDeviceInfo>()?),
            StructType::VirtualMachineIdeDiskDeviceInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineIdeDiskDeviceInfo>()?),
            StructType::VirtualMachineScsiDiskDeviceInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineScsiDiskDeviceInfo>()?),
            StructType::VirtualMachineDynamicPassthroughInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineDynamicPassthroughInfo>()?),
            StructType::VirtualMachineFloppyInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineFloppyInfo>()?),
            StructType::VirtualMachineNetworkInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineNetworkInfo>()?),
            StructType::OpaqueNetworkTargetInfo => Some(from.as_any_ref().downcast_ref::<OpaqueNetworkTargetInfo>()?),
            StructType::VirtualMachineParallelInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineParallelInfo>()?),
            StructType::VirtualMachinePciPassthroughInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachinePciPassthroughInfo>()?),
            StructType::VirtualMachineSriovInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineSriovInfo>()?),
            StructType::VirtualMachinePciSharedGpuPassthroughInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachinePciSharedGpuPassthroughInfo>()?),
            StructType::VirtualMachinePrecisionClockInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachinePrecisionClockInfo>()?),
            StructType::VirtualMachineScsiPassthroughInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineScsiPassthroughInfo>()?),
            StructType::VirtualMachineSerialInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineSerialInfo>()?),
            StructType::VirtualMachineSgxTargetInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineSgxTargetInfo>()?),
            StructType::VirtualMachineSoundInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineSoundInfo>()?),
            StructType::VirtualMachineUsbInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineUsbInfo>()?),
            StructType::VirtualMachineVFlashModuleInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineVFlashModuleInfo>()?),
            StructType::VirtualMachineVMotionStunTimeInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineVMotionStunTimeInfo>()?),
            StructType::VirtualMachineVendorDeviceGroupInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineVendorDeviceGroupInfo>()?),
            StructType::VirtualMachineVgpuDeviceInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineVgpuDeviceInfo>()?),
            StructType::VirtualMachineVgpuProfileInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineVgpuProfileInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineTargetInfo => Ok(from.as_any_box().downcast::<VirtualMachineTargetInfo>()?),
            StructType::VirtualMachineCdromInfo => Ok(from.as_any_box().downcast::<VirtualMachineCdromInfo>()?),
            StructType::VirtualMachineDatastoreInfo => Ok(from.as_any_box().downcast::<VirtualMachineDatastoreInfo>()?),
            StructType::VirtualMachineDiskDeviceInfo => Ok(from.as_any_box().downcast::<VirtualMachineDiskDeviceInfo>()?),
            StructType::VirtualMachineIdeDiskDeviceInfo => Ok(from.as_any_box().downcast::<VirtualMachineIdeDiskDeviceInfo>()?),
            StructType::VirtualMachineScsiDiskDeviceInfo => Ok(from.as_any_box().downcast::<VirtualMachineScsiDiskDeviceInfo>()?),
            StructType::VirtualMachineDynamicPassthroughInfo => Ok(from.as_any_box().downcast::<VirtualMachineDynamicPassthroughInfo>()?),
            StructType::VirtualMachineFloppyInfo => Ok(from.as_any_box().downcast::<VirtualMachineFloppyInfo>()?),
            StructType::VirtualMachineNetworkInfo => Ok(from.as_any_box().downcast::<VirtualMachineNetworkInfo>()?),
            StructType::OpaqueNetworkTargetInfo => Ok(from.as_any_box().downcast::<OpaqueNetworkTargetInfo>()?),
            StructType::VirtualMachineParallelInfo => Ok(from.as_any_box().downcast::<VirtualMachineParallelInfo>()?),
            StructType::VirtualMachinePciPassthroughInfo => Ok(from.as_any_box().downcast::<VirtualMachinePciPassthroughInfo>()?),
            StructType::VirtualMachineSriovInfo => Ok(from.as_any_box().downcast::<VirtualMachineSriovInfo>()?),
            StructType::VirtualMachinePciSharedGpuPassthroughInfo => Ok(from.as_any_box().downcast::<VirtualMachinePciSharedGpuPassthroughInfo>()?),
            StructType::VirtualMachinePrecisionClockInfo => Ok(from.as_any_box().downcast::<VirtualMachinePrecisionClockInfo>()?),
            StructType::VirtualMachineScsiPassthroughInfo => Ok(from.as_any_box().downcast::<VirtualMachineScsiPassthroughInfo>()?),
            StructType::VirtualMachineSerialInfo => Ok(from.as_any_box().downcast::<VirtualMachineSerialInfo>()?),
            StructType::VirtualMachineSgxTargetInfo => Ok(from.as_any_box().downcast::<VirtualMachineSgxTargetInfo>()?),
            StructType::VirtualMachineSoundInfo => Ok(from.as_any_box().downcast::<VirtualMachineSoundInfo>()?),
            StructType::VirtualMachineUsbInfo => Ok(from.as_any_box().downcast::<VirtualMachineUsbInfo>()?),
            StructType::VirtualMachineVFlashModuleInfo => Ok(from.as_any_box().downcast::<VirtualMachineVFlashModuleInfo>()?),
            StructType::VirtualMachineVMotionStunTimeInfo => Ok(from.as_any_box().downcast::<VirtualMachineVMotionStunTimeInfo>()?),
            StructType::VirtualMachineVendorDeviceGroupInfo => Ok(from.as_any_box().downcast::<VirtualMachineVendorDeviceGroupInfo>()?),
            StructType::VirtualMachineVgpuDeviceInfo => Ok(from.as_any_box().downcast::<VirtualMachineVgpuDeviceInfo>()?),
            StructType::VirtualMachineVgpuProfileInfo => Ok(from.as_any_box().downcast::<VirtualMachineVgpuProfileInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The DiskDeviceInfo class contains basic information about a specific disk hardware
/// device.
pub trait VirtualMachineDiskDeviceInfoTrait : super::traits::VirtualMachineTargetInfoTrait {
    /// Size of disk
    fn get_capacity(&self) -> Option<i64>;
    /// List of known virtual machines using this physical disk as a backing
    /// 
    /// Refers instances of *VirtualMachine*.
    fn get_vm(&self) -> &Option<Vec<ManagedObjectReference>>;
}
impl<'s> serde::Serialize for dyn VirtualMachineDiskDeviceInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualMachineDiskDeviceInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualMachineDiskDeviceInfoVisitor)
            }
        }

struct VirtualMachineDiskDeviceInfoVisitor;

impl<'de> de::Visitor<'de> for VirtualMachineDiskDeviceInfoVisitor {
    type Value = Box<dyn VirtualMachineDiskDeviceInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualMachineDiskDeviceInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualMachineDiskDeviceInfoTrait for VirtualMachineDiskDeviceInfo {
    fn get_capacity(&self) -> Option<i64> { self.capacity }
    fn get_vm(&self) -> &Option<Vec<ManagedObjectReference>> { &self.vm }
}
impl VirtualMachineDiskDeviceInfoTrait for VirtualMachineIdeDiskDeviceInfo {
    fn get_capacity(&self) -> Option<i64> { self.capacity }
    fn get_vm(&self) -> &Option<Vec<ManagedObjectReference>> { &self.vm }
}
impl VirtualMachineDiskDeviceInfoTrait for VirtualMachineScsiDiskDeviceInfo {
    fn get_capacity(&self) -> Option<i64> { self.capacity }
    fn get_vm(&self) -> &Option<Vec<ManagedObjectReference>> { &self.vm }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualMachineDiskDeviceInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineDiskDeviceInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineDiskDeviceInfo>()?),
            StructType::VirtualMachineIdeDiskDeviceInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineIdeDiskDeviceInfo>()?),
            StructType::VirtualMachineScsiDiskDeviceInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineScsiDiskDeviceInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineDiskDeviceInfo => Ok(from.as_any_box().downcast::<VirtualMachineDiskDeviceInfo>()?),
            StructType::VirtualMachineIdeDiskDeviceInfo => Ok(from.as_any_box().downcast::<VirtualMachineIdeDiskDeviceInfo>()?),
            StructType::VirtualMachineScsiDiskDeviceInfo => Ok(from.as_any_box().downcast::<VirtualMachineScsiDiskDeviceInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Description of a generic PCI device that can be attached to a virtual machine.
pub trait VirtualMachinePciPassthroughInfoTrait : super::traits::VirtualMachineTargetInfoTrait {
    /// Details of the PCI device, including vendor, class and
    /// device identification information.
    fn get_pci_device(&self) -> &HostPciDevice;
    /// The ID of the system the PCI device is attached to.
    fn get_system_id(&self) -> &str;
}
impl<'s> serde::Serialize for dyn VirtualMachinePciPassthroughInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualMachinePciPassthroughInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualMachinePciPassthroughInfoVisitor)
            }
        }

struct VirtualMachinePciPassthroughInfoVisitor;

impl<'de> de::Visitor<'de> for VirtualMachinePciPassthroughInfoVisitor {
    type Value = Box<dyn VirtualMachinePciPassthroughInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualMachinePciPassthroughInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualMachinePciPassthroughInfoTrait for VirtualMachinePciPassthroughInfo {
    fn get_pci_device(&self) -> &HostPciDevice { &self.pci_device }
    fn get_system_id(&self) -> &str { &self.system_id }
}
impl VirtualMachinePciPassthroughInfoTrait for VirtualMachineSriovInfo {
    fn get_pci_device(&self) -> &HostPciDevice { &self.pci_device }
    fn get_system_id(&self) -> &str { &self.system_id }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualMachinePciPassthroughInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachinePciPassthroughInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachinePciPassthroughInfo>()?),
            StructType::VirtualMachineSriovInfo => Some(from.as_any_ref().downcast_ref::<VirtualMachineSriovInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachinePciPassthroughInfo => Ok(from.as_any_box().downcast::<VirtualMachinePciPassthroughInfo>()?),
            StructType::VirtualMachineSriovInfo => Ok(from.as_any_box().downcast::<VirtualMachineSriovInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base device group type.
pub trait VirtualMachineVirtualDeviceGroupsDeviceGroupTrait : super::traits::DataObjectTrait {
    /// Group instance key.
    /// 
    /// Unique integer referencing
    /// device group. During group creation client should
    /// use a temporary negative number. Once group is
    /// added to the virtual machine, server generates non-negative
    /// integer that stays constant during group lifetime.
    /// See *VirtualDevice.key* for details.
    fn get_group_instance_key(&self) -> i32;
    /// Provides a label and summary information for the device.
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>>;
}
impl<'s> serde::Serialize for dyn VirtualMachineVirtualDeviceGroupsDeviceGroupTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualMachineVirtualDeviceGroupsDeviceGroupTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualMachineVirtualDeviceGroupsDeviceGroupVisitor)
            }
        }

struct VirtualMachineVirtualDeviceGroupsDeviceGroupVisitor;

impl<'de> de::Visitor<'de> for VirtualMachineVirtualDeviceGroupsDeviceGroupVisitor {
    type Value = Box<dyn VirtualMachineVirtualDeviceGroupsDeviceGroupTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualMachineVirtualDeviceGroupsDeviceGroupTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualMachineVirtualDeviceGroupsDeviceGroupTrait for VirtualMachineVirtualDeviceGroupsDeviceGroup {
    fn get_group_instance_key(&self) -> i32 { self.group_instance_key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
}
impl VirtualMachineVirtualDeviceGroupsDeviceGroupTrait for VirtualMachineVirtualDeviceGroupsVendorDeviceGroup {
    fn get_group_instance_key(&self) -> i32 { self.group_instance_key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualMachineVirtualDeviceGroupsDeviceGroupTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineVirtualDeviceGroupsDeviceGroup => Some(from.as_any_ref().downcast_ref::<VirtualMachineVirtualDeviceGroupsDeviceGroup>()?),
            StructType::VirtualMachineVirtualDeviceGroupsVendorDeviceGroup => Some(from.as_any_ref().downcast_ref::<VirtualMachineVirtualDeviceGroupsVendorDeviceGroup>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualMachineVirtualDeviceGroupsDeviceGroup => Ok(from.as_any_box().downcast::<VirtualMachineVirtualDeviceGroupsDeviceGroup>()?),
            StructType::VirtualMachineVirtualDeviceGroupsVendorDeviceGroup => Ok(from.as_any_box().downcast::<VirtualMachineVirtualDeviceGroupsVendorDeviceGroup>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base type for sysprep, sysprepText, or linuxPrep object type.
pub trait CustomizationIdentitySettingsTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn CustomizationIdentitySettingsTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn CustomizationIdentitySettingsTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(CustomizationIdentitySettingsVisitor)
            }
        }

struct CustomizationIdentitySettingsVisitor;

impl<'de> de::Visitor<'de> for CustomizationIdentitySettingsVisitor {
    type Value = Box<dyn CustomizationIdentitySettingsTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid CustomizationIdentitySettingsTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl CustomizationIdentitySettingsTrait for CustomizationIdentitySettings {
}
impl CustomizationIdentitySettingsTrait for CustomizationCloudinitPrep {
}
impl CustomizationIdentitySettingsTrait for CustomizationLinuxPrep {
}
impl CustomizationIdentitySettingsTrait for CustomizationSysprep {
}
impl CustomizationIdentitySettingsTrait for CustomizationSysprepText {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn CustomizationIdentitySettingsTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::CustomizationIdentitySettings => Some(from.as_any_ref().downcast_ref::<CustomizationIdentitySettings>()?),
            StructType::CustomizationCloudinitPrep => Some(from.as_any_ref().downcast_ref::<CustomizationCloudinitPrep>()?),
            StructType::CustomizationLinuxPrep => Some(from.as_any_ref().downcast_ref::<CustomizationLinuxPrep>()?),
            StructType::CustomizationSysprep => Some(from.as_any_ref().downcast_ref::<CustomizationSysprep>()?),
            StructType::CustomizationSysprepText => Some(from.as_any_ref().downcast_ref::<CustomizationSysprepText>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::CustomizationIdentitySettings => Ok(from.as_any_box().downcast::<CustomizationIdentitySettings>()?),
            StructType::CustomizationCloudinitPrep => Ok(from.as_any_box().downcast::<CustomizationCloudinitPrep>()?),
            StructType::CustomizationLinuxPrep => Ok(from.as_any_box().downcast::<CustomizationLinuxPrep>()?),
            StructType::CustomizationSysprep => Ok(from.as_any_box().downcast::<CustomizationSysprep>()?),
            StructType::CustomizationSysprepText => Ok(from.as_any_box().downcast::<CustomizationSysprepText>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base type for the various IP specification possibilities.
pub trait CustomizationIpGeneratorTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn CustomizationIpGeneratorTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn CustomizationIpGeneratorTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(CustomizationIpGeneratorVisitor)
            }
        }

struct CustomizationIpGeneratorVisitor;

impl<'de> de::Visitor<'de> for CustomizationIpGeneratorVisitor {
    type Value = Box<dyn CustomizationIpGeneratorTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid CustomizationIpGeneratorTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl CustomizationIpGeneratorTrait for CustomizationIpGenerator {
}
impl CustomizationIpGeneratorTrait for CustomizationCustomIpGenerator {
}
impl CustomizationIpGeneratorTrait for CustomizationDhcpIpGenerator {
}
impl CustomizationIpGeneratorTrait for CustomizationFixedIp {
}
impl CustomizationIpGeneratorTrait for CustomizationUnknownIpGenerator {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn CustomizationIpGeneratorTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::CustomizationIpGenerator => Some(from.as_any_ref().downcast_ref::<CustomizationIpGenerator>()?),
            StructType::CustomizationCustomIpGenerator => Some(from.as_any_ref().downcast_ref::<CustomizationCustomIpGenerator>()?),
            StructType::CustomizationDhcpIpGenerator => Some(from.as_any_ref().downcast_ref::<CustomizationDhcpIpGenerator>()?),
            StructType::CustomizationFixedIp => Some(from.as_any_ref().downcast_ref::<CustomizationFixedIp>()?),
            StructType::CustomizationUnknownIpGenerator => Some(from.as_any_ref().downcast_ref::<CustomizationUnknownIpGenerator>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::CustomizationIpGenerator => Ok(from.as_any_box().downcast::<CustomizationIpGenerator>()?),
            StructType::CustomizationCustomIpGenerator => Ok(from.as_any_box().downcast::<CustomizationCustomIpGenerator>()?),
            StructType::CustomizationDhcpIpGenerator => Ok(from.as_any_box().downcast::<CustomizationDhcpIpGenerator>()?),
            StructType::CustomizationFixedIp => Ok(from.as_any_box().downcast::<CustomizationFixedIp>()?),
            StructType::CustomizationUnknownIpGenerator => Ok(from.as_any_box().downcast::<CustomizationUnknownIpGenerator>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base type for the various IpV6 specification possibilities
pub trait CustomizationIpV6GeneratorTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn CustomizationIpV6GeneratorTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn CustomizationIpV6GeneratorTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(CustomizationIpV6GeneratorVisitor)
            }
        }

struct CustomizationIpV6GeneratorVisitor;

impl<'de> de::Visitor<'de> for CustomizationIpV6GeneratorVisitor {
    type Value = Box<dyn CustomizationIpV6GeneratorTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid CustomizationIpV6GeneratorTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl CustomizationIpV6GeneratorTrait for CustomizationIpV6Generator {
}
impl CustomizationIpV6GeneratorTrait for CustomizationAutoIpV6Generator {
}
impl CustomizationIpV6GeneratorTrait for CustomizationCustomIpV6Generator {
}
impl CustomizationIpV6GeneratorTrait for CustomizationDhcpIpV6Generator {
}
impl CustomizationIpV6GeneratorTrait for CustomizationFixedIpV6 {
}
impl CustomizationIpV6GeneratorTrait for CustomizationStatelessIpV6Generator {
}
impl CustomizationIpV6GeneratorTrait for CustomizationUnknownIpV6Generator {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn CustomizationIpV6GeneratorTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::CustomizationIpV6Generator => Some(from.as_any_ref().downcast_ref::<CustomizationIpV6Generator>()?),
            StructType::CustomizationAutoIpV6Generator => Some(from.as_any_ref().downcast_ref::<CustomizationAutoIpV6Generator>()?),
            StructType::CustomizationCustomIpV6Generator => Some(from.as_any_ref().downcast_ref::<CustomizationCustomIpV6Generator>()?),
            StructType::CustomizationDhcpIpV6Generator => Some(from.as_any_ref().downcast_ref::<CustomizationDhcpIpV6Generator>()?),
            StructType::CustomizationFixedIpV6 => Some(from.as_any_ref().downcast_ref::<CustomizationFixedIpV6>()?),
            StructType::CustomizationStatelessIpV6Generator => Some(from.as_any_ref().downcast_ref::<CustomizationStatelessIpV6Generator>()?),
            StructType::CustomizationUnknownIpV6Generator => Some(from.as_any_ref().downcast_ref::<CustomizationUnknownIpV6Generator>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::CustomizationIpV6Generator => Ok(from.as_any_box().downcast::<CustomizationIpV6Generator>()?),
            StructType::CustomizationAutoIpV6Generator => Ok(from.as_any_box().downcast::<CustomizationAutoIpV6Generator>()?),
            StructType::CustomizationCustomIpV6Generator => Ok(from.as_any_box().downcast::<CustomizationCustomIpV6Generator>()?),
            StructType::CustomizationDhcpIpV6Generator => Ok(from.as_any_box().downcast::<CustomizationDhcpIpV6Generator>()?),
            StructType::CustomizationFixedIpV6 => Ok(from.as_any_box().downcast::<CustomizationFixedIpV6>()?),
            StructType::CustomizationStatelessIpV6Generator => Ok(from.as_any_box().downcast::<CustomizationStatelessIpV6Generator>()?),
            StructType::CustomizationUnknownIpV6Generator => Ok(from.as_any_box().downcast::<CustomizationUnknownIpV6Generator>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// A base object type for a virtual machine name that can be either fixed or
/// auto-generated.
pub trait CustomizationNameTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn CustomizationNameTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn CustomizationNameTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(CustomizationNameVisitor)
            }
        }

struct CustomizationNameVisitor;

impl<'de> de::Visitor<'de> for CustomizationNameVisitor {
    type Value = Box<dyn CustomizationNameTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid CustomizationNameTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl CustomizationNameTrait for CustomizationName {
}
impl CustomizationNameTrait for CustomizationCustomName {
}
impl CustomizationNameTrait for CustomizationFixedName {
}
impl CustomizationNameTrait for CustomizationPrefixName {
}
impl CustomizationNameTrait for CustomizationUnknownName {
}
impl CustomizationNameTrait for CustomizationVirtualMachineName {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn CustomizationNameTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::CustomizationName => Some(from.as_any_ref().downcast_ref::<CustomizationName>()?),
            StructType::CustomizationCustomName => Some(from.as_any_ref().downcast_ref::<CustomizationCustomName>()?),
            StructType::CustomizationFixedName => Some(from.as_any_ref().downcast_ref::<CustomizationFixedName>()?),
            StructType::CustomizationPrefixName => Some(from.as_any_ref().downcast_ref::<CustomizationPrefixName>()?),
            StructType::CustomizationUnknownName => Some(from.as_any_ref().downcast_ref::<CustomizationUnknownName>()?),
            StructType::CustomizationVirtualMachineName => Some(from.as_any_ref().downcast_ref::<CustomizationVirtualMachineName>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::CustomizationName => Ok(from.as_any_box().downcast::<CustomizationName>()?),
            StructType::CustomizationCustomName => Ok(from.as_any_box().downcast::<CustomizationCustomName>()?),
            StructType::CustomizationFixedName => Ok(from.as_any_box().downcast::<CustomizationFixedName>()?),
            StructType::CustomizationPrefixName => Ok(from.as_any_box().downcast::<CustomizationPrefixName>()?),
            StructType::CustomizationUnknownName => Ok(from.as_any_box().downcast::<CustomizationUnknownName>()?),
            StructType::CustomizationVirtualMachineName => Ok(from.as_any_box().downcast::<CustomizationVirtualMachineName>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base object type for optional operations supported by the customization process.
pub trait CustomizationOptionsTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn CustomizationOptionsTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn CustomizationOptionsTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(CustomizationOptionsVisitor)
            }
        }

struct CustomizationOptionsVisitor;

impl<'de> de::Visitor<'de> for CustomizationOptionsVisitor {
    type Value = Box<dyn CustomizationOptionsTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid CustomizationOptionsTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl CustomizationOptionsTrait for CustomizationOptions {
}
impl CustomizationOptionsTrait for CustomizationLinuxOptions {
}
impl CustomizationOptionsTrait for CustomizationWinOptions {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn CustomizationOptionsTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::CustomizationOptions => Some(from.as_any_ref().downcast_ref::<CustomizationOptions>()?),
            StructType::CustomizationLinuxOptions => Some(from.as_any_ref().downcast_ref::<CustomizationLinuxOptions>()?),
            StructType::CustomizationWinOptions => Some(from.as_any_ref().downcast_ref::<CustomizationWinOptions>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::CustomizationOptions => Ok(from.as_any_box().downcast::<CustomizationOptions>()?),
            StructType::CustomizationLinuxOptions => Ok(from.as_any_box().downcast::<CustomizationLinuxOptions>()?),
            StructType::CustomizationWinOptions => Ok(from.as_any_box().downcast::<CustomizationWinOptions>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// VirtualDevice is the base data object type for devices in a virtual machine.
/// 
/// This type contains enough information about a virtual device to allow clients
/// to display devices they do not recognize. For example, a client with an
/// older version than the server to which it connects may see a device
/// without knowing what it is.
pub trait VirtualDeviceTrait : super::traits::DataObjectTrait {
    /// A unique key that distinguishes this device from other
    /// devices in the same virtual machine.
    /// 
    /// Keys are immutable but may be
    /// recycled; that is, a key does not change as long as the device is
    /// associated with a particular virtual machine. However, once a device is
    /// removed, its key may be used when another device is added.
    /// 
    /// This property is not read-only, but the client cannot control its value.
    /// Persistent device keys are always assigned and managed by the server, which
    /// guarantees that all devices will have non-negative key values.
    /// 
    /// When adding new devices, it may be necessary for a client to assign keys
    /// temporarily in order to associate controllers with devices in
    /// configuring a virtual machine. However, the server does not allow a
    /// client to reassign a device key, and the server may assign a different
    /// value from the one passed during configuration. Clients should ensure
    /// that existing device keys are not reused as temporary key values for the
    /// new device to be added (for example, by using unique negative integers as
    /// temporary keys).
    /// 
    /// When editing or deleting a device, clients must use the server-provided key
    /// to refer to an existing device.
    fn get_key(&self) -> i32;
    /// Provides a label and summary information for the device.
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>>;
    /// Information about the backing of this virtual device presented
    /// in the context of the virtual machine's environment.
    /// 
    /// Not all devices are required to have backing information.
    /// 
    /// See also *VirtualMachineConfigOption*.
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>>;
    /// Provides information about restrictions on removing this device while
    /// a virtual machine is running.
    /// 
    /// If the device is not removable, then
    /// this property is null.
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo>;
    /// Information about the bus slot of a device in a virtual machine.
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>>;
    /// Object key for the controller object for this device.
    /// 
    /// This property contains the key property value of the controller device
    /// object.
    fn get_controller_key(&self) -> Option<i32>;
    /// The unit number of this device on its controller.
    /// 
    /// This property is null if
    /// the controller property is null (for example, when the device is not
    /// attached to a specific controller object).
    /// 
    /// Normally, two devices on the same controller
    /// may not be assigned the same unit number. If
    /// multiple devices could exist on a controller,
    /// then unit number has to be specified to
    /// configure respective devices.
    fn get_unit_number(&self) -> Option<i32>;
    /// The virtual NUMA node.
    /// 
    /// A negative number means there is no
    /// affinity for the device. A positive number is a vNUMA node.
    /// An unset value of numaNode is status-quo during Reconfigure time.
    /// If numaNode is unset during ConfigInfo, then it means there is no
    /// affinity for the device.
    /// 
    /// ***Since:*** vSphere API Release 8.0.0.1
    fn get_numa_node(&self) -> Option<i32>;
    /// Information about device group device is part of.
    /// 
    /// Devices in the device group cannot be added/removed individually,
    /// whole group has to be added/removed at once. Value can be set
    /// during device add, it cannot be modified later.
    /// 
    /// ***Since:*** vSphere API Release 8.0.0.1
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo>;
}
impl<'s> serde::Serialize for dyn VirtualDeviceTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDeviceTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDeviceVisitor)
            }
        }

struct VirtualDeviceVisitor;

impl<'de> de::Visitor<'de> for VirtualDeviceVisitor {
    type Value = Box<dyn VirtualDeviceTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDeviceTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDeviceTrait for VirtualDevice {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualCdrom {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualController {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualIdeController {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualNvdimmController {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualNvmeController {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualPciController {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualPs2Controller {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualSataController {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualAhciController {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualScsiController {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for ParaVirtualScsiController {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualBusLogicController {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualLsiLogicController {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualLsiLogicSasController {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualSioController {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualUsbController {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualUsbxhciController {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualDisk {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualEthernetCard {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualE1000 {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualE1000E {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualPcNet32 {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualSriovEthernetCard {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualVmxnet {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualVmxnet2 {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualVmxnet3 {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualVmxnet3Vrdma {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualFloppy {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualKeyboard {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualNvdimm {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualPciPassthrough {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualParallelPort {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualPointingDevice {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualPrecisionClock {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualScsiPassthrough {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualSerialPort {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualSoundCard {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualEnsoniq1371 {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualHdAudioCard {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualSoundBlaster16 {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualTpm {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualUsb {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualMachineVmciDevice {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualMachineVmirom {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualMachineVideoCard {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl VirtualDeviceTrait for VirtualWdt {
    fn get_key(&self) -> i32 { self.key }
    fn get_device_info(&self) -> &Option<Box<dyn super::traits::DescriptionTrait>> { &self.device_info }
    fn get_backing(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBackingInfoTrait>> { &self.backing }
    fn get_connectable(&self) -> &Option<VirtualDeviceConnectInfo> { &self.connectable }
    fn get_slot_info(&self) -> &Option<Box<dyn super::traits::VirtualDeviceBusSlotInfoTrait>> { &self.slot_info }
    fn get_controller_key(&self) -> Option<i32> { self.controller_key }
    fn get_unit_number(&self) -> Option<i32> { self.unit_number }
    fn get_numa_node(&self) -> Option<i32> { self.numa_node }
    fn get_device_group_info(&self) -> &Option<VirtualDeviceDeviceGroupInfo> { &self.device_group_info }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDeviceTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDevice => Some(from.as_any_ref().downcast_ref::<VirtualDevice>()?),
            StructType::VirtualCdrom => Some(from.as_any_ref().downcast_ref::<VirtualCdrom>()?),
            StructType::VirtualController => Some(from.as_any_ref().downcast_ref::<VirtualController>()?),
            StructType::VirtualIdeController => Some(from.as_any_ref().downcast_ref::<VirtualIdeController>()?),
            StructType::VirtualNvdimmController => Some(from.as_any_ref().downcast_ref::<VirtualNvdimmController>()?),
            StructType::VirtualNvmeController => Some(from.as_any_ref().downcast_ref::<VirtualNvmeController>()?),
            StructType::VirtualPciController => Some(from.as_any_ref().downcast_ref::<VirtualPciController>()?),
            StructType::VirtualPs2Controller => Some(from.as_any_ref().downcast_ref::<VirtualPs2Controller>()?),
            StructType::VirtualSataController => Some(from.as_any_ref().downcast_ref::<VirtualSataController>()?),
            StructType::VirtualAhciController => Some(from.as_any_ref().downcast_ref::<VirtualAhciController>()?),
            StructType::VirtualScsiController => Some(from.as_any_ref().downcast_ref::<VirtualScsiController>()?),
            StructType::ParaVirtualScsiController => Some(from.as_any_ref().downcast_ref::<ParaVirtualScsiController>()?),
            StructType::VirtualBusLogicController => Some(from.as_any_ref().downcast_ref::<VirtualBusLogicController>()?),
            StructType::VirtualLsiLogicController => Some(from.as_any_ref().downcast_ref::<VirtualLsiLogicController>()?),
            StructType::VirtualLsiLogicSasController => Some(from.as_any_ref().downcast_ref::<VirtualLsiLogicSasController>()?),
            StructType::VirtualSioController => Some(from.as_any_ref().downcast_ref::<VirtualSioController>()?),
            StructType::VirtualUsbController => Some(from.as_any_ref().downcast_ref::<VirtualUsbController>()?),
            StructType::VirtualUsbxhciController => Some(from.as_any_ref().downcast_ref::<VirtualUsbxhciController>()?),
            StructType::VirtualDisk => Some(from.as_any_ref().downcast_ref::<VirtualDisk>()?),
            StructType::VirtualEthernetCard => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCard>()?),
            StructType::VirtualE1000 => Some(from.as_any_ref().downcast_ref::<VirtualE1000>()?),
            StructType::VirtualE1000E => Some(from.as_any_ref().downcast_ref::<VirtualE1000E>()?),
            StructType::VirtualPcNet32 => Some(from.as_any_ref().downcast_ref::<VirtualPcNet32>()?),
            StructType::VirtualSriovEthernetCard => Some(from.as_any_ref().downcast_ref::<VirtualSriovEthernetCard>()?),
            StructType::VirtualVmxnet => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet>()?),
            StructType::VirtualVmxnet2 => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet2>()?),
            StructType::VirtualVmxnet3 => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3>()?),
            StructType::VirtualVmxnet3Vrdma => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3Vrdma>()?),
            StructType::VirtualFloppy => Some(from.as_any_ref().downcast_ref::<VirtualFloppy>()?),
            StructType::VirtualKeyboard => Some(from.as_any_ref().downcast_ref::<VirtualKeyboard>()?),
            StructType::VirtualNvdimm => Some(from.as_any_ref().downcast_ref::<VirtualNvdimm>()?),
            StructType::VirtualPciPassthrough => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthrough>()?),
            StructType::VirtualParallelPort => Some(from.as_any_ref().downcast_ref::<VirtualParallelPort>()?),
            StructType::VirtualPointingDevice => Some(from.as_any_ref().downcast_ref::<VirtualPointingDevice>()?),
            StructType::VirtualPrecisionClock => Some(from.as_any_ref().downcast_ref::<VirtualPrecisionClock>()?),
            StructType::VirtualScsiPassthrough => Some(from.as_any_ref().downcast_ref::<VirtualScsiPassthrough>()?),
            StructType::VirtualSerialPort => Some(from.as_any_ref().downcast_ref::<VirtualSerialPort>()?),
            StructType::VirtualSoundCard => Some(from.as_any_ref().downcast_ref::<VirtualSoundCard>()?),
            StructType::VirtualEnsoniq1371 => Some(from.as_any_ref().downcast_ref::<VirtualEnsoniq1371>()?),
            StructType::VirtualHdAudioCard => Some(from.as_any_ref().downcast_ref::<VirtualHdAudioCard>()?),
            StructType::VirtualSoundBlaster16 => Some(from.as_any_ref().downcast_ref::<VirtualSoundBlaster16>()?),
            StructType::VirtualTpm => Some(from.as_any_ref().downcast_ref::<VirtualTpm>()?),
            StructType::VirtualUsb => Some(from.as_any_ref().downcast_ref::<VirtualUsb>()?),
            StructType::VirtualMachineVmciDevice => Some(from.as_any_ref().downcast_ref::<VirtualMachineVmciDevice>()?),
            StructType::VirtualMachineVmirom => Some(from.as_any_ref().downcast_ref::<VirtualMachineVmirom>()?),
            StructType::VirtualMachineVideoCard => Some(from.as_any_ref().downcast_ref::<VirtualMachineVideoCard>()?),
            StructType::VirtualWdt => Some(from.as_any_ref().downcast_ref::<VirtualWdt>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDevice => Ok(from.as_any_box().downcast::<VirtualDevice>()?),
            StructType::VirtualCdrom => Ok(from.as_any_box().downcast::<VirtualCdrom>()?),
            StructType::VirtualController => Ok(from.as_any_box().downcast::<VirtualController>()?),
            StructType::VirtualIdeController => Ok(from.as_any_box().downcast::<VirtualIdeController>()?),
            StructType::VirtualNvdimmController => Ok(from.as_any_box().downcast::<VirtualNvdimmController>()?),
            StructType::VirtualNvmeController => Ok(from.as_any_box().downcast::<VirtualNvmeController>()?),
            StructType::VirtualPciController => Ok(from.as_any_box().downcast::<VirtualPciController>()?),
            StructType::VirtualPs2Controller => Ok(from.as_any_box().downcast::<VirtualPs2Controller>()?),
            StructType::VirtualSataController => Ok(from.as_any_box().downcast::<VirtualSataController>()?),
            StructType::VirtualAhciController => Ok(from.as_any_box().downcast::<VirtualAhciController>()?),
            StructType::VirtualScsiController => Ok(from.as_any_box().downcast::<VirtualScsiController>()?),
            StructType::ParaVirtualScsiController => Ok(from.as_any_box().downcast::<ParaVirtualScsiController>()?),
            StructType::VirtualBusLogicController => Ok(from.as_any_box().downcast::<VirtualBusLogicController>()?),
            StructType::VirtualLsiLogicController => Ok(from.as_any_box().downcast::<VirtualLsiLogicController>()?),
            StructType::VirtualLsiLogicSasController => Ok(from.as_any_box().downcast::<VirtualLsiLogicSasController>()?),
            StructType::VirtualSioController => Ok(from.as_any_box().downcast::<VirtualSioController>()?),
            StructType::VirtualUsbController => Ok(from.as_any_box().downcast::<VirtualUsbController>()?),
            StructType::VirtualUsbxhciController => Ok(from.as_any_box().downcast::<VirtualUsbxhciController>()?),
            StructType::VirtualDisk => Ok(from.as_any_box().downcast::<VirtualDisk>()?),
            StructType::VirtualEthernetCard => Ok(from.as_any_box().downcast::<VirtualEthernetCard>()?),
            StructType::VirtualE1000 => Ok(from.as_any_box().downcast::<VirtualE1000>()?),
            StructType::VirtualE1000E => Ok(from.as_any_box().downcast::<VirtualE1000E>()?),
            StructType::VirtualPcNet32 => Ok(from.as_any_box().downcast::<VirtualPcNet32>()?),
            StructType::VirtualSriovEthernetCard => Ok(from.as_any_box().downcast::<VirtualSriovEthernetCard>()?),
            StructType::VirtualVmxnet => Ok(from.as_any_box().downcast::<VirtualVmxnet>()?),
            StructType::VirtualVmxnet2 => Ok(from.as_any_box().downcast::<VirtualVmxnet2>()?),
            StructType::VirtualVmxnet3 => Ok(from.as_any_box().downcast::<VirtualVmxnet3>()?),
            StructType::VirtualVmxnet3Vrdma => Ok(from.as_any_box().downcast::<VirtualVmxnet3Vrdma>()?),
            StructType::VirtualFloppy => Ok(from.as_any_box().downcast::<VirtualFloppy>()?),
            StructType::VirtualKeyboard => Ok(from.as_any_box().downcast::<VirtualKeyboard>()?),
            StructType::VirtualNvdimm => Ok(from.as_any_box().downcast::<VirtualNvdimm>()?),
            StructType::VirtualPciPassthrough => Ok(from.as_any_box().downcast::<VirtualPciPassthrough>()?),
            StructType::VirtualParallelPort => Ok(from.as_any_box().downcast::<VirtualParallelPort>()?),
            StructType::VirtualPointingDevice => Ok(from.as_any_box().downcast::<VirtualPointingDevice>()?),
            StructType::VirtualPrecisionClock => Ok(from.as_any_box().downcast::<VirtualPrecisionClock>()?),
            StructType::VirtualScsiPassthrough => Ok(from.as_any_box().downcast::<VirtualScsiPassthrough>()?),
            StructType::VirtualSerialPort => Ok(from.as_any_box().downcast::<VirtualSerialPort>()?),
            StructType::VirtualSoundCard => Ok(from.as_any_box().downcast::<VirtualSoundCard>()?),
            StructType::VirtualEnsoniq1371 => Ok(from.as_any_box().downcast::<VirtualEnsoniq1371>()?),
            StructType::VirtualHdAudioCard => Ok(from.as_any_box().downcast::<VirtualHdAudioCard>()?),
            StructType::VirtualSoundBlaster16 => Ok(from.as_any_box().downcast::<VirtualSoundBlaster16>()?),
            StructType::VirtualTpm => Ok(from.as_any_box().downcast::<VirtualTpm>()?),
            StructType::VirtualUsb => Ok(from.as_any_box().downcast::<VirtualUsb>()?),
            StructType::VirtualMachineVmciDevice => Ok(from.as_any_box().downcast::<VirtualMachineVmciDevice>()?),
            StructType::VirtualMachineVmirom => Ok(from.as_any_box().downcast::<VirtualMachineVmirom>()?),
            StructType::VirtualMachineVideoCard => Ok(from.as_any_box().downcast::<VirtualMachineVideoCard>()?),
            StructType::VirtualWdt => Ok(from.as_any_box().downcast::<VirtualWdt>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// VirtualController is the base data object type for a device controller in
/// a virtual machine.
/// 
/// VirtualController extends
/// *VirtualDevice* to inherit
/// general information about a controller (such as name and description), and to allow
/// controllers to appear in a generic list of virtual devices.
pub trait VirtualControllerTrait : super::traits::VirtualDeviceTrait {
    /// Bus number associated with this controller.
    fn get_bus_number(&self) -> i32;
    /// List of devices currently controlled by this controller.
    /// 
    /// Each entry contains the *VirtualDevice.key* property of the
    /// corresponding device object.
    fn get_device(&self) -> &Option<Vec<i32>>;
}
impl<'s> serde::Serialize for dyn VirtualControllerTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualControllerTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualControllerVisitor)
            }
        }

struct VirtualControllerVisitor;

impl<'de> de::Visitor<'de> for VirtualControllerVisitor {
    type Value = Box<dyn VirtualControllerTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualControllerTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualControllerTrait for VirtualController {
    fn get_bus_number(&self) -> i32 { self.bus_number }
    fn get_device(&self) -> &Option<Vec<i32>> { &self.device }
}
impl VirtualControllerTrait for VirtualIdeController {
    fn get_bus_number(&self) -> i32 { self.bus_number }
    fn get_device(&self) -> &Option<Vec<i32>> { &self.device }
}
impl VirtualControllerTrait for VirtualNvdimmController {
    fn get_bus_number(&self) -> i32 { self.bus_number }
    fn get_device(&self) -> &Option<Vec<i32>> { &self.device }
}
impl VirtualControllerTrait for VirtualNvmeController {
    fn get_bus_number(&self) -> i32 { self.bus_number }
    fn get_device(&self) -> &Option<Vec<i32>> { &self.device }
}
impl VirtualControllerTrait for VirtualPciController {
    fn get_bus_number(&self) -> i32 { self.bus_number }
    fn get_device(&self) -> &Option<Vec<i32>> { &self.device }
}
impl VirtualControllerTrait for VirtualPs2Controller {
    fn get_bus_number(&self) -> i32 { self.bus_number }
    fn get_device(&self) -> &Option<Vec<i32>> { &self.device }
}
impl VirtualControllerTrait for VirtualSataController {
    fn get_bus_number(&self) -> i32 { self.bus_number }
    fn get_device(&self) -> &Option<Vec<i32>> { &self.device }
}
impl VirtualControllerTrait for VirtualAhciController {
    fn get_bus_number(&self) -> i32 { self.bus_number }
    fn get_device(&self) -> &Option<Vec<i32>> { &self.device }
}
impl VirtualControllerTrait for VirtualScsiController {
    fn get_bus_number(&self) -> i32 { self.bus_number }
    fn get_device(&self) -> &Option<Vec<i32>> { &self.device }
}
impl VirtualControllerTrait for ParaVirtualScsiController {
    fn get_bus_number(&self) -> i32 { self.bus_number }
    fn get_device(&self) -> &Option<Vec<i32>> { &self.device }
}
impl VirtualControllerTrait for VirtualBusLogicController {
    fn get_bus_number(&self) -> i32 { self.bus_number }
    fn get_device(&self) -> &Option<Vec<i32>> { &self.device }
}
impl VirtualControllerTrait for VirtualLsiLogicController {
    fn get_bus_number(&self) -> i32 { self.bus_number }
    fn get_device(&self) -> &Option<Vec<i32>> { &self.device }
}
impl VirtualControllerTrait for VirtualLsiLogicSasController {
    fn get_bus_number(&self) -> i32 { self.bus_number }
    fn get_device(&self) -> &Option<Vec<i32>> { &self.device }
}
impl VirtualControllerTrait for VirtualSioController {
    fn get_bus_number(&self) -> i32 { self.bus_number }
    fn get_device(&self) -> &Option<Vec<i32>> { &self.device }
}
impl VirtualControllerTrait for VirtualUsbController {
    fn get_bus_number(&self) -> i32 { self.bus_number }
    fn get_device(&self) -> &Option<Vec<i32>> { &self.device }
}
impl VirtualControllerTrait for VirtualUsbxhciController {
    fn get_bus_number(&self) -> i32 { self.bus_number }
    fn get_device(&self) -> &Option<Vec<i32>> { &self.device }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualControllerTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualController => Some(from.as_any_ref().downcast_ref::<VirtualController>()?),
            StructType::VirtualIdeController => Some(from.as_any_ref().downcast_ref::<VirtualIdeController>()?),
            StructType::VirtualNvdimmController => Some(from.as_any_ref().downcast_ref::<VirtualNvdimmController>()?),
            StructType::VirtualNvmeController => Some(from.as_any_ref().downcast_ref::<VirtualNvmeController>()?),
            StructType::VirtualPciController => Some(from.as_any_ref().downcast_ref::<VirtualPciController>()?),
            StructType::VirtualPs2Controller => Some(from.as_any_ref().downcast_ref::<VirtualPs2Controller>()?),
            StructType::VirtualSataController => Some(from.as_any_ref().downcast_ref::<VirtualSataController>()?),
            StructType::VirtualAhciController => Some(from.as_any_ref().downcast_ref::<VirtualAhciController>()?),
            StructType::VirtualScsiController => Some(from.as_any_ref().downcast_ref::<VirtualScsiController>()?),
            StructType::ParaVirtualScsiController => Some(from.as_any_ref().downcast_ref::<ParaVirtualScsiController>()?),
            StructType::VirtualBusLogicController => Some(from.as_any_ref().downcast_ref::<VirtualBusLogicController>()?),
            StructType::VirtualLsiLogicController => Some(from.as_any_ref().downcast_ref::<VirtualLsiLogicController>()?),
            StructType::VirtualLsiLogicSasController => Some(from.as_any_ref().downcast_ref::<VirtualLsiLogicSasController>()?),
            StructType::VirtualSioController => Some(from.as_any_ref().downcast_ref::<VirtualSioController>()?),
            StructType::VirtualUsbController => Some(from.as_any_ref().downcast_ref::<VirtualUsbController>()?),
            StructType::VirtualUsbxhciController => Some(from.as_any_ref().downcast_ref::<VirtualUsbxhciController>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualController => Ok(from.as_any_box().downcast::<VirtualController>()?),
            StructType::VirtualIdeController => Ok(from.as_any_box().downcast::<VirtualIdeController>()?),
            StructType::VirtualNvdimmController => Ok(from.as_any_box().downcast::<VirtualNvdimmController>()?),
            StructType::VirtualNvmeController => Ok(from.as_any_box().downcast::<VirtualNvmeController>()?),
            StructType::VirtualPciController => Ok(from.as_any_box().downcast::<VirtualPciController>()?),
            StructType::VirtualPs2Controller => Ok(from.as_any_box().downcast::<VirtualPs2Controller>()?),
            StructType::VirtualSataController => Ok(from.as_any_box().downcast::<VirtualSataController>()?),
            StructType::VirtualAhciController => Ok(from.as_any_box().downcast::<VirtualAhciController>()?),
            StructType::VirtualScsiController => Ok(from.as_any_box().downcast::<VirtualScsiController>()?),
            StructType::ParaVirtualScsiController => Ok(from.as_any_box().downcast::<ParaVirtualScsiController>()?),
            StructType::VirtualBusLogicController => Ok(from.as_any_box().downcast::<VirtualBusLogicController>()?),
            StructType::VirtualLsiLogicController => Ok(from.as_any_box().downcast::<VirtualLsiLogicController>()?),
            StructType::VirtualLsiLogicSasController => Ok(from.as_any_box().downcast::<VirtualLsiLogicSasController>()?),
            StructType::VirtualSioController => Ok(from.as_any_box().downcast::<VirtualSioController>()?),
            StructType::VirtualUsbController => Ok(from.as_any_box().downcast::<VirtualUsbController>()?),
            StructType::VirtualUsbxhciController => Ok(from.as_any_box().downcast::<VirtualUsbxhciController>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The VirtualSATAController data object type represents
/// a SATA controller in a virtual machine.
pub trait VirtualSataControllerTrait : super::traits::VirtualControllerTrait {
}
impl<'s> serde::Serialize for dyn VirtualSataControllerTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualSataControllerTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualSataControllerVisitor)
            }
        }

struct VirtualSataControllerVisitor;

impl<'de> de::Visitor<'de> for VirtualSataControllerVisitor {
    type Value = Box<dyn VirtualSataControllerTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualSataControllerTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualSataControllerTrait for VirtualSataController {
}
impl VirtualSataControllerTrait for VirtualAhciController {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualSataControllerTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualSataController => Some(from.as_any_ref().downcast_ref::<VirtualSataController>()?),
            StructType::VirtualAhciController => Some(from.as_any_ref().downcast_ref::<VirtualAhciController>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualSataController => Ok(from.as_any_box().downcast::<VirtualSataController>()?),
            StructType::VirtualAhciController => Ok(from.as_any_box().downcast::<VirtualAhciController>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The VirtualSCSIController data object type represents
/// a SCSI controller in a virtual machine.
pub trait VirtualScsiControllerTrait : super::traits::VirtualControllerTrait {
    /// All SCSI controllers support hot adding and removing of devices.
    /// 
    /// This
    /// support can't be toggled in the current implementation. Therefore, this
    /// option is ignored when reconfiguring a SCSI controller and is always set
    /// to "true" when reading an existing configuration.
    fn get_hot_add_remove(&self) -> Option<bool>;
    /// Mode for sharing the SCSI bus.
    /// 
    /// The modes are physicalSharing,
    /// virtualSharing, and noSharing. See the
    /// *Sharing*
    /// data object type for an explanation of these modes.
    fn get_shared_bus(&self) -> &super::enums::VirtualScsiSharingEnum;
    /// The unit number of the SCSI controller.
    /// 
    /// The SCSI controller sits on its
    /// own bus, so this field defines which slot the controller is using.
    fn get_scsi_ctlr_unit_number(&self) -> Option<i32>;
}
impl<'s> serde::Serialize for dyn VirtualScsiControllerTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualScsiControllerTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualScsiControllerVisitor)
            }
        }

struct VirtualScsiControllerVisitor;

impl<'de> de::Visitor<'de> for VirtualScsiControllerVisitor {
    type Value = Box<dyn VirtualScsiControllerTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualScsiControllerTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualScsiControllerTrait for VirtualScsiController {
    fn get_hot_add_remove(&self) -> Option<bool> { self.hot_add_remove }
    fn get_shared_bus(&self) -> &super::enums::VirtualScsiSharingEnum { &self.shared_bus }
    fn get_scsi_ctlr_unit_number(&self) -> Option<i32> { self.scsi_ctlr_unit_number }
}
impl VirtualScsiControllerTrait for ParaVirtualScsiController {
    fn get_hot_add_remove(&self) -> Option<bool> { self.hot_add_remove }
    fn get_shared_bus(&self) -> &super::enums::VirtualScsiSharingEnum { &self.shared_bus }
    fn get_scsi_ctlr_unit_number(&self) -> Option<i32> { self.scsi_ctlr_unit_number }
}
impl VirtualScsiControllerTrait for VirtualBusLogicController {
    fn get_hot_add_remove(&self) -> Option<bool> { self.hot_add_remove }
    fn get_shared_bus(&self) -> &super::enums::VirtualScsiSharingEnum { &self.shared_bus }
    fn get_scsi_ctlr_unit_number(&self) -> Option<i32> { self.scsi_ctlr_unit_number }
}
impl VirtualScsiControllerTrait for VirtualLsiLogicController {
    fn get_hot_add_remove(&self) -> Option<bool> { self.hot_add_remove }
    fn get_shared_bus(&self) -> &super::enums::VirtualScsiSharingEnum { &self.shared_bus }
    fn get_scsi_ctlr_unit_number(&self) -> Option<i32> { self.scsi_ctlr_unit_number }
}
impl VirtualScsiControllerTrait for VirtualLsiLogicSasController {
    fn get_hot_add_remove(&self) -> Option<bool> { self.hot_add_remove }
    fn get_shared_bus(&self) -> &super::enums::VirtualScsiSharingEnum { &self.shared_bus }
    fn get_scsi_ctlr_unit_number(&self) -> Option<i32> { self.scsi_ctlr_unit_number }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualScsiControllerTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualScsiController => Some(from.as_any_ref().downcast_ref::<VirtualScsiController>()?),
            StructType::ParaVirtualScsiController => Some(from.as_any_ref().downcast_ref::<ParaVirtualScsiController>()?),
            StructType::VirtualBusLogicController => Some(from.as_any_ref().downcast_ref::<VirtualBusLogicController>()?),
            StructType::VirtualLsiLogicController => Some(from.as_any_ref().downcast_ref::<VirtualLsiLogicController>()?),
            StructType::VirtualLsiLogicSasController => Some(from.as_any_ref().downcast_ref::<VirtualLsiLogicSasController>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualScsiController => Ok(from.as_any_box().downcast::<VirtualScsiController>()?),
            StructType::ParaVirtualScsiController => Ok(from.as_any_box().downcast::<ParaVirtualScsiController>()?),
            StructType::VirtualBusLogicController => Ok(from.as_any_box().downcast::<VirtualBusLogicController>()?),
            StructType::VirtualLsiLogicController => Ok(from.as_any_box().downcast::<VirtualLsiLogicController>()?),
            StructType::VirtualLsiLogicSasController => Ok(from.as_any_box().downcast::<VirtualLsiLogicSasController>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *VirtualEthernetCard* data object contains the properties
/// of an Ethernet adapter attached to a virtual machine.
pub trait VirtualEthernetCardTrait : super::traits::VirtualDeviceTrait {
    /// Set of dynamic properties.
    /// 
    /// This property is optional because only the
    /// properties of an object that are unknown to a client will be part of this set.
    /// This property is not readonly just in case we want to send such properties
    /// from a client in the future.
    fn get_dynamic_property(&self) -> &Option<Vec<DynamicProperty>>;
    /// MAC address type.
    /// 
    /// Valid values for address type are:
    /// <dl>
    /// <dt>Manual</dt>
    /// <dd>Statically assigned MAC address.</dd>
    /// <dt>Generated</dt>
    /// <dd>Automatically generated MAC address.</dd>
    /// <dt>Assigned</dt>
    /// <dd>MAC address assigned by VirtualCenter.</dd>
    /// </dl>
    fn get_address_type(&self) -> &Option<String>;
    /// MAC address assigned to the virtual network adapter.
    /// 
    /// Clients can
    /// set this property to any of the allowed address types. The server might
    /// override the specified value for "Generated" or "Assigned" if it does not
    /// fall in the right ranges or is determined to be a duplicate.
    fn get_mac_address(&self) -> &Option<String>;
    /// Indicates whether wake-on-LAN is enabled on this virtual network adapter.
    /// 
    /// Clients
    /// can set this property to selectively enable or disable wake-on-LAN.
    fn get_wake_on_lan_enabled(&self) -> Option<bool>;
    /// Resource requirements of the virtual network adapter
    fn get_resource_allocation(&self) -> &Option<VirtualEthernetCardResourceAllocation>;
    /// An ID assigned to the virtual network adapter by external management plane or
    /// controller.
    /// 
    /// The value and format of this property is determined by external
    /// management plane or controller, and vSphere doesn't do any validation. It's
    /// also up to external management plane or controller to set, unset or maintain
    /// this property. Setting this property with an empty string value will unset the
    /// property.
    fn get_external_id(&self) -> &Option<String>;
    /// Deprecated as of vSphere API 8.0. VMDirectPath Gen 2 is no longer supported and
    /// there is no replacement.
    /// 
    /// Indicates whether UPT(Universal Pass-through) compatibility is enabled
    /// on this network adapter.
    /// 
    /// UPT is only compatible for Vmxnet3 adapter.
    /// Clients can set this property enabled or disabled if ethernet
    /// virtual device is Vmxnet3.
    fn get_upt_compatibility_enabled(&self) -> Option<bool>;
}
impl<'s> serde::Serialize for dyn VirtualEthernetCardTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualEthernetCardTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualEthernetCardVisitor)
            }
        }

struct VirtualEthernetCardVisitor;

impl<'de> de::Visitor<'de> for VirtualEthernetCardVisitor {
    type Value = Box<dyn VirtualEthernetCardTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualEthernetCardTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualEthernetCardTrait for VirtualEthernetCard {
    fn get_dynamic_property(&self) -> &Option<Vec<DynamicProperty>> { &self.dynamic_property }
    fn get_address_type(&self) -> &Option<String> { &self.address_type }
    fn get_mac_address(&self) -> &Option<String> { &self.mac_address }
    fn get_wake_on_lan_enabled(&self) -> Option<bool> { self.wake_on_lan_enabled }
    fn get_resource_allocation(&self) -> &Option<VirtualEthernetCardResourceAllocation> { &self.resource_allocation }
    fn get_external_id(&self) -> &Option<String> { &self.external_id }
    fn get_upt_compatibility_enabled(&self) -> Option<bool> { self.upt_compatibility_enabled }
}
impl VirtualEthernetCardTrait for VirtualE1000 {
    fn get_dynamic_property(&self) -> &Option<Vec<DynamicProperty>> { &self.dynamic_property }
    fn get_address_type(&self) -> &Option<String> { &self.address_type }
    fn get_mac_address(&self) -> &Option<String> { &self.mac_address }
    fn get_wake_on_lan_enabled(&self) -> Option<bool> { self.wake_on_lan_enabled }
    fn get_resource_allocation(&self) -> &Option<VirtualEthernetCardResourceAllocation> { &self.resource_allocation }
    fn get_external_id(&self) -> &Option<String> { &self.external_id }
    fn get_upt_compatibility_enabled(&self) -> Option<bool> { self.upt_compatibility_enabled }
}
impl VirtualEthernetCardTrait for VirtualE1000E {
    fn get_dynamic_property(&self) -> &Option<Vec<DynamicProperty>> { &self.dynamic_property }
    fn get_address_type(&self) -> &Option<String> { &self.address_type }
    fn get_mac_address(&self) -> &Option<String> { &self.mac_address }
    fn get_wake_on_lan_enabled(&self) -> Option<bool> { self.wake_on_lan_enabled }
    fn get_resource_allocation(&self) -> &Option<VirtualEthernetCardResourceAllocation> { &self.resource_allocation }
    fn get_external_id(&self) -> &Option<String> { &self.external_id }
    fn get_upt_compatibility_enabled(&self) -> Option<bool> { self.upt_compatibility_enabled }
}
impl VirtualEthernetCardTrait for VirtualPcNet32 {
    fn get_dynamic_property(&self) -> &Option<Vec<DynamicProperty>> { &self.dynamic_property }
    fn get_address_type(&self) -> &Option<String> { &self.address_type }
    fn get_mac_address(&self) -> &Option<String> { &self.mac_address }
    fn get_wake_on_lan_enabled(&self) -> Option<bool> { self.wake_on_lan_enabled }
    fn get_resource_allocation(&self) -> &Option<VirtualEthernetCardResourceAllocation> { &self.resource_allocation }
    fn get_external_id(&self) -> &Option<String> { &self.external_id }
    fn get_upt_compatibility_enabled(&self) -> Option<bool> { self.upt_compatibility_enabled }
}
impl VirtualEthernetCardTrait for VirtualSriovEthernetCard {
    fn get_dynamic_property(&self) -> &Option<Vec<DynamicProperty>> { &self.dynamic_property }
    fn get_address_type(&self) -> &Option<String> { &self.address_type }
    fn get_mac_address(&self) -> &Option<String> { &self.mac_address }
    fn get_wake_on_lan_enabled(&self) -> Option<bool> { self.wake_on_lan_enabled }
    fn get_resource_allocation(&self) -> &Option<VirtualEthernetCardResourceAllocation> { &self.resource_allocation }
    fn get_external_id(&self) -> &Option<String> { &self.external_id }
    fn get_upt_compatibility_enabled(&self) -> Option<bool> { self.upt_compatibility_enabled }
}
impl VirtualEthernetCardTrait for VirtualVmxnet {
    fn get_dynamic_property(&self) -> &Option<Vec<DynamicProperty>> { &self.dynamic_property }
    fn get_address_type(&self) -> &Option<String> { &self.address_type }
    fn get_mac_address(&self) -> &Option<String> { &self.mac_address }
    fn get_wake_on_lan_enabled(&self) -> Option<bool> { self.wake_on_lan_enabled }
    fn get_resource_allocation(&self) -> &Option<VirtualEthernetCardResourceAllocation> { &self.resource_allocation }
    fn get_external_id(&self) -> &Option<String> { &self.external_id }
    fn get_upt_compatibility_enabled(&self) -> Option<bool> { self.upt_compatibility_enabled }
}
impl VirtualEthernetCardTrait for VirtualVmxnet2 {
    fn get_dynamic_property(&self) -> &Option<Vec<DynamicProperty>> { &self.dynamic_property }
    fn get_address_type(&self) -> &Option<String> { &self.address_type }
    fn get_mac_address(&self) -> &Option<String> { &self.mac_address }
    fn get_wake_on_lan_enabled(&self) -> Option<bool> { self.wake_on_lan_enabled }
    fn get_resource_allocation(&self) -> &Option<VirtualEthernetCardResourceAllocation> { &self.resource_allocation }
    fn get_external_id(&self) -> &Option<String> { &self.external_id }
    fn get_upt_compatibility_enabled(&self) -> Option<bool> { self.upt_compatibility_enabled }
}
impl VirtualEthernetCardTrait for VirtualVmxnet3 {
    fn get_dynamic_property(&self) -> &Option<Vec<DynamicProperty>> { &self.dynamic_property }
    fn get_address_type(&self) -> &Option<String> { &self.address_type }
    fn get_mac_address(&self) -> &Option<String> { &self.mac_address }
    fn get_wake_on_lan_enabled(&self) -> Option<bool> { self.wake_on_lan_enabled }
    fn get_resource_allocation(&self) -> &Option<VirtualEthernetCardResourceAllocation> { &self.resource_allocation }
    fn get_external_id(&self) -> &Option<String> { &self.external_id }
    fn get_upt_compatibility_enabled(&self) -> Option<bool> { self.upt_compatibility_enabled }
}
impl VirtualEthernetCardTrait for VirtualVmxnet3Vrdma {
    fn get_dynamic_property(&self) -> &Option<Vec<DynamicProperty>> { &self.dynamic_property }
    fn get_address_type(&self) -> &Option<String> { &self.address_type }
    fn get_mac_address(&self) -> &Option<String> { &self.mac_address }
    fn get_wake_on_lan_enabled(&self) -> Option<bool> { self.wake_on_lan_enabled }
    fn get_resource_allocation(&self) -> &Option<VirtualEthernetCardResourceAllocation> { &self.resource_allocation }
    fn get_external_id(&self) -> &Option<String> { &self.external_id }
    fn get_upt_compatibility_enabled(&self) -> Option<bool> { self.upt_compatibility_enabled }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualEthernetCardTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualEthernetCard => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCard>()?),
            StructType::VirtualE1000 => Some(from.as_any_ref().downcast_ref::<VirtualE1000>()?),
            StructType::VirtualE1000E => Some(from.as_any_ref().downcast_ref::<VirtualE1000E>()?),
            StructType::VirtualPcNet32 => Some(from.as_any_ref().downcast_ref::<VirtualPcNet32>()?),
            StructType::VirtualSriovEthernetCard => Some(from.as_any_ref().downcast_ref::<VirtualSriovEthernetCard>()?),
            StructType::VirtualVmxnet => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet>()?),
            StructType::VirtualVmxnet2 => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet2>()?),
            StructType::VirtualVmxnet3 => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3>()?),
            StructType::VirtualVmxnet3Vrdma => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3Vrdma>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualEthernetCard => Ok(from.as_any_box().downcast::<VirtualEthernetCard>()?),
            StructType::VirtualE1000 => Ok(from.as_any_box().downcast::<VirtualE1000>()?),
            StructType::VirtualE1000E => Ok(from.as_any_box().downcast::<VirtualE1000E>()?),
            StructType::VirtualPcNet32 => Ok(from.as_any_box().downcast::<VirtualPcNet32>()?),
            StructType::VirtualSriovEthernetCard => Ok(from.as_any_box().downcast::<VirtualSriovEthernetCard>()?),
            StructType::VirtualVmxnet => Ok(from.as_any_box().downcast::<VirtualVmxnet>()?),
            StructType::VirtualVmxnet2 => Ok(from.as_any_box().downcast::<VirtualVmxnet2>()?),
            StructType::VirtualVmxnet3 => Ok(from.as_any_box().downcast::<VirtualVmxnet3>()?),
            StructType::VirtualVmxnet3Vrdma => Ok(from.as_any_box().downcast::<VirtualVmxnet3Vrdma>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The VirtualVmxnet data object type represents an instance
/// of the Vmxnet virtual Ethernet adapter attached to a virtual machine.
pub trait VirtualVmxnetTrait : super::traits::VirtualEthernetCardTrait {
}
impl<'s> serde::Serialize for dyn VirtualVmxnetTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualVmxnetTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualVmxnetVisitor)
            }
        }

struct VirtualVmxnetVisitor;

impl<'de> de::Visitor<'de> for VirtualVmxnetVisitor {
    type Value = Box<dyn VirtualVmxnetTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualVmxnetTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualVmxnetTrait for VirtualVmxnet {
}
impl VirtualVmxnetTrait for VirtualVmxnet2 {
}
impl VirtualVmxnetTrait for VirtualVmxnet3 {
}
impl VirtualVmxnetTrait for VirtualVmxnet3Vrdma {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualVmxnetTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualVmxnet => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet>()?),
            StructType::VirtualVmxnet2 => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet2>()?),
            StructType::VirtualVmxnet3 => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3>()?),
            StructType::VirtualVmxnet3Vrdma => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3Vrdma>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualVmxnet => Ok(from.as_any_box().downcast::<VirtualVmxnet>()?),
            StructType::VirtualVmxnet2 => Ok(from.as_any_box().downcast::<VirtualVmxnet2>()?),
            StructType::VirtualVmxnet3 => Ok(from.as_any_box().downcast::<VirtualVmxnet3>()?),
            StructType::VirtualVmxnet3Vrdma => Ok(from.as_any_box().downcast::<VirtualVmxnet3Vrdma>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The VirtualVmxnet3 data object type represents an instance
/// of the Vmxnet3 virtual Ethernet adapter attached to a virtual machine.
pub trait VirtualVmxnet3Trait : super::traits::VirtualVmxnetTrait {
    /// Indicates whether UPTv2(Uniform Pass-through version 2) compatibility is
    /// enabled on this network adapter.
    /// 
    /// UPTv2 is only available on Vmxnet3
    /// adapter. Clients can set this property enabled or disabled if ethernet
    /// virtual device is Vmxnet3. It requires the VM hardware version is
    /// compatible with ESXi version which has enabled smartnic feature.
    /// 
    /// ***Since:*** vSphere API Release 8.0.0.1
    fn get_uptv_2_enabled(&self) -> Option<bool>;
}
impl<'s> serde::Serialize for dyn VirtualVmxnet3Trait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualVmxnet3Trait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualVmxnet3Visitor)
            }
        }

struct VirtualVmxnet3Visitor;

impl<'de> de::Visitor<'de> for VirtualVmxnet3Visitor {
    type Value = Box<dyn VirtualVmxnet3Trait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualVmxnet3Trait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualVmxnet3Trait for VirtualVmxnet3 {
    fn get_uptv_2_enabled(&self) -> Option<bool> { self.uptv_2_enabled }
}
impl VirtualVmxnet3Trait for VirtualVmxnet3Vrdma {
    fn get_uptv_2_enabled(&self) -> Option<bool> { self.uptv_2_enabled }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualVmxnet3Trait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualVmxnet3 => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3>()?),
            StructType::VirtualVmxnet3Vrdma => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3Vrdma>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualVmxnet3 => Ok(from.as_any_box().downcast::<VirtualVmxnet3>()?),
            StructType::VirtualVmxnet3Vrdma => Ok(from.as_any_box().downcast::<VirtualVmxnet3Vrdma>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type represents a sound card in
/// a virtual machine.
pub trait VirtualSoundCardTrait : super::traits::VirtualDeviceTrait {
}
impl<'s> serde::Serialize for dyn VirtualSoundCardTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualSoundCardTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualSoundCardVisitor)
            }
        }

struct VirtualSoundCardVisitor;

impl<'de> de::Visitor<'de> for VirtualSoundCardVisitor {
    type Value = Box<dyn VirtualSoundCardTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualSoundCardTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualSoundCardTrait for VirtualSoundCard {
}
impl VirtualSoundCardTrait for VirtualEnsoniq1371 {
}
impl VirtualSoundCardTrait for VirtualHdAudioCard {
}
impl VirtualSoundCardTrait for VirtualSoundBlaster16 {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualSoundCardTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualSoundCard => Some(from.as_any_ref().downcast_ref::<VirtualSoundCard>()?),
            StructType::VirtualEnsoniq1371 => Some(from.as_any_ref().downcast_ref::<VirtualEnsoniq1371>()?),
            StructType::VirtualHdAudioCard => Some(from.as_any_ref().downcast_ref::<VirtualHdAudioCard>()?),
            StructType::VirtualSoundBlaster16 => Some(from.as_any_ref().downcast_ref::<VirtualSoundBlaster16>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualSoundCard => Ok(from.as_any_box().downcast::<VirtualSoundCard>()?),
            StructType::VirtualEnsoniq1371 => Ok(from.as_any_box().downcast::<VirtualEnsoniq1371>()?),
            StructType::VirtualHdAudioCard => Ok(from.as_any_box().downcast::<VirtualHdAudioCard>()?),
            StructType::VirtualSoundBlaster16 => Ok(from.as_any_box().downcast::<VirtualSoundBlaster16>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// <code>*VirtualDeviceBackingInfo*</code> is a base data object type
/// for information about the backing of a device in a virtual machine.
/// 
/// This base type does not define any properties. It is used as a namespace
/// for general-purpose subtypes. Specific devices are represented by subtypes
/// which define properties for device-specific backing information.
pub trait VirtualDeviceBackingInfoTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn VirtualDeviceBackingInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDeviceBackingInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDeviceBackingInfoVisitor)
            }
        }

struct VirtualDeviceBackingInfoVisitor;

impl<'de> de::Visitor<'de> for VirtualDeviceBackingInfoVisitor {
    type Value = Box<dyn VirtualDeviceBackingInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDeviceBackingInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDeviceBackingInfoTrait for VirtualDeviceBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualDeviceDeviceBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualCdromAtapiBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualCdromPassthroughBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualDiskRawDiskVer2BackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualDiskPartitionedRawDiskVer2BackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualEthernetCardLegacyNetworkBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualEthernetCardNetworkBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualFloppyDeviceBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualPciPassthroughDeviceBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualPciPassthroughDynamicBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualParallelPortDeviceBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualPointingDeviceDeviceBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualScsiPassthroughDeviceBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualSerialPortDeviceBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualSoundCardDeviceBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualUsbRemoteHostBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualUsbusbBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualDeviceFileBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualCdromIsoBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualDiskFlatVer1BackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualDiskFlatVer2BackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualDiskLocalPMemBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualDiskRawDiskMappingVer1BackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualDiskSeSparseBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualDiskSparseVer1BackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualDiskSparseVer2BackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualFloppyImageBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualNvdimmBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualParallelPortFileBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualSerialPortFileBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualDevicePipeBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualSerialPortPipeBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualDeviceRemoteDeviceBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualCdromRemoteAtapiBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualCdromRemotePassthroughBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualFloppyRemoteDeviceBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualUsbRemoteClientBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualDeviceUriBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualSerialPortUriBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualEthernetCardDistributedVirtualPortBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualEthernetCardOpaqueNetworkBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualPciPassthroughDvxBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualPciPassthroughPluginBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualPciPassthroughVmiopBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualPrecisionClockSystemClockBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualSerialPortThinPrintBackingInfo {
}
impl VirtualDeviceBackingInfoTrait for VirtualSriovEthernetCardSriovBackingInfo {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDeviceBackingInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDeviceBackingInfo>()?),
            StructType::VirtualDeviceDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDeviceDeviceBackingInfo>()?),
            StructType::VirtualCdromAtapiBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualCdromAtapiBackingInfo>()?),
            StructType::VirtualCdromPassthroughBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualCdromPassthroughBackingInfo>()?),
            StructType::VirtualDiskRawDiskVer2BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskRawDiskVer2BackingInfo>()?),
            StructType::VirtualDiskPartitionedRawDiskVer2BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskPartitionedRawDiskVer2BackingInfo>()?),
            StructType::VirtualEthernetCardLegacyNetworkBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardLegacyNetworkBackingInfo>()?),
            StructType::VirtualEthernetCardNetworkBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardNetworkBackingInfo>()?),
            StructType::VirtualFloppyDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualFloppyDeviceBackingInfo>()?),
            StructType::VirtualPciPassthroughDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughDeviceBackingInfo>()?),
            StructType::VirtualPciPassthroughDynamicBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughDynamicBackingInfo>()?),
            StructType::VirtualParallelPortDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualParallelPortDeviceBackingInfo>()?),
            StructType::VirtualPointingDeviceDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPointingDeviceDeviceBackingInfo>()?),
            StructType::VirtualScsiPassthroughDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualScsiPassthroughDeviceBackingInfo>()?),
            StructType::VirtualSerialPortDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortDeviceBackingInfo>()?),
            StructType::VirtualSoundCardDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSoundCardDeviceBackingInfo>()?),
            StructType::VirtualUsbRemoteHostBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualUsbRemoteHostBackingInfo>()?),
            StructType::VirtualUsbusbBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualUsbusbBackingInfo>()?),
            StructType::VirtualDeviceFileBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDeviceFileBackingInfo>()?),
            StructType::VirtualCdromIsoBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualCdromIsoBackingInfo>()?),
            StructType::VirtualDiskFlatVer1BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskFlatVer1BackingInfo>()?),
            StructType::VirtualDiskFlatVer2BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskFlatVer2BackingInfo>()?),
            StructType::VirtualDiskLocalPMemBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskLocalPMemBackingInfo>()?),
            StructType::VirtualDiskRawDiskMappingVer1BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskRawDiskMappingVer1BackingInfo>()?),
            StructType::VirtualDiskSeSparseBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskSeSparseBackingInfo>()?),
            StructType::VirtualDiskSparseVer1BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskSparseVer1BackingInfo>()?),
            StructType::VirtualDiskSparseVer2BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskSparseVer2BackingInfo>()?),
            StructType::VirtualFloppyImageBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualFloppyImageBackingInfo>()?),
            StructType::VirtualNvdimmBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualNvdimmBackingInfo>()?),
            StructType::VirtualParallelPortFileBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualParallelPortFileBackingInfo>()?),
            StructType::VirtualSerialPortFileBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortFileBackingInfo>()?),
            StructType::VirtualDevicePipeBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDevicePipeBackingInfo>()?),
            StructType::VirtualSerialPortPipeBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortPipeBackingInfo>()?),
            StructType::VirtualDeviceRemoteDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDeviceRemoteDeviceBackingInfo>()?),
            StructType::VirtualCdromRemoteAtapiBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualCdromRemoteAtapiBackingInfo>()?),
            StructType::VirtualCdromRemotePassthroughBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualCdromRemotePassthroughBackingInfo>()?),
            StructType::VirtualFloppyRemoteDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualFloppyRemoteDeviceBackingInfo>()?),
            StructType::VirtualUsbRemoteClientBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualUsbRemoteClientBackingInfo>()?),
            StructType::VirtualDeviceUriBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDeviceUriBackingInfo>()?),
            StructType::VirtualSerialPortUriBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortUriBackingInfo>()?),
            StructType::VirtualEthernetCardDistributedVirtualPortBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardDistributedVirtualPortBackingInfo>()?),
            StructType::VirtualEthernetCardOpaqueNetworkBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardOpaqueNetworkBackingInfo>()?),
            StructType::VirtualPciPassthroughDvxBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughDvxBackingInfo>()?),
            StructType::VirtualPciPassthroughPluginBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughPluginBackingInfo>()?),
            StructType::VirtualPciPassthroughVmiopBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughVmiopBackingInfo>()?),
            StructType::VirtualPrecisionClockSystemClockBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPrecisionClockSystemClockBackingInfo>()?),
            StructType::VirtualSerialPortThinPrintBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortThinPrintBackingInfo>()?),
            StructType::VirtualSriovEthernetCardSriovBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSriovEthernetCardSriovBackingInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualDeviceBackingInfo>()?),
            StructType::VirtualDeviceDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualDeviceDeviceBackingInfo>()?),
            StructType::VirtualCdromAtapiBackingInfo => Ok(from.as_any_box().downcast::<VirtualCdromAtapiBackingInfo>()?),
            StructType::VirtualCdromPassthroughBackingInfo => Ok(from.as_any_box().downcast::<VirtualCdromPassthroughBackingInfo>()?),
            StructType::VirtualDiskRawDiskVer2BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskRawDiskVer2BackingInfo>()?),
            StructType::VirtualDiskPartitionedRawDiskVer2BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskPartitionedRawDiskVer2BackingInfo>()?),
            StructType::VirtualEthernetCardLegacyNetworkBackingInfo => Ok(from.as_any_box().downcast::<VirtualEthernetCardLegacyNetworkBackingInfo>()?),
            StructType::VirtualEthernetCardNetworkBackingInfo => Ok(from.as_any_box().downcast::<VirtualEthernetCardNetworkBackingInfo>()?),
            StructType::VirtualFloppyDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualFloppyDeviceBackingInfo>()?),
            StructType::VirtualPciPassthroughDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualPciPassthroughDeviceBackingInfo>()?),
            StructType::VirtualPciPassthroughDynamicBackingInfo => Ok(from.as_any_box().downcast::<VirtualPciPassthroughDynamicBackingInfo>()?),
            StructType::VirtualParallelPortDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualParallelPortDeviceBackingInfo>()?),
            StructType::VirtualPointingDeviceDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualPointingDeviceDeviceBackingInfo>()?),
            StructType::VirtualScsiPassthroughDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualScsiPassthroughDeviceBackingInfo>()?),
            StructType::VirtualSerialPortDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualSerialPortDeviceBackingInfo>()?),
            StructType::VirtualSoundCardDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualSoundCardDeviceBackingInfo>()?),
            StructType::VirtualUsbRemoteHostBackingInfo => Ok(from.as_any_box().downcast::<VirtualUsbRemoteHostBackingInfo>()?),
            StructType::VirtualUsbusbBackingInfo => Ok(from.as_any_box().downcast::<VirtualUsbusbBackingInfo>()?),
            StructType::VirtualDeviceFileBackingInfo => Ok(from.as_any_box().downcast::<VirtualDeviceFileBackingInfo>()?),
            StructType::VirtualCdromIsoBackingInfo => Ok(from.as_any_box().downcast::<VirtualCdromIsoBackingInfo>()?),
            StructType::VirtualDiskFlatVer1BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskFlatVer1BackingInfo>()?),
            StructType::VirtualDiskFlatVer2BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskFlatVer2BackingInfo>()?),
            StructType::VirtualDiskLocalPMemBackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskLocalPMemBackingInfo>()?),
            StructType::VirtualDiskRawDiskMappingVer1BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskRawDiskMappingVer1BackingInfo>()?),
            StructType::VirtualDiskSeSparseBackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskSeSparseBackingInfo>()?),
            StructType::VirtualDiskSparseVer1BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskSparseVer1BackingInfo>()?),
            StructType::VirtualDiskSparseVer2BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskSparseVer2BackingInfo>()?),
            StructType::VirtualFloppyImageBackingInfo => Ok(from.as_any_box().downcast::<VirtualFloppyImageBackingInfo>()?),
            StructType::VirtualNvdimmBackingInfo => Ok(from.as_any_box().downcast::<VirtualNvdimmBackingInfo>()?),
            StructType::VirtualParallelPortFileBackingInfo => Ok(from.as_any_box().downcast::<VirtualParallelPortFileBackingInfo>()?),
            StructType::VirtualSerialPortFileBackingInfo => Ok(from.as_any_box().downcast::<VirtualSerialPortFileBackingInfo>()?),
            StructType::VirtualDevicePipeBackingInfo => Ok(from.as_any_box().downcast::<VirtualDevicePipeBackingInfo>()?),
            StructType::VirtualSerialPortPipeBackingInfo => Ok(from.as_any_box().downcast::<VirtualSerialPortPipeBackingInfo>()?),
            StructType::VirtualDeviceRemoteDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualDeviceRemoteDeviceBackingInfo>()?),
            StructType::VirtualCdromRemoteAtapiBackingInfo => Ok(from.as_any_box().downcast::<VirtualCdromRemoteAtapiBackingInfo>()?),
            StructType::VirtualCdromRemotePassthroughBackingInfo => Ok(from.as_any_box().downcast::<VirtualCdromRemotePassthroughBackingInfo>()?),
            StructType::VirtualFloppyRemoteDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualFloppyRemoteDeviceBackingInfo>()?),
            StructType::VirtualUsbRemoteClientBackingInfo => Ok(from.as_any_box().downcast::<VirtualUsbRemoteClientBackingInfo>()?),
            StructType::VirtualDeviceUriBackingInfo => Ok(from.as_any_box().downcast::<VirtualDeviceUriBackingInfo>()?),
            StructType::VirtualSerialPortUriBackingInfo => Ok(from.as_any_box().downcast::<VirtualSerialPortUriBackingInfo>()?),
            StructType::VirtualEthernetCardDistributedVirtualPortBackingInfo => Ok(from.as_any_box().downcast::<VirtualEthernetCardDistributedVirtualPortBackingInfo>()?),
            StructType::VirtualEthernetCardOpaqueNetworkBackingInfo => Ok(from.as_any_box().downcast::<VirtualEthernetCardOpaqueNetworkBackingInfo>()?),
            StructType::VirtualPciPassthroughDvxBackingInfo => Ok(from.as_any_box().downcast::<VirtualPciPassthroughDvxBackingInfo>()?),
            StructType::VirtualPciPassthroughPluginBackingInfo => Ok(from.as_any_box().downcast::<VirtualPciPassthroughPluginBackingInfo>()?),
            StructType::VirtualPciPassthroughVmiopBackingInfo => Ok(from.as_any_box().downcast::<VirtualPciPassthroughVmiopBackingInfo>()?),
            StructType::VirtualPrecisionClockSystemClockBackingInfo => Ok(from.as_any_box().downcast::<VirtualPrecisionClockSystemClockBackingInfo>()?),
            StructType::VirtualSerialPortThinPrintBackingInfo => Ok(from.as_any_box().downcast::<VirtualSerialPortThinPrintBackingInfo>()?),
            StructType::VirtualSriovEthernetCardSriovBackingInfo => Ok(from.as_any_box().downcast::<VirtualSriovEthernetCardSriovBackingInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The <code>*VirtualDeviceDeviceBackingInfo*</code> data object type
/// defines information about a host device or resource that backs a device
/// in a virtual machine.
pub trait VirtualDeviceDeviceBackingInfoTrait : super::traits::VirtualDeviceBackingInfoTrait {
    /// The name of the device on the host system.
    fn get_device_name(&self) -> &str;
    /// Indicates whether the device should be auto detected
    /// instead of directly specified.
    /// 
    /// If this value is set to TRUE,
    /// deviceName is ignored.
    fn get_use_auto_detect(&self) -> Option<bool>;
}
impl<'s> serde::Serialize for dyn VirtualDeviceDeviceBackingInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDeviceDeviceBackingInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDeviceDeviceBackingInfoVisitor)
            }
        }

struct VirtualDeviceDeviceBackingInfoVisitor;

impl<'de> de::Visitor<'de> for VirtualDeviceDeviceBackingInfoVisitor {
    type Value = Box<dyn VirtualDeviceDeviceBackingInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDeviceDeviceBackingInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDeviceDeviceBackingInfoTrait for VirtualDeviceDeviceBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceDeviceBackingInfoTrait for VirtualCdromAtapiBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceDeviceBackingInfoTrait for VirtualCdromPassthroughBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceDeviceBackingInfoTrait for VirtualDiskRawDiskVer2BackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceDeviceBackingInfoTrait for VirtualDiskPartitionedRawDiskVer2BackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceDeviceBackingInfoTrait for VirtualEthernetCardLegacyNetworkBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceDeviceBackingInfoTrait for VirtualEthernetCardNetworkBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceDeviceBackingInfoTrait for VirtualFloppyDeviceBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceDeviceBackingInfoTrait for VirtualPciPassthroughDeviceBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceDeviceBackingInfoTrait for VirtualPciPassthroughDynamicBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceDeviceBackingInfoTrait for VirtualParallelPortDeviceBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceDeviceBackingInfoTrait for VirtualPointingDeviceDeviceBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceDeviceBackingInfoTrait for VirtualScsiPassthroughDeviceBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceDeviceBackingInfoTrait for VirtualSerialPortDeviceBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceDeviceBackingInfoTrait for VirtualSoundCardDeviceBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceDeviceBackingInfoTrait for VirtualUsbRemoteHostBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceDeviceBackingInfoTrait for VirtualUsbusbBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDeviceDeviceBackingInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDeviceDeviceBackingInfo>()?),
            StructType::VirtualCdromAtapiBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualCdromAtapiBackingInfo>()?),
            StructType::VirtualCdromPassthroughBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualCdromPassthroughBackingInfo>()?),
            StructType::VirtualDiskRawDiskVer2BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskRawDiskVer2BackingInfo>()?),
            StructType::VirtualDiskPartitionedRawDiskVer2BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskPartitionedRawDiskVer2BackingInfo>()?),
            StructType::VirtualEthernetCardLegacyNetworkBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardLegacyNetworkBackingInfo>()?),
            StructType::VirtualEthernetCardNetworkBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardNetworkBackingInfo>()?),
            StructType::VirtualFloppyDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualFloppyDeviceBackingInfo>()?),
            StructType::VirtualPciPassthroughDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughDeviceBackingInfo>()?),
            StructType::VirtualPciPassthroughDynamicBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughDynamicBackingInfo>()?),
            StructType::VirtualParallelPortDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualParallelPortDeviceBackingInfo>()?),
            StructType::VirtualPointingDeviceDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPointingDeviceDeviceBackingInfo>()?),
            StructType::VirtualScsiPassthroughDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualScsiPassthroughDeviceBackingInfo>()?),
            StructType::VirtualSerialPortDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortDeviceBackingInfo>()?),
            StructType::VirtualSoundCardDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSoundCardDeviceBackingInfo>()?),
            StructType::VirtualUsbRemoteHostBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualUsbRemoteHostBackingInfo>()?),
            StructType::VirtualUsbusbBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualUsbusbBackingInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualDeviceDeviceBackingInfo>()?),
            StructType::VirtualCdromAtapiBackingInfo => Ok(from.as_any_box().downcast::<VirtualCdromAtapiBackingInfo>()?),
            StructType::VirtualCdromPassthroughBackingInfo => Ok(from.as_any_box().downcast::<VirtualCdromPassthroughBackingInfo>()?),
            StructType::VirtualDiskRawDiskVer2BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskRawDiskVer2BackingInfo>()?),
            StructType::VirtualDiskPartitionedRawDiskVer2BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskPartitionedRawDiskVer2BackingInfo>()?),
            StructType::VirtualEthernetCardLegacyNetworkBackingInfo => Ok(from.as_any_box().downcast::<VirtualEthernetCardLegacyNetworkBackingInfo>()?),
            StructType::VirtualEthernetCardNetworkBackingInfo => Ok(from.as_any_box().downcast::<VirtualEthernetCardNetworkBackingInfo>()?),
            StructType::VirtualFloppyDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualFloppyDeviceBackingInfo>()?),
            StructType::VirtualPciPassthroughDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualPciPassthroughDeviceBackingInfo>()?),
            StructType::VirtualPciPassthroughDynamicBackingInfo => Ok(from.as_any_box().downcast::<VirtualPciPassthroughDynamicBackingInfo>()?),
            StructType::VirtualParallelPortDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualParallelPortDeviceBackingInfo>()?),
            StructType::VirtualPointingDeviceDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualPointingDeviceDeviceBackingInfo>()?),
            StructType::VirtualScsiPassthroughDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualScsiPassthroughDeviceBackingInfo>()?),
            StructType::VirtualSerialPortDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualSerialPortDeviceBackingInfo>()?),
            StructType::VirtualSoundCardDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualSoundCardDeviceBackingInfo>()?),
            StructType::VirtualUsbRemoteHostBackingInfo => Ok(from.as_any_box().downcast::<VirtualUsbRemoteHostBackingInfo>()?),
            StructType::VirtualUsbusbBackingInfo => Ok(from.as_any_box().downcast::<VirtualUsbusbBackingInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type contains information about backing a virtual disk by
/// using a host device, as used by VMware Server.
pub trait VirtualDiskRawDiskVer2BackingInfoTrait : super::traits::VirtualDeviceDeviceBackingInfoTrait {
    /// The name of the raw disk descriptor file.
    fn get_descriptor_file_name(&self) -> &str;
    /// Disk UUID for the virtual disk, if available.
    fn get_uuid(&self) -> &Option<String>;
    /// The change ID of the virtual disk for the corresponding
    /// snapshot or virtual machine.
    /// 
    /// This can be used to track
    /// incremental changes to a virtual disk. See
    /// *VirtualMachine.QueryChangedDiskAreas*.
    fn get_change_id(&self) -> &Option<String>;
    /// The sharing mode of the virtual disk.
    /// 
    /// See *VirtualDiskSharing_enum*. The default value is
    /// no sharing.
    fn get_sharing(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn VirtualDiskRawDiskVer2BackingInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDiskRawDiskVer2BackingInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDiskRawDiskVer2BackingInfoVisitor)
            }
        }

struct VirtualDiskRawDiskVer2BackingInfoVisitor;

impl<'de> de::Visitor<'de> for VirtualDiskRawDiskVer2BackingInfoVisitor {
    type Value = Box<dyn VirtualDiskRawDiskVer2BackingInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDiskRawDiskVer2BackingInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDiskRawDiskVer2BackingInfoTrait for VirtualDiskRawDiskVer2BackingInfo {
    fn get_descriptor_file_name(&self) -> &str { &self.descriptor_file_name }
    fn get_uuid(&self) -> &Option<String> { &self.uuid }
    fn get_change_id(&self) -> &Option<String> { &self.change_id }
    fn get_sharing(&self) -> &Option<String> { &self.sharing }
}
impl VirtualDiskRawDiskVer2BackingInfoTrait for VirtualDiskPartitionedRawDiskVer2BackingInfo {
    fn get_descriptor_file_name(&self) -> &str { &self.descriptor_file_name }
    fn get_uuid(&self) -> &Option<String> { &self.uuid }
    fn get_change_id(&self) -> &Option<String> { &self.change_id }
    fn get_sharing(&self) -> &Option<String> { &self.sharing }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDiskRawDiskVer2BackingInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDiskRawDiskVer2BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskRawDiskVer2BackingInfo>()?),
            StructType::VirtualDiskPartitionedRawDiskVer2BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskPartitionedRawDiskVer2BackingInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDiskRawDiskVer2BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskRawDiskVer2BackingInfo>()?),
            StructType::VirtualDiskPartitionedRawDiskVer2BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskPartitionedRawDiskVer2BackingInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// <code>*VirtualDeviceFileBackingInfo*</code> is a data object type
/// for information about file backing for a device in a virtual machine.
pub trait VirtualDeviceFileBackingInfoTrait : super::traits::VirtualDeviceBackingInfoTrait {
    /// Filename for the host file used in this backing.
    fn get_file_name(&self) -> &str;
    /// Reference to the datastore managed object where this file is stored.
    /// 
    /// If the file is not located on a datastore, then this reference is null.
    /// This is not used for configuration.
    /// 
    /// Refers instance of *Datastore*.
    fn get_datastore(&self) -> &Option<ManagedObjectReference>;
    /// Backing object's durable and unmutable identifier.
    /// 
    /// Each backing object has a unique identifier which is not settable.
    fn get_backing_object_id(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn VirtualDeviceFileBackingInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDeviceFileBackingInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDeviceFileBackingInfoVisitor)
            }
        }

struct VirtualDeviceFileBackingInfoVisitor;

impl<'de> de::Visitor<'de> for VirtualDeviceFileBackingInfoVisitor {
    type Value = Box<dyn VirtualDeviceFileBackingInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDeviceFileBackingInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDeviceFileBackingInfoTrait for VirtualDeviceFileBackingInfo {
    fn get_file_name(&self) -> &str { &self.file_name }
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
    fn get_backing_object_id(&self) -> &Option<String> { &self.backing_object_id }
}
impl VirtualDeviceFileBackingInfoTrait for VirtualCdromIsoBackingInfo {
    fn get_file_name(&self) -> &str { &self.file_name }
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
    fn get_backing_object_id(&self) -> &Option<String> { &self.backing_object_id }
}
impl VirtualDeviceFileBackingInfoTrait for VirtualDiskFlatVer1BackingInfo {
    fn get_file_name(&self) -> &str { &self.file_name }
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
    fn get_backing_object_id(&self) -> &Option<String> { &self.backing_object_id }
}
impl VirtualDeviceFileBackingInfoTrait for VirtualDiskFlatVer2BackingInfo {
    fn get_file_name(&self) -> &str { &self.file_name }
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
    fn get_backing_object_id(&self) -> &Option<String> { &self.backing_object_id }
}
impl VirtualDeviceFileBackingInfoTrait for VirtualDiskLocalPMemBackingInfo {
    fn get_file_name(&self) -> &str { &self.file_name }
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
    fn get_backing_object_id(&self) -> &Option<String> { &self.backing_object_id }
}
impl VirtualDeviceFileBackingInfoTrait for VirtualDiskRawDiskMappingVer1BackingInfo {
    fn get_file_name(&self) -> &str { &self.file_name }
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
    fn get_backing_object_id(&self) -> &Option<String> { &self.backing_object_id }
}
impl VirtualDeviceFileBackingInfoTrait for VirtualDiskSeSparseBackingInfo {
    fn get_file_name(&self) -> &str { &self.file_name }
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
    fn get_backing_object_id(&self) -> &Option<String> { &self.backing_object_id }
}
impl VirtualDeviceFileBackingInfoTrait for VirtualDiskSparseVer1BackingInfo {
    fn get_file_name(&self) -> &str { &self.file_name }
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
    fn get_backing_object_id(&self) -> &Option<String> { &self.backing_object_id }
}
impl VirtualDeviceFileBackingInfoTrait for VirtualDiskSparseVer2BackingInfo {
    fn get_file_name(&self) -> &str { &self.file_name }
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
    fn get_backing_object_id(&self) -> &Option<String> { &self.backing_object_id }
}
impl VirtualDeviceFileBackingInfoTrait for VirtualFloppyImageBackingInfo {
    fn get_file_name(&self) -> &str { &self.file_name }
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
    fn get_backing_object_id(&self) -> &Option<String> { &self.backing_object_id }
}
impl VirtualDeviceFileBackingInfoTrait for VirtualNvdimmBackingInfo {
    fn get_file_name(&self) -> &str { &self.file_name }
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
    fn get_backing_object_id(&self) -> &Option<String> { &self.backing_object_id }
}
impl VirtualDeviceFileBackingInfoTrait for VirtualParallelPortFileBackingInfo {
    fn get_file_name(&self) -> &str { &self.file_name }
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
    fn get_backing_object_id(&self) -> &Option<String> { &self.backing_object_id }
}
impl VirtualDeviceFileBackingInfoTrait for VirtualSerialPortFileBackingInfo {
    fn get_file_name(&self) -> &str { &self.file_name }
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
    fn get_backing_object_id(&self) -> &Option<String> { &self.backing_object_id }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDeviceFileBackingInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceFileBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDeviceFileBackingInfo>()?),
            StructType::VirtualCdromIsoBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualCdromIsoBackingInfo>()?),
            StructType::VirtualDiskFlatVer1BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskFlatVer1BackingInfo>()?),
            StructType::VirtualDiskFlatVer2BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskFlatVer2BackingInfo>()?),
            StructType::VirtualDiskLocalPMemBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskLocalPMemBackingInfo>()?),
            StructType::VirtualDiskRawDiskMappingVer1BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskRawDiskMappingVer1BackingInfo>()?),
            StructType::VirtualDiskSeSparseBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskSeSparseBackingInfo>()?),
            StructType::VirtualDiskSparseVer1BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskSparseVer1BackingInfo>()?),
            StructType::VirtualDiskSparseVer2BackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDiskSparseVer2BackingInfo>()?),
            StructType::VirtualFloppyImageBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualFloppyImageBackingInfo>()?),
            StructType::VirtualNvdimmBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualNvdimmBackingInfo>()?),
            StructType::VirtualParallelPortFileBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualParallelPortFileBackingInfo>()?),
            StructType::VirtualSerialPortFileBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortFileBackingInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceFileBackingInfo => Ok(from.as_any_box().downcast::<VirtualDeviceFileBackingInfo>()?),
            StructType::VirtualCdromIsoBackingInfo => Ok(from.as_any_box().downcast::<VirtualCdromIsoBackingInfo>()?),
            StructType::VirtualDiskFlatVer1BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskFlatVer1BackingInfo>()?),
            StructType::VirtualDiskFlatVer2BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskFlatVer2BackingInfo>()?),
            StructType::VirtualDiskLocalPMemBackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskLocalPMemBackingInfo>()?),
            StructType::VirtualDiskRawDiskMappingVer1BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskRawDiskMappingVer1BackingInfo>()?),
            StructType::VirtualDiskSeSparseBackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskSeSparseBackingInfo>()?),
            StructType::VirtualDiskSparseVer1BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskSparseVer1BackingInfo>()?),
            StructType::VirtualDiskSparseVer2BackingInfo => Ok(from.as_any_box().downcast::<VirtualDiskSparseVer2BackingInfo>()?),
            StructType::VirtualFloppyImageBackingInfo => Ok(from.as_any_box().downcast::<VirtualFloppyImageBackingInfo>()?),
            StructType::VirtualNvdimmBackingInfo => Ok(from.as_any_box().downcast::<VirtualNvdimmBackingInfo>()?),
            StructType::VirtualParallelPortFileBackingInfo => Ok(from.as_any_box().downcast::<VirtualParallelPortFileBackingInfo>()?),
            StructType::VirtualSerialPortFileBackingInfo => Ok(from.as_any_box().downcast::<VirtualSerialPortFileBackingInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The <code>*VirtualDevicePipeBackingInfo*</code> data object type
/// defines information for using a named pipe as backing for a device
/// in a virtual machine.
pub trait VirtualDevicePipeBackingInfoTrait : super::traits::VirtualDeviceBackingInfoTrait {
    /// Pipe name for the host pipe associated with this backing.
    fn get_pipe_name(&self) -> &str;
}
impl<'s> serde::Serialize for dyn VirtualDevicePipeBackingInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDevicePipeBackingInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDevicePipeBackingInfoVisitor)
            }
        }

struct VirtualDevicePipeBackingInfoVisitor;

impl<'de> de::Visitor<'de> for VirtualDevicePipeBackingInfoVisitor {
    type Value = Box<dyn VirtualDevicePipeBackingInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDevicePipeBackingInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDevicePipeBackingInfoTrait for VirtualDevicePipeBackingInfo {
    fn get_pipe_name(&self) -> &str { &self.pipe_name }
}
impl VirtualDevicePipeBackingInfoTrait for VirtualSerialPortPipeBackingInfo {
    fn get_pipe_name(&self) -> &str { &self.pipe_name }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDevicePipeBackingInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDevicePipeBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDevicePipeBackingInfo>()?),
            StructType::VirtualSerialPortPipeBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortPipeBackingInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDevicePipeBackingInfo => Ok(from.as_any_box().downcast::<VirtualDevicePipeBackingInfo>()?),
            StructType::VirtualSerialPortPipeBackingInfo => Ok(from.as_any_box().downcast::<VirtualSerialPortPipeBackingInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// <code>*VirtualDeviceRemoteDeviceBackingInfo*</code> is a data object type
/// for information
/// about a remote device backing used by a device in a virtual machine.
/// 
/// The primary difference between a remote device backing and a
/// local device backing is that the VirtualCenter server cannot provide a list
/// of remote host devices available for this virtual device backing.
pub trait VirtualDeviceRemoteDeviceBackingInfoTrait : super::traits::VirtualDeviceBackingInfoTrait {
    /// The name of the device on the remote system.
    fn get_device_name(&self) -> &str;
    /// Indicates whether the device should be auto detected
    /// instead of directly specified.
    /// 
    /// If this value is set to TRUE,
    /// <code>deviceName</code> is ignored.
    fn get_use_auto_detect(&self) -> Option<bool>;
}
impl<'s> serde::Serialize for dyn VirtualDeviceRemoteDeviceBackingInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDeviceRemoteDeviceBackingInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDeviceRemoteDeviceBackingInfoVisitor)
            }
        }

struct VirtualDeviceRemoteDeviceBackingInfoVisitor;

impl<'de> de::Visitor<'de> for VirtualDeviceRemoteDeviceBackingInfoVisitor {
    type Value = Box<dyn VirtualDeviceRemoteDeviceBackingInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDeviceRemoteDeviceBackingInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDeviceRemoteDeviceBackingInfoTrait for VirtualDeviceRemoteDeviceBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceRemoteDeviceBackingInfoTrait for VirtualCdromRemoteAtapiBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceRemoteDeviceBackingInfoTrait for VirtualCdromRemotePassthroughBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceRemoteDeviceBackingInfoTrait for VirtualFloppyRemoteDeviceBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl VirtualDeviceRemoteDeviceBackingInfoTrait for VirtualUsbRemoteClientBackingInfo {
    fn get_device_name(&self) -> &str { &self.device_name }
    fn get_use_auto_detect(&self) -> Option<bool> { self.use_auto_detect }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDeviceRemoteDeviceBackingInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceRemoteDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDeviceRemoteDeviceBackingInfo>()?),
            StructType::VirtualCdromRemoteAtapiBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualCdromRemoteAtapiBackingInfo>()?),
            StructType::VirtualCdromRemotePassthroughBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualCdromRemotePassthroughBackingInfo>()?),
            StructType::VirtualFloppyRemoteDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualFloppyRemoteDeviceBackingInfo>()?),
            StructType::VirtualUsbRemoteClientBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualUsbRemoteClientBackingInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceRemoteDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualDeviceRemoteDeviceBackingInfo>()?),
            StructType::VirtualCdromRemoteAtapiBackingInfo => Ok(from.as_any_box().downcast::<VirtualCdromRemoteAtapiBackingInfo>()?),
            StructType::VirtualCdromRemotePassthroughBackingInfo => Ok(from.as_any_box().downcast::<VirtualCdromRemotePassthroughBackingInfo>()?),
            StructType::VirtualFloppyRemoteDeviceBackingInfo => Ok(from.as_any_box().downcast::<VirtualFloppyRemoteDeviceBackingInfo>()?),
            StructType::VirtualUsbRemoteClientBackingInfo => Ok(from.as_any_box().downcast::<VirtualUsbRemoteClientBackingInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The <code>*VirtualDeviceURIBackingInfo*</code> data object type
/// defines information for using a network socket as backing for a virtual device.
pub trait VirtualDeviceUriBackingInfoTrait : super::traits::VirtualDeviceBackingInfoTrait {
    /// Identifies the local host or a system on the network,
    /// depending on the value of <code>*VirtualDeviceURIBackingInfo.direction*</code>.
    /// - If you use the virtual machine as a server, the URI identifies
    ///   the host on which the virtual machine runs. In this case,
    ///   the host name part of the URI should be empty, or it should
    ///   specify the address of the local host.
    /// - If you use the virtual machine as a client, the URI identifies
    ///   the remote system on the network.
    fn get_service_uri(&self) -> &str;
    /// The direction of the connection.
    /// 
    /// For possible values see
    /// *VirtualDeviceURIBackingOptionDirection_enum*
    fn get_direction(&self) -> &str;
    /// Identifies a proxy service that provides network access to the
    /// <code>*VirtualDeviceURIBackingInfo.serviceURI*</code>.
    /// 
    /// If you specify a proxy URI, the virtual machine initiates
    /// a connection with the proxy service and forwards the
    /// *VirtualDeviceURIBackingInfo.serviceURI* and *VirtualDeviceURIBackingInfo.direction* to the proxy.
    fn get_proxy_uri(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn VirtualDeviceUriBackingInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDeviceUriBackingInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDeviceUriBackingInfoVisitor)
            }
        }

struct VirtualDeviceUriBackingInfoVisitor;

impl<'de> de::Visitor<'de> for VirtualDeviceUriBackingInfoVisitor {
    type Value = Box<dyn VirtualDeviceUriBackingInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDeviceUriBackingInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDeviceUriBackingInfoTrait for VirtualDeviceUriBackingInfo {
    fn get_service_uri(&self) -> &str { &self.service_uri }
    fn get_direction(&self) -> &str { &self.direction }
    fn get_proxy_uri(&self) -> &Option<String> { &self.proxy_uri }
}
impl VirtualDeviceUriBackingInfoTrait for VirtualSerialPortUriBackingInfo {
    fn get_service_uri(&self) -> &str { &self.service_uri }
    fn get_direction(&self) -> &str { &self.direction }
    fn get_proxy_uri(&self) -> &Option<String> { &self.proxy_uri }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDeviceUriBackingInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceUriBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualDeviceUriBackingInfo>()?),
            StructType::VirtualSerialPortUriBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortUriBackingInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceUriBackingInfo => Ok(from.as_any_box().downcast::<VirtualDeviceUriBackingInfo>()?),
            StructType::VirtualSerialPortUriBackingInfo => Ok(from.as_any_box().downcast::<VirtualSerialPortUriBackingInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The VirtualPCIPassthrough.PluginBackingInfo is a base data object type
/// for encoding plugin-specific information.
/// 
/// This base type does not define
/// any properties. Specific plugin types are represented by subtypes which
/// define properties for subtype-specific backing information.
pub trait VirtualPciPassthroughPluginBackingInfoTrait : super::traits::VirtualDeviceBackingInfoTrait {
}
impl<'s> serde::Serialize for dyn VirtualPciPassthroughPluginBackingInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualPciPassthroughPluginBackingInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualPciPassthroughPluginBackingInfoVisitor)
            }
        }

struct VirtualPciPassthroughPluginBackingInfoVisitor;

impl<'de> de::Visitor<'de> for VirtualPciPassthroughPluginBackingInfoVisitor {
    type Value = Box<dyn VirtualPciPassthroughPluginBackingInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualPciPassthroughPluginBackingInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualPciPassthroughPluginBackingInfoTrait for VirtualPciPassthroughPluginBackingInfo {
}
impl VirtualPciPassthroughPluginBackingInfoTrait for VirtualPciPassthroughVmiopBackingInfo {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualPciPassthroughPluginBackingInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualPciPassthroughPluginBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughPluginBackingInfo>()?),
            StructType::VirtualPciPassthroughVmiopBackingInfo => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughVmiopBackingInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualPciPassthroughPluginBackingInfo => Ok(from.as_any_box().downcast::<VirtualPciPassthroughPluginBackingInfo>()?),
            StructType::VirtualPciPassthroughVmiopBackingInfo => Ok(from.as_any_box().downcast::<VirtualPciPassthroughVmiopBackingInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// <code>*VirtualDeviceBusSlotInfo*</code> is a base data object type
/// for information about device connection to its bus.
/// 
/// This base type does not
/// define any properties. It is used as a namespace for general-purpose subtypes.
/// Specific devices types are represented by subtypes which define properties for
/// device-specific backing information.
pub trait VirtualDeviceBusSlotInfoTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn VirtualDeviceBusSlotInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDeviceBusSlotInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDeviceBusSlotInfoVisitor)
            }
        }

struct VirtualDeviceBusSlotInfoVisitor;

impl<'de> de::Visitor<'de> for VirtualDeviceBusSlotInfoVisitor {
    type Value = Box<dyn VirtualDeviceBusSlotInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDeviceBusSlotInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDeviceBusSlotInfoTrait for VirtualDeviceBusSlotInfo {
}
impl VirtualDeviceBusSlotInfoTrait for VirtualDevicePciBusSlotInfo {
}
impl VirtualDeviceBusSlotInfoTrait for VirtualUsbControllerPciBusSlotInfo {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDeviceBusSlotInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceBusSlotInfo => Some(from.as_any_ref().downcast_ref::<VirtualDeviceBusSlotInfo>()?),
            StructType::VirtualDevicePciBusSlotInfo => Some(from.as_any_ref().downcast_ref::<VirtualDevicePciBusSlotInfo>()?),
            StructType::VirtualUsbControllerPciBusSlotInfo => Some(from.as_any_ref().downcast_ref::<VirtualUsbControllerPciBusSlotInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceBusSlotInfo => Ok(from.as_any_box().downcast::<VirtualDeviceBusSlotInfo>()?),
            StructType::VirtualDevicePciBusSlotInfo => Ok(from.as_any_box().downcast::<VirtualDevicePciBusSlotInfo>()?),
            StructType::VirtualUsbControllerPciBusSlotInfo => Ok(from.as_any_box().downcast::<VirtualUsbControllerPciBusSlotInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The <code>*VirtualDevicePciBusSlotInfo*</code> data object type
/// defines information about a pci bus slot of pci device in a virtual machine.
pub trait VirtualDevicePciBusSlotInfoTrait : super::traits::VirtualDeviceBusSlotInfoTrait {
    /// The pci slot number of the virtual device.
    /// 
    /// The pci slot number assignment should generally be left to the system.
    /// If assigned a value, and the value is invalid or duplicated, it will
    /// automatically be reassigned. This will not cause an error.
    /// 
    /// Generally, the PCI slot numbers should never be specified in an
    /// Reconfigure operation, and only in a CreateVM operation if i) they
    /// are specified for all devices, and ii) the numbers have been
    /// determined by looking at an existing VM configuration of similar
    /// hardware version. In other words, when the virtual hardware configuration
    /// is duplicated.
    fn get_pci_slot_number(&self) -> i32;
}
impl<'s> serde::Serialize for dyn VirtualDevicePciBusSlotInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDevicePciBusSlotInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDevicePciBusSlotInfoVisitor)
            }
        }

struct VirtualDevicePciBusSlotInfoVisitor;

impl<'de> de::Visitor<'de> for VirtualDevicePciBusSlotInfoVisitor {
    type Value = Box<dyn VirtualDevicePciBusSlotInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDevicePciBusSlotInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDevicePciBusSlotInfoTrait for VirtualDevicePciBusSlotInfo {
    fn get_pci_slot_number(&self) -> i32 { self.pci_slot_number }
}
impl VirtualDevicePciBusSlotInfoTrait for VirtualUsbControllerPciBusSlotInfo {
    fn get_pci_slot_number(&self) -> i32 { self.pci_slot_number }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDevicePciBusSlotInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDevicePciBusSlotInfo => Some(from.as_any_ref().downcast_ref::<VirtualDevicePciBusSlotInfo>()?),
            StructType::VirtualUsbControllerPciBusSlotInfo => Some(from.as_any_ref().downcast_ref::<VirtualUsbControllerPciBusSlotInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDevicePciBusSlotInfo => Ok(from.as_any_box().downcast::<VirtualDevicePciBusSlotInfo>()?),
            StructType::VirtualUsbControllerPciBusSlotInfo => Ok(from.as_any_box().downcast::<VirtualUsbControllerPciBusSlotInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The VirtualDeviceOption data object type contains information about
/// a virtual device type, the options for configuring the virtual device,
/// and the relationship between this virtual device and other devices.
/// 
/// The vSphere API groups device configurations that are mutually exclusive
/// into different configuration objects; each of these configuration objects
/// may define subtypes for virtual device backing options
/// that are independent of the virtual device.
/// Backing-dependent options should appear in a subtype of
/// *VirtualDeviceBackingOption*.
pub trait VirtualDeviceOptionTrait : super::traits::DataObjectTrait {
    /// The name of the run-time class the client should instantiate
    /// to create a run-time instance of this device.
    fn get_type(&self) -> &str;
    /// If the device is connectable, then the connectOption
    /// describes the connect options and defaults.
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption>;
    /// If the device can use a bus slot configuration, then the busSlotOption
    /// describes the bus slot options.
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption>;
    /// Data object type that denotes the controller option object that is
    /// valid for controlling this device.
    fn get_controller_type(&self) -> &Option<String>;
    /// Flag to indicate whether or not this device will be auto-assigned a controller
    /// if one is required.
    /// 
    /// If this is true, then a client need not explicitly create
    /// the controller that this device will plug into.
    fn get_auto_assign_controller(&self) -> &Option<BoolOption>;
    /// A list of backing options that can be used to map the virtual
    /// device to the host.
    /// 
    /// The list is optional, since some devices exist only within
    /// the virtual machine; for example, a VirtualController.
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>>;
    /// Index into the backingOption list, indicating the default backing.
    fn get_default_backing_option_index(&self) -> Option<i32>;
    /// List of property names enforced by a licensing restriction
    /// of the underlying product.
    /// 
    /// For example, a limit that is not
    /// derived based on the product or hardware features; the
    /// property name "numCPU".
    fn get_licensing_limit(&self) -> &Option<Vec<String>>;
    /// Indicates whether this device is deprecated.
    /// 
    /// Hence, if set the device
    /// cannot be used when creating a new virtual machine or be added to an existing
    /// virtual machine. However, the device is still supported by the platform.
    fn get_deprecated(&self) -> bool;
    /// Indicates if this type of device can be hot-added to the virtual machine
    /// via a reconfigure operation when the virtual machine is powered on.
    fn get_plug_and_play(&self) -> bool;
    /// Indicates if this type of device can be hot-removed from the virtual machine
    /// via a reconfigure operation when the virtual machine is powered on.
    fn get_hot_remove_supported(&self) -> bool;
    /// ***Since:*** vSphere API Release 8.0.0.1
    fn get_numa_supported(&self) -> Option<bool>;
}
impl<'s> serde::Serialize for dyn VirtualDeviceOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDeviceOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDeviceOptionVisitor)
            }
        }

struct VirtualDeviceOptionVisitor;

impl<'de> de::Visitor<'de> for VirtualDeviceOptionVisitor {
    type Value = Box<dyn VirtualDeviceOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDeviceOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDeviceOptionTrait for VirtualDeviceOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualCdromOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualControllerOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualIdeControllerOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualNvdimmControllerOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualNvmeControllerOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualPciControllerOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualPs2ControllerOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualSataControllerOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualAhciControllerOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualScsiControllerOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for ParaVirtualScsiControllerOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualBusLogicControllerOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualLsiLogicControllerOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualLsiLogicSasControllerOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualSioControllerOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualUsbControllerOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualUsbxhciControllerOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualDiskOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualEthernetCardOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualE1000Option {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualE1000EOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualPcNet32Option {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualSriovEthernetCardOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualVmxnetOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualVmxnet2Option {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualVmxnet3Option {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualVmxnet3VrdmaOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualFloppyOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualKeyboardOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualNvdimmOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualPciPassthroughOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualParallelPortOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualPointingDeviceOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualPrecisionClockOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualScsiPassthroughOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualSerialPortOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualSoundCardOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualEnsoniq1371Option {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualHdAudioCardOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualSoundBlaster16Option {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualTpmOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualUsbOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualMachineVmciDeviceOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualVmiromOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualVideoCardOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl VirtualDeviceOptionTrait for VirtualWdtOption {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_connect_option(&self) -> &Option<VirtualDeviceConnectOption> { &self.connect_option }
    fn get_bus_slot_option(&self) -> &Option<VirtualDeviceBusSlotOption> { &self.bus_slot_option }
    fn get_controller_type(&self) -> &Option<String> { &self.controller_type }
    fn get_auto_assign_controller(&self) -> &Option<BoolOption> { &self.auto_assign_controller }
    fn get_backing_option(&self) -> &Option<Vec<Box<dyn super::traits::VirtualDeviceBackingOptionTrait>>> { &self.backing_option }
    fn get_default_backing_option_index(&self) -> Option<i32> { self.default_backing_option_index }
    fn get_licensing_limit(&self) -> &Option<Vec<String>> { &self.licensing_limit }
    fn get_deprecated(&self) -> bool { self.deprecated }
    fn get_plug_and_play(&self) -> bool { self.plug_and_play }
    fn get_hot_remove_supported(&self) -> bool { self.hot_remove_supported }
    fn get_numa_supported(&self) -> Option<bool> { self.numa_supported }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDeviceOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceOption => Some(from.as_any_ref().downcast_ref::<VirtualDeviceOption>()?),
            StructType::VirtualCdromOption => Some(from.as_any_ref().downcast_ref::<VirtualCdromOption>()?),
            StructType::VirtualControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualControllerOption>()?),
            StructType::VirtualIdeControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualIdeControllerOption>()?),
            StructType::VirtualNvdimmControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualNvdimmControllerOption>()?),
            StructType::VirtualNvmeControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualNvmeControllerOption>()?),
            StructType::VirtualPciControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualPciControllerOption>()?),
            StructType::VirtualPs2ControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualPs2ControllerOption>()?),
            StructType::VirtualSataControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualSataControllerOption>()?),
            StructType::VirtualAhciControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualAhciControllerOption>()?),
            StructType::VirtualScsiControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualScsiControllerOption>()?),
            StructType::ParaVirtualScsiControllerOption => Some(from.as_any_ref().downcast_ref::<ParaVirtualScsiControllerOption>()?),
            StructType::VirtualBusLogicControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualBusLogicControllerOption>()?),
            StructType::VirtualLsiLogicControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualLsiLogicControllerOption>()?),
            StructType::VirtualLsiLogicSasControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualLsiLogicSasControllerOption>()?),
            StructType::VirtualSioControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualSioControllerOption>()?),
            StructType::VirtualUsbControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualUsbControllerOption>()?),
            StructType::VirtualUsbxhciControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualUsbxhciControllerOption>()?),
            StructType::VirtualDiskOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskOption>()?),
            StructType::VirtualEthernetCardOption => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardOption>()?),
            StructType::VirtualE1000Option => Some(from.as_any_ref().downcast_ref::<VirtualE1000Option>()?),
            StructType::VirtualE1000EOption => Some(from.as_any_ref().downcast_ref::<VirtualE1000EOption>()?),
            StructType::VirtualPcNet32Option => Some(from.as_any_ref().downcast_ref::<VirtualPcNet32Option>()?),
            StructType::VirtualSriovEthernetCardOption => Some(from.as_any_ref().downcast_ref::<VirtualSriovEthernetCardOption>()?),
            StructType::VirtualVmxnetOption => Some(from.as_any_ref().downcast_ref::<VirtualVmxnetOption>()?),
            StructType::VirtualVmxnet2Option => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet2Option>()?),
            StructType::VirtualVmxnet3Option => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3Option>()?),
            StructType::VirtualVmxnet3VrdmaOption => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3VrdmaOption>()?),
            StructType::VirtualFloppyOption => Some(from.as_any_ref().downcast_ref::<VirtualFloppyOption>()?),
            StructType::VirtualKeyboardOption => Some(from.as_any_ref().downcast_ref::<VirtualKeyboardOption>()?),
            StructType::VirtualNvdimmOption => Some(from.as_any_ref().downcast_ref::<VirtualNvdimmOption>()?),
            StructType::VirtualPciPassthroughOption => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughOption>()?),
            StructType::VirtualParallelPortOption => Some(from.as_any_ref().downcast_ref::<VirtualParallelPortOption>()?),
            StructType::VirtualPointingDeviceOption => Some(from.as_any_ref().downcast_ref::<VirtualPointingDeviceOption>()?),
            StructType::VirtualPrecisionClockOption => Some(from.as_any_ref().downcast_ref::<VirtualPrecisionClockOption>()?),
            StructType::VirtualScsiPassthroughOption => Some(from.as_any_ref().downcast_ref::<VirtualScsiPassthroughOption>()?),
            StructType::VirtualSerialPortOption => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortOption>()?),
            StructType::VirtualSoundCardOption => Some(from.as_any_ref().downcast_ref::<VirtualSoundCardOption>()?),
            StructType::VirtualEnsoniq1371Option => Some(from.as_any_ref().downcast_ref::<VirtualEnsoniq1371Option>()?),
            StructType::VirtualHdAudioCardOption => Some(from.as_any_ref().downcast_ref::<VirtualHdAudioCardOption>()?),
            StructType::VirtualSoundBlaster16Option => Some(from.as_any_ref().downcast_ref::<VirtualSoundBlaster16Option>()?),
            StructType::VirtualTpmOption => Some(from.as_any_ref().downcast_ref::<VirtualTpmOption>()?),
            StructType::VirtualUsbOption => Some(from.as_any_ref().downcast_ref::<VirtualUsbOption>()?),
            StructType::VirtualMachineVmciDeviceOption => Some(from.as_any_ref().downcast_ref::<VirtualMachineVmciDeviceOption>()?),
            StructType::VirtualVmiromOption => Some(from.as_any_ref().downcast_ref::<VirtualVmiromOption>()?),
            StructType::VirtualVideoCardOption => Some(from.as_any_ref().downcast_ref::<VirtualVideoCardOption>()?),
            StructType::VirtualWdtOption => Some(from.as_any_ref().downcast_ref::<VirtualWdtOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceOption => Ok(from.as_any_box().downcast::<VirtualDeviceOption>()?),
            StructType::VirtualCdromOption => Ok(from.as_any_box().downcast::<VirtualCdromOption>()?),
            StructType::VirtualControllerOption => Ok(from.as_any_box().downcast::<VirtualControllerOption>()?),
            StructType::VirtualIdeControllerOption => Ok(from.as_any_box().downcast::<VirtualIdeControllerOption>()?),
            StructType::VirtualNvdimmControllerOption => Ok(from.as_any_box().downcast::<VirtualNvdimmControllerOption>()?),
            StructType::VirtualNvmeControllerOption => Ok(from.as_any_box().downcast::<VirtualNvmeControllerOption>()?),
            StructType::VirtualPciControllerOption => Ok(from.as_any_box().downcast::<VirtualPciControllerOption>()?),
            StructType::VirtualPs2ControllerOption => Ok(from.as_any_box().downcast::<VirtualPs2ControllerOption>()?),
            StructType::VirtualSataControllerOption => Ok(from.as_any_box().downcast::<VirtualSataControllerOption>()?),
            StructType::VirtualAhciControllerOption => Ok(from.as_any_box().downcast::<VirtualAhciControllerOption>()?),
            StructType::VirtualScsiControllerOption => Ok(from.as_any_box().downcast::<VirtualScsiControllerOption>()?),
            StructType::ParaVirtualScsiControllerOption => Ok(from.as_any_box().downcast::<ParaVirtualScsiControllerOption>()?),
            StructType::VirtualBusLogicControllerOption => Ok(from.as_any_box().downcast::<VirtualBusLogicControllerOption>()?),
            StructType::VirtualLsiLogicControllerOption => Ok(from.as_any_box().downcast::<VirtualLsiLogicControllerOption>()?),
            StructType::VirtualLsiLogicSasControllerOption => Ok(from.as_any_box().downcast::<VirtualLsiLogicSasControllerOption>()?),
            StructType::VirtualSioControllerOption => Ok(from.as_any_box().downcast::<VirtualSioControllerOption>()?),
            StructType::VirtualUsbControllerOption => Ok(from.as_any_box().downcast::<VirtualUsbControllerOption>()?),
            StructType::VirtualUsbxhciControllerOption => Ok(from.as_any_box().downcast::<VirtualUsbxhciControllerOption>()?),
            StructType::VirtualDiskOption => Ok(from.as_any_box().downcast::<VirtualDiskOption>()?),
            StructType::VirtualEthernetCardOption => Ok(from.as_any_box().downcast::<VirtualEthernetCardOption>()?),
            StructType::VirtualE1000Option => Ok(from.as_any_box().downcast::<VirtualE1000Option>()?),
            StructType::VirtualE1000EOption => Ok(from.as_any_box().downcast::<VirtualE1000EOption>()?),
            StructType::VirtualPcNet32Option => Ok(from.as_any_box().downcast::<VirtualPcNet32Option>()?),
            StructType::VirtualSriovEthernetCardOption => Ok(from.as_any_box().downcast::<VirtualSriovEthernetCardOption>()?),
            StructType::VirtualVmxnetOption => Ok(from.as_any_box().downcast::<VirtualVmxnetOption>()?),
            StructType::VirtualVmxnet2Option => Ok(from.as_any_box().downcast::<VirtualVmxnet2Option>()?),
            StructType::VirtualVmxnet3Option => Ok(from.as_any_box().downcast::<VirtualVmxnet3Option>()?),
            StructType::VirtualVmxnet3VrdmaOption => Ok(from.as_any_box().downcast::<VirtualVmxnet3VrdmaOption>()?),
            StructType::VirtualFloppyOption => Ok(from.as_any_box().downcast::<VirtualFloppyOption>()?),
            StructType::VirtualKeyboardOption => Ok(from.as_any_box().downcast::<VirtualKeyboardOption>()?),
            StructType::VirtualNvdimmOption => Ok(from.as_any_box().downcast::<VirtualNvdimmOption>()?),
            StructType::VirtualPciPassthroughOption => Ok(from.as_any_box().downcast::<VirtualPciPassthroughOption>()?),
            StructType::VirtualParallelPortOption => Ok(from.as_any_box().downcast::<VirtualParallelPortOption>()?),
            StructType::VirtualPointingDeviceOption => Ok(from.as_any_box().downcast::<VirtualPointingDeviceOption>()?),
            StructType::VirtualPrecisionClockOption => Ok(from.as_any_box().downcast::<VirtualPrecisionClockOption>()?),
            StructType::VirtualScsiPassthroughOption => Ok(from.as_any_box().downcast::<VirtualScsiPassthroughOption>()?),
            StructType::VirtualSerialPortOption => Ok(from.as_any_box().downcast::<VirtualSerialPortOption>()?),
            StructType::VirtualSoundCardOption => Ok(from.as_any_box().downcast::<VirtualSoundCardOption>()?),
            StructType::VirtualEnsoniq1371Option => Ok(from.as_any_box().downcast::<VirtualEnsoniq1371Option>()?),
            StructType::VirtualHdAudioCardOption => Ok(from.as_any_box().downcast::<VirtualHdAudioCardOption>()?),
            StructType::VirtualSoundBlaster16Option => Ok(from.as_any_box().downcast::<VirtualSoundBlaster16Option>()?),
            StructType::VirtualTpmOption => Ok(from.as_any_box().downcast::<VirtualTpmOption>()?),
            StructType::VirtualUsbOption => Ok(from.as_any_box().downcast::<VirtualUsbOption>()?),
            StructType::VirtualMachineVmciDeviceOption => Ok(from.as_any_box().downcast::<VirtualMachineVmciDeviceOption>()?),
            StructType::VirtualVmiromOption => Ok(from.as_any_box().downcast::<VirtualVmiromOption>()?),
            StructType::VirtualVideoCardOption => Ok(from.as_any_box().downcast::<VirtualVideoCardOption>()?),
            StructType::VirtualWdtOption => Ok(from.as_any_box().downcast::<VirtualWdtOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The VirtualControllerOption data object type contains information about
/// a virtual controller type.
pub trait VirtualControllerOptionTrait : super::traits::VirtualDeviceOptionTrait {
    /// The minimum and maximum number of devices this controller can control
    /// at run time.
    fn get_devices(&self) -> &IntOption;
    /// Array of supported device options for this controller.
    fn get_supported_device(&self) -> &Option<Vec<String>>;
}
impl<'s> serde::Serialize for dyn VirtualControllerOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualControllerOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualControllerOptionVisitor)
            }
        }

struct VirtualControllerOptionVisitor;

impl<'de> de::Visitor<'de> for VirtualControllerOptionVisitor {
    type Value = Box<dyn VirtualControllerOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualControllerOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualControllerOptionTrait for VirtualControllerOption {
    fn get_devices(&self) -> &IntOption { &self.devices }
    fn get_supported_device(&self) -> &Option<Vec<String>> { &self.supported_device }
}
impl VirtualControllerOptionTrait for VirtualIdeControllerOption {
    fn get_devices(&self) -> &IntOption { &self.devices }
    fn get_supported_device(&self) -> &Option<Vec<String>> { &self.supported_device }
}
impl VirtualControllerOptionTrait for VirtualNvdimmControllerOption {
    fn get_devices(&self) -> &IntOption { &self.devices }
    fn get_supported_device(&self) -> &Option<Vec<String>> { &self.supported_device }
}
impl VirtualControllerOptionTrait for VirtualNvmeControllerOption {
    fn get_devices(&self) -> &IntOption { &self.devices }
    fn get_supported_device(&self) -> &Option<Vec<String>> { &self.supported_device }
}
impl VirtualControllerOptionTrait for VirtualPciControllerOption {
    fn get_devices(&self) -> &IntOption { &self.devices }
    fn get_supported_device(&self) -> &Option<Vec<String>> { &self.supported_device }
}
impl VirtualControllerOptionTrait for VirtualPs2ControllerOption {
    fn get_devices(&self) -> &IntOption { &self.devices }
    fn get_supported_device(&self) -> &Option<Vec<String>> { &self.supported_device }
}
impl VirtualControllerOptionTrait for VirtualSataControllerOption {
    fn get_devices(&self) -> &IntOption { &self.devices }
    fn get_supported_device(&self) -> &Option<Vec<String>> { &self.supported_device }
}
impl VirtualControllerOptionTrait for VirtualAhciControllerOption {
    fn get_devices(&self) -> &IntOption { &self.devices }
    fn get_supported_device(&self) -> &Option<Vec<String>> { &self.supported_device }
}
impl VirtualControllerOptionTrait for VirtualScsiControllerOption {
    fn get_devices(&self) -> &IntOption { &self.devices }
    fn get_supported_device(&self) -> &Option<Vec<String>> { &self.supported_device }
}
impl VirtualControllerOptionTrait for ParaVirtualScsiControllerOption {
    fn get_devices(&self) -> &IntOption { &self.devices }
    fn get_supported_device(&self) -> &Option<Vec<String>> { &self.supported_device }
}
impl VirtualControllerOptionTrait for VirtualBusLogicControllerOption {
    fn get_devices(&self) -> &IntOption { &self.devices }
    fn get_supported_device(&self) -> &Option<Vec<String>> { &self.supported_device }
}
impl VirtualControllerOptionTrait for VirtualLsiLogicControllerOption {
    fn get_devices(&self) -> &IntOption { &self.devices }
    fn get_supported_device(&self) -> &Option<Vec<String>> { &self.supported_device }
}
impl VirtualControllerOptionTrait for VirtualLsiLogicSasControllerOption {
    fn get_devices(&self) -> &IntOption { &self.devices }
    fn get_supported_device(&self) -> &Option<Vec<String>> { &self.supported_device }
}
impl VirtualControllerOptionTrait for VirtualSioControllerOption {
    fn get_devices(&self) -> &IntOption { &self.devices }
    fn get_supported_device(&self) -> &Option<Vec<String>> { &self.supported_device }
}
impl VirtualControllerOptionTrait for VirtualUsbControllerOption {
    fn get_devices(&self) -> &IntOption { &self.devices }
    fn get_supported_device(&self) -> &Option<Vec<String>> { &self.supported_device }
}
impl VirtualControllerOptionTrait for VirtualUsbxhciControllerOption {
    fn get_devices(&self) -> &IntOption { &self.devices }
    fn get_supported_device(&self) -> &Option<Vec<String>> { &self.supported_device }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualControllerOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualControllerOption>()?),
            StructType::VirtualIdeControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualIdeControllerOption>()?),
            StructType::VirtualNvdimmControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualNvdimmControllerOption>()?),
            StructType::VirtualNvmeControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualNvmeControllerOption>()?),
            StructType::VirtualPciControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualPciControllerOption>()?),
            StructType::VirtualPs2ControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualPs2ControllerOption>()?),
            StructType::VirtualSataControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualSataControllerOption>()?),
            StructType::VirtualAhciControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualAhciControllerOption>()?),
            StructType::VirtualScsiControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualScsiControllerOption>()?),
            StructType::ParaVirtualScsiControllerOption => Some(from.as_any_ref().downcast_ref::<ParaVirtualScsiControllerOption>()?),
            StructType::VirtualBusLogicControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualBusLogicControllerOption>()?),
            StructType::VirtualLsiLogicControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualLsiLogicControllerOption>()?),
            StructType::VirtualLsiLogicSasControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualLsiLogicSasControllerOption>()?),
            StructType::VirtualSioControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualSioControllerOption>()?),
            StructType::VirtualUsbControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualUsbControllerOption>()?),
            StructType::VirtualUsbxhciControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualUsbxhciControllerOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualControllerOption => Ok(from.as_any_box().downcast::<VirtualControllerOption>()?),
            StructType::VirtualIdeControllerOption => Ok(from.as_any_box().downcast::<VirtualIdeControllerOption>()?),
            StructType::VirtualNvdimmControllerOption => Ok(from.as_any_box().downcast::<VirtualNvdimmControllerOption>()?),
            StructType::VirtualNvmeControllerOption => Ok(from.as_any_box().downcast::<VirtualNvmeControllerOption>()?),
            StructType::VirtualPciControllerOption => Ok(from.as_any_box().downcast::<VirtualPciControllerOption>()?),
            StructType::VirtualPs2ControllerOption => Ok(from.as_any_box().downcast::<VirtualPs2ControllerOption>()?),
            StructType::VirtualSataControllerOption => Ok(from.as_any_box().downcast::<VirtualSataControllerOption>()?),
            StructType::VirtualAhciControllerOption => Ok(from.as_any_box().downcast::<VirtualAhciControllerOption>()?),
            StructType::VirtualScsiControllerOption => Ok(from.as_any_box().downcast::<VirtualScsiControllerOption>()?),
            StructType::ParaVirtualScsiControllerOption => Ok(from.as_any_box().downcast::<ParaVirtualScsiControllerOption>()?),
            StructType::VirtualBusLogicControllerOption => Ok(from.as_any_box().downcast::<VirtualBusLogicControllerOption>()?),
            StructType::VirtualLsiLogicControllerOption => Ok(from.as_any_box().downcast::<VirtualLsiLogicControllerOption>()?),
            StructType::VirtualLsiLogicSasControllerOption => Ok(from.as_any_box().downcast::<VirtualLsiLogicSasControllerOption>()?),
            StructType::VirtualSioControllerOption => Ok(from.as_any_box().downcast::<VirtualSioControllerOption>()?),
            StructType::VirtualUsbControllerOption => Ok(from.as_any_box().downcast::<VirtualUsbControllerOption>()?),
            StructType::VirtualUsbxhciControllerOption => Ok(from.as_any_box().downcast::<VirtualUsbxhciControllerOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The VirtualSATAControllerOption data object type contains the options
/// for a virtual SATA controller defined by the
/// *VirtualSATAController*
/// data object type.
pub trait VirtualSataControllerOptionTrait : super::traits::VirtualControllerOptionTrait {
    /// Three properties (numSATADisks.min, numSATADisks.max, and
    /// numSATADisks.defaultValue) define the minimum, maximum, and default
    /// number of SATA VirtualDisk instances available at any given time in the
    /// SATA controller.
    /// 
    /// The number of SATA VirtualDisk instances is
    /// also limited by the number of available slots in the SATA controller.
    fn get_num_sata_disks(&self) -> &IntOption;
    /// Three properties (numSATACdroms.min, numSATACdroms.max, and
    /// numSATACdroms.defaultValue) define the minimum, maximum, and default
    /// number of SATA VirtualCdrom instances available
    /// in the SATA controller.
    /// 
    /// The number of SATA VirtualCdrom instances is
    /// also limited by the number of available slots in the SATA controller.
    fn get_num_sata_cdroms(&self) -> &IntOption;
}
impl<'s> serde::Serialize for dyn VirtualSataControllerOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualSataControllerOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualSataControllerOptionVisitor)
            }
        }

struct VirtualSataControllerOptionVisitor;

impl<'de> de::Visitor<'de> for VirtualSataControllerOptionVisitor {
    type Value = Box<dyn VirtualSataControllerOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualSataControllerOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualSataControllerOptionTrait for VirtualSataControllerOption {
    fn get_num_sata_disks(&self) -> &IntOption { &self.num_sata_disks }
    fn get_num_sata_cdroms(&self) -> &IntOption { &self.num_sata_cdroms }
}
impl VirtualSataControllerOptionTrait for VirtualAhciControllerOption {
    fn get_num_sata_disks(&self) -> &IntOption { &self.num_sata_disks }
    fn get_num_sata_cdroms(&self) -> &IntOption { &self.num_sata_cdroms }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualSataControllerOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualSataControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualSataControllerOption>()?),
            StructType::VirtualAhciControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualAhciControllerOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualSataControllerOption => Ok(from.as_any_box().downcast::<VirtualSataControllerOption>()?),
            StructType::VirtualAhciControllerOption => Ok(from.as_any_box().downcast::<VirtualAhciControllerOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The VirtualSCSIControllerOption data object type contains the options
/// for a virtual SCSI controller defined by the
/// *VirtualSCSIController*
/// data object type.
pub trait VirtualScsiControllerOptionTrait : super::traits::VirtualControllerOptionTrait {
    /// Three properties (numSCSIDisks.min, numSCSIDisks.max, and
    /// numSCSIDisks.defaultValue) define the minimum, maximum, and default
    /// number of SCSI VirtualDisk instances available at any given time in the
    /// SCSI controller.
    /// 
    /// The number of SCSI VirtualDisk instances is
    /// also limited by the number of available slots in the SCSI controller.
    fn get_num_scsi_disks(&self) -> &IntOption;
    /// Three properties (numSCSICdroms.min, numSCSICdroms.max, and
    /// numSCSICdroms.defaultValue) define the minimum, maximum, and default
    /// number of SCSI VirtualCdrom instances available
    /// in the SCSI controller.
    /// 
    /// The number of SCSI VirtualCdrom instances is
    /// also limited by the number of available slots in the SCSI controller.
    fn get_num_scsi_cdroms(&self) -> &IntOption;
    /// Three properties (numSCSIPassthrough.min, numSCSIPassthrough.max, and
    /// numSCSIPassthrough.defaultValue) define the minimum, maximum, and
    /// default number of VirtualSCSIPassthrough instances available
    /// have at any given time in the SCSI controller.
    /// 
    /// The number of
    /// VirtualSCSIPassthrough instances is also limited by the number of
    /// available slots in the SCSI controller.
    fn get_num_scsi_passthrough(&self) -> &IntOption;
    /// Supported shared bus modes.
    fn get_sharing(&self) -> &Vec<super::enums::VirtualScsiSharingEnum>;
    /// Index into sharing array specifying the default value.
    fn get_default_shared_index(&self) -> i32;
    /// All SCSI controllers support hot adding and removing of devices.
    /// 
    /// This
    /// support can't be toggled in the current implementation. Therefore, this
    /// option is ignored when reconfiguring a SCSI controller and is always set
    /// to "true" when reading an existing configuration.
    fn get_hot_add_remove(&self) -> &BoolOption;
    /// The unit number of the SCSI controller.
    /// 
    /// The SCSI controller sits on its
    /// own bus, so that this field defines which slot the controller will use.
    fn get_scsi_ctlr_unit_number(&self) -> i32;
}
impl<'s> serde::Serialize for dyn VirtualScsiControllerOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualScsiControllerOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualScsiControllerOptionVisitor)
            }
        }

struct VirtualScsiControllerOptionVisitor;

impl<'de> de::Visitor<'de> for VirtualScsiControllerOptionVisitor {
    type Value = Box<dyn VirtualScsiControllerOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualScsiControllerOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualScsiControllerOptionTrait for VirtualScsiControllerOption {
    fn get_num_scsi_disks(&self) -> &IntOption { &self.num_scsi_disks }
    fn get_num_scsi_cdroms(&self) -> &IntOption { &self.num_scsi_cdroms }
    fn get_num_scsi_passthrough(&self) -> &IntOption { &self.num_scsi_passthrough }
    fn get_sharing(&self) -> &Vec<super::enums::VirtualScsiSharingEnum> { &self.sharing }
    fn get_default_shared_index(&self) -> i32 { self.default_shared_index }
    fn get_hot_add_remove(&self) -> &BoolOption { &self.hot_add_remove }
    fn get_scsi_ctlr_unit_number(&self) -> i32 { self.scsi_ctlr_unit_number }
}
impl VirtualScsiControllerOptionTrait for ParaVirtualScsiControllerOption {
    fn get_num_scsi_disks(&self) -> &IntOption { &self.num_scsi_disks }
    fn get_num_scsi_cdroms(&self) -> &IntOption { &self.num_scsi_cdroms }
    fn get_num_scsi_passthrough(&self) -> &IntOption { &self.num_scsi_passthrough }
    fn get_sharing(&self) -> &Vec<super::enums::VirtualScsiSharingEnum> { &self.sharing }
    fn get_default_shared_index(&self) -> i32 { self.default_shared_index }
    fn get_hot_add_remove(&self) -> &BoolOption { &self.hot_add_remove }
    fn get_scsi_ctlr_unit_number(&self) -> i32 { self.scsi_ctlr_unit_number }
}
impl VirtualScsiControllerOptionTrait for VirtualBusLogicControllerOption {
    fn get_num_scsi_disks(&self) -> &IntOption { &self.num_scsi_disks }
    fn get_num_scsi_cdroms(&self) -> &IntOption { &self.num_scsi_cdroms }
    fn get_num_scsi_passthrough(&self) -> &IntOption { &self.num_scsi_passthrough }
    fn get_sharing(&self) -> &Vec<super::enums::VirtualScsiSharingEnum> { &self.sharing }
    fn get_default_shared_index(&self) -> i32 { self.default_shared_index }
    fn get_hot_add_remove(&self) -> &BoolOption { &self.hot_add_remove }
    fn get_scsi_ctlr_unit_number(&self) -> i32 { self.scsi_ctlr_unit_number }
}
impl VirtualScsiControllerOptionTrait for VirtualLsiLogicControllerOption {
    fn get_num_scsi_disks(&self) -> &IntOption { &self.num_scsi_disks }
    fn get_num_scsi_cdroms(&self) -> &IntOption { &self.num_scsi_cdroms }
    fn get_num_scsi_passthrough(&self) -> &IntOption { &self.num_scsi_passthrough }
    fn get_sharing(&self) -> &Vec<super::enums::VirtualScsiSharingEnum> { &self.sharing }
    fn get_default_shared_index(&self) -> i32 { self.default_shared_index }
    fn get_hot_add_remove(&self) -> &BoolOption { &self.hot_add_remove }
    fn get_scsi_ctlr_unit_number(&self) -> i32 { self.scsi_ctlr_unit_number }
}
impl VirtualScsiControllerOptionTrait for VirtualLsiLogicSasControllerOption {
    fn get_num_scsi_disks(&self) -> &IntOption { &self.num_scsi_disks }
    fn get_num_scsi_cdroms(&self) -> &IntOption { &self.num_scsi_cdroms }
    fn get_num_scsi_passthrough(&self) -> &IntOption { &self.num_scsi_passthrough }
    fn get_sharing(&self) -> &Vec<super::enums::VirtualScsiSharingEnum> { &self.sharing }
    fn get_default_shared_index(&self) -> i32 { self.default_shared_index }
    fn get_hot_add_remove(&self) -> &BoolOption { &self.hot_add_remove }
    fn get_scsi_ctlr_unit_number(&self) -> i32 { self.scsi_ctlr_unit_number }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualScsiControllerOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualScsiControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualScsiControllerOption>()?),
            StructType::ParaVirtualScsiControllerOption => Some(from.as_any_ref().downcast_ref::<ParaVirtualScsiControllerOption>()?),
            StructType::VirtualBusLogicControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualBusLogicControllerOption>()?),
            StructType::VirtualLsiLogicControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualLsiLogicControllerOption>()?),
            StructType::VirtualLsiLogicSasControllerOption => Some(from.as_any_ref().downcast_ref::<VirtualLsiLogicSasControllerOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualScsiControllerOption => Ok(from.as_any_box().downcast::<VirtualScsiControllerOption>()?),
            StructType::ParaVirtualScsiControllerOption => Ok(from.as_any_box().downcast::<ParaVirtualScsiControllerOption>()?),
            StructType::VirtualBusLogicControllerOption => Ok(from.as_any_box().downcast::<VirtualBusLogicControllerOption>()?),
            StructType::VirtualLsiLogicControllerOption => Ok(from.as_any_box().downcast::<VirtualLsiLogicControllerOption>()?),
            StructType::VirtualLsiLogicSasControllerOption => Ok(from.as_any_box().downcast::<VirtualLsiLogicSasControllerOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type contains the options for the
/// virtual ethernet card data object type.
pub trait VirtualEthernetCardOptionTrait : super::traits::VirtualDeviceOptionTrait {
    /// The valid Organizational Unique Identifiers (OUIs)
    /// supported by this virtual Ethernet card.
    /// 
    /// <dl>
    /// <dt>Supported OUIs for statically assigned MAC addresses:</dt>
    /// <dd>"00:50:56"</dd>
    /// </dl>
    fn get_supported_oui(&self) -> &ChoiceOption;
    /// The supported MAC address types.
    fn get_mac_type(&self) -> &ChoiceOption;
    /// Flag to indicate whether or not wake-on-LAN is settable on this device.
    fn get_wake_on_lan_enabled(&self) -> &BoolOption;
    /// Deprecated as of vSphere API 8.0. VMDirectPath Gen 2 is no longer supported and
    /// there is no replacement.
    /// 
    /// Flag to indicate whether VMDirectPath Gen 2 is available on this device.
    fn get_vm_direct_path_gen_2_supported(&self) -> Option<bool>;
    /// Deprecated as of vSphere API 8.0. VMDirectPath Gen 2 is no longer supported and
    /// there is no replacement.
    /// 
    /// Flag to indicate whether Universal Pass-through(UPT) is settable on this device.
    fn get_upt_compatibility_enabled(&self) -> &Option<BoolOption>;
}
impl<'s> serde::Serialize for dyn VirtualEthernetCardOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualEthernetCardOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualEthernetCardOptionVisitor)
            }
        }

struct VirtualEthernetCardOptionVisitor;

impl<'de> de::Visitor<'de> for VirtualEthernetCardOptionVisitor {
    type Value = Box<dyn VirtualEthernetCardOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualEthernetCardOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualEthernetCardOptionTrait for VirtualEthernetCardOption {
    fn get_supported_oui(&self) -> &ChoiceOption { &self.supported_oui }
    fn get_mac_type(&self) -> &ChoiceOption { &self.mac_type }
    fn get_wake_on_lan_enabled(&self) -> &BoolOption { &self.wake_on_lan_enabled }
    fn get_vm_direct_path_gen_2_supported(&self) -> Option<bool> { self.vm_direct_path_gen_2_supported }
    fn get_upt_compatibility_enabled(&self) -> &Option<BoolOption> { &self.upt_compatibility_enabled }
}
impl VirtualEthernetCardOptionTrait for VirtualE1000Option {
    fn get_supported_oui(&self) -> &ChoiceOption { &self.supported_oui }
    fn get_mac_type(&self) -> &ChoiceOption { &self.mac_type }
    fn get_wake_on_lan_enabled(&self) -> &BoolOption { &self.wake_on_lan_enabled }
    fn get_vm_direct_path_gen_2_supported(&self) -> Option<bool> { self.vm_direct_path_gen_2_supported }
    fn get_upt_compatibility_enabled(&self) -> &Option<BoolOption> { &self.upt_compatibility_enabled }
}
impl VirtualEthernetCardOptionTrait for VirtualE1000EOption {
    fn get_supported_oui(&self) -> &ChoiceOption { &self.supported_oui }
    fn get_mac_type(&self) -> &ChoiceOption { &self.mac_type }
    fn get_wake_on_lan_enabled(&self) -> &BoolOption { &self.wake_on_lan_enabled }
    fn get_vm_direct_path_gen_2_supported(&self) -> Option<bool> { self.vm_direct_path_gen_2_supported }
    fn get_upt_compatibility_enabled(&self) -> &Option<BoolOption> { &self.upt_compatibility_enabled }
}
impl VirtualEthernetCardOptionTrait for VirtualPcNet32Option {
    fn get_supported_oui(&self) -> &ChoiceOption { &self.supported_oui }
    fn get_mac_type(&self) -> &ChoiceOption { &self.mac_type }
    fn get_wake_on_lan_enabled(&self) -> &BoolOption { &self.wake_on_lan_enabled }
    fn get_vm_direct_path_gen_2_supported(&self) -> Option<bool> { self.vm_direct_path_gen_2_supported }
    fn get_upt_compatibility_enabled(&self) -> &Option<BoolOption> { &self.upt_compatibility_enabled }
}
impl VirtualEthernetCardOptionTrait for VirtualSriovEthernetCardOption {
    fn get_supported_oui(&self) -> &ChoiceOption { &self.supported_oui }
    fn get_mac_type(&self) -> &ChoiceOption { &self.mac_type }
    fn get_wake_on_lan_enabled(&self) -> &BoolOption { &self.wake_on_lan_enabled }
    fn get_vm_direct_path_gen_2_supported(&self) -> Option<bool> { self.vm_direct_path_gen_2_supported }
    fn get_upt_compatibility_enabled(&self) -> &Option<BoolOption> { &self.upt_compatibility_enabled }
}
impl VirtualEthernetCardOptionTrait for VirtualVmxnetOption {
    fn get_supported_oui(&self) -> &ChoiceOption { &self.supported_oui }
    fn get_mac_type(&self) -> &ChoiceOption { &self.mac_type }
    fn get_wake_on_lan_enabled(&self) -> &BoolOption { &self.wake_on_lan_enabled }
    fn get_vm_direct_path_gen_2_supported(&self) -> Option<bool> { self.vm_direct_path_gen_2_supported }
    fn get_upt_compatibility_enabled(&self) -> &Option<BoolOption> { &self.upt_compatibility_enabled }
}
impl VirtualEthernetCardOptionTrait for VirtualVmxnet2Option {
    fn get_supported_oui(&self) -> &ChoiceOption { &self.supported_oui }
    fn get_mac_type(&self) -> &ChoiceOption { &self.mac_type }
    fn get_wake_on_lan_enabled(&self) -> &BoolOption { &self.wake_on_lan_enabled }
    fn get_vm_direct_path_gen_2_supported(&self) -> Option<bool> { self.vm_direct_path_gen_2_supported }
    fn get_upt_compatibility_enabled(&self) -> &Option<BoolOption> { &self.upt_compatibility_enabled }
}
impl VirtualEthernetCardOptionTrait for VirtualVmxnet3Option {
    fn get_supported_oui(&self) -> &ChoiceOption { &self.supported_oui }
    fn get_mac_type(&self) -> &ChoiceOption { &self.mac_type }
    fn get_wake_on_lan_enabled(&self) -> &BoolOption { &self.wake_on_lan_enabled }
    fn get_vm_direct_path_gen_2_supported(&self) -> Option<bool> { self.vm_direct_path_gen_2_supported }
    fn get_upt_compatibility_enabled(&self) -> &Option<BoolOption> { &self.upt_compatibility_enabled }
}
impl VirtualEthernetCardOptionTrait for VirtualVmxnet3VrdmaOption {
    fn get_supported_oui(&self) -> &ChoiceOption { &self.supported_oui }
    fn get_mac_type(&self) -> &ChoiceOption { &self.mac_type }
    fn get_wake_on_lan_enabled(&self) -> &BoolOption { &self.wake_on_lan_enabled }
    fn get_vm_direct_path_gen_2_supported(&self) -> Option<bool> { self.vm_direct_path_gen_2_supported }
    fn get_upt_compatibility_enabled(&self) -> &Option<BoolOption> { &self.upt_compatibility_enabled }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualEthernetCardOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualEthernetCardOption => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardOption>()?),
            StructType::VirtualE1000Option => Some(from.as_any_ref().downcast_ref::<VirtualE1000Option>()?),
            StructType::VirtualE1000EOption => Some(from.as_any_ref().downcast_ref::<VirtualE1000EOption>()?),
            StructType::VirtualPcNet32Option => Some(from.as_any_ref().downcast_ref::<VirtualPcNet32Option>()?),
            StructType::VirtualSriovEthernetCardOption => Some(from.as_any_ref().downcast_ref::<VirtualSriovEthernetCardOption>()?),
            StructType::VirtualVmxnetOption => Some(from.as_any_ref().downcast_ref::<VirtualVmxnetOption>()?),
            StructType::VirtualVmxnet2Option => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet2Option>()?),
            StructType::VirtualVmxnet3Option => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3Option>()?),
            StructType::VirtualVmxnet3VrdmaOption => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3VrdmaOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualEthernetCardOption => Ok(from.as_any_box().downcast::<VirtualEthernetCardOption>()?),
            StructType::VirtualE1000Option => Ok(from.as_any_box().downcast::<VirtualE1000Option>()?),
            StructType::VirtualE1000EOption => Ok(from.as_any_box().downcast::<VirtualE1000EOption>()?),
            StructType::VirtualPcNet32Option => Ok(from.as_any_box().downcast::<VirtualPcNet32Option>()?),
            StructType::VirtualSriovEthernetCardOption => Ok(from.as_any_box().downcast::<VirtualSriovEthernetCardOption>()?),
            StructType::VirtualVmxnetOption => Ok(from.as_any_box().downcast::<VirtualVmxnetOption>()?),
            StructType::VirtualVmxnet2Option => Ok(from.as_any_box().downcast::<VirtualVmxnet2Option>()?),
            StructType::VirtualVmxnet3Option => Ok(from.as_any_box().downcast::<VirtualVmxnet3Option>()?),
            StructType::VirtualVmxnet3VrdmaOption => Ok(from.as_any_box().downcast::<VirtualVmxnet3VrdmaOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The VirtualVmxnetOption data object type contains the options for the
/// *VirtualVmxnet* data object type.
pub trait VirtualVmxnetOptionTrait : super::traits::VirtualEthernetCardOptionTrait {
}
impl<'s> serde::Serialize for dyn VirtualVmxnetOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualVmxnetOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualVmxnetOptionVisitor)
            }
        }

struct VirtualVmxnetOptionVisitor;

impl<'de> de::Visitor<'de> for VirtualVmxnetOptionVisitor {
    type Value = Box<dyn VirtualVmxnetOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualVmxnetOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualVmxnetOptionTrait for VirtualVmxnetOption {
}
impl VirtualVmxnetOptionTrait for VirtualVmxnet2Option {
}
impl VirtualVmxnetOptionTrait for VirtualVmxnet3Option {
}
impl VirtualVmxnetOptionTrait for VirtualVmxnet3VrdmaOption {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualVmxnetOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualVmxnetOption => Some(from.as_any_ref().downcast_ref::<VirtualVmxnetOption>()?),
            StructType::VirtualVmxnet2Option => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet2Option>()?),
            StructType::VirtualVmxnet3Option => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3Option>()?),
            StructType::VirtualVmxnet3VrdmaOption => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3VrdmaOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualVmxnetOption => Ok(from.as_any_box().downcast::<VirtualVmxnetOption>()?),
            StructType::VirtualVmxnet2Option => Ok(from.as_any_box().downcast::<VirtualVmxnet2Option>()?),
            StructType::VirtualVmxnet3Option => Ok(from.as_any_box().downcast::<VirtualVmxnet3Option>()?),
            StructType::VirtualVmxnet3VrdmaOption => Ok(from.as_any_box().downcast::<VirtualVmxnet3VrdmaOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The VirtualVmxnet3Option data object type contains the options for the
/// *VirtualVmxnet3* data object type.
pub trait VirtualVmxnet3OptionTrait : super::traits::VirtualVmxnetOptionTrait {
    /// Flag to indicate whether UPTv2(Uniform Pass-through version 2) is
    /// settable on this device.
    /// 
    /// ***Since:*** vSphere API Release 8.0.0.1
    fn get_uptv_2_enabled(&self) -> &Option<BoolOption>;
}
impl<'s> serde::Serialize for dyn VirtualVmxnet3OptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualVmxnet3OptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualVmxnet3OptionVisitor)
            }
        }

struct VirtualVmxnet3OptionVisitor;

impl<'de> de::Visitor<'de> for VirtualVmxnet3OptionVisitor {
    type Value = Box<dyn VirtualVmxnet3OptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualVmxnet3OptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualVmxnet3OptionTrait for VirtualVmxnet3Option {
    fn get_uptv_2_enabled(&self) -> &Option<BoolOption> { &self.uptv_2_enabled }
}
impl VirtualVmxnet3OptionTrait for VirtualVmxnet3VrdmaOption {
    fn get_uptv_2_enabled(&self) -> &Option<BoolOption> { &self.uptv_2_enabled }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualVmxnet3OptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualVmxnet3Option => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3Option>()?),
            StructType::VirtualVmxnet3VrdmaOption => Some(from.as_any_ref().downcast_ref::<VirtualVmxnet3VrdmaOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualVmxnet3Option => Ok(from.as_any_box().downcast::<VirtualVmxnet3Option>()?),
            StructType::VirtualVmxnet3VrdmaOption => Ok(from.as_any_box().downcast::<VirtualVmxnet3VrdmaOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The VirtualSoundCardOption data class contains the options for the
/// virtual sound card class.
pub trait VirtualSoundCardOptionTrait : super::traits::VirtualDeviceOptionTrait {
}
impl<'s> serde::Serialize for dyn VirtualSoundCardOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualSoundCardOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualSoundCardOptionVisitor)
            }
        }

struct VirtualSoundCardOptionVisitor;

impl<'de> de::Visitor<'de> for VirtualSoundCardOptionVisitor {
    type Value = Box<dyn VirtualSoundCardOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualSoundCardOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualSoundCardOptionTrait for VirtualSoundCardOption {
}
impl VirtualSoundCardOptionTrait for VirtualEnsoniq1371Option {
}
impl VirtualSoundCardOptionTrait for VirtualHdAudioCardOption {
}
impl VirtualSoundCardOptionTrait for VirtualSoundBlaster16Option {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualSoundCardOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualSoundCardOption => Some(from.as_any_ref().downcast_ref::<VirtualSoundCardOption>()?),
            StructType::VirtualEnsoniq1371Option => Some(from.as_any_ref().downcast_ref::<VirtualEnsoniq1371Option>()?),
            StructType::VirtualHdAudioCardOption => Some(from.as_any_ref().downcast_ref::<VirtualHdAudioCardOption>()?),
            StructType::VirtualSoundBlaster16Option => Some(from.as_any_ref().downcast_ref::<VirtualSoundBlaster16Option>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualSoundCardOption => Ok(from.as_any_box().downcast::<VirtualSoundCardOption>()?),
            StructType::VirtualEnsoniq1371Option => Ok(from.as_any_box().downcast::<VirtualEnsoniq1371Option>()?),
            StructType::VirtualHdAudioCardOption => Ok(from.as_any_box().downcast::<VirtualHdAudioCardOption>()?),
            StructType::VirtualSoundBlaster16Option => Ok(from.as_any_box().downcast::<VirtualSoundBlaster16Option>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *VirtualDeviceBackingOption* data class
/// defines options for device-specific virtual backing objects.
pub trait VirtualDeviceBackingOptionTrait : super::traits::DataObjectTrait {
    /// The name of the class the client should use to instantiate backing
    /// for the virtual device.
    fn get_type(&self) -> &str;
}
impl<'s> serde::Serialize for dyn VirtualDeviceBackingOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDeviceBackingOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDeviceBackingOptionVisitor)
            }
        }

struct VirtualDeviceBackingOptionVisitor;

impl<'de> de::Visitor<'de> for VirtualDeviceBackingOptionVisitor {
    type Value = Box<dyn VirtualDeviceBackingOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDeviceBackingOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDeviceBackingOptionTrait for VirtualDeviceBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualDeviceDeviceBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualCdromAtapiBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualCdromPassthroughBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualCdromRemoteAtapiBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualDiskRawDiskMappingVer1BackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualDiskRawDiskVer2BackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualDiskPartitionedRawDiskVer2BackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualEthernetCardLegacyNetworkBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualEthernetCardNetworkBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualFloppyDeviceBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualPciPassthroughDeviceBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualPciPassthroughDynamicBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualParallelPortDeviceBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualPointingDeviceBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualScsiPassthroughDeviceBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualSerialPortDeviceBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualSoundCardDeviceBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualUsbRemoteHostBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualUsbusbBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualDeviceFileBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualCdromIsoBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualDiskFlatVer1BackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualDiskFlatVer2BackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualDiskLocalPMemBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualDiskSeSparseBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualDiskSparseVer1BackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualDiskSparseVer2BackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualFloppyImageBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualParallelPortFileBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualSerialPortFileBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualDevicePipeBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualSerialPortPipeBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualDeviceRemoteDeviceBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualCdromRemotePassthroughBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualFloppyRemoteDeviceBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualUsbRemoteClientBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualDeviceUriBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualSerialPortUriBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualEthernetCardDvPortBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualEthernetCardOpaqueNetworkBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualPciPassthroughDvxBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualPciPassthroughPluginBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualPciPassthroughVmiopBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualPrecisionClockSystemClockBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualSerialPortThinPrintBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl VirtualDeviceBackingOptionTrait for VirtualSriovEthernetCardSriovBackingOption {
    fn get_type(&self) -> &str { &self.r#type }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDeviceBackingOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDeviceBackingOption>()?),
            StructType::VirtualDeviceDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDeviceDeviceBackingOption>()?),
            StructType::VirtualCdromAtapiBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualCdromAtapiBackingOption>()?),
            StructType::VirtualCdromPassthroughBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualCdromPassthroughBackingOption>()?),
            StructType::VirtualCdromRemoteAtapiBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualCdromRemoteAtapiBackingOption>()?),
            StructType::VirtualDiskRawDiskMappingVer1BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskRawDiskMappingVer1BackingOption>()?),
            StructType::VirtualDiskRawDiskVer2BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskRawDiskVer2BackingOption>()?),
            StructType::VirtualDiskPartitionedRawDiskVer2BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskPartitionedRawDiskVer2BackingOption>()?),
            StructType::VirtualEthernetCardLegacyNetworkBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardLegacyNetworkBackingOption>()?),
            StructType::VirtualEthernetCardNetworkBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardNetworkBackingOption>()?),
            StructType::VirtualFloppyDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualFloppyDeviceBackingOption>()?),
            StructType::VirtualPciPassthroughDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughDeviceBackingOption>()?),
            StructType::VirtualPciPassthroughDynamicBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughDynamicBackingOption>()?),
            StructType::VirtualParallelPortDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualParallelPortDeviceBackingOption>()?),
            StructType::VirtualPointingDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPointingDeviceBackingOption>()?),
            StructType::VirtualScsiPassthroughDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualScsiPassthroughDeviceBackingOption>()?),
            StructType::VirtualSerialPortDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortDeviceBackingOption>()?),
            StructType::VirtualSoundCardDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSoundCardDeviceBackingOption>()?),
            StructType::VirtualUsbRemoteHostBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualUsbRemoteHostBackingOption>()?),
            StructType::VirtualUsbusbBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualUsbusbBackingOption>()?),
            StructType::VirtualDeviceFileBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDeviceFileBackingOption>()?),
            StructType::VirtualCdromIsoBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualCdromIsoBackingOption>()?),
            StructType::VirtualDiskFlatVer1BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskFlatVer1BackingOption>()?),
            StructType::VirtualDiskFlatVer2BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskFlatVer2BackingOption>()?),
            StructType::VirtualDiskLocalPMemBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskLocalPMemBackingOption>()?),
            StructType::VirtualDiskSeSparseBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskSeSparseBackingOption>()?),
            StructType::VirtualDiskSparseVer1BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskSparseVer1BackingOption>()?),
            StructType::VirtualDiskSparseVer2BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskSparseVer2BackingOption>()?),
            StructType::VirtualFloppyImageBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualFloppyImageBackingOption>()?),
            StructType::VirtualParallelPortFileBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualParallelPortFileBackingOption>()?),
            StructType::VirtualSerialPortFileBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortFileBackingOption>()?),
            StructType::VirtualDevicePipeBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDevicePipeBackingOption>()?),
            StructType::VirtualSerialPortPipeBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortPipeBackingOption>()?),
            StructType::VirtualDeviceRemoteDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDeviceRemoteDeviceBackingOption>()?),
            StructType::VirtualCdromRemotePassthroughBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualCdromRemotePassthroughBackingOption>()?),
            StructType::VirtualFloppyRemoteDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualFloppyRemoteDeviceBackingOption>()?),
            StructType::VirtualUsbRemoteClientBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualUsbRemoteClientBackingOption>()?),
            StructType::VirtualDeviceUriBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDeviceUriBackingOption>()?),
            StructType::VirtualSerialPortUriBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortUriBackingOption>()?),
            StructType::VirtualEthernetCardDvPortBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardDvPortBackingOption>()?),
            StructType::VirtualEthernetCardOpaqueNetworkBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardOpaqueNetworkBackingOption>()?),
            StructType::VirtualPciPassthroughDvxBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughDvxBackingOption>()?),
            StructType::VirtualPciPassthroughPluginBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughPluginBackingOption>()?),
            StructType::VirtualPciPassthroughVmiopBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughVmiopBackingOption>()?),
            StructType::VirtualPrecisionClockSystemClockBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPrecisionClockSystemClockBackingOption>()?),
            StructType::VirtualSerialPortThinPrintBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortThinPrintBackingOption>()?),
            StructType::VirtualSriovEthernetCardSriovBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSriovEthernetCardSriovBackingOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualDeviceBackingOption>()?),
            StructType::VirtualDeviceDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualDeviceDeviceBackingOption>()?),
            StructType::VirtualCdromAtapiBackingOption => Ok(from.as_any_box().downcast::<VirtualCdromAtapiBackingOption>()?),
            StructType::VirtualCdromPassthroughBackingOption => Ok(from.as_any_box().downcast::<VirtualCdromPassthroughBackingOption>()?),
            StructType::VirtualCdromRemoteAtapiBackingOption => Ok(from.as_any_box().downcast::<VirtualCdromRemoteAtapiBackingOption>()?),
            StructType::VirtualDiskRawDiskMappingVer1BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskRawDiskMappingVer1BackingOption>()?),
            StructType::VirtualDiskRawDiskVer2BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskRawDiskVer2BackingOption>()?),
            StructType::VirtualDiskPartitionedRawDiskVer2BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskPartitionedRawDiskVer2BackingOption>()?),
            StructType::VirtualEthernetCardLegacyNetworkBackingOption => Ok(from.as_any_box().downcast::<VirtualEthernetCardLegacyNetworkBackingOption>()?),
            StructType::VirtualEthernetCardNetworkBackingOption => Ok(from.as_any_box().downcast::<VirtualEthernetCardNetworkBackingOption>()?),
            StructType::VirtualFloppyDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualFloppyDeviceBackingOption>()?),
            StructType::VirtualPciPassthroughDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualPciPassthroughDeviceBackingOption>()?),
            StructType::VirtualPciPassthroughDynamicBackingOption => Ok(from.as_any_box().downcast::<VirtualPciPassthroughDynamicBackingOption>()?),
            StructType::VirtualParallelPortDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualParallelPortDeviceBackingOption>()?),
            StructType::VirtualPointingDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualPointingDeviceBackingOption>()?),
            StructType::VirtualScsiPassthroughDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualScsiPassthroughDeviceBackingOption>()?),
            StructType::VirtualSerialPortDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualSerialPortDeviceBackingOption>()?),
            StructType::VirtualSoundCardDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualSoundCardDeviceBackingOption>()?),
            StructType::VirtualUsbRemoteHostBackingOption => Ok(from.as_any_box().downcast::<VirtualUsbRemoteHostBackingOption>()?),
            StructType::VirtualUsbusbBackingOption => Ok(from.as_any_box().downcast::<VirtualUsbusbBackingOption>()?),
            StructType::VirtualDeviceFileBackingOption => Ok(from.as_any_box().downcast::<VirtualDeviceFileBackingOption>()?),
            StructType::VirtualCdromIsoBackingOption => Ok(from.as_any_box().downcast::<VirtualCdromIsoBackingOption>()?),
            StructType::VirtualDiskFlatVer1BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskFlatVer1BackingOption>()?),
            StructType::VirtualDiskFlatVer2BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskFlatVer2BackingOption>()?),
            StructType::VirtualDiskLocalPMemBackingOption => Ok(from.as_any_box().downcast::<VirtualDiskLocalPMemBackingOption>()?),
            StructType::VirtualDiskSeSparseBackingOption => Ok(from.as_any_box().downcast::<VirtualDiskSeSparseBackingOption>()?),
            StructType::VirtualDiskSparseVer1BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskSparseVer1BackingOption>()?),
            StructType::VirtualDiskSparseVer2BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskSparseVer2BackingOption>()?),
            StructType::VirtualFloppyImageBackingOption => Ok(from.as_any_box().downcast::<VirtualFloppyImageBackingOption>()?),
            StructType::VirtualParallelPortFileBackingOption => Ok(from.as_any_box().downcast::<VirtualParallelPortFileBackingOption>()?),
            StructType::VirtualSerialPortFileBackingOption => Ok(from.as_any_box().downcast::<VirtualSerialPortFileBackingOption>()?),
            StructType::VirtualDevicePipeBackingOption => Ok(from.as_any_box().downcast::<VirtualDevicePipeBackingOption>()?),
            StructType::VirtualSerialPortPipeBackingOption => Ok(from.as_any_box().downcast::<VirtualSerialPortPipeBackingOption>()?),
            StructType::VirtualDeviceRemoteDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualDeviceRemoteDeviceBackingOption>()?),
            StructType::VirtualCdromRemotePassthroughBackingOption => Ok(from.as_any_box().downcast::<VirtualCdromRemotePassthroughBackingOption>()?),
            StructType::VirtualFloppyRemoteDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualFloppyRemoteDeviceBackingOption>()?),
            StructType::VirtualUsbRemoteClientBackingOption => Ok(from.as_any_box().downcast::<VirtualUsbRemoteClientBackingOption>()?),
            StructType::VirtualDeviceUriBackingOption => Ok(from.as_any_box().downcast::<VirtualDeviceUriBackingOption>()?),
            StructType::VirtualSerialPortUriBackingOption => Ok(from.as_any_box().downcast::<VirtualSerialPortUriBackingOption>()?),
            StructType::VirtualEthernetCardDvPortBackingOption => Ok(from.as_any_box().downcast::<VirtualEthernetCardDvPortBackingOption>()?),
            StructType::VirtualEthernetCardOpaqueNetworkBackingOption => Ok(from.as_any_box().downcast::<VirtualEthernetCardOpaqueNetworkBackingOption>()?),
            StructType::VirtualPciPassthroughDvxBackingOption => Ok(from.as_any_box().downcast::<VirtualPciPassthroughDvxBackingOption>()?),
            StructType::VirtualPciPassthroughPluginBackingOption => Ok(from.as_any_box().downcast::<VirtualPciPassthroughPluginBackingOption>()?),
            StructType::VirtualPciPassthroughVmiopBackingOption => Ok(from.as_any_box().downcast::<VirtualPciPassthroughVmiopBackingOption>()?),
            StructType::VirtualPrecisionClockSystemClockBackingOption => Ok(from.as_any_box().downcast::<VirtualPrecisionClockSystemClockBackingOption>()?),
            StructType::VirtualSerialPortThinPrintBackingOption => Ok(from.as_any_box().downcast::<VirtualSerialPortThinPrintBackingOption>()?),
            StructType::VirtualSriovEthernetCardSriovBackingOption => Ok(from.as_any_box().downcast::<VirtualSriovEthernetCardSriovBackingOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The DeviceBackingOption data class contains device-specific backing options.
pub trait VirtualDeviceDeviceBackingOptionTrait : super::traits::VirtualDeviceBackingOptionTrait {
    /// Flag to indicate whether the specific instance of this device can
    /// be auto-detected on the host instead of having to specify a
    /// particular physical device.
    fn get_auto_detect_available(&self) -> &BoolOption;
}
impl<'s> serde::Serialize for dyn VirtualDeviceDeviceBackingOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDeviceDeviceBackingOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDeviceDeviceBackingOptionVisitor)
            }
        }

struct VirtualDeviceDeviceBackingOptionVisitor;

impl<'de> de::Visitor<'de> for VirtualDeviceDeviceBackingOptionVisitor {
    type Value = Box<dyn VirtualDeviceDeviceBackingOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDeviceDeviceBackingOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDeviceDeviceBackingOptionTrait for VirtualDeviceDeviceBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceDeviceBackingOptionTrait for VirtualCdromAtapiBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceDeviceBackingOptionTrait for VirtualCdromPassthroughBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceDeviceBackingOptionTrait for VirtualCdromRemoteAtapiBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceDeviceBackingOptionTrait for VirtualDiskRawDiskMappingVer1BackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceDeviceBackingOptionTrait for VirtualDiskRawDiskVer2BackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceDeviceBackingOptionTrait for VirtualDiskPartitionedRawDiskVer2BackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceDeviceBackingOptionTrait for VirtualEthernetCardLegacyNetworkBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceDeviceBackingOptionTrait for VirtualEthernetCardNetworkBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceDeviceBackingOptionTrait for VirtualFloppyDeviceBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceDeviceBackingOptionTrait for VirtualPciPassthroughDeviceBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceDeviceBackingOptionTrait for VirtualPciPassthroughDynamicBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceDeviceBackingOptionTrait for VirtualParallelPortDeviceBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceDeviceBackingOptionTrait for VirtualPointingDeviceBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceDeviceBackingOptionTrait for VirtualScsiPassthroughDeviceBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceDeviceBackingOptionTrait for VirtualSerialPortDeviceBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceDeviceBackingOptionTrait for VirtualSoundCardDeviceBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceDeviceBackingOptionTrait for VirtualUsbRemoteHostBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceDeviceBackingOptionTrait for VirtualUsbusbBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDeviceDeviceBackingOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDeviceDeviceBackingOption>()?),
            StructType::VirtualCdromAtapiBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualCdromAtapiBackingOption>()?),
            StructType::VirtualCdromPassthroughBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualCdromPassthroughBackingOption>()?),
            StructType::VirtualCdromRemoteAtapiBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualCdromRemoteAtapiBackingOption>()?),
            StructType::VirtualDiskRawDiskMappingVer1BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskRawDiskMappingVer1BackingOption>()?),
            StructType::VirtualDiskRawDiskVer2BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskRawDiskVer2BackingOption>()?),
            StructType::VirtualDiskPartitionedRawDiskVer2BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskPartitionedRawDiskVer2BackingOption>()?),
            StructType::VirtualEthernetCardLegacyNetworkBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardLegacyNetworkBackingOption>()?),
            StructType::VirtualEthernetCardNetworkBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardNetworkBackingOption>()?),
            StructType::VirtualFloppyDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualFloppyDeviceBackingOption>()?),
            StructType::VirtualPciPassthroughDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughDeviceBackingOption>()?),
            StructType::VirtualPciPassthroughDynamicBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughDynamicBackingOption>()?),
            StructType::VirtualParallelPortDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualParallelPortDeviceBackingOption>()?),
            StructType::VirtualPointingDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPointingDeviceBackingOption>()?),
            StructType::VirtualScsiPassthroughDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualScsiPassthroughDeviceBackingOption>()?),
            StructType::VirtualSerialPortDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortDeviceBackingOption>()?),
            StructType::VirtualSoundCardDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSoundCardDeviceBackingOption>()?),
            StructType::VirtualUsbRemoteHostBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualUsbRemoteHostBackingOption>()?),
            StructType::VirtualUsbusbBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualUsbusbBackingOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualDeviceDeviceBackingOption>()?),
            StructType::VirtualCdromAtapiBackingOption => Ok(from.as_any_box().downcast::<VirtualCdromAtapiBackingOption>()?),
            StructType::VirtualCdromPassthroughBackingOption => Ok(from.as_any_box().downcast::<VirtualCdromPassthroughBackingOption>()?),
            StructType::VirtualCdromRemoteAtapiBackingOption => Ok(from.as_any_box().downcast::<VirtualCdromRemoteAtapiBackingOption>()?),
            StructType::VirtualDiskRawDiskMappingVer1BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskRawDiskMappingVer1BackingOption>()?),
            StructType::VirtualDiskRawDiskVer2BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskRawDiskVer2BackingOption>()?),
            StructType::VirtualDiskPartitionedRawDiskVer2BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskPartitionedRawDiskVer2BackingOption>()?),
            StructType::VirtualEthernetCardLegacyNetworkBackingOption => Ok(from.as_any_box().downcast::<VirtualEthernetCardLegacyNetworkBackingOption>()?),
            StructType::VirtualEthernetCardNetworkBackingOption => Ok(from.as_any_box().downcast::<VirtualEthernetCardNetworkBackingOption>()?),
            StructType::VirtualFloppyDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualFloppyDeviceBackingOption>()?),
            StructType::VirtualPciPassthroughDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualPciPassthroughDeviceBackingOption>()?),
            StructType::VirtualPciPassthroughDynamicBackingOption => Ok(from.as_any_box().downcast::<VirtualPciPassthroughDynamicBackingOption>()?),
            StructType::VirtualParallelPortDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualParallelPortDeviceBackingOption>()?),
            StructType::VirtualPointingDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualPointingDeviceBackingOption>()?),
            StructType::VirtualScsiPassthroughDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualScsiPassthroughDeviceBackingOption>()?),
            StructType::VirtualSerialPortDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualSerialPortDeviceBackingOption>()?),
            StructType::VirtualSoundCardDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualSoundCardDeviceBackingOption>()?),
            StructType::VirtualUsbRemoteHostBackingOption => Ok(from.as_any_box().downcast::<VirtualUsbRemoteHostBackingOption>()?),
            StructType::VirtualUsbusbBackingOption => Ok(from.as_any_box().downcast::<VirtualUsbusbBackingOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The VirtualDiskOption.RawDiskVer2BackingOption object type
/// contains the available options when backing a virtual disk
/// using a host device on VMware Server.
pub trait VirtualDiskRawDiskVer2BackingOptionTrait : super::traits::VirtualDeviceDeviceBackingOptionTrait {
    /// Valid extensions for the filename of the raw disk descriptor
    /// file.
    fn get_descriptor_file_name_extensions(&self) -> &ChoiceOption;
    /// Flag to indicate whether this backing supports disk UUID property.
    fn get_uuid(&self) -> bool;
}
impl<'s> serde::Serialize for dyn VirtualDiskRawDiskVer2BackingOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDiskRawDiskVer2BackingOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDiskRawDiskVer2BackingOptionVisitor)
            }
        }

struct VirtualDiskRawDiskVer2BackingOptionVisitor;

impl<'de> de::Visitor<'de> for VirtualDiskRawDiskVer2BackingOptionVisitor {
    type Value = Box<dyn VirtualDiskRawDiskVer2BackingOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDiskRawDiskVer2BackingOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDiskRawDiskVer2BackingOptionTrait for VirtualDiskRawDiskVer2BackingOption {
    fn get_descriptor_file_name_extensions(&self) -> &ChoiceOption { &self.descriptor_file_name_extensions }
    fn get_uuid(&self) -> bool { self.uuid }
}
impl VirtualDiskRawDiskVer2BackingOptionTrait for VirtualDiskPartitionedRawDiskVer2BackingOption {
    fn get_descriptor_file_name_extensions(&self) -> &ChoiceOption { &self.descriptor_file_name_extensions }
    fn get_uuid(&self) -> bool { self.uuid }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDiskRawDiskVer2BackingOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDiskRawDiskVer2BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskRawDiskVer2BackingOption>()?),
            StructType::VirtualDiskPartitionedRawDiskVer2BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskPartitionedRawDiskVer2BackingOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDiskRawDiskVer2BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskRawDiskVer2BackingOption>()?),
            StructType::VirtualDiskPartitionedRawDiskVer2BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskPartitionedRawDiskVer2BackingOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The FileBackingOption data class contains file-specific backing options.
pub trait VirtualDeviceFileBackingOptionTrait : super::traits::VirtualDeviceBackingOptionTrait {
    /// Valid filename extension for the filename.
    /// 
    /// If no extensions are present, any file extension is acceptable.
    fn get_file_name_extensions(&self) -> &Option<ChoiceOption>;
}
impl<'s> serde::Serialize for dyn VirtualDeviceFileBackingOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDeviceFileBackingOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDeviceFileBackingOptionVisitor)
            }
        }

struct VirtualDeviceFileBackingOptionVisitor;

impl<'de> de::Visitor<'de> for VirtualDeviceFileBackingOptionVisitor {
    type Value = Box<dyn VirtualDeviceFileBackingOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDeviceFileBackingOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDeviceFileBackingOptionTrait for VirtualDeviceFileBackingOption {
    fn get_file_name_extensions(&self) -> &Option<ChoiceOption> { &self.file_name_extensions }
}
impl VirtualDeviceFileBackingOptionTrait for VirtualCdromIsoBackingOption {
    fn get_file_name_extensions(&self) -> &Option<ChoiceOption> { &self.file_name_extensions }
}
impl VirtualDeviceFileBackingOptionTrait for VirtualDiskFlatVer1BackingOption {
    fn get_file_name_extensions(&self) -> &Option<ChoiceOption> { &self.file_name_extensions }
}
impl VirtualDeviceFileBackingOptionTrait for VirtualDiskFlatVer2BackingOption {
    fn get_file_name_extensions(&self) -> &Option<ChoiceOption> { &self.file_name_extensions }
}
impl VirtualDeviceFileBackingOptionTrait for VirtualDiskLocalPMemBackingOption {
    fn get_file_name_extensions(&self) -> &Option<ChoiceOption> { &self.file_name_extensions }
}
impl VirtualDeviceFileBackingOptionTrait for VirtualDiskSeSparseBackingOption {
    fn get_file_name_extensions(&self) -> &Option<ChoiceOption> { &self.file_name_extensions }
}
impl VirtualDeviceFileBackingOptionTrait for VirtualDiskSparseVer1BackingOption {
    fn get_file_name_extensions(&self) -> &Option<ChoiceOption> { &self.file_name_extensions }
}
impl VirtualDeviceFileBackingOptionTrait for VirtualDiskSparseVer2BackingOption {
    fn get_file_name_extensions(&self) -> &Option<ChoiceOption> { &self.file_name_extensions }
}
impl VirtualDeviceFileBackingOptionTrait for VirtualFloppyImageBackingOption {
    fn get_file_name_extensions(&self) -> &Option<ChoiceOption> { &self.file_name_extensions }
}
impl VirtualDeviceFileBackingOptionTrait for VirtualParallelPortFileBackingOption {
    fn get_file_name_extensions(&self) -> &Option<ChoiceOption> { &self.file_name_extensions }
}
impl VirtualDeviceFileBackingOptionTrait for VirtualSerialPortFileBackingOption {
    fn get_file_name_extensions(&self) -> &Option<ChoiceOption> { &self.file_name_extensions }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDeviceFileBackingOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceFileBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDeviceFileBackingOption>()?),
            StructType::VirtualCdromIsoBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualCdromIsoBackingOption>()?),
            StructType::VirtualDiskFlatVer1BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskFlatVer1BackingOption>()?),
            StructType::VirtualDiskFlatVer2BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskFlatVer2BackingOption>()?),
            StructType::VirtualDiskLocalPMemBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskLocalPMemBackingOption>()?),
            StructType::VirtualDiskSeSparseBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskSeSparseBackingOption>()?),
            StructType::VirtualDiskSparseVer1BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskSparseVer1BackingOption>()?),
            StructType::VirtualDiskSparseVer2BackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDiskSparseVer2BackingOption>()?),
            StructType::VirtualFloppyImageBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualFloppyImageBackingOption>()?),
            StructType::VirtualParallelPortFileBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualParallelPortFileBackingOption>()?),
            StructType::VirtualSerialPortFileBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortFileBackingOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceFileBackingOption => Ok(from.as_any_box().downcast::<VirtualDeviceFileBackingOption>()?),
            StructType::VirtualCdromIsoBackingOption => Ok(from.as_any_box().downcast::<VirtualCdromIsoBackingOption>()?),
            StructType::VirtualDiskFlatVer1BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskFlatVer1BackingOption>()?),
            StructType::VirtualDiskFlatVer2BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskFlatVer2BackingOption>()?),
            StructType::VirtualDiskLocalPMemBackingOption => Ok(from.as_any_box().downcast::<VirtualDiskLocalPMemBackingOption>()?),
            StructType::VirtualDiskSeSparseBackingOption => Ok(from.as_any_box().downcast::<VirtualDiskSeSparseBackingOption>()?),
            StructType::VirtualDiskSparseVer1BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskSparseVer1BackingOption>()?),
            StructType::VirtualDiskSparseVer2BackingOption => Ok(from.as_any_box().downcast::<VirtualDiskSparseVer2BackingOption>()?),
            StructType::VirtualFloppyImageBackingOption => Ok(from.as_any_box().downcast::<VirtualFloppyImageBackingOption>()?),
            StructType::VirtualParallelPortFileBackingOption => Ok(from.as_any_box().downcast::<VirtualParallelPortFileBackingOption>()?),
            StructType::VirtualSerialPortFileBackingOption => Ok(from.as_any_box().downcast::<VirtualSerialPortFileBackingOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The <code>*VirtualDevicePipeBackingOption*</code> data object type contains options
/// specific to pipe backings.
pub trait VirtualDevicePipeBackingOptionTrait : super::traits::VirtualDeviceBackingOptionTrait {
}
impl<'s> serde::Serialize for dyn VirtualDevicePipeBackingOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDevicePipeBackingOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDevicePipeBackingOptionVisitor)
            }
        }

struct VirtualDevicePipeBackingOptionVisitor;

impl<'de> de::Visitor<'de> for VirtualDevicePipeBackingOptionVisitor {
    type Value = Box<dyn VirtualDevicePipeBackingOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDevicePipeBackingOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDevicePipeBackingOptionTrait for VirtualDevicePipeBackingOption {
}
impl VirtualDevicePipeBackingOptionTrait for VirtualSerialPortPipeBackingOption {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDevicePipeBackingOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDevicePipeBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDevicePipeBackingOption>()?),
            StructType::VirtualSerialPortPipeBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortPipeBackingOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDevicePipeBackingOption => Ok(from.as_any_box().downcast::<VirtualDevicePipeBackingOption>()?),
            StructType::VirtualSerialPortPipeBackingOption => Ok(from.as_any_box().downcast::<VirtualSerialPortPipeBackingOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// VirtualDeviceOption.RemoteDeviceBackingOption describes the options
/// for a remote device backing.
/// 
/// The primary difference
/// between a remote device backing and a local device backing is that
/// the VirtualCenter server cannot provide a list of remote host devices
/// available for this virtual device backing.
pub trait VirtualDeviceRemoteDeviceBackingOptionTrait : super::traits::VirtualDeviceBackingOptionTrait {
    /// Flag to indicate whether the specific instance of this device can
    /// be auto-detected on the host instead of having to specify a
    /// particular physical device.
    fn get_auto_detect_available(&self) -> &BoolOption;
}
impl<'s> serde::Serialize for dyn VirtualDeviceRemoteDeviceBackingOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDeviceRemoteDeviceBackingOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDeviceRemoteDeviceBackingOptionVisitor)
            }
        }

struct VirtualDeviceRemoteDeviceBackingOptionVisitor;

impl<'de> de::Visitor<'de> for VirtualDeviceRemoteDeviceBackingOptionVisitor {
    type Value = Box<dyn VirtualDeviceRemoteDeviceBackingOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDeviceRemoteDeviceBackingOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDeviceRemoteDeviceBackingOptionTrait for VirtualDeviceRemoteDeviceBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceRemoteDeviceBackingOptionTrait for VirtualCdromRemotePassthroughBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceRemoteDeviceBackingOptionTrait for VirtualFloppyRemoteDeviceBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl VirtualDeviceRemoteDeviceBackingOptionTrait for VirtualUsbRemoteClientBackingOption {
    fn get_auto_detect_available(&self) -> &BoolOption { &self.auto_detect_available }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDeviceRemoteDeviceBackingOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceRemoteDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDeviceRemoteDeviceBackingOption>()?),
            StructType::VirtualCdromRemotePassthroughBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualCdromRemotePassthroughBackingOption>()?),
            StructType::VirtualFloppyRemoteDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualFloppyRemoteDeviceBackingOption>()?),
            StructType::VirtualUsbRemoteClientBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualUsbRemoteClientBackingOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceRemoteDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualDeviceRemoteDeviceBackingOption>()?),
            StructType::VirtualCdromRemotePassthroughBackingOption => Ok(from.as_any_box().downcast::<VirtualCdromRemotePassthroughBackingOption>()?),
            StructType::VirtualFloppyRemoteDeviceBackingOption => Ok(from.as_any_box().downcast::<VirtualFloppyRemoteDeviceBackingOption>()?),
            StructType::VirtualUsbRemoteClientBackingOption => Ok(from.as_any_box().downcast::<VirtualUsbRemoteClientBackingOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *VirtualDeviceURIBackingOption* data object type describes network communication
/// options for virtual devices.
/// 
/// When establishing a connection with a remote system on the network,
/// the virtual machine can act as a server or a client.
/// When the virtual machine acts as a server, it accepts a connection.
/// When the virtual machine acts as a client, it initiates the connection.
pub trait VirtualDeviceUriBackingOptionTrait : super::traits::VirtualDeviceBackingOptionTrait {
    /// List of possible directions.
    /// 
    /// Valid directions are:
    /// - *server*
    /// - *client*
    fn get_directions(&self) -> &ChoiceOption;
}
impl<'s> serde::Serialize for dyn VirtualDeviceUriBackingOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDeviceUriBackingOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDeviceUriBackingOptionVisitor)
            }
        }

struct VirtualDeviceUriBackingOptionVisitor;

impl<'de> de::Visitor<'de> for VirtualDeviceUriBackingOptionVisitor {
    type Value = Box<dyn VirtualDeviceUriBackingOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDeviceUriBackingOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDeviceUriBackingOptionTrait for VirtualDeviceUriBackingOption {
    fn get_directions(&self) -> &ChoiceOption { &self.directions }
}
impl VirtualDeviceUriBackingOptionTrait for VirtualSerialPortUriBackingOption {
    fn get_directions(&self) -> &ChoiceOption { &self.directions }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDeviceUriBackingOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceUriBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualDeviceUriBackingOption>()?),
            StructType::VirtualSerialPortUriBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualSerialPortUriBackingOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceUriBackingOption => Ok(from.as_any_box().downcast::<VirtualDeviceUriBackingOption>()?),
            StructType::VirtualSerialPortUriBackingOption => Ok(from.as_any_box().downcast::<VirtualSerialPortUriBackingOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type describes the options for the
/// *VirtualPCIPassthroughPluginBackingInfo* data object type.
pub trait VirtualPciPassthroughPluginBackingOptionTrait : super::traits::VirtualDeviceBackingOptionTrait {
}
impl<'s> serde::Serialize for dyn VirtualPciPassthroughPluginBackingOptionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualPciPassthroughPluginBackingOptionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualPciPassthroughPluginBackingOptionVisitor)
            }
        }

struct VirtualPciPassthroughPluginBackingOptionVisitor;

impl<'de> de::Visitor<'de> for VirtualPciPassthroughPluginBackingOptionVisitor {
    type Value = Box<dyn VirtualPciPassthroughPluginBackingOptionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualPciPassthroughPluginBackingOptionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualPciPassthroughPluginBackingOptionTrait for VirtualPciPassthroughPluginBackingOption {
}
impl VirtualPciPassthroughPluginBackingOptionTrait for VirtualPciPassthroughVmiopBackingOption {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualPciPassthroughPluginBackingOptionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualPciPassthroughPluginBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughPluginBackingOption>()?),
            StructType::VirtualPciPassthroughVmiopBackingOption => Some(from.as_any_ref().downcast_ref::<VirtualPciPassthroughVmiopBackingOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualPciPassthroughPluginBackingOption => Ok(from.as_any_box().downcast::<VirtualPciPassthroughPluginBackingOption>()?),
            StructType::VirtualPciPassthroughVmiopBackingOption => Ok(from.as_any_box().downcast::<VirtualPciPassthroughVmiopBackingOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The VirtualDeviceSpec data object type encapsulates change
/// specifications for an individual virtual device.
/// 
/// The virtual
/// device being added or modified must be fully specified.
pub trait VirtualDeviceConfigSpecTrait : super::traits::DataObjectTrait {
    /// Type of operation being performed on the specified virtual device.
    /// 
    /// If no operation is specified, the spec. is ignored.
    fn get_operation(&self) -> &Option<super::enums::VirtualDeviceConfigSpecOperationEnum>;
    /// Type of operation being performed on the backing
    /// of the specified virtual device.
    /// 
    /// If no file operation is specified in the VirtualDeviceSpec,
    /// then any backing filenames in the
    /// *VirtualDevice*
    /// must refer to files that already exist.
    /// The "replace" and "delete" values for this property are only
    /// applicable to virtual disk backing files.
    fn get_file_operation(&self) -> &Option<super::enums::VirtualDeviceConfigSpecFileOperationEnum>;
    /// Device specification, with all necessary properties set.
    fn get_device(&self) -> &Box<dyn super::traits::VirtualDeviceTrait>;
    /// Virtual Device Profile requirement.
    /// 
    /// Profiles are solution specifics.
    /// Storage Profile Based Management(SPBM) is a vSphere server extension.
    /// The API users who want to provision VMs using Storage Profiles, need to
    /// interact with SPBM service.
    /// This is an optional parameter and if user doesn't specify profile,
    /// the default behavior will apply.
    fn get_profile(&self) -> &Option<Vec<Box<dyn super::traits::VirtualMachineProfileSpecTrait>>>;
    /// BackingInfo configuration options.
    /// 
    /// Each BackingSpec corresponds to a BackingInfo object. The member
    /// *VirtualDeviceConfigSpec.backing* refers to the
    /// *VirtualDeviceConfigSpec.device*.*VirtualDevice.backing*.
    fn get_backing(&self) -> &Option<VirtualDeviceConfigSpecBackingSpec>;
    /// List of independent filters *VirtualMachineIndependentFilterSpec*
    /// to configure on the virtual device.
    /// 
    /// ***Since:*** vSphere API Release 7.0.2.1
    fn get_filter_spec(&self) -> &Option<Vec<Box<dyn super::traits::VirtualMachineBaseIndependentFilterSpecTrait>>>;
    /// The change mode of the device.
    /// 
    /// The values of the mode will be one of *VirtualDeviceConfigSpecChangeMode_enum* enumerations.
    /// On unset, default to 'fail'.
    /// 
    /// ***Since:*** vSphere API Release 8.0.0.1
    fn get_change_mode(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn VirtualDeviceConfigSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualDeviceConfigSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualDeviceConfigSpecVisitor)
            }
        }

struct VirtualDeviceConfigSpecVisitor;

impl<'de> de::Visitor<'de> for VirtualDeviceConfigSpecVisitor {
    type Value = Box<dyn VirtualDeviceConfigSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualDeviceConfigSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualDeviceConfigSpecTrait for VirtualDeviceConfigSpec {
    fn get_operation(&self) -> &Option<super::enums::VirtualDeviceConfigSpecOperationEnum> { &self.operation }
    fn get_file_operation(&self) -> &Option<super::enums::VirtualDeviceConfigSpecFileOperationEnum> { &self.file_operation }
    fn get_device(&self) -> &Box<dyn super::traits::VirtualDeviceTrait> { &self.device }
    fn get_profile(&self) -> &Option<Vec<Box<dyn super::traits::VirtualMachineProfileSpecTrait>>> { &self.profile }
    fn get_backing(&self) -> &Option<VirtualDeviceConfigSpecBackingSpec> { &self.backing }
    fn get_filter_spec(&self) -> &Option<Vec<Box<dyn super::traits::VirtualMachineBaseIndependentFilterSpecTrait>>> { &self.filter_spec }
    fn get_change_mode(&self) -> &Option<String> { &self.change_mode }
}
impl VirtualDeviceConfigSpecTrait for VirtualDiskConfigSpec {
    fn get_operation(&self) -> &Option<super::enums::VirtualDeviceConfigSpecOperationEnum> { &self.operation }
    fn get_file_operation(&self) -> &Option<super::enums::VirtualDeviceConfigSpecFileOperationEnum> { &self.file_operation }
    fn get_device(&self) -> &Box<dyn super::traits::VirtualDeviceTrait> { &self.device }
    fn get_profile(&self) -> &Option<Vec<Box<dyn super::traits::VirtualMachineProfileSpecTrait>>> { &self.profile }
    fn get_backing(&self) -> &Option<VirtualDeviceConfigSpecBackingSpec> { &self.backing }
    fn get_filter_spec(&self) -> &Option<Vec<Box<dyn super::traits::VirtualMachineBaseIndependentFilterSpecTrait>>> { &self.filter_spec }
    fn get_change_mode(&self) -> &Option<String> { &self.change_mode }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualDeviceConfigSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceConfigSpec => Some(from.as_any_ref().downcast_ref::<VirtualDeviceConfigSpec>()?),
            StructType::VirtualDiskConfigSpec => Some(from.as_any_ref().downcast_ref::<VirtualDiskConfigSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualDeviceConfigSpec => Ok(from.as_any_box().downcast::<VirtualDeviceConfigSpec>()?),
            StructType::VirtualDiskConfigSpec => Ok(from.as_any_box().downcast::<VirtualDiskConfigSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// A Subject.
pub trait GuestAuthSubjectTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn GuestAuthSubjectTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn GuestAuthSubjectTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(GuestAuthSubjectVisitor)
            }
        }

struct GuestAuthSubjectVisitor;

impl<'de> de::Visitor<'de> for GuestAuthSubjectVisitor {
    type Value = Box<dyn GuestAuthSubjectTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid GuestAuthSubjectTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl GuestAuthSubjectTrait for GuestAuthSubject {
}
impl GuestAuthSubjectTrait for GuestAuthAnySubject {
}
impl GuestAuthSubjectTrait for GuestAuthNamedSubject {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn GuestAuthSubjectTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::GuestAuthSubject => Some(from.as_any_ref().downcast_ref::<GuestAuthSubject>()?),
            StructType::GuestAuthAnySubject => Some(from.as_any_ref().downcast_ref::<GuestAuthAnySubject>()?),
            StructType::GuestAuthNamedSubject => Some(from.as_any_ref().downcast_ref::<GuestAuthNamedSubject>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::GuestAuthSubject => Ok(from.as_any_box().downcast::<GuestAuthSubject>()?),
            StructType::GuestAuthAnySubject => Ok(from.as_any_box().downcast::<GuestAuthAnySubject>()?),
            StructType::GuestAuthNamedSubject => Ok(from.as_any_box().downcast::<GuestAuthNamedSubject>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Different attributes for a guest file.
/// - Check *GuestPosixFileAttributes*
///   for Posix guest files.
/// - Check *GuestWindowsFileAttributes*
///   for Windows guest files.
pub trait GuestFileAttributesTrait : super::traits::DataObjectTrait {
    /// The date and time the file was last modified.
    /// 
    /// If this property is not specified when passing a
    /// *GuestFileAttributes* object to
    /// *GuestFileManager.InitiateFileTransferToGuest*,
    /// the default value will be the time when the file is created inside the
    /// guest.
    fn get_modification_time(&self) -> &Option<String>;
    /// The date and time the file was last accessed.
    /// 
    /// If this property is not specified when passing a
    /// *GuestFileAttributes* object to
    /// *GuestFileManager.InitiateFileTransferToGuest*,
    /// the default value will be the time when the file is created inside the
    /// guest.
    fn get_access_time(&self) -> &Option<String>;
    /// The target for the file if it's a symbolic link.
    /// 
    /// This is currently only set for Linux guest operating systems,
    /// but may be supported in the
    /// future on Windows guest operating systems that support symbolic links.
    /// This property gives information about files when returned from
    /// *GuestFileManager.ListFilesInGuest* or
    /// *GuestFileManager.InitiateFileTransferFromGuest*
    /// as part of a *GuestFileAttributes* object.
    /// This property will be ignored when passing a
    /// *GuestFileAttributes* object to
    /// *GuestFileManager.InitiateFileTransferToGuest* or
    /// *GuestFileManager.ChangeFileAttributesInGuest*.
    /// If the file is a symbolic link, then the attributes of the target
    /// are returned, not those of the symbolic link.
    fn get_symlink_target(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn GuestFileAttributesTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn GuestFileAttributesTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(GuestFileAttributesVisitor)
            }
        }

struct GuestFileAttributesVisitor;

impl<'de> de::Visitor<'de> for GuestFileAttributesVisitor {
    type Value = Box<dyn GuestFileAttributesTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid GuestFileAttributesTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl GuestFileAttributesTrait for GuestFileAttributes {
    fn get_modification_time(&self) -> &Option<String> { &self.modification_time }
    fn get_access_time(&self) -> &Option<String> { &self.access_time }
    fn get_symlink_target(&self) -> &Option<String> { &self.symlink_target }
}
impl GuestFileAttributesTrait for GuestPosixFileAttributes {
    fn get_modification_time(&self) -> &Option<String> { &self.modification_time }
    fn get_access_time(&self) -> &Option<String> { &self.access_time }
    fn get_symlink_target(&self) -> &Option<String> { &self.symlink_target }
}
impl GuestFileAttributesTrait for GuestWindowsFileAttributes {
    fn get_modification_time(&self) -> &Option<String> { &self.modification_time }
    fn get_access_time(&self) -> &Option<String> { &self.access_time }
    fn get_symlink_target(&self) -> &Option<String> { &self.symlink_target }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn GuestFileAttributesTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::GuestFileAttributes => Some(from.as_any_ref().downcast_ref::<GuestFileAttributes>()?),
            StructType::GuestPosixFileAttributes => Some(from.as_any_ref().downcast_ref::<GuestPosixFileAttributes>()?),
            StructType::GuestWindowsFileAttributes => Some(from.as_any_ref().downcast_ref::<GuestWindowsFileAttributes>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::GuestFileAttributes => Ok(from.as_any_box().downcast::<GuestFileAttributes>()?),
            StructType::GuestPosixFileAttributes => Ok(from.as_any_box().downcast::<GuestPosixFileAttributes>()?),
            StructType::GuestWindowsFileAttributes => Ok(from.as_any_box().downcast::<GuestWindowsFileAttributes>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// GuestAuthentication is an abstract base class for authentication
/// in the guest.
pub trait GuestAuthenticationTrait : super::traits::DataObjectTrait {
    /// This is set to true if the client wants an interactive session
    /// in the guest.
    /// 
    /// Setting this is supported only for *NamePasswordAuthentication*.
    fn get_interactive_session(&self) -> bool;
}
impl<'s> serde::Serialize for dyn GuestAuthenticationTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn GuestAuthenticationTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(GuestAuthenticationVisitor)
            }
        }

struct GuestAuthenticationVisitor;

impl<'de> de::Visitor<'de> for GuestAuthenticationVisitor {
    type Value = Box<dyn GuestAuthenticationTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid GuestAuthenticationTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl GuestAuthenticationTrait for GuestAuthentication {
    fn get_interactive_session(&self) -> bool { self.interactive_session }
}
impl GuestAuthenticationTrait for NamePasswordAuthentication {
    fn get_interactive_session(&self) -> bool { self.interactive_session }
}
impl GuestAuthenticationTrait for SamlTokenAuthentication {
    fn get_interactive_session(&self) -> bool { self.interactive_session }
}
impl GuestAuthenticationTrait for SspiAuthentication {
    fn get_interactive_session(&self) -> bool { self.interactive_session }
}
impl GuestAuthenticationTrait for TicketedSessionAuthentication {
    fn get_interactive_session(&self) -> bool { self.interactive_session }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn GuestAuthenticationTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::GuestAuthentication => Some(from.as_any_ref().downcast_ref::<GuestAuthentication>()?),
            StructType::NamePasswordAuthentication => Some(from.as_any_ref().downcast_ref::<NamePasswordAuthentication>()?),
            StructType::SamlTokenAuthentication => Some(from.as_any_ref().downcast_ref::<SamlTokenAuthentication>()?),
            StructType::SspiAuthentication => Some(from.as_any_ref().downcast_ref::<SspiAuthentication>()?),
            StructType::TicketedSessionAuthentication => Some(from.as_any_ref().downcast_ref::<TicketedSessionAuthentication>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::GuestAuthentication => Ok(from.as_any_box().downcast::<GuestAuthentication>()?),
            StructType::NamePasswordAuthentication => Ok(from.as_any_box().downcast::<NamePasswordAuthentication>()?),
            StructType::SamlTokenAuthentication => Ok(from.as_any_box().downcast::<SamlTokenAuthentication>()?),
            StructType::SspiAuthentication => Ok(from.as_any_box().downcast::<SspiAuthentication>()?),
            StructType::TicketedSessionAuthentication => Ok(from.as_any_box().downcast::<TicketedSessionAuthentication>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This describes the arguments to *GuestProcessManager.StartProgramInGuest*.
pub trait GuestProgramSpecTrait : super::traits::DataObjectTrait {
    /// The absolute path to the program to start.
    /// 
    /// For Linux guest operating systems, /bin/bash is used to start the
    /// program.
    /// 
    /// For Solaris guest operating systems, /bin/bash is used to start
    /// the program if it exists.
    /// Otherwise /bin/sh is used. If /bin/sh is used, then the process ID
    /// returned by *GuestProcessManager.StartProgramInGuest* will be that of the shell used
    /// to start the program, rather than the program itself, due to the
    /// differences in how /bin/sh and /bin/bash work. This PID will
    /// still be usable for watching the process with
    /// *GuestProcessManager.ListProcessesInGuest* to
    /// find its exit code and elapsed time.
    fn get_program_path(&self) -> &str;
    /// The arguments to the program.
    /// 
    /// In Linux and Solaris guest operating
    /// systems, the program will be executed by a guest shell.
    /// This allows stdio redirection, but may also
    /// require that characters which must be escaped to the shell also
    /// be escaped on the command line provided.
    /// 
    /// For Windows guest operating systems, prefixing the command with
    /// "cmd /c" can provide stdio redirection.
    fn get_arguments(&self) -> &str;
    /// The absolute path of the working directory for the program to be
    /// run.
    /// 
    /// VMware recommends explicitly setting the working directory
    /// for the program to be run. If this value is unset or is an empty
    /// string, the behavior depends on the guest operating system.
    /// For Linux guest operating systems, if this value is unset or is
    /// an empty string, the working directory will be the home directory
    /// of the user associated with the guest authentication.
    /// For other guest operating systems, if this value is unset, the
    /// behavior is unspecified.
    fn get_working_directory(&self) -> &Option<String>;
    /// An array of environment variables, specified
    /// in the guest OS notation (eg PATH=c:\\bin;c:\\windows\\system32
    /// or LD\_LIBRARY\_PATH=/usr/lib:/lib), to be set for the program
    /// being run.
    /// 
    /// Note that these are not additions to the default
    /// environment variables; they define the complete set available to
    /// the program. If none are specified the values are guest dependent.
    fn get_env_variables(&self) -> &Option<Vec<String>>;
}
impl<'s> serde::Serialize for dyn GuestProgramSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn GuestProgramSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(GuestProgramSpecVisitor)
            }
        }

struct GuestProgramSpecVisitor;

impl<'de> de::Visitor<'de> for GuestProgramSpecVisitor {
    type Value = Box<dyn GuestProgramSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid GuestProgramSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl GuestProgramSpecTrait for GuestProgramSpec {
    fn get_program_path(&self) -> &str { &self.program_path }
    fn get_arguments(&self) -> &str { &self.arguments }
    fn get_working_directory(&self) -> &Option<String> { &self.working_directory }
    fn get_env_variables(&self) -> &Option<Vec<String>> { &self.env_variables }
}
impl GuestProgramSpecTrait for GuestWindowsProgramSpec {
    fn get_program_path(&self) -> &str { &self.program_path }
    fn get_arguments(&self) -> &str { &self.arguments }
    fn get_working_directory(&self) -> &Option<String> { &self.working_directory }
    fn get_env_variables(&self) -> &Option<Vec<String>> { &self.env_variables }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn GuestProgramSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::GuestProgramSpec => Some(from.as_any_ref().downcast_ref::<GuestProgramSpec>()?),
            StructType::GuestWindowsProgramSpec => Some(from.as_any_ref().downcast_ref::<GuestWindowsProgramSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::GuestProgramSpec => Ok(from.as_any_box().downcast::<GuestProgramSpec>()?),
            StructType::GuestWindowsProgramSpec => Ok(from.as_any_box().downcast::<GuestWindowsProgramSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This describes the registry value data.
pub trait GuestRegValueDataSpecTrait : super::traits::DataObjectTrait {
}
impl<'s> serde::Serialize for dyn GuestRegValueDataSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn GuestRegValueDataSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(GuestRegValueDataSpecVisitor)
            }
        }

struct GuestRegValueDataSpecVisitor;

impl<'de> de::Visitor<'de> for GuestRegValueDataSpecVisitor {
    type Value = Box<dyn GuestRegValueDataSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid GuestRegValueDataSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl GuestRegValueDataSpecTrait for GuestRegValueDataSpec {
}
impl GuestRegValueDataSpecTrait for GuestRegValueBinarySpec {
}
impl GuestRegValueDataSpecTrait for GuestRegValueDwordSpec {
}
impl GuestRegValueDataSpecTrait for GuestRegValueExpandStringSpec {
}
impl GuestRegValueDataSpecTrait for GuestRegValueMultiStringSpec {
}
impl GuestRegValueDataSpecTrait for GuestRegValueQwordSpec {
}
impl GuestRegValueDataSpecTrait for GuestRegValueStringSpec {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn GuestRegValueDataSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::GuestRegValueDataSpec => Some(from.as_any_ref().downcast_ref::<GuestRegValueDataSpec>()?),
            StructType::GuestRegValueBinarySpec => Some(from.as_any_ref().downcast_ref::<GuestRegValueBinarySpec>()?),
            StructType::GuestRegValueDwordSpec => Some(from.as_any_ref().downcast_ref::<GuestRegValueDwordSpec>()?),
            StructType::GuestRegValueExpandStringSpec => Some(from.as_any_ref().downcast_ref::<GuestRegValueExpandStringSpec>()?),
            StructType::GuestRegValueMultiStringSpec => Some(from.as_any_ref().downcast_ref::<GuestRegValueMultiStringSpec>()?),
            StructType::GuestRegValueQwordSpec => Some(from.as_any_ref().downcast_ref::<GuestRegValueQwordSpec>()?),
            StructType::GuestRegValueStringSpec => Some(from.as_any_ref().downcast_ref::<GuestRegValueStringSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::GuestRegValueDataSpec => Ok(from.as_any_box().downcast::<GuestRegValueDataSpec>()?),
            StructType::GuestRegValueBinarySpec => Ok(from.as_any_box().downcast::<GuestRegValueBinarySpec>()?),
            StructType::GuestRegValueDwordSpec => Ok(from.as_any_box().downcast::<GuestRegValueDwordSpec>()?),
            StructType::GuestRegValueExpandStringSpec => Ok(from.as_any_box().downcast::<GuestRegValueExpandStringSpec>()?),
            StructType::GuestRegValueMultiStringSpec => Ok(from.as_any_box().downcast::<GuestRegValueMultiStringSpec>()?),
            StructType::GuestRegValueQwordSpec => Ok(from.as_any_box().downcast::<GuestRegValueQwordSpec>()?),
            StructType::GuestRegValueStringSpec => Ok(from.as_any_box().downcast::<GuestRegValueStringSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This data object type contains the basic configuration for
/// a virtual storage object or a virtual storage object snapshot.
pub trait BaseConfigInfoTrait : super::traits::DataObjectTrait {
    /// ID of this object.
    fn get_id(&self) -> &Id;
    /// Descriptive name of this object.
    fn get_name(&self) -> &str;
    /// The date and time this object was created.
    fn get_create_time(&self) -> &str;
    /// Choice of the deletion behavior of this virtual storage object.
    /// 
    /// If not set, the default value is false.
    fn get_keep_after_delete_vm(&self) -> Option<bool>;
    /// Is virtual storage object relocation disabled.
    /// 
    /// If not set, the default value is false.
    fn get_relocation_disabled(&self) -> Option<bool>;
    /// Is virtual storage object supports native snapshot.
    /// 
    /// If not set, the default value is false.
    fn get_native_snapshot_supported(&self) -> Option<bool>;
    /// If Virtua storage object has changed block tracking enabled.
    /// 
    /// If not set, the default value is false.
    fn get_changed_block_tracking_enabled(&self) -> Option<bool>;
    /// Backing of this object.
    fn get_backing(&self) -> &Box<dyn super::traits::BaseConfigInfoBackingInfoTrait>;
    /// Metadata associated with the FCD if available.
    /// 
    /// ***Since:*** vSphere API Release 7.0.2.0
    fn get_metadata(&self) -> &Option<Vec<KeyValue>>;
    /// VClock associated with the fcd when the operation completed.
    /// 
    /// The files is unset if the operation is a retrieve.
    /// 
    /// ***Since:*** vSphere API Release 7.0.2.0
    fn get_vclock(&self) -> &Option<VslmVClockInfo>;
    /// IDs of the IO Filters associated with the virtual disk.
    /// 
    /// See *IoFilterInfo.id*.
    /// The client cannot modify this information on a virtual machine.
    fn get_iofilter(&self) -> &Option<Vec<String>>;
}
impl<'s> serde::Serialize for dyn BaseConfigInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn BaseConfigInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(BaseConfigInfoVisitor)
            }
        }

struct BaseConfigInfoVisitor;

impl<'de> de::Visitor<'de> for BaseConfigInfoVisitor {
    type Value = Box<dyn BaseConfigInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid BaseConfigInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl BaseConfigInfoTrait for BaseConfigInfo {
    fn get_id(&self) -> &Id { &self.id }
    fn get_name(&self) -> &str { &self.name }
    fn get_create_time(&self) -> &str { &self.create_time }
    fn get_keep_after_delete_vm(&self) -> Option<bool> { self.keep_after_delete_vm }
    fn get_relocation_disabled(&self) -> Option<bool> { self.relocation_disabled }
    fn get_native_snapshot_supported(&self) -> Option<bool> { self.native_snapshot_supported }
    fn get_changed_block_tracking_enabled(&self) -> Option<bool> { self.changed_block_tracking_enabled }
    fn get_backing(&self) -> &Box<dyn super::traits::BaseConfigInfoBackingInfoTrait> { &self.backing }
    fn get_metadata(&self) -> &Option<Vec<KeyValue>> { &self.metadata }
    fn get_vclock(&self) -> &Option<VslmVClockInfo> { &self.vclock }
    fn get_iofilter(&self) -> &Option<Vec<String>> { &self.iofilter }
}
impl BaseConfigInfoTrait for VStorageObjectConfigInfo {
    fn get_id(&self) -> &Id { &self.id }
    fn get_name(&self) -> &str { &self.name }
    fn get_create_time(&self) -> &str { &self.create_time }
    fn get_keep_after_delete_vm(&self) -> Option<bool> { self.keep_after_delete_vm }
    fn get_relocation_disabled(&self) -> Option<bool> { self.relocation_disabled }
    fn get_native_snapshot_supported(&self) -> Option<bool> { self.native_snapshot_supported }
    fn get_changed_block_tracking_enabled(&self) -> Option<bool> { self.changed_block_tracking_enabled }
    fn get_backing(&self) -> &Box<dyn super::traits::BaseConfigInfoBackingInfoTrait> { &self.backing }
    fn get_metadata(&self) -> &Option<Vec<KeyValue>> { &self.metadata }
    fn get_vclock(&self) -> &Option<VslmVClockInfo> { &self.vclock }
    fn get_iofilter(&self) -> &Option<Vec<String>> { &self.iofilter }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn BaseConfigInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::BaseConfigInfo => Some(from.as_any_ref().downcast_ref::<BaseConfigInfo>()?),
            StructType::VStorageObjectConfigInfo => Some(from.as_any_ref().downcast_ref::<VStorageObjectConfigInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::BaseConfigInfo => Ok(from.as_any_box().downcast::<BaseConfigInfo>()?),
            StructType::VStorageObjectConfigInfo => Ok(from.as_any_box().downcast::<VStorageObjectConfigInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The data object type is a base type of backing of a virtual
/// storage object.
pub trait BaseConfigInfoBackingInfoTrait : super::traits::DataObjectTrait {
    /// The datastore managed object where this backing is located.
    /// 
    /// Refers instance of *Datastore*.
    fn get_datastore(&self) -> &ManagedObjectReference;
}
impl<'s> serde::Serialize for dyn BaseConfigInfoBackingInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn BaseConfigInfoBackingInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(BaseConfigInfoBackingInfoVisitor)
            }
        }

struct BaseConfigInfoBackingInfoVisitor;

impl<'de> de::Visitor<'de> for BaseConfigInfoBackingInfoVisitor {
    type Value = Box<dyn BaseConfigInfoBackingInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid BaseConfigInfoBackingInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl BaseConfigInfoBackingInfoTrait for BaseConfigInfoBackingInfo {
    fn get_datastore(&self) -> &ManagedObjectReference { &self.datastore }
}
impl BaseConfigInfoBackingInfoTrait for BaseConfigInfoFileBackingInfo {
    fn get_datastore(&self) -> &ManagedObjectReference { &self.datastore }
}
impl BaseConfigInfoBackingInfoTrait for BaseConfigInfoDiskFileBackingInfo {
    fn get_datastore(&self) -> &ManagedObjectReference { &self.datastore }
}
impl BaseConfigInfoBackingInfoTrait for BaseConfigInfoRawDiskMappingBackingInfo {
    fn get_datastore(&self) -> &ManagedObjectReference { &self.datastore }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn BaseConfigInfoBackingInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::BaseConfigInfoBackingInfo => Some(from.as_any_ref().downcast_ref::<BaseConfigInfoBackingInfo>()?),
            StructType::BaseConfigInfoFileBackingInfo => Some(from.as_any_ref().downcast_ref::<BaseConfigInfoFileBackingInfo>()?),
            StructType::BaseConfigInfoDiskFileBackingInfo => Some(from.as_any_ref().downcast_ref::<BaseConfigInfoDiskFileBackingInfo>()?),
            StructType::BaseConfigInfoRawDiskMappingBackingInfo => Some(from.as_any_ref().downcast_ref::<BaseConfigInfoRawDiskMappingBackingInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::BaseConfigInfoBackingInfo => Ok(from.as_any_box().downcast::<BaseConfigInfoBackingInfo>()?),
            StructType::BaseConfigInfoFileBackingInfo => Ok(from.as_any_box().downcast::<BaseConfigInfoFileBackingInfo>()?),
            StructType::BaseConfigInfoDiskFileBackingInfo => Ok(from.as_any_box().downcast::<BaseConfigInfoDiskFileBackingInfo>()?),
            StructType::BaseConfigInfoRawDiskMappingBackingInfo => Ok(from.as_any_box().downcast::<BaseConfigInfoRawDiskMappingBackingInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Information for file backing of a virtual storage
/// object.
/// 
/// File backing is mainly used for virtual disks.
pub trait BaseConfigInfoFileBackingInfoTrait : super::traits::BaseConfigInfoBackingInfoTrait {
    /// Full file path for the host file used in this backing.
    fn get_file_path(&self) -> &str;
    /// Id refers to the backed storage object where the virtual storage object
    /// is backed on.
    fn get_backing_object_id(&self) -> &Option<String>;
    /// The parent of this virtual disk file, if this is a delta disk backing.
    /// 
    /// This will be unset if this is the root disk backing.
    /// 
    /// Note that the type of the backing is consistent throughout the chain;
    /// any new delta disk backing which is added is of the same type as the
    /// original disk. Also note that since the parent backing is not being
    /// written to, it is possible that the parent backing may be shared among
    /// multiple disks.
    /// 
    /// Only raw disk mappings in
    /// *virtual compatibility mode* can have parents.
    fn get_parent(&self) -> &Option<Box<dyn super::traits::BaseConfigInfoFileBackingInfoTrait>>;
    /// Size allocated by the FS for this file/chain/link/extent only.
    /// 
    /// This property is used only for a delta disk whose
    /// *BaseConfigInfoFileBackingInfo.parent* is set.
    fn get_delta_size_in_mb(&self) -> Option<i64>;
    /// key id used to encrypt the backing disk.
    fn get_key_id(&self) -> &Option<CryptoKeyId>;
}
impl<'s> serde::Serialize for dyn BaseConfigInfoFileBackingInfoTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn BaseConfigInfoFileBackingInfoTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(BaseConfigInfoFileBackingInfoVisitor)
            }
        }

struct BaseConfigInfoFileBackingInfoVisitor;

impl<'de> de::Visitor<'de> for BaseConfigInfoFileBackingInfoVisitor {
    type Value = Box<dyn BaseConfigInfoFileBackingInfoTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid BaseConfigInfoFileBackingInfoTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl BaseConfigInfoFileBackingInfoTrait for BaseConfigInfoFileBackingInfo {
    fn get_file_path(&self) -> &str { &self.file_path }
    fn get_backing_object_id(&self) -> &Option<String> { &self.backing_object_id }
    fn get_parent(&self) -> &Option<Box<dyn super::traits::BaseConfigInfoFileBackingInfoTrait>> { &self.parent }
    fn get_delta_size_in_mb(&self) -> Option<i64> { self.delta_size_in_mb }
    fn get_key_id(&self) -> &Option<CryptoKeyId> { &self.key_id }
}
impl BaseConfigInfoFileBackingInfoTrait for BaseConfigInfoDiskFileBackingInfo {
    fn get_file_path(&self) -> &str { &self.file_path }
    fn get_backing_object_id(&self) -> &Option<String> { &self.backing_object_id }
    fn get_parent(&self) -> &Option<Box<dyn super::traits::BaseConfigInfoFileBackingInfoTrait>> { &self.parent }
    fn get_delta_size_in_mb(&self) -> Option<i64> { self.delta_size_in_mb }
    fn get_key_id(&self) -> &Option<CryptoKeyId> { &self.key_id }
}
impl BaseConfigInfoFileBackingInfoTrait for BaseConfigInfoRawDiskMappingBackingInfo {
    fn get_file_path(&self) -> &str { &self.file_path }
    fn get_backing_object_id(&self) -> &Option<String> { &self.backing_object_id }
    fn get_parent(&self) -> &Option<Box<dyn super::traits::BaseConfigInfoFileBackingInfoTrait>> { &self.parent }
    fn get_delta_size_in_mb(&self) -> Option<i64> { self.delta_size_in_mb }
    fn get_key_id(&self) -> &Option<CryptoKeyId> { &self.key_id }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn BaseConfigInfoFileBackingInfoTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::BaseConfigInfoFileBackingInfo => Some(from.as_any_ref().downcast_ref::<BaseConfigInfoFileBackingInfo>()?),
            StructType::BaseConfigInfoDiskFileBackingInfo => Some(from.as_any_ref().downcast_ref::<BaseConfigInfoDiskFileBackingInfo>()?),
            StructType::BaseConfigInfoRawDiskMappingBackingInfo => Some(from.as_any_ref().downcast_ref::<BaseConfigInfoRawDiskMappingBackingInfo>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::BaseConfigInfoFileBackingInfo => Ok(from.as_any_box().downcast::<BaseConfigInfoFileBackingInfo>()?),
            StructType::BaseConfigInfoDiskFileBackingInfo => Ok(from.as_any_box().downcast::<BaseConfigInfoDiskFileBackingInfo>()?),
            StructType::BaseConfigInfoRawDiskMappingBackingInfo => Ok(from.as_any_box().downcast::<BaseConfigInfoRawDiskMappingBackingInfo>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Specification of the backing of a virtual
/// storage object.
pub trait VslmCreateSpecBackingSpecTrait : super::traits::DataObjectTrait {
    /// The datastore managed object where this backing is located.
    /// 
    /// Refers instance of *Datastore*.
    fn get_datastore(&self) -> &ManagedObjectReference;
    /// Relative location in the specified datastore where disk needs to be
    /// created.
    /// 
    /// If not specified disk gets created at the defualt
    /// VStorageObject location on the specified datastore.
    fn get_path(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn VslmCreateSpecBackingSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VslmCreateSpecBackingSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VslmCreateSpecBackingSpecVisitor)
            }
        }

struct VslmCreateSpecBackingSpecVisitor;

impl<'de> de::Visitor<'de> for VslmCreateSpecBackingSpecVisitor {
    type Value = Box<dyn VslmCreateSpecBackingSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VslmCreateSpecBackingSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VslmCreateSpecBackingSpecTrait for VslmCreateSpecBackingSpec {
    fn get_datastore(&self) -> &ManagedObjectReference { &self.datastore }
    fn get_path(&self) -> &Option<String> { &self.path }
}
impl VslmCreateSpecBackingSpecTrait for VslmCreateSpecDiskFileBackingSpec {
    fn get_datastore(&self) -> &ManagedObjectReference { &self.datastore }
    fn get_path(&self) -> &Option<String> { &self.path }
}
impl VslmCreateSpecBackingSpecTrait for VslmCreateSpecRawDiskMappingBackingSpec {
    fn get_datastore(&self) -> &ManagedObjectReference { &self.datastore }
    fn get_path(&self) -> &Option<String> { &self.path }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VslmCreateSpecBackingSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VslmCreateSpecBackingSpec => Some(from.as_any_ref().downcast_ref::<VslmCreateSpecBackingSpec>()?),
            StructType::VslmCreateSpecDiskFileBackingSpec => Some(from.as_any_ref().downcast_ref::<VslmCreateSpecDiskFileBackingSpec>()?),
            StructType::VslmCreateSpecRawDiskMappingBackingSpec => Some(from.as_any_ref().downcast_ref::<VslmCreateSpecRawDiskMappingBackingSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VslmCreateSpecBackingSpec => Ok(from.as_any_box().downcast::<VslmCreateSpecBackingSpec>()?),
            StructType::VslmCreateSpecDiskFileBackingSpec => Ok(from.as_any_box().downcast::<VslmCreateSpecDiskFileBackingSpec>()?),
            StructType::VslmCreateSpecRawDiskMappingBackingSpec => Ok(from.as_any_box().downcast::<VslmCreateSpecRawDiskMappingBackingSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base specification of moving or copying a virtual storage object.
pub trait VslmMigrateSpecTrait : super::traits::DataObjectTrait {
    /// Specification of the backings of the target virtual storage object.
    fn get_backing_spec(&self) -> &Box<dyn super::traits::VslmCreateSpecBackingSpecTrait>;
    /// Virtual storage object Profile requirement.
    /// 
    /// If unset,
    /// the default behavior will apply.
    fn get_profile(&self) -> &Option<Vec<Box<dyn super::traits::VirtualMachineProfileSpecTrait>>>;
    /// Flag indicates any delta disk backings will be consolidated
    /// during migration.
    /// 
    /// If unset, delta disk backings will not be
    /// consolidated.
    fn get_consolidate(&self) -> Option<bool>;
    /// Disk chain crypto information.
    /// 
    /// If unset and if *VslmMigrateSpec.profile* contains an encryption iofilter and if
    /// source VStorageObject is unencrypted, then disksCyrpto will be of type
    /// CryptoSpecEncrypt, and filled with keyId that is automatically generated
    /// and keyProviderId that is the default kms cluster. During the migration,
    /// the object will be encrypted.
    /// If unset and if *VslmMigrateSpec.profile* is a default policy and if source
    /// VStorageObject is unenrypted, then disksCrypto is treated as
    /// CryptoSpecNoOp. During migration, no cryptographic change.
    /// If unset and if *VslmMigrateSpec.profile* contains an encryption iofilter and if
    /// source VStorageObject is encrypted, then disksCyrpto is treated as
    /// CryptoSpecNoOp. During migration, no cryptographic change.
    /// If unset and if *VslmMigrateSpec.profile* is a default policy and if
    /// source VStorageObject is encrypted, then disksCyrpto is treated as
    /// CryptoSpecDecrypt, during migration, the object will be decrypted.
    /// To recrypt the disk during migration, disksCrypto has to be present.
    fn get_disks_crypto(&self) -> &Option<DiskCryptoSpec>;
}
impl<'s> serde::Serialize for dyn VslmMigrateSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VslmMigrateSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VslmMigrateSpecVisitor)
            }
        }

struct VslmMigrateSpecVisitor;

impl<'de> de::Visitor<'de> for VslmMigrateSpecVisitor {
    type Value = Box<dyn VslmMigrateSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VslmMigrateSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VslmMigrateSpecTrait for VslmMigrateSpec {
    fn get_backing_spec(&self) -> &Box<dyn super::traits::VslmCreateSpecBackingSpecTrait> { &self.backing_spec }
    fn get_profile(&self) -> &Option<Vec<Box<dyn super::traits::VirtualMachineProfileSpecTrait>>> { &self.profile }
    fn get_consolidate(&self) -> Option<bool> { self.consolidate }
    fn get_disks_crypto(&self) -> &Option<DiskCryptoSpec> { &self.disks_crypto }
}
impl VslmMigrateSpecTrait for VslmCloneSpec {
    fn get_backing_spec(&self) -> &Box<dyn super::traits::VslmCreateSpecBackingSpecTrait> { &self.backing_spec }
    fn get_profile(&self) -> &Option<Vec<Box<dyn super::traits::VirtualMachineProfileSpecTrait>>> { &self.profile }
    fn get_consolidate(&self) -> Option<bool> { self.consolidate }
    fn get_disks_crypto(&self) -> &Option<DiskCryptoSpec> { &self.disks_crypto }
}
impl VslmMigrateSpecTrait for VslmRelocateSpec {
    fn get_backing_spec(&self) -> &Box<dyn super::traits::VslmCreateSpecBackingSpecTrait> { &self.backing_spec }
    fn get_profile(&self) -> &Option<Vec<Box<dyn super::traits::VirtualMachineProfileSpecTrait>>> { &self.profile }
    fn get_consolidate(&self) -> Option<bool> { self.consolidate }
    fn get_disks_crypto(&self) -> &Option<DiskCryptoSpec> { &self.disks_crypto }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VslmMigrateSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VslmMigrateSpec => Some(from.as_any_ref().downcast_ref::<VslmMigrateSpec>()?),
            StructType::VslmCloneSpec => Some(from.as_any_ref().downcast_ref::<VslmCloneSpec>()?),
            StructType::VslmRelocateSpec => Some(from.as_any_ref().downcast_ref::<VslmRelocateSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VslmMigrateSpec => Ok(from.as_any_box().downcast::<VslmMigrateSpec>()?),
            StructType::VslmCloneSpec => Ok(from.as_any_box().downcast::<VslmCloneSpec>()?),
            StructType::VslmRelocateSpec => Ok(from.as_any_box().downcast::<VslmRelocateSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The *SelectionSpec* is the base type for data
/// object types that specify what additional objects to filter.
/// 
/// The base
/// type contains only an optional "name" field, which allows a selection to
/// be named for future reference. More information is available in the
/// subtype.
/// 
/// Named selections support recursive specifications on an object
/// hierarchy. When used by a derived object, the "name" field allows other
/// *SelectionSpec* objects to refer to the object by
/// name. When used as the base type only, the "name" field indicates
/// recursion to the derived object by name.
/// 
/// Names are meaningful only within the same FilterSpec.
pub trait SelectionSpecTrait : super::traits::DataObjectTrait {
    /// Name of the selection specification.
    fn get_name(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn SelectionSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn SelectionSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(SelectionSpecVisitor)
            }
        }

struct SelectionSpecVisitor;

impl<'de> de::Visitor<'de> for SelectionSpecVisitor {
    type Value = Box<dyn SelectionSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid SelectionSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl SelectionSpecTrait for SelectionSpec {
    fn get_name(&self) -> &Option<String> { &self.name }
}
impl SelectionSpecTrait for TraversalSpec {
    fn get_name(&self) -> &Option<String> { &self.name }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn SelectionSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::SelectionSpec => Some(from.as_any_ref().downcast_ref::<SelectionSpec>()?),
            StructType::TraversalSpec => Some(from.as_any_ref().downcast_ref::<TraversalSpec>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::SelectionSpec => Ok(from.as_any_box().downcast::<SelectionSpec>()?),
            StructType::TraversalSpec => Ok(from.as_any_box().downcast::<TraversalSpec>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The base data object type for all the object model faults
/// that an application might handle.
pub trait MethodFaultTrait : super::traits::VimObjectTrait {
    /// Fault which is the cause of this fault.
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>>;
    /// Message which has details about the error
    /// Message can also contain a key to message catalog which
    /// can be used to generate better localized messages.
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>>;
}
impl<'s> serde::Serialize for dyn MethodFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn MethodFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(MethodFaultVisitor)
            }
        }

struct MethodFaultVisitor;

impl<'de> de::Visitor<'de> for MethodFaultVisitor {
    type Value = Box<dyn MethodFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid MethodFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl MethodFaultTrait for MethodFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VimFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ActiveDirectoryFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DomainNotFound {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidCamServer {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CamServerRefusedConnection {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidCamCertificate {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NoPermissionOnAd {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NonAdUserRequired {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for AlreadyExists {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for AlreadyUpgraded {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for AnswerFileUpdateFailed {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for AuthMinimumAdminPermission {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CannotAccessLocalSource {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CannotDisconnectHostWithFaultToleranceVm {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CannotEnableVmcpForCluster {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CannotMoveFaultToleranceVm {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CannotMoveHostWithFaultToleranceVm {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CannotPlaceWithoutPrerequisiteMoves {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ConcurrentAccess {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CustomizationFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CannotDecryptPasswords {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CustomizationPending {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for IpHostnameGeneratorError {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for LinuxVolumeNotClean {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for MissingLinuxCustResources {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for MissingWindowsCustResources {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for MountError {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NicSettingMismatch {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NoDisksToCustomize {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for UncustomizableGuest {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for UnexpectedCustomizationFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VolumeEditorError {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DasConfigFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DrsDisabledOnVm {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DuplicateName {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DvsFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for BackupBlobReadFailure {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for BackupBlobWriteFailure {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CollectorAddressUnset {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ConflictingConfiguration {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DvsApplyOperationFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DvsNotAuthorized {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DvsOperationBulkFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DvsScopeViolated {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ImportHostAddFailure {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ImportOperationBulkFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidIpfixConfig {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for RollbackFailure {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for SwitchIpUnset {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for SwitchNotInUpgradeMode {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VspanDestPortConflict {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VspanPortConflict {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VspanPortMoveFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VspanPortPromiscChangeFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VspanPortgroupPromiscChangeFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VspanPortgroupTypeChangeFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VspanPromiscuousPortNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VspanSameSessionPortConflict {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for EvcConfigFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ActiveVMsBlockingEvc {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DisconnectedHostsBlockingEvc {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for EvcModeIllegalByVendor {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for EvcModeUnsupportedByHosts {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for EvcUnsupportedByHostHardware {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for EvcUnsupportedByHostSoftware {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for HeterogenousHostsBlockingEvc {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ExtendedFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for FaultToleranceVmNotDasProtected {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for FcoeFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for FcoeFaultPnicHasNoPortSet {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for FileFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CannotAccessFile {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CannotCreateFile {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CannotDeleteFile {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DirectoryNotEmpty {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for FileAlreadyExists {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for FileLocked {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for FileNameTooLong {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for FileNotFound {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for FileNotWritable {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for FileTooLarge {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for IncorrectFileType {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NetworkCopyFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NoDiskSpace {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NotADirectory {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NotAFile {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for TooManyConcurrentNativeClones {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for TooManyNativeCloneLevels {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for TooManyNativeClonesOnFile {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for GenericDrsFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for GuestOperationsFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for GuestAuthenticationChallenge {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for GuestComponentsOutOfDate {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for GuestMultipleMappings {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for GuestOperationsUnavailable {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for GuestPermissionDenied {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for GuestProcessNotFound {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for GuestRegistryFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for GuestRegistryKeyFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for GuestRegistryKeyAlreadyExists {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for GuestRegistryKeyHasSubkeys {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for GuestRegistryKeyInvalid {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for GuestRegistryKeyParentVolatile {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for GuestRegistryValueFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for GuestRegistryValueNotFound {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidGuestLogin {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OperationDisabledByGuest {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OperationNotSupportedByGuest {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for TooManyGuestLogons {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for HostConfigFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for AdminDisabled {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for AdminNotDisabled {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for BlockedByFirewall {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ClockSkew {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DisableAdminNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for HostConfigFailed {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for HostInDomain {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidHostName {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NasConfigFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidNasCredentials {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidNetworkResource {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NasConnectionLimitReached {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NasSessionCredentialConflict {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NasVolumeNotMounted {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NetworkInaccessible {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NoPermissionOnNasVolume {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NoGateway {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NoVirtualNic {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for PlatformConfigFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidBundle {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for PatchInstallFailed {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for PatchIntegrityError {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VmfsMountFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VmfsAlreadyMounted {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VmfsAmbiguousMount {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for HostConnectFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for AgentInstallFailed {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for AlreadyBeingManaged {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for AlreadyConnected {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CannotAddHostWithFtVmAsStandalone {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CannotAddHostWithFtVmToDifferentCluster {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CannotAddHostWithFtVmToNonHaCluster {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for GatewayConnectFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for GatewayNotFound {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for GatewayNotReachable {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for GatewayOperationRefused {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for GatewayToHostConnectFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for GatewayHostNotReachable {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for GatewayToHostAuthFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for GatewayToHostTrustVerifyFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for MultipleCertificatesVerifyFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NoHost {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NoPermissionOnHost {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NotSupportedHost {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NonVmwareOuiMacNotSupportedHost {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NotSupportedHostForVFlash {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NotSupportedHostForVmcp {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NotSupportedHostForVmemFile {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NotSupportedHostForVsan {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NotSupportedHostInCluster {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for EvcAdmissionFailed {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for EvcAdmissionFailedCpuFeaturesForMode {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for EvcAdmissionFailedCpuModel {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for EvcAdmissionFailedCpuModelForMode {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for EvcAdmissionFailedCpuVendor {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for EvcAdmissionFailedCpuVendorUnknown {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for EvcAdmissionFailedHostDisconnected {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for EvcAdmissionFailedHostSoftware {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for EvcAdmissionFailedHostSoftwareForMode {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for EvcAdmissionFailedVmActive {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NotSupportedHostInDvs {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NotSupportedHostInHaCluster {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ReadHostResourcePoolTreeFailed {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for SslDisabledFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for SslVerifyFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for TooManyHosts {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for HostHasComponentFailure {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for HostIncompatibleForRecordReplay {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for HostPowerOpFailed {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NoPeerHostFound {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VmotionInterfaceNotEnabled {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for WakeOnLanNotSupportedByVmotionNic {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for HostSpecificationOperationFailed {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for HttpFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for IormNotSupportedHostOnDatastore {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InaccessibleVFlashSource {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InsufficientResourcesFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InsufficientAgentVmsDeployed {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InsufficientCpuResourcesFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InsufficientFailoverResourcesFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InsufficientGraphicsResourcesFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InsufficientHostCapacityFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InsufficientHostCpuCapacityFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InsufficientHostMemoryCapacityFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InsufficientPerCpuCapacity {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InsufficientMemoryResourcesFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InsufficientNetworkCapacity {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InsufficientNetworkResourcePoolCapacity {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InsufficientStandbyResource {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InsufficientStandbyCpuResource {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InsufficientStandbyMemoryResource {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InsufficientStorageSpace {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InsufficientVFlashResourcesFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidResourcePoolStructureFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NumVirtualCpusExceedsLimit {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VmFaultToleranceTooManyFtVcpusOnHost {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VmFaultToleranceTooManyVMsOnHost {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VmSmpFaultToleranceTooManyVMsOnHost {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InsufficientStorageIops {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidAffinitySettingFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidBmcRole {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidDatastore {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DatastoreNotWritableOnHost {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for SwapDatastoreNotWritableOnHost {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InaccessibleDatastore {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InaccessibleFtMetadataDatastore {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidDatastorePath {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidEvent {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidFolder {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VmAlreadyExistsInDatacenter {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidIpmiLoginInfo {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidIpmiMacAddress {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidLicense {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidLocale {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidLogin {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidClientCertificate {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for PasswordExpired {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidName {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidPrivilege {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidState {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CannotPowerOffVmInCluster {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for EncryptionKeyRequired {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidDatastoreState {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidHostState {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidHostConnectionState {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidPowerState {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidVmState {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for MksConnectionLimitReached {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NoActiveHostInCluster {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfConsumerPowerOnFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for QuestionPending {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VmPowerOnDisabled {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for IscsiFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for IscsiFaultInvalidVnic {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for IscsiFaultPnicInUse {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for IscsiFaultVnicAlreadyBound {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for IscsiFaultVnicHasActivePaths {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for IscsiFaultVnicHasMultipleUplinks {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for IscsiFaultVnicHasNoUplinks {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for IscsiFaultVnicHasWrongUplink {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for IscsiFaultVnicInUse {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for IscsiFaultVnicIsLastPath {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for IscsiFaultVnicNotBound {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for IscsiFaultVnicNotFound {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for KeyNotFound {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for LicenseEntityNotFound {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for LicenseServerUnavailable {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for LimitExceeded {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for LogBundlingFailed {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for MigrationFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for AffinityConfigured {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CannotModifyConfigCpuRequirements {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CannotMoveVmWithDeltaDisk {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CannotMoveVmWithNativeDeltaDisk {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CloneFromSnapshotNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DatacenterMismatch {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DisallowedMigrationDeviceAttached {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DiskMoveTypeNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for FaultToleranceAntiAffinityViolated {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for FaultToleranceNeedsThickDisk {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for FaultToleranceNotSameBuild {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for HaErrorsAtDest {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for IncompatibleDefaultDevice {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for LargeRdmConversionNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for MaintenanceModeFileMove {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for MigrationDisabled {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for MigrationFeatureNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for FullStorageVMotionNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for IndependentDiskVMotionNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NonHomeRdmvMotionNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for StorageVMotionNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for UnsharedSwapVMotionNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VMotionAcrossNetworkNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for MigrationNotReady {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for MismatchedNetworkPolicies {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for MismatchedVMotionNetworkNames {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NetworksMayNotBeTheSame {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NoGuestHeartbeat {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for RdmConversionNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for RdmNotPreserved {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ReadOnlyDisksWithLegacyDestination {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for SnapshotCopyNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for HotSnapshotMoveNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for SnapshotCloneNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for SnapshotMoveFromNonHomeNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for SnapshotMoveNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for SnapshotMoveToNonHomeNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for SnapshotRevertIssue {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for SuspendedRelocateNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for TooManyDisksOnLegacyHost {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ToolsInstallationInProgress {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for UncommittedUndoableDisk {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VMotionInterfaceIssue {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VMotionLinkCapacityLow {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VMotionLinkDown {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VMotionNotConfigured {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VMotionNotLicensed {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VMotionNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VMotionProtocolIncompatible {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for WillLoseHaProtection {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for WillModifyConfigCpuRequirements {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for WillResetSnapshotDirectory {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for MismatchedBundle {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for MissingBmcSupport {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NamespaceFull {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NamespaceLimitReached {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NamespaceWriteProtected {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NetworkDisruptedAndConfigRolledBack {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NoClientCertificate {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NoCompatibleDatastore {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NoCompatibleHost {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NoCompatibleHostWithAccessToDevice {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NoConnectedDatastore {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NoDiskFound {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NoSubjectName {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NotFound {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NotSupportedHostForChecksum {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OutOfBounds {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfConsumerCallbackFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfConsumerCommunicationError {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfConsumerFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfConsumerInvalidSection {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfConsumerUndeclaredSection {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfConsumerUndefinedPrefix {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfExport {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ConnectedIso {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfDuplicatedPropertyIdExport {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfDuplicatedPropertyIdImport {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfExportFailed {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfHardwareExport {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfConnectedDevice {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfConnectedDeviceFloppy {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfConnectedDeviceIso {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfUnableToExportDisk {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfUnknownDeviceBacking {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfUnsupportedDeviceExport {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfPropertyExport {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfPropertyNetworkExport {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfImport {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfCpuCompatibility {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfCpuCompatibilityCheckNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfHardwareCheck {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfImportFailed {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfMappedOsId {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfMissingHardware {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfNetworkMappingNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfUnsupportedDiskProvisioning {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfInvalidPackage {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfAttribute {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfInvalidValue {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfInvalidValueConfiguration {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfInvalidValueEmpty {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfInvalidValueFormatMalformed {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfInvalidValueReference {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfMissingAttribute {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfConstraint {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfDiskOrderConstraint {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfHostResourceConstraint {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfElement {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfDuplicateElement {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfDuplicatedElementBoundary {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfElementInvalidValue {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfMissingElement {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfMissingElementNormalBoundary {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfUnexpectedElement {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfWrongElement {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfProperty {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfPropertyNetwork {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfPropertyQualifier {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfPropertyQualifierDuplicate {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfPropertyQualifierIgnored {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfPropertyType {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfPropertyValue {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfWrongNamespace {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfXmlFormat {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfSystemFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfDiskMappingNotFound {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfHostValueNotParsed {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfInternalError {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfToXmlUnsupportedElement {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfUnknownDevice {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfUnknownEntity {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfUnsupportedDeviceBackingInfo {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfUnsupportedDeviceBackingOption {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfUnsupportedPackage {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfInvalidVmName {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfNoHostNic {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfNoSupportedHardwareFamily {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfUnsupportedAttribute {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfUnsupportedAttributeValue {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfUnsupportedElement {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfNoSpaceOnController {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfUnsupportedElementValue {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfUnsupportedSection {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfUnsupportedSubType {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfUnsupportedType {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for PatchBinariesNotFound {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for PatchMetadataInvalid {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for PatchMetadataCorrupted {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for PatchMetadataNotFound {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for PatchNotApplicable {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for PatchAlreadyInstalled {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for PatchMissingDependencies {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for PatchSuperseded {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ProfileUpdateFailed {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for RebootRequired {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for RecordReplayDisabled {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for RemoveFailed {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ReplicationFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for IncompatibleHostForVmReplication {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ReplicationConfigFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ReplicationDiskConfigFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ReplicationVmConfigFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ReplicationIncompatibleWithFt {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ReplicationInvalidOptions {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ReplicationNotSupportedOnHost {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ReplicationVmFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ReplicationVmInProgressFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ResourceInUse {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for FilterInUse {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for QuiesceDatastoreIoForHaFailed {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ResourceNotAvailable {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for SspiChallenge {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ShrinkDiskFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for SnapshotFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ApplicationQuiesceFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for FilesystemQuiesceFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for MemorySnapshotOnIndependentDisk {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for MultipleSnapshotsNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for SnapshotDisabled {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for SnapshotIncompatibleDeviceInVm {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for SnapshotLocked {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for SnapshotNoChange {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for TooManySnapshotLevels {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for SsdDiskNotAvailable {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for StorageDrsCannotMoveDiskInMultiWriterMode {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for StorageDrsCannotMoveFtVm {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for StorageDrsCannotMoveIndependentDisk {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for StorageDrsCannotMoveManuallyPlacedSwapFile {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for StorageDrsCannotMoveManuallyPlacedVm {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for StorageDrsCannotMoveSharedDisk {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for StorageDrsCannotMoveTemplate {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for StorageDrsCannotMoveVmInUserFolder {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for StorageDrsCannotMoveVmWithMountedCdrom {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for StorageDrsCannotMoveVmWithNoFilesInLayout {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for StorageDrsDatacentersCannotShareDatastore {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for StorageDrsDisabledOnVm {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for StorageDrsHbrDiskNotMovable {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for StorageDrsHmsMoveInProgress {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for StorageDrsHmsUnreachable {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for StorageDrsIolbDisabledInternally {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for StorageDrsRelocateDisabled {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for StorageDrsStaleHmsCollection {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for StorageDrsUnableToMoveFiles {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for SwapDatastoreUnset {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for TaskInProgress {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VAppTaskInProgress {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for Timedout {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for PowerOnFtSecondaryTimedout {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for TooManyConsecutiveOverrides {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ToolsUnavailable {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for UnrecognizedHost {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for UnsupportedVimApiVersion {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for UserNotFound {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VAppConfigFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for MissingPowerOffConfiguration {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for MissingPowerOnConfiguration {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NoVmInVApp {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VFlashModuleVersionIncompatible {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VmConfigFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CannotAccessVmComponent {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CannotAccessVmConfig {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CannotAccessVmDevice {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CannotAccessNetwork {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DestinationSwitchFull {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for LegacyNetworkInterfaceInUse {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VmOnConflictDvPort {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VmOnVirtualIntranet {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CannotAccessVmDisk {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for RdmPointsToInaccessibleDisk {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CannotDisableSnapshot {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CannotUseNetwork {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CpuHotPlugNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DeltaDiskFormatNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for EightHostLimitViolated {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for FaultToleranceCannotEditMem {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for GenericVmConfigFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidFormat {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidDiskFormat {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidSnapshotFormat {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidVmConfig {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidDeviceSpec {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DeviceHotPlugNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DeviceNotFound {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DeviceUnsupportedForVmPlatform {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DeviceUnsupportedForVmVersion {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DisallowedDiskModeChange {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidController {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidDeviceBacking {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidDeviceOperation {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for MissingController {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for SwapPlacementOverrideNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for TooManyDevices {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for UnsupportedGuest {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VmWwnConflict {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for LargeRdmNotSupportedOnDatastore {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for MemoryHotPlugNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NoCompatibleHardAffinityHost {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NoCompatibleSoftAffinityHost {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NumVirtualCpusIncompatible {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OvfConsumerValidationFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for QuarantineModeFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for RdmNotSupportedOnDatastore {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for RuleViolation {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for SoftRuleVioCorrectionDisallowed {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for SoftRuleVioCorrectionImpact {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for UnsupportedDatastore {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for MemoryFileFormatNotSupportedByDatastore {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for UnSupportedDatastoreForVFlash {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for UnsupportedVmxLocation {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VAppNotRunning {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VAppPropertyFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidNetworkInType {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidPropertyType {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidPropertyValue {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for UnconfiguredPropertyValue {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for MissingIpPool {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for MissingNetworkIpConfig {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NoAvailableIp {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NoVcManagedIpConfigured {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NotUserConfigurableProperty {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VFlashCacheHotConfigNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VFlashModuleNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VirtualHardwareCompatibilityIssue {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CpuIncompatible {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CpuCompatibilityUnknown {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CpuIncompatible1Ecx {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CpuIncompatible81Edx {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for FaultToleranceCpuIncompatible {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DeviceNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DeviceBackingNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DvPortNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for UnusedVirtualDiskBlocksNotScrubbed {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VirtualDiskBlocksNotFullyProvisioned {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DeviceControllerNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DigestNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for FileBackedPortNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for MultiWriterNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NonPersistentDisksNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for RdmNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for PhysCompatRdmNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for RawDiskNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for RemoteDeviceNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for SharedBusControllerNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VmiNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VirtualDiskModeNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VirtualEthernetCardNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DiskNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for IdeDiskNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DrsVmotionIncompatibleFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for FeatureRequirementsNotMet {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for MemorySizeNotRecommended {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for MemorySizeNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for MemorySizeNotSupportedByDatastore {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NotEnoughCpus {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NotEnoughLogicalCpus {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NumVirtualCoresPerSocketNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NumVirtualCpusNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for StorageVmotionIncompatible {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VirtualHardwareVersionNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for WakeOnLanNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VmConfigIncompatibleForFaultTolerance {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VmConfigIncompatibleForRecordReplay {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VmHostAffinityRuleViolation {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VmFaultToleranceIssue {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CannotChangeDrsBehaviorForFtSecondary {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CannotChangeHaSettingsForFtSecondary {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CannotComputeFtCompatibleHosts {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for FaultToleranceNotLicensed {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for FaultTolerancePrimaryPowerOnNotAttempted {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for FtIssuesOnHost {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for HostIncompatibleForFaultTolerance {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for IncompatibleHostForFtSecondary {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidOperationOnSecondaryVm {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NoHostSuitableForFtSecondary {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NotSupportedDeviceForFt {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for PowerOnFtSecondaryFailed {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for SecondaryVmAlreadyDisabled {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for SecondaryVmAlreadyEnabled {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for SecondaryVmAlreadyRegistered {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for SecondaryVmNotRegistered {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VmFaultToleranceConfigIssue {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VmFaultToleranceConfigIssueWrapper {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VmFaultToleranceInvalidFileBacking {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VmFaultToleranceOpIssuesList {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VmMetadataManagerFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VmMonitorIncompatibleForFaultTolerance {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VmToolsUpgradeFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ToolsAlreadyUpgraded {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ToolsAutoUpgradeNotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ToolsImageCopyFailed {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ToolsImageNotAvailable {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ToolsImageSignatureCheckFailed {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ToolsUpgradeCancelled {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VmValidateMaxDevice {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VsanFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CannotChangeVsanClusterUuid {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CannotChangeVsanNodeUuid {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CannotMoveVsanEnabledHost {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DestinationVsanDisabled {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VsanClusterUuidMismatch {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CannotReconfigureVsanWhenHaEnabled {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DuplicateVsanNetworkInterface {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VsanDiskFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DiskHasPartitions {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DiskIsLastRemainingNonSsd {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DiskIsNonLocal {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DiskIsUsb {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DiskTooSmall {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DuplicateDisks {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InsufficientDisks {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VsanIncompatibleDiskMapping {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for WipeDiskFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for RuntimeFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for CannotDisableDrsOnClustersWithVApps {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ConflictingDatastoreFound {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DatabaseError {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DisallowedChangeByService {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for DisallowedOperationOnFailoverHost {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for FailToLockFaultToleranceVMs {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidProfileReferenceHost {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidScheduledTask {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for LicenseAssignmentFailed {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for MethodAlreadyDisabledFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for MethodDisabled {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for OperationDisallowedOnHost {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for RestrictedByAdministrator {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ThirdPartyLicenseAssignmentFailed {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VAppOperationInProgress {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for HostCommunication {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for HostNotConnected {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for HostNotReachable {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidArgument {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for IncompatibleSetting {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidDasConfigArgument {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidDasRestartPriorityForFtVm {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidDrsBehaviorForFtVm {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidIndexArgument {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidRequest {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidType {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for MethodNotFound {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ManagedObjectNotFound {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NotEnoughLicenses {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ExpiredFeatureLicense {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ExpiredAddonLicense {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for ExpiredEditionLicense {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for FailToEnableSpbm {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for HostInventoryFull {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InUseFeatureManipulationDisallowed {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for IncorrectHostInformation {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidEditionLicense {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InventoryHasStandardAloneHosts {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for LicenseDowngradeDisallowed {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for LicenseExpired {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for LicenseKeyEntityMismatch {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for LicenseRestricted {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for LicenseSourceUnavailable {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NoLicenseServerConfigured {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VmLimitLicense {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for VramLimitLicense {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NotImplemented {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NotSupported {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for HostAccessRestrictedToManagementServer {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for RequestCanceled {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for SecurityError {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NoPermission {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for NotAuthenticated {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for RestrictedVersion {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for SolutionUserRequired {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for SystemError {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for UnexpectedFault {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidCollectorVersion {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl MethodFaultTrait for InvalidProperty {
    fn get_fault_cause(&self) -> &Option<Box<dyn super::traits::MethodFaultTrait>> { &self.fault_cause }
    fn get_fault_message(&self) -> &Option<Vec<LocalizableMessage>> { &self.fault_message }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn MethodFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::MethodFault => Some(from.as_any_ref().downcast_ref::<MethodFault>()?),
            StructType::VimFault => Some(from.as_any_ref().downcast_ref::<VimFault>()?),
            StructType::ActiveDirectoryFault => Some(from.as_any_ref().downcast_ref::<ActiveDirectoryFault>()?),
            StructType::DomainNotFound => Some(from.as_any_ref().downcast_ref::<DomainNotFound>()?),
            StructType::InvalidCamServer => Some(from.as_any_ref().downcast_ref::<InvalidCamServer>()?),
            StructType::CamServerRefusedConnection => Some(from.as_any_ref().downcast_ref::<CamServerRefusedConnection>()?),
            StructType::InvalidCamCertificate => Some(from.as_any_ref().downcast_ref::<InvalidCamCertificate>()?),
            StructType::NoPermissionOnAd => Some(from.as_any_ref().downcast_ref::<NoPermissionOnAd>()?),
            StructType::NonAdUserRequired => Some(from.as_any_ref().downcast_ref::<NonAdUserRequired>()?),
            StructType::AlreadyExists => Some(from.as_any_ref().downcast_ref::<AlreadyExists>()?),
            StructType::AlreadyUpgraded => Some(from.as_any_ref().downcast_ref::<AlreadyUpgraded>()?),
            StructType::AnswerFileUpdateFailed => Some(from.as_any_ref().downcast_ref::<AnswerFileUpdateFailed>()?),
            StructType::AuthMinimumAdminPermission => Some(from.as_any_ref().downcast_ref::<AuthMinimumAdminPermission>()?),
            StructType::CannotAccessLocalSource => Some(from.as_any_ref().downcast_ref::<CannotAccessLocalSource>()?),
            StructType::CannotDisconnectHostWithFaultToleranceVm => Some(from.as_any_ref().downcast_ref::<CannotDisconnectHostWithFaultToleranceVm>()?),
            StructType::CannotEnableVmcpForCluster => Some(from.as_any_ref().downcast_ref::<CannotEnableVmcpForCluster>()?),
            StructType::CannotMoveFaultToleranceVm => Some(from.as_any_ref().downcast_ref::<CannotMoveFaultToleranceVm>()?),
            StructType::CannotMoveHostWithFaultToleranceVm => Some(from.as_any_ref().downcast_ref::<CannotMoveHostWithFaultToleranceVm>()?),
            StructType::CannotPlaceWithoutPrerequisiteMoves => Some(from.as_any_ref().downcast_ref::<CannotPlaceWithoutPrerequisiteMoves>()?),
            StructType::ConcurrentAccess => Some(from.as_any_ref().downcast_ref::<ConcurrentAccess>()?),
            StructType::CustomizationFault => Some(from.as_any_ref().downcast_ref::<CustomizationFault>()?),
            StructType::CannotDecryptPasswords => Some(from.as_any_ref().downcast_ref::<CannotDecryptPasswords>()?),
            StructType::CustomizationPending => Some(from.as_any_ref().downcast_ref::<CustomizationPending>()?),
            StructType::IpHostnameGeneratorError => Some(from.as_any_ref().downcast_ref::<IpHostnameGeneratorError>()?),
            StructType::LinuxVolumeNotClean => Some(from.as_any_ref().downcast_ref::<LinuxVolumeNotClean>()?),
            StructType::MissingLinuxCustResources => Some(from.as_any_ref().downcast_ref::<MissingLinuxCustResources>()?),
            StructType::MissingWindowsCustResources => Some(from.as_any_ref().downcast_ref::<MissingWindowsCustResources>()?),
            StructType::MountError => Some(from.as_any_ref().downcast_ref::<MountError>()?),
            StructType::NicSettingMismatch => Some(from.as_any_ref().downcast_ref::<NicSettingMismatch>()?),
            StructType::NoDisksToCustomize => Some(from.as_any_ref().downcast_ref::<NoDisksToCustomize>()?),
            StructType::UncustomizableGuest => Some(from.as_any_ref().downcast_ref::<UncustomizableGuest>()?),
            StructType::UnexpectedCustomizationFault => Some(from.as_any_ref().downcast_ref::<UnexpectedCustomizationFault>()?),
            StructType::VolumeEditorError => Some(from.as_any_ref().downcast_ref::<VolumeEditorError>()?),
            StructType::DasConfigFault => Some(from.as_any_ref().downcast_ref::<DasConfigFault>()?),
            StructType::DrsDisabledOnVm => Some(from.as_any_ref().downcast_ref::<DrsDisabledOnVm>()?),
            StructType::DuplicateName => Some(from.as_any_ref().downcast_ref::<DuplicateName>()?),
            StructType::DvsFault => Some(from.as_any_ref().downcast_ref::<DvsFault>()?),
            StructType::BackupBlobReadFailure => Some(from.as_any_ref().downcast_ref::<BackupBlobReadFailure>()?),
            StructType::BackupBlobWriteFailure => Some(from.as_any_ref().downcast_ref::<BackupBlobWriteFailure>()?),
            StructType::CollectorAddressUnset => Some(from.as_any_ref().downcast_ref::<CollectorAddressUnset>()?),
            StructType::ConflictingConfiguration => Some(from.as_any_ref().downcast_ref::<ConflictingConfiguration>()?),
            StructType::DvsApplyOperationFault => Some(from.as_any_ref().downcast_ref::<DvsApplyOperationFault>()?),
            StructType::DvsNotAuthorized => Some(from.as_any_ref().downcast_ref::<DvsNotAuthorized>()?),
            StructType::DvsOperationBulkFault => Some(from.as_any_ref().downcast_ref::<DvsOperationBulkFault>()?),
            StructType::DvsScopeViolated => Some(from.as_any_ref().downcast_ref::<DvsScopeViolated>()?),
            StructType::ImportHostAddFailure => Some(from.as_any_ref().downcast_ref::<ImportHostAddFailure>()?),
            StructType::ImportOperationBulkFault => Some(from.as_any_ref().downcast_ref::<ImportOperationBulkFault>()?),
            StructType::InvalidIpfixConfig => Some(from.as_any_ref().downcast_ref::<InvalidIpfixConfig>()?),
            StructType::RollbackFailure => Some(from.as_any_ref().downcast_ref::<RollbackFailure>()?),
            StructType::SwitchIpUnset => Some(from.as_any_ref().downcast_ref::<SwitchIpUnset>()?),
            StructType::SwitchNotInUpgradeMode => Some(from.as_any_ref().downcast_ref::<SwitchNotInUpgradeMode>()?),
            StructType::VspanDestPortConflict => Some(from.as_any_ref().downcast_ref::<VspanDestPortConflict>()?),
            StructType::VspanPortConflict => Some(from.as_any_ref().downcast_ref::<VspanPortConflict>()?),
            StructType::VspanPortMoveFault => Some(from.as_any_ref().downcast_ref::<VspanPortMoveFault>()?),
            StructType::VspanPortPromiscChangeFault => Some(from.as_any_ref().downcast_ref::<VspanPortPromiscChangeFault>()?),
            StructType::VspanPortgroupPromiscChangeFault => Some(from.as_any_ref().downcast_ref::<VspanPortgroupPromiscChangeFault>()?),
            StructType::VspanPortgroupTypeChangeFault => Some(from.as_any_ref().downcast_ref::<VspanPortgroupTypeChangeFault>()?),
            StructType::VspanPromiscuousPortNotSupported => Some(from.as_any_ref().downcast_ref::<VspanPromiscuousPortNotSupported>()?),
            StructType::VspanSameSessionPortConflict => Some(from.as_any_ref().downcast_ref::<VspanSameSessionPortConflict>()?),
            StructType::EvcConfigFault => Some(from.as_any_ref().downcast_ref::<EvcConfigFault>()?),
            StructType::ActiveVMsBlockingEvc => Some(from.as_any_ref().downcast_ref::<ActiveVMsBlockingEvc>()?),
            StructType::DisconnectedHostsBlockingEvc => Some(from.as_any_ref().downcast_ref::<DisconnectedHostsBlockingEvc>()?),
            StructType::EvcModeIllegalByVendor => Some(from.as_any_ref().downcast_ref::<EvcModeIllegalByVendor>()?),
            StructType::EvcModeUnsupportedByHosts => Some(from.as_any_ref().downcast_ref::<EvcModeUnsupportedByHosts>()?),
            StructType::EvcUnsupportedByHostHardware => Some(from.as_any_ref().downcast_ref::<EvcUnsupportedByHostHardware>()?),
            StructType::EvcUnsupportedByHostSoftware => Some(from.as_any_ref().downcast_ref::<EvcUnsupportedByHostSoftware>()?),
            StructType::HeterogenousHostsBlockingEvc => Some(from.as_any_ref().downcast_ref::<HeterogenousHostsBlockingEvc>()?),
            StructType::ExtendedFault => Some(from.as_any_ref().downcast_ref::<ExtendedFault>()?),
            StructType::FaultToleranceVmNotDasProtected => Some(from.as_any_ref().downcast_ref::<FaultToleranceVmNotDasProtected>()?),
            StructType::FcoeFault => Some(from.as_any_ref().downcast_ref::<FcoeFault>()?),
            StructType::FcoeFaultPnicHasNoPortSet => Some(from.as_any_ref().downcast_ref::<FcoeFaultPnicHasNoPortSet>()?),
            StructType::FileFault => Some(from.as_any_ref().downcast_ref::<FileFault>()?),
            StructType::CannotAccessFile => Some(from.as_any_ref().downcast_ref::<CannotAccessFile>()?),
            StructType::CannotCreateFile => Some(from.as_any_ref().downcast_ref::<CannotCreateFile>()?),
            StructType::CannotDeleteFile => Some(from.as_any_ref().downcast_ref::<CannotDeleteFile>()?),
            StructType::DirectoryNotEmpty => Some(from.as_any_ref().downcast_ref::<DirectoryNotEmpty>()?),
            StructType::FileAlreadyExists => Some(from.as_any_ref().downcast_ref::<FileAlreadyExists>()?),
            StructType::FileLocked => Some(from.as_any_ref().downcast_ref::<FileLocked>()?),
            StructType::FileNameTooLong => Some(from.as_any_ref().downcast_ref::<FileNameTooLong>()?),
            StructType::FileNotFound => Some(from.as_any_ref().downcast_ref::<FileNotFound>()?),
            StructType::FileNotWritable => Some(from.as_any_ref().downcast_ref::<FileNotWritable>()?),
            StructType::FileTooLarge => Some(from.as_any_ref().downcast_ref::<FileTooLarge>()?),
            StructType::IncorrectFileType => Some(from.as_any_ref().downcast_ref::<IncorrectFileType>()?),
            StructType::NetworkCopyFault => Some(from.as_any_ref().downcast_ref::<NetworkCopyFault>()?),
            StructType::NoDiskSpace => Some(from.as_any_ref().downcast_ref::<NoDiskSpace>()?),
            StructType::NotADirectory => Some(from.as_any_ref().downcast_ref::<NotADirectory>()?),
            StructType::NotAFile => Some(from.as_any_ref().downcast_ref::<NotAFile>()?),
            StructType::TooManyConcurrentNativeClones => Some(from.as_any_ref().downcast_ref::<TooManyConcurrentNativeClones>()?),
            StructType::TooManyNativeCloneLevels => Some(from.as_any_ref().downcast_ref::<TooManyNativeCloneLevels>()?),
            StructType::TooManyNativeClonesOnFile => Some(from.as_any_ref().downcast_ref::<TooManyNativeClonesOnFile>()?),
            StructType::GenericDrsFault => Some(from.as_any_ref().downcast_ref::<GenericDrsFault>()?),
            StructType::GuestOperationsFault => Some(from.as_any_ref().downcast_ref::<GuestOperationsFault>()?),
            StructType::GuestAuthenticationChallenge => Some(from.as_any_ref().downcast_ref::<GuestAuthenticationChallenge>()?),
            StructType::GuestComponentsOutOfDate => Some(from.as_any_ref().downcast_ref::<GuestComponentsOutOfDate>()?),
            StructType::GuestMultipleMappings => Some(from.as_any_ref().downcast_ref::<GuestMultipleMappings>()?),
            StructType::GuestOperationsUnavailable => Some(from.as_any_ref().downcast_ref::<GuestOperationsUnavailable>()?),
            StructType::GuestPermissionDenied => Some(from.as_any_ref().downcast_ref::<GuestPermissionDenied>()?),
            StructType::GuestProcessNotFound => Some(from.as_any_ref().downcast_ref::<GuestProcessNotFound>()?),
            StructType::GuestRegistryFault => Some(from.as_any_ref().downcast_ref::<GuestRegistryFault>()?),
            StructType::GuestRegistryKeyFault => Some(from.as_any_ref().downcast_ref::<GuestRegistryKeyFault>()?),
            StructType::GuestRegistryKeyAlreadyExists => Some(from.as_any_ref().downcast_ref::<GuestRegistryKeyAlreadyExists>()?),
            StructType::GuestRegistryKeyHasSubkeys => Some(from.as_any_ref().downcast_ref::<GuestRegistryKeyHasSubkeys>()?),
            StructType::GuestRegistryKeyInvalid => Some(from.as_any_ref().downcast_ref::<GuestRegistryKeyInvalid>()?),
            StructType::GuestRegistryKeyParentVolatile => Some(from.as_any_ref().downcast_ref::<GuestRegistryKeyParentVolatile>()?),
            StructType::GuestRegistryValueFault => Some(from.as_any_ref().downcast_ref::<GuestRegistryValueFault>()?),
            StructType::GuestRegistryValueNotFound => Some(from.as_any_ref().downcast_ref::<GuestRegistryValueNotFound>()?),
            StructType::InvalidGuestLogin => Some(from.as_any_ref().downcast_ref::<InvalidGuestLogin>()?),
            StructType::OperationDisabledByGuest => Some(from.as_any_ref().downcast_ref::<OperationDisabledByGuest>()?),
            StructType::OperationNotSupportedByGuest => Some(from.as_any_ref().downcast_ref::<OperationNotSupportedByGuest>()?),
            StructType::TooManyGuestLogons => Some(from.as_any_ref().downcast_ref::<TooManyGuestLogons>()?),
            StructType::HostConfigFault => Some(from.as_any_ref().downcast_ref::<HostConfigFault>()?),
            StructType::AdminDisabled => Some(from.as_any_ref().downcast_ref::<AdminDisabled>()?),
            StructType::AdminNotDisabled => Some(from.as_any_ref().downcast_ref::<AdminNotDisabled>()?),
            StructType::BlockedByFirewall => Some(from.as_any_ref().downcast_ref::<BlockedByFirewall>()?),
            StructType::ClockSkew => Some(from.as_any_ref().downcast_ref::<ClockSkew>()?),
            StructType::DisableAdminNotSupported => Some(from.as_any_ref().downcast_ref::<DisableAdminNotSupported>()?),
            StructType::HostConfigFailed => Some(from.as_any_ref().downcast_ref::<HostConfigFailed>()?),
            StructType::HostInDomain => Some(from.as_any_ref().downcast_ref::<HostInDomain>()?),
            StructType::InvalidHostName => Some(from.as_any_ref().downcast_ref::<InvalidHostName>()?),
            StructType::NasConfigFault => Some(from.as_any_ref().downcast_ref::<NasConfigFault>()?),
            StructType::InvalidNasCredentials => Some(from.as_any_ref().downcast_ref::<InvalidNasCredentials>()?),
            StructType::InvalidNetworkResource => Some(from.as_any_ref().downcast_ref::<InvalidNetworkResource>()?),
            StructType::NasConnectionLimitReached => Some(from.as_any_ref().downcast_ref::<NasConnectionLimitReached>()?),
            StructType::NasSessionCredentialConflict => Some(from.as_any_ref().downcast_ref::<NasSessionCredentialConflict>()?),
            StructType::NasVolumeNotMounted => Some(from.as_any_ref().downcast_ref::<NasVolumeNotMounted>()?),
            StructType::NetworkInaccessible => Some(from.as_any_ref().downcast_ref::<NetworkInaccessible>()?),
            StructType::NoPermissionOnNasVolume => Some(from.as_any_ref().downcast_ref::<NoPermissionOnNasVolume>()?),
            StructType::NoGateway => Some(from.as_any_ref().downcast_ref::<NoGateway>()?),
            StructType::NoVirtualNic => Some(from.as_any_ref().downcast_ref::<NoVirtualNic>()?),
            StructType::PlatformConfigFault => Some(from.as_any_ref().downcast_ref::<PlatformConfigFault>()?),
            StructType::InvalidBundle => Some(from.as_any_ref().downcast_ref::<InvalidBundle>()?),
            StructType::PatchInstallFailed => Some(from.as_any_ref().downcast_ref::<PatchInstallFailed>()?),
            StructType::PatchIntegrityError => Some(from.as_any_ref().downcast_ref::<PatchIntegrityError>()?),
            StructType::VmfsMountFault => Some(from.as_any_ref().downcast_ref::<VmfsMountFault>()?),
            StructType::VmfsAlreadyMounted => Some(from.as_any_ref().downcast_ref::<VmfsAlreadyMounted>()?),
            StructType::VmfsAmbiguousMount => Some(from.as_any_ref().downcast_ref::<VmfsAmbiguousMount>()?),
            StructType::HostConnectFault => Some(from.as_any_ref().downcast_ref::<HostConnectFault>()?),
            StructType::AgentInstallFailed => Some(from.as_any_ref().downcast_ref::<AgentInstallFailed>()?),
            StructType::AlreadyBeingManaged => Some(from.as_any_ref().downcast_ref::<AlreadyBeingManaged>()?),
            StructType::AlreadyConnected => Some(from.as_any_ref().downcast_ref::<AlreadyConnected>()?),
            StructType::CannotAddHostWithFtVmAsStandalone => Some(from.as_any_ref().downcast_ref::<CannotAddHostWithFtVmAsStandalone>()?),
            StructType::CannotAddHostWithFtVmToDifferentCluster => Some(from.as_any_ref().downcast_ref::<CannotAddHostWithFtVmToDifferentCluster>()?),
            StructType::CannotAddHostWithFtVmToNonHaCluster => Some(from.as_any_ref().downcast_ref::<CannotAddHostWithFtVmToNonHaCluster>()?),
            StructType::GatewayConnectFault => Some(from.as_any_ref().downcast_ref::<GatewayConnectFault>()?),
            StructType::GatewayNotFound => Some(from.as_any_ref().downcast_ref::<GatewayNotFound>()?),
            StructType::GatewayNotReachable => Some(from.as_any_ref().downcast_ref::<GatewayNotReachable>()?),
            StructType::GatewayOperationRefused => Some(from.as_any_ref().downcast_ref::<GatewayOperationRefused>()?),
            StructType::GatewayToHostConnectFault => Some(from.as_any_ref().downcast_ref::<GatewayToHostConnectFault>()?),
            StructType::GatewayHostNotReachable => Some(from.as_any_ref().downcast_ref::<GatewayHostNotReachable>()?),
            StructType::GatewayToHostAuthFault => Some(from.as_any_ref().downcast_ref::<GatewayToHostAuthFault>()?),
            StructType::GatewayToHostTrustVerifyFault => Some(from.as_any_ref().downcast_ref::<GatewayToHostTrustVerifyFault>()?),
            StructType::MultipleCertificatesVerifyFault => Some(from.as_any_ref().downcast_ref::<MultipleCertificatesVerifyFault>()?),
            StructType::NoHost => Some(from.as_any_ref().downcast_ref::<NoHost>()?),
            StructType::NoPermissionOnHost => Some(from.as_any_ref().downcast_ref::<NoPermissionOnHost>()?),
            StructType::NotSupportedHost => Some(from.as_any_ref().downcast_ref::<NotSupportedHost>()?),
            StructType::NonVmwareOuiMacNotSupportedHost => Some(from.as_any_ref().downcast_ref::<NonVmwareOuiMacNotSupportedHost>()?),
            StructType::NotSupportedHostForVFlash => Some(from.as_any_ref().downcast_ref::<NotSupportedHostForVFlash>()?),
            StructType::NotSupportedHostForVmcp => Some(from.as_any_ref().downcast_ref::<NotSupportedHostForVmcp>()?),
            StructType::NotSupportedHostForVmemFile => Some(from.as_any_ref().downcast_ref::<NotSupportedHostForVmemFile>()?),
            StructType::NotSupportedHostForVsan => Some(from.as_any_ref().downcast_ref::<NotSupportedHostForVsan>()?),
            StructType::NotSupportedHostInCluster => Some(from.as_any_ref().downcast_ref::<NotSupportedHostInCluster>()?),
            StructType::EvcAdmissionFailed => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailed>()?),
            StructType::EvcAdmissionFailedCpuFeaturesForMode => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedCpuFeaturesForMode>()?),
            StructType::EvcAdmissionFailedCpuModel => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedCpuModel>()?),
            StructType::EvcAdmissionFailedCpuModelForMode => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedCpuModelForMode>()?),
            StructType::EvcAdmissionFailedCpuVendor => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedCpuVendor>()?),
            StructType::EvcAdmissionFailedCpuVendorUnknown => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedCpuVendorUnknown>()?),
            StructType::EvcAdmissionFailedHostDisconnected => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedHostDisconnected>()?),
            StructType::EvcAdmissionFailedHostSoftware => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedHostSoftware>()?),
            StructType::EvcAdmissionFailedHostSoftwareForMode => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedHostSoftwareForMode>()?),
            StructType::EvcAdmissionFailedVmActive => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedVmActive>()?),
            StructType::NotSupportedHostInDvs => Some(from.as_any_ref().downcast_ref::<NotSupportedHostInDvs>()?),
            StructType::NotSupportedHostInHaCluster => Some(from.as_any_ref().downcast_ref::<NotSupportedHostInHaCluster>()?),
            StructType::ReadHostResourcePoolTreeFailed => Some(from.as_any_ref().downcast_ref::<ReadHostResourcePoolTreeFailed>()?),
            StructType::SslDisabledFault => Some(from.as_any_ref().downcast_ref::<SslDisabledFault>()?),
            StructType::SslVerifyFault => Some(from.as_any_ref().downcast_ref::<SslVerifyFault>()?),
            StructType::TooManyHosts => Some(from.as_any_ref().downcast_ref::<TooManyHosts>()?),
            StructType::HostHasComponentFailure => Some(from.as_any_ref().downcast_ref::<HostHasComponentFailure>()?),
            StructType::HostIncompatibleForRecordReplay => Some(from.as_any_ref().downcast_ref::<HostIncompatibleForRecordReplay>()?),
            StructType::HostPowerOpFailed => Some(from.as_any_ref().downcast_ref::<HostPowerOpFailed>()?),
            StructType::NoPeerHostFound => Some(from.as_any_ref().downcast_ref::<NoPeerHostFound>()?),
            StructType::VmotionInterfaceNotEnabled => Some(from.as_any_ref().downcast_ref::<VmotionInterfaceNotEnabled>()?),
            StructType::WakeOnLanNotSupportedByVmotionNic => Some(from.as_any_ref().downcast_ref::<WakeOnLanNotSupportedByVmotionNic>()?),
            StructType::HostSpecificationOperationFailed => Some(from.as_any_ref().downcast_ref::<HostSpecificationOperationFailed>()?),
            StructType::HttpFault => Some(from.as_any_ref().downcast_ref::<HttpFault>()?),
            StructType::IormNotSupportedHostOnDatastore => Some(from.as_any_ref().downcast_ref::<IormNotSupportedHostOnDatastore>()?),
            StructType::InaccessibleVFlashSource => Some(from.as_any_ref().downcast_ref::<InaccessibleVFlashSource>()?),
            StructType::InsufficientResourcesFault => Some(from.as_any_ref().downcast_ref::<InsufficientResourcesFault>()?),
            StructType::InsufficientAgentVmsDeployed => Some(from.as_any_ref().downcast_ref::<InsufficientAgentVmsDeployed>()?),
            StructType::InsufficientCpuResourcesFault => Some(from.as_any_ref().downcast_ref::<InsufficientCpuResourcesFault>()?),
            StructType::InsufficientFailoverResourcesFault => Some(from.as_any_ref().downcast_ref::<InsufficientFailoverResourcesFault>()?),
            StructType::InsufficientGraphicsResourcesFault => Some(from.as_any_ref().downcast_ref::<InsufficientGraphicsResourcesFault>()?),
            StructType::InsufficientHostCapacityFault => Some(from.as_any_ref().downcast_ref::<InsufficientHostCapacityFault>()?),
            StructType::InsufficientHostCpuCapacityFault => Some(from.as_any_ref().downcast_ref::<InsufficientHostCpuCapacityFault>()?),
            StructType::InsufficientHostMemoryCapacityFault => Some(from.as_any_ref().downcast_ref::<InsufficientHostMemoryCapacityFault>()?),
            StructType::InsufficientPerCpuCapacity => Some(from.as_any_ref().downcast_ref::<InsufficientPerCpuCapacity>()?),
            StructType::InsufficientMemoryResourcesFault => Some(from.as_any_ref().downcast_ref::<InsufficientMemoryResourcesFault>()?),
            StructType::InsufficientNetworkCapacity => Some(from.as_any_ref().downcast_ref::<InsufficientNetworkCapacity>()?),
            StructType::InsufficientNetworkResourcePoolCapacity => Some(from.as_any_ref().downcast_ref::<InsufficientNetworkResourcePoolCapacity>()?),
            StructType::InsufficientStandbyResource => Some(from.as_any_ref().downcast_ref::<InsufficientStandbyResource>()?),
            StructType::InsufficientStandbyCpuResource => Some(from.as_any_ref().downcast_ref::<InsufficientStandbyCpuResource>()?),
            StructType::InsufficientStandbyMemoryResource => Some(from.as_any_ref().downcast_ref::<InsufficientStandbyMemoryResource>()?),
            StructType::InsufficientStorageSpace => Some(from.as_any_ref().downcast_ref::<InsufficientStorageSpace>()?),
            StructType::InsufficientVFlashResourcesFault => Some(from.as_any_ref().downcast_ref::<InsufficientVFlashResourcesFault>()?),
            StructType::InvalidResourcePoolStructureFault => Some(from.as_any_ref().downcast_ref::<InvalidResourcePoolStructureFault>()?),
            StructType::NumVirtualCpusExceedsLimit => Some(from.as_any_ref().downcast_ref::<NumVirtualCpusExceedsLimit>()?),
            StructType::VmFaultToleranceTooManyFtVcpusOnHost => Some(from.as_any_ref().downcast_ref::<VmFaultToleranceTooManyFtVcpusOnHost>()?),
            StructType::VmFaultToleranceTooManyVMsOnHost => Some(from.as_any_ref().downcast_ref::<VmFaultToleranceTooManyVMsOnHost>()?),
            StructType::VmSmpFaultToleranceTooManyVMsOnHost => Some(from.as_any_ref().downcast_ref::<VmSmpFaultToleranceTooManyVMsOnHost>()?),
            StructType::InsufficientStorageIops => Some(from.as_any_ref().downcast_ref::<InsufficientStorageIops>()?),
            StructType::InvalidAffinitySettingFault => Some(from.as_any_ref().downcast_ref::<InvalidAffinitySettingFault>()?),
            StructType::InvalidBmcRole => Some(from.as_any_ref().downcast_ref::<InvalidBmcRole>()?),
            StructType::InvalidDatastore => Some(from.as_any_ref().downcast_ref::<InvalidDatastore>()?),
            StructType::DatastoreNotWritableOnHost => Some(from.as_any_ref().downcast_ref::<DatastoreNotWritableOnHost>()?),
            StructType::SwapDatastoreNotWritableOnHost => Some(from.as_any_ref().downcast_ref::<SwapDatastoreNotWritableOnHost>()?),
            StructType::InaccessibleDatastore => Some(from.as_any_ref().downcast_ref::<InaccessibleDatastore>()?),
            StructType::InaccessibleFtMetadataDatastore => Some(from.as_any_ref().downcast_ref::<InaccessibleFtMetadataDatastore>()?),
            StructType::InvalidDatastorePath => Some(from.as_any_ref().downcast_ref::<InvalidDatastorePath>()?),
            StructType::InvalidEvent => Some(from.as_any_ref().downcast_ref::<InvalidEvent>()?),
            StructType::InvalidFolder => Some(from.as_any_ref().downcast_ref::<InvalidFolder>()?),
            StructType::VmAlreadyExistsInDatacenter => Some(from.as_any_ref().downcast_ref::<VmAlreadyExistsInDatacenter>()?),
            StructType::InvalidIpmiLoginInfo => Some(from.as_any_ref().downcast_ref::<InvalidIpmiLoginInfo>()?),
            StructType::InvalidIpmiMacAddress => Some(from.as_any_ref().downcast_ref::<InvalidIpmiMacAddress>()?),
            StructType::InvalidLicense => Some(from.as_any_ref().downcast_ref::<InvalidLicense>()?),
            StructType::InvalidLocale => Some(from.as_any_ref().downcast_ref::<InvalidLocale>()?),
            StructType::InvalidLogin => Some(from.as_any_ref().downcast_ref::<InvalidLogin>()?),
            StructType::InvalidClientCertificate => Some(from.as_any_ref().downcast_ref::<InvalidClientCertificate>()?),
            StructType::PasswordExpired => Some(from.as_any_ref().downcast_ref::<PasswordExpired>()?),
            StructType::InvalidName => Some(from.as_any_ref().downcast_ref::<InvalidName>()?),
            StructType::InvalidPrivilege => Some(from.as_any_ref().downcast_ref::<InvalidPrivilege>()?),
            StructType::InvalidState => Some(from.as_any_ref().downcast_ref::<InvalidState>()?),
            StructType::CannotPowerOffVmInCluster => Some(from.as_any_ref().downcast_ref::<CannotPowerOffVmInCluster>()?),
            StructType::EncryptionKeyRequired => Some(from.as_any_ref().downcast_ref::<EncryptionKeyRequired>()?),
            StructType::InvalidDatastoreState => Some(from.as_any_ref().downcast_ref::<InvalidDatastoreState>()?),
            StructType::InvalidHostState => Some(from.as_any_ref().downcast_ref::<InvalidHostState>()?),
            StructType::InvalidHostConnectionState => Some(from.as_any_ref().downcast_ref::<InvalidHostConnectionState>()?),
            StructType::InvalidPowerState => Some(from.as_any_ref().downcast_ref::<InvalidPowerState>()?),
            StructType::InvalidVmState => Some(from.as_any_ref().downcast_ref::<InvalidVmState>()?),
            StructType::MksConnectionLimitReached => Some(from.as_any_ref().downcast_ref::<MksConnectionLimitReached>()?),
            StructType::NoActiveHostInCluster => Some(from.as_any_ref().downcast_ref::<NoActiveHostInCluster>()?),
            StructType::OvfConsumerPowerOnFault => Some(from.as_any_ref().downcast_ref::<OvfConsumerPowerOnFault>()?),
            StructType::QuestionPending => Some(from.as_any_ref().downcast_ref::<QuestionPending>()?),
            StructType::VmPowerOnDisabled => Some(from.as_any_ref().downcast_ref::<VmPowerOnDisabled>()?),
            StructType::IscsiFault => Some(from.as_any_ref().downcast_ref::<IscsiFault>()?),
            StructType::IscsiFaultInvalidVnic => Some(from.as_any_ref().downcast_ref::<IscsiFaultInvalidVnic>()?),
            StructType::IscsiFaultPnicInUse => Some(from.as_any_ref().downcast_ref::<IscsiFaultPnicInUse>()?),
            StructType::IscsiFaultVnicAlreadyBound => Some(from.as_any_ref().downcast_ref::<IscsiFaultVnicAlreadyBound>()?),
            StructType::IscsiFaultVnicHasActivePaths => Some(from.as_any_ref().downcast_ref::<IscsiFaultVnicHasActivePaths>()?),
            StructType::IscsiFaultVnicHasMultipleUplinks => Some(from.as_any_ref().downcast_ref::<IscsiFaultVnicHasMultipleUplinks>()?),
            StructType::IscsiFaultVnicHasNoUplinks => Some(from.as_any_ref().downcast_ref::<IscsiFaultVnicHasNoUplinks>()?),
            StructType::IscsiFaultVnicHasWrongUplink => Some(from.as_any_ref().downcast_ref::<IscsiFaultVnicHasWrongUplink>()?),
            StructType::IscsiFaultVnicInUse => Some(from.as_any_ref().downcast_ref::<IscsiFaultVnicInUse>()?),
            StructType::IscsiFaultVnicIsLastPath => Some(from.as_any_ref().downcast_ref::<IscsiFaultVnicIsLastPath>()?),
            StructType::IscsiFaultVnicNotBound => Some(from.as_any_ref().downcast_ref::<IscsiFaultVnicNotBound>()?),
            StructType::IscsiFaultVnicNotFound => Some(from.as_any_ref().downcast_ref::<IscsiFaultVnicNotFound>()?),
            StructType::KeyNotFound => Some(from.as_any_ref().downcast_ref::<KeyNotFound>()?),
            StructType::LicenseEntityNotFound => Some(from.as_any_ref().downcast_ref::<LicenseEntityNotFound>()?),
            StructType::LicenseServerUnavailable => Some(from.as_any_ref().downcast_ref::<LicenseServerUnavailable>()?),
            StructType::LimitExceeded => Some(from.as_any_ref().downcast_ref::<LimitExceeded>()?),
            StructType::LogBundlingFailed => Some(from.as_any_ref().downcast_ref::<LogBundlingFailed>()?),
            StructType::MigrationFault => Some(from.as_any_ref().downcast_ref::<MigrationFault>()?),
            StructType::AffinityConfigured => Some(from.as_any_ref().downcast_ref::<AffinityConfigured>()?),
            StructType::CannotModifyConfigCpuRequirements => Some(from.as_any_ref().downcast_ref::<CannotModifyConfigCpuRequirements>()?),
            StructType::CannotMoveVmWithDeltaDisk => Some(from.as_any_ref().downcast_ref::<CannotMoveVmWithDeltaDisk>()?),
            StructType::CannotMoveVmWithNativeDeltaDisk => Some(from.as_any_ref().downcast_ref::<CannotMoveVmWithNativeDeltaDisk>()?),
            StructType::CloneFromSnapshotNotSupported => Some(from.as_any_ref().downcast_ref::<CloneFromSnapshotNotSupported>()?),
            StructType::DatacenterMismatch => Some(from.as_any_ref().downcast_ref::<DatacenterMismatch>()?),
            StructType::DisallowedMigrationDeviceAttached => Some(from.as_any_ref().downcast_ref::<DisallowedMigrationDeviceAttached>()?),
            StructType::DiskMoveTypeNotSupported => Some(from.as_any_ref().downcast_ref::<DiskMoveTypeNotSupported>()?),
            StructType::FaultToleranceAntiAffinityViolated => Some(from.as_any_ref().downcast_ref::<FaultToleranceAntiAffinityViolated>()?),
            StructType::FaultToleranceNeedsThickDisk => Some(from.as_any_ref().downcast_ref::<FaultToleranceNeedsThickDisk>()?),
            StructType::FaultToleranceNotSameBuild => Some(from.as_any_ref().downcast_ref::<FaultToleranceNotSameBuild>()?),
            StructType::HaErrorsAtDest => Some(from.as_any_ref().downcast_ref::<HaErrorsAtDest>()?),
            StructType::IncompatibleDefaultDevice => Some(from.as_any_ref().downcast_ref::<IncompatibleDefaultDevice>()?),
            StructType::LargeRdmConversionNotSupported => Some(from.as_any_ref().downcast_ref::<LargeRdmConversionNotSupported>()?),
            StructType::MaintenanceModeFileMove => Some(from.as_any_ref().downcast_ref::<MaintenanceModeFileMove>()?),
            StructType::MigrationDisabled => Some(from.as_any_ref().downcast_ref::<MigrationDisabled>()?),
            StructType::MigrationFeatureNotSupported => Some(from.as_any_ref().downcast_ref::<MigrationFeatureNotSupported>()?),
            StructType::FullStorageVMotionNotSupported => Some(from.as_any_ref().downcast_ref::<FullStorageVMotionNotSupported>()?),
            StructType::IndependentDiskVMotionNotSupported => Some(from.as_any_ref().downcast_ref::<IndependentDiskVMotionNotSupported>()?),
            StructType::NonHomeRdmvMotionNotSupported => Some(from.as_any_ref().downcast_ref::<NonHomeRdmvMotionNotSupported>()?),
            StructType::StorageVMotionNotSupported => Some(from.as_any_ref().downcast_ref::<StorageVMotionNotSupported>()?),
            StructType::UnsharedSwapVMotionNotSupported => Some(from.as_any_ref().downcast_ref::<UnsharedSwapVMotionNotSupported>()?),
            StructType::VMotionAcrossNetworkNotSupported => Some(from.as_any_ref().downcast_ref::<VMotionAcrossNetworkNotSupported>()?),
            StructType::MigrationNotReady => Some(from.as_any_ref().downcast_ref::<MigrationNotReady>()?),
            StructType::MismatchedNetworkPolicies => Some(from.as_any_ref().downcast_ref::<MismatchedNetworkPolicies>()?),
            StructType::MismatchedVMotionNetworkNames => Some(from.as_any_ref().downcast_ref::<MismatchedVMotionNetworkNames>()?),
            StructType::NetworksMayNotBeTheSame => Some(from.as_any_ref().downcast_ref::<NetworksMayNotBeTheSame>()?),
            StructType::NoGuestHeartbeat => Some(from.as_any_ref().downcast_ref::<NoGuestHeartbeat>()?),
            StructType::RdmConversionNotSupported => Some(from.as_any_ref().downcast_ref::<RdmConversionNotSupported>()?),
            StructType::RdmNotPreserved => Some(from.as_any_ref().downcast_ref::<RdmNotPreserved>()?),
            StructType::ReadOnlyDisksWithLegacyDestination => Some(from.as_any_ref().downcast_ref::<ReadOnlyDisksWithLegacyDestination>()?),
            StructType::SnapshotCopyNotSupported => Some(from.as_any_ref().downcast_ref::<SnapshotCopyNotSupported>()?),
            StructType::HotSnapshotMoveNotSupported => Some(from.as_any_ref().downcast_ref::<HotSnapshotMoveNotSupported>()?),
            StructType::SnapshotCloneNotSupported => Some(from.as_any_ref().downcast_ref::<SnapshotCloneNotSupported>()?),
            StructType::SnapshotMoveFromNonHomeNotSupported => Some(from.as_any_ref().downcast_ref::<SnapshotMoveFromNonHomeNotSupported>()?),
            StructType::SnapshotMoveNotSupported => Some(from.as_any_ref().downcast_ref::<SnapshotMoveNotSupported>()?),
            StructType::SnapshotMoveToNonHomeNotSupported => Some(from.as_any_ref().downcast_ref::<SnapshotMoveToNonHomeNotSupported>()?),
            StructType::SnapshotRevertIssue => Some(from.as_any_ref().downcast_ref::<SnapshotRevertIssue>()?),
            StructType::SuspendedRelocateNotSupported => Some(from.as_any_ref().downcast_ref::<SuspendedRelocateNotSupported>()?),
            StructType::TooManyDisksOnLegacyHost => Some(from.as_any_ref().downcast_ref::<TooManyDisksOnLegacyHost>()?),
            StructType::ToolsInstallationInProgress => Some(from.as_any_ref().downcast_ref::<ToolsInstallationInProgress>()?),
            StructType::UncommittedUndoableDisk => Some(from.as_any_ref().downcast_ref::<UncommittedUndoableDisk>()?),
            StructType::VMotionInterfaceIssue => Some(from.as_any_ref().downcast_ref::<VMotionInterfaceIssue>()?),
            StructType::VMotionLinkCapacityLow => Some(from.as_any_ref().downcast_ref::<VMotionLinkCapacityLow>()?),
            StructType::VMotionLinkDown => Some(from.as_any_ref().downcast_ref::<VMotionLinkDown>()?),
            StructType::VMotionNotConfigured => Some(from.as_any_ref().downcast_ref::<VMotionNotConfigured>()?),
            StructType::VMotionNotLicensed => Some(from.as_any_ref().downcast_ref::<VMotionNotLicensed>()?),
            StructType::VMotionNotSupported => Some(from.as_any_ref().downcast_ref::<VMotionNotSupported>()?),
            StructType::VMotionProtocolIncompatible => Some(from.as_any_ref().downcast_ref::<VMotionProtocolIncompatible>()?),
            StructType::WillLoseHaProtection => Some(from.as_any_ref().downcast_ref::<WillLoseHaProtection>()?),
            StructType::WillModifyConfigCpuRequirements => Some(from.as_any_ref().downcast_ref::<WillModifyConfigCpuRequirements>()?),
            StructType::WillResetSnapshotDirectory => Some(from.as_any_ref().downcast_ref::<WillResetSnapshotDirectory>()?),
            StructType::MismatchedBundle => Some(from.as_any_ref().downcast_ref::<MismatchedBundle>()?),
            StructType::MissingBmcSupport => Some(from.as_any_ref().downcast_ref::<MissingBmcSupport>()?),
            StructType::NamespaceFull => Some(from.as_any_ref().downcast_ref::<NamespaceFull>()?),
            StructType::NamespaceLimitReached => Some(from.as_any_ref().downcast_ref::<NamespaceLimitReached>()?),
            StructType::NamespaceWriteProtected => Some(from.as_any_ref().downcast_ref::<NamespaceWriteProtected>()?),
            StructType::NetworkDisruptedAndConfigRolledBack => Some(from.as_any_ref().downcast_ref::<NetworkDisruptedAndConfigRolledBack>()?),
            StructType::NoClientCertificate => Some(from.as_any_ref().downcast_ref::<NoClientCertificate>()?),
            StructType::NoCompatibleDatastore => Some(from.as_any_ref().downcast_ref::<NoCompatibleDatastore>()?),
            StructType::NoCompatibleHost => Some(from.as_any_ref().downcast_ref::<NoCompatibleHost>()?),
            StructType::NoCompatibleHostWithAccessToDevice => Some(from.as_any_ref().downcast_ref::<NoCompatibleHostWithAccessToDevice>()?),
            StructType::NoConnectedDatastore => Some(from.as_any_ref().downcast_ref::<NoConnectedDatastore>()?),
            StructType::NoDiskFound => Some(from.as_any_ref().downcast_ref::<NoDiskFound>()?),
            StructType::NoSubjectName => Some(from.as_any_ref().downcast_ref::<NoSubjectName>()?),
            StructType::NotFound => Some(from.as_any_ref().downcast_ref::<NotFound>()?),
            StructType::NotSupportedHostForChecksum => Some(from.as_any_ref().downcast_ref::<NotSupportedHostForChecksum>()?),
            StructType::OutOfBounds => Some(from.as_any_ref().downcast_ref::<OutOfBounds>()?),
            StructType::OvfFault => Some(from.as_any_ref().downcast_ref::<OvfFault>()?),
            StructType::OvfConsumerCallbackFault => Some(from.as_any_ref().downcast_ref::<OvfConsumerCallbackFault>()?),
            StructType::OvfConsumerCommunicationError => Some(from.as_any_ref().downcast_ref::<OvfConsumerCommunicationError>()?),
            StructType::OvfConsumerFault => Some(from.as_any_ref().downcast_ref::<OvfConsumerFault>()?),
            StructType::OvfConsumerInvalidSection => Some(from.as_any_ref().downcast_ref::<OvfConsumerInvalidSection>()?),
            StructType::OvfConsumerUndeclaredSection => Some(from.as_any_ref().downcast_ref::<OvfConsumerUndeclaredSection>()?),
            StructType::OvfConsumerUndefinedPrefix => Some(from.as_any_ref().downcast_ref::<OvfConsumerUndefinedPrefix>()?),
            StructType::OvfExport => Some(from.as_any_ref().downcast_ref::<OvfExport>()?),
            StructType::ConnectedIso => Some(from.as_any_ref().downcast_ref::<ConnectedIso>()?),
            StructType::OvfDuplicatedPropertyIdExport => Some(from.as_any_ref().downcast_ref::<OvfDuplicatedPropertyIdExport>()?),
            StructType::OvfDuplicatedPropertyIdImport => Some(from.as_any_ref().downcast_ref::<OvfDuplicatedPropertyIdImport>()?),
            StructType::OvfExportFailed => Some(from.as_any_ref().downcast_ref::<OvfExportFailed>()?),
            StructType::OvfHardwareExport => Some(from.as_any_ref().downcast_ref::<OvfHardwareExport>()?),
            StructType::OvfConnectedDevice => Some(from.as_any_ref().downcast_ref::<OvfConnectedDevice>()?),
            StructType::OvfConnectedDeviceFloppy => Some(from.as_any_ref().downcast_ref::<OvfConnectedDeviceFloppy>()?),
            StructType::OvfConnectedDeviceIso => Some(from.as_any_ref().downcast_ref::<OvfConnectedDeviceIso>()?),
            StructType::OvfUnableToExportDisk => Some(from.as_any_ref().downcast_ref::<OvfUnableToExportDisk>()?),
            StructType::OvfUnknownDeviceBacking => Some(from.as_any_ref().downcast_ref::<OvfUnknownDeviceBacking>()?),
            StructType::OvfUnsupportedDeviceExport => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedDeviceExport>()?),
            StructType::OvfPropertyExport => Some(from.as_any_ref().downcast_ref::<OvfPropertyExport>()?),
            StructType::OvfPropertyNetworkExport => Some(from.as_any_ref().downcast_ref::<OvfPropertyNetworkExport>()?),
            StructType::OvfImport => Some(from.as_any_ref().downcast_ref::<OvfImport>()?),
            StructType::OvfCpuCompatibility => Some(from.as_any_ref().downcast_ref::<OvfCpuCompatibility>()?),
            StructType::OvfCpuCompatibilityCheckNotSupported => Some(from.as_any_ref().downcast_ref::<OvfCpuCompatibilityCheckNotSupported>()?),
            StructType::OvfHardwareCheck => Some(from.as_any_ref().downcast_ref::<OvfHardwareCheck>()?),
            StructType::OvfImportFailed => Some(from.as_any_ref().downcast_ref::<OvfImportFailed>()?),
            StructType::OvfMappedOsId => Some(from.as_any_ref().downcast_ref::<OvfMappedOsId>()?),
            StructType::OvfMissingHardware => Some(from.as_any_ref().downcast_ref::<OvfMissingHardware>()?),
            StructType::OvfNetworkMappingNotSupported => Some(from.as_any_ref().downcast_ref::<OvfNetworkMappingNotSupported>()?),
            StructType::OvfUnsupportedDiskProvisioning => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedDiskProvisioning>()?),
            StructType::OvfInvalidPackage => Some(from.as_any_ref().downcast_ref::<OvfInvalidPackage>()?),
            StructType::OvfAttribute => Some(from.as_any_ref().downcast_ref::<OvfAttribute>()?),
            StructType::OvfInvalidValue => Some(from.as_any_ref().downcast_ref::<OvfInvalidValue>()?),
            StructType::OvfInvalidValueConfiguration => Some(from.as_any_ref().downcast_ref::<OvfInvalidValueConfiguration>()?),
            StructType::OvfInvalidValueEmpty => Some(from.as_any_ref().downcast_ref::<OvfInvalidValueEmpty>()?),
            StructType::OvfInvalidValueFormatMalformed => Some(from.as_any_ref().downcast_ref::<OvfInvalidValueFormatMalformed>()?),
            StructType::OvfInvalidValueReference => Some(from.as_any_ref().downcast_ref::<OvfInvalidValueReference>()?),
            StructType::OvfMissingAttribute => Some(from.as_any_ref().downcast_ref::<OvfMissingAttribute>()?),
            StructType::OvfConstraint => Some(from.as_any_ref().downcast_ref::<OvfConstraint>()?),
            StructType::OvfDiskOrderConstraint => Some(from.as_any_ref().downcast_ref::<OvfDiskOrderConstraint>()?),
            StructType::OvfHostResourceConstraint => Some(from.as_any_ref().downcast_ref::<OvfHostResourceConstraint>()?),
            StructType::OvfElement => Some(from.as_any_ref().downcast_ref::<OvfElement>()?),
            StructType::OvfDuplicateElement => Some(from.as_any_ref().downcast_ref::<OvfDuplicateElement>()?),
            StructType::OvfDuplicatedElementBoundary => Some(from.as_any_ref().downcast_ref::<OvfDuplicatedElementBoundary>()?),
            StructType::OvfElementInvalidValue => Some(from.as_any_ref().downcast_ref::<OvfElementInvalidValue>()?),
            StructType::OvfMissingElement => Some(from.as_any_ref().downcast_ref::<OvfMissingElement>()?),
            StructType::OvfMissingElementNormalBoundary => Some(from.as_any_ref().downcast_ref::<OvfMissingElementNormalBoundary>()?),
            StructType::OvfUnexpectedElement => Some(from.as_any_ref().downcast_ref::<OvfUnexpectedElement>()?),
            StructType::OvfWrongElement => Some(from.as_any_ref().downcast_ref::<OvfWrongElement>()?),
            StructType::OvfProperty => Some(from.as_any_ref().downcast_ref::<OvfProperty>()?),
            StructType::OvfPropertyNetwork => Some(from.as_any_ref().downcast_ref::<OvfPropertyNetwork>()?),
            StructType::OvfPropertyQualifier => Some(from.as_any_ref().downcast_ref::<OvfPropertyQualifier>()?),
            StructType::OvfPropertyQualifierDuplicate => Some(from.as_any_ref().downcast_ref::<OvfPropertyQualifierDuplicate>()?),
            StructType::OvfPropertyQualifierIgnored => Some(from.as_any_ref().downcast_ref::<OvfPropertyQualifierIgnored>()?),
            StructType::OvfPropertyType => Some(from.as_any_ref().downcast_ref::<OvfPropertyType>()?),
            StructType::OvfPropertyValue => Some(from.as_any_ref().downcast_ref::<OvfPropertyValue>()?),
            StructType::OvfWrongNamespace => Some(from.as_any_ref().downcast_ref::<OvfWrongNamespace>()?),
            StructType::OvfXmlFormat => Some(from.as_any_ref().downcast_ref::<OvfXmlFormat>()?),
            StructType::OvfSystemFault => Some(from.as_any_ref().downcast_ref::<OvfSystemFault>()?),
            StructType::OvfDiskMappingNotFound => Some(from.as_any_ref().downcast_ref::<OvfDiskMappingNotFound>()?),
            StructType::OvfHostValueNotParsed => Some(from.as_any_ref().downcast_ref::<OvfHostValueNotParsed>()?),
            StructType::OvfInternalError => Some(from.as_any_ref().downcast_ref::<OvfInternalError>()?),
            StructType::OvfToXmlUnsupportedElement => Some(from.as_any_ref().downcast_ref::<OvfToXmlUnsupportedElement>()?),
            StructType::OvfUnknownDevice => Some(from.as_any_ref().downcast_ref::<OvfUnknownDevice>()?),
            StructType::OvfUnknownEntity => Some(from.as_any_ref().downcast_ref::<OvfUnknownEntity>()?),
            StructType::OvfUnsupportedDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedDeviceBackingInfo>()?),
            StructType::OvfUnsupportedDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedDeviceBackingOption>()?),
            StructType::OvfUnsupportedPackage => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedPackage>()?),
            StructType::OvfInvalidVmName => Some(from.as_any_ref().downcast_ref::<OvfInvalidVmName>()?),
            StructType::OvfNoHostNic => Some(from.as_any_ref().downcast_ref::<OvfNoHostNic>()?),
            StructType::OvfNoSupportedHardwareFamily => Some(from.as_any_ref().downcast_ref::<OvfNoSupportedHardwareFamily>()?),
            StructType::OvfUnsupportedAttribute => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedAttribute>()?),
            StructType::OvfUnsupportedAttributeValue => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedAttributeValue>()?),
            StructType::OvfUnsupportedElement => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedElement>()?),
            StructType::OvfNoSpaceOnController => Some(from.as_any_ref().downcast_ref::<OvfNoSpaceOnController>()?),
            StructType::OvfUnsupportedElementValue => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedElementValue>()?),
            StructType::OvfUnsupportedSection => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedSection>()?),
            StructType::OvfUnsupportedSubType => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedSubType>()?),
            StructType::OvfUnsupportedType => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedType>()?),
            StructType::PatchBinariesNotFound => Some(from.as_any_ref().downcast_ref::<PatchBinariesNotFound>()?),
            StructType::PatchMetadataInvalid => Some(from.as_any_ref().downcast_ref::<PatchMetadataInvalid>()?),
            StructType::PatchMetadataCorrupted => Some(from.as_any_ref().downcast_ref::<PatchMetadataCorrupted>()?),
            StructType::PatchMetadataNotFound => Some(from.as_any_ref().downcast_ref::<PatchMetadataNotFound>()?),
            StructType::PatchNotApplicable => Some(from.as_any_ref().downcast_ref::<PatchNotApplicable>()?),
            StructType::PatchAlreadyInstalled => Some(from.as_any_ref().downcast_ref::<PatchAlreadyInstalled>()?),
            StructType::PatchMissingDependencies => Some(from.as_any_ref().downcast_ref::<PatchMissingDependencies>()?),
            StructType::PatchSuperseded => Some(from.as_any_ref().downcast_ref::<PatchSuperseded>()?),
            StructType::ProfileUpdateFailed => Some(from.as_any_ref().downcast_ref::<ProfileUpdateFailed>()?),
            StructType::RebootRequired => Some(from.as_any_ref().downcast_ref::<RebootRequired>()?),
            StructType::RecordReplayDisabled => Some(from.as_any_ref().downcast_ref::<RecordReplayDisabled>()?),
            StructType::RemoveFailed => Some(from.as_any_ref().downcast_ref::<RemoveFailed>()?),
            StructType::ReplicationFault => Some(from.as_any_ref().downcast_ref::<ReplicationFault>()?),
            StructType::IncompatibleHostForVmReplication => Some(from.as_any_ref().downcast_ref::<IncompatibleHostForVmReplication>()?),
            StructType::ReplicationConfigFault => Some(from.as_any_ref().downcast_ref::<ReplicationConfigFault>()?),
            StructType::ReplicationDiskConfigFault => Some(from.as_any_ref().downcast_ref::<ReplicationDiskConfigFault>()?),
            StructType::ReplicationVmConfigFault => Some(from.as_any_ref().downcast_ref::<ReplicationVmConfigFault>()?),
            StructType::ReplicationIncompatibleWithFt => Some(from.as_any_ref().downcast_ref::<ReplicationIncompatibleWithFt>()?),
            StructType::ReplicationInvalidOptions => Some(from.as_any_ref().downcast_ref::<ReplicationInvalidOptions>()?),
            StructType::ReplicationNotSupportedOnHost => Some(from.as_any_ref().downcast_ref::<ReplicationNotSupportedOnHost>()?),
            StructType::ReplicationVmFault => Some(from.as_any_ref().downcast_ref::<ReplicationVmFault>()?),
            StructType::ReplicationVmInProgressFault => Some(from.as_any_ref().downcast_ref::<ReplicationVmInProgressFault>()?),
            StructType::ResourceInUse => Some(from.as_any_ref().downcast_ref::<ResourceInUse>()?),
            StructType::FilterInUse => Some(from.as_any_ref().downcast_ref::<FilterInUse>()?),
            StructType::QuiesceDatastoreIoForHaFailed => Some(from.as_any_ref().downcast_ref::<QuiesceDatastoreIoForHaFailed>()?),
            StructType::ResourceNotAvailable => Some(from.as_any_ref().downcast_ref::<ResourceNotAvailable>()?),
            StructType::SspiChallenge => Some(from.as_any_ref().downcast_ref::<SspiChallenge>()?),
            StructType::ShrinkDiskFault => Some(from.as_any_ref().downcast_ref::<ShrinkDiskFault>()?),
            StructType::SnapshotFault => Some(from.as_any_ref().downcast_ref::<SnapshotFault>()?),
            StructType::ApplicationQuiesceFault => Some(from.as_any_ref().downcast_ref::<ApplicationQuiesceFault>()?),
            StructType::FilesystemQuiesceFault => Some(from.as_any_ref().downcast_ref::<FilesystemQuiesceFault>()?),
            StructType::MemorySnapshotOnIndependentDisk => Some(from.as_any_ref().downcast_ref::<MemorySnapshotOnIndependentDisk>()?),
            StructType::MultipleSnapshotsNotSupported => Some(from.as_any_ref().downcast_ref::<MultipleSnapshotsNotSupported>()?),
            StructType::SnapshotDisabled => Some(from.as_any_ref().downcast_ref::<SnapshotDisabled>()?),
            StructType::SnapshotIncompatibleDeviceInVm => Some(from.as_any_ref().downcast_ref::<SnapshotIncompatibleDeviceInVm>()?),
            StructType::SnapshotLocked => Some(from.as_any_ref().downcast_ref::<SnapshotLocked>()?),
            StructType::SnapshotNoChange => Some(from.as_any_ref().downcast_ref::<SnapshotNoChange>()?),
            StructType::TooManySnapshotLevels => Some(from.as_any_ref().downcast_ref::<TooManySnapshotLevels>()?),
            StructType::SsdDiskNotAvailable => Some(from.as_any_ref().downcast_ref::<SsdDiskNotAvailable>()?),
            StructType::StorageDrsCannotMoveDiskInMultiWriterMode => Some(from.as_any_ref().downcast_ref::<StorageDrsCannotMoveDiskInMultiWriterMode>()?),
            StructType::StorageDrsCannotMoveFtVm => Some(from.as_any_ref().downcast_ref::<StorageDrsCannotMoveFtVm>()?),
            StructType::StorageDrsCannotMoveIndependentDisk => Some(from.as_any_ref().downcast_ref::<StorageDrsCannotMoveIndependentDisk>()?),
            StructType::StorageDrsCannotMoveManuallyPlacedSwapFile => Some(from.as_any_ref().downcast_ref::<StorageDrsCannotMoveManuallyPlacedSwapFile>()?),
            StructType::StorageDrsCannotMoveManuallyPlacedVm => Some(from.as_any_ref().downcast_ref::<StorageDrsCannotMoveManuallyPlacedVm>()?),
            StructType::StorageDrsCannotMoveSharedDisk => Some(from.as_any_ref().downcast_ref::<StorageDrsCannotMoveSharedDisk>()?),
            StructType::StorageDrsCannotMoveTemplate => Some(from.as_any_ref().downcast_ref::<StorageDrsCannotMoveTemplate>()?),
            StructType::StorageDrsCannotMoveVmInUserFolder => Some(from.as_any_ref().downcast_ref::<StorageDrsCannotMoveVmInUserFolder>()?),
            StructType::StorageDrsCannotMoveVmWithMountedCdrom => Some(from.as_any_ref().downcast_ref::<StorageDrsCannotMoveVmWithMountedCdrom>()?),
            StructType::StorageDrsCannotMoveVmWithNoFilesInLayout => Some(from.as_any_ref().downcast_ref::<StorageDrsCannotMoveVmWithNoFilesInLayout>()?),
            StructType::StorageDrsDatacentersCannotShareDatastore => Some(from.as_any_ref().downcast_ref::<StorageDrsDatacentersCannotShareDatastore>()?),
            StructType::StorageDrsDisabledOnVm => Some(from.as_any_ref().downcast_ref::<StorageDrsDisabledOnVm>()?),
            StructType::StorageDrsHbrDiskNotMovable => Some(from.as_any_ref().downcast_ref::<StorageDrsHbrDiskNotMovable>()?),
            StructType::StorageDrsHmsMoveInProgress => Some(from.as_any_ref().downcast_ref::<StorageDrsHmsMoveInProgress>()?),
            StructType::StorageDrsHmsUnreachable => Some(from.as_any_ref().downcast_ref::<StorageDrsHmsUnreachable>()?),
            StructType::StorageDrsIolbDisabledInternally => Some(from.as_any_ref().downcast_ref::<StorageDrsIolbDisabledInternally>()?),
            StructType::StorageDrsRelocateDisabled => Some(from.as_any_ref().downcast_ref::<StorageDrsRelocateDisabled>()?),
            StructType::StorageDrsStaleHmsCollection => Some(from.as_any_ref().downcast_ref::<StorageDrsStaleHmsCollection>()?),
            StructType::StorageDrsUnableToMoveFiles => Some(from.as_any_ref().downcast_ref::<StorageDrsUnableToMoveFiles>()?),
            StructType::SwapDatastoreUnset => Some(from.as_any_ref().downcast_ref::<SwapDatastoreUnset>()?),
            StructType::TaskInProgress => Some(from.as_any_ref().downcast_ref::<TaskInProgress>()?),
            StructType::VAppTaskInProgress => Some(from.as_any_ref().downcast_ref::<VAppTaskInProgress>()?),
            StructType::Timedout => Some(from.as_any_ref().downcast_ref::<Timedout>()?),
            StructType::PowerOnFtSecondaryTimedout => Some(from.as_any_ref().downcast_ref::<PowerOnFtSecondaryTimedout>()?),
            StructType::TooManyConsecutiveOverrides => Some(from.as_any_ref().downcast_ref::<TooManyConsecutiveOverrides>()?),
            StructType::ToolsUnavailable => Some(from.as_any_ref().downcast_ref::<ToolsUnavailable>()?),
            StructType::UnrecognizedHost => Some(from.as_any_ref().downcast_ref::<UnrecognizedHost>()?),
            StructType::UnsupportedVimApiVersion => Some(from.as_any_ref().downcast_ref::<UnsupportedVimApiVersion>()?),
            StructType::UserNotFound => Some(from.as_any_ref().downcast_ref::<UserNotFound>()?),
            StructType::VAppConfigFault => Some(from.as_any_ref().downcast_ref::<VAppConfigFault>()?),
            StructType::MissingPowerOffConfiguration => Some(from.as_any_ref().downcast_ref::<MissingPowerOffConfiguration>()?),
            StructType::MissingPowerOnConfiguration => Some(from.as_any_ref().downcast_ref::<MissingPowerOnConfiguration>()?),
            StructType::NoVmInVApp => Some(from.as_any_ref().downcast_ref::<NoVmInVApp>()?),
            StructType::VFlashModuleVersionIncompatible => Some(from.as_any_ref().downcast_ref::<VFlashModuleVersionIncompatible>()?),
            StructType::VmConfigFault => Some(from.as_any_ref().downcast_ref::<VmConfigFault>()?),
            StructType::CannotAccessVmComponent => Some(from.as_any_ref().downcast_ref::<CannotAccessVmComponent>()?),
            StructType::CannotAccessVmConfig => Some(from.as_any_ref().downcast_ref::<CannotAccessVmConfig>()?),
            StructType::CannotAccessVmDevice => Some(from.as_any_ref().downcast_ref::<CannotAccessVmDevice>()?),
            StructType::CannotAccessNetwork => Some(from.as_any_ref().downcast_ref::<CannotAccessNetwork>()?),
            StructType::DestinationSwitchFull => Some(from.as_any_ref().downcast_ref::<DestinationSwitchFull>()?),
            StructType::LegacyNetworkInterfaceInUse => Some(from.as_any_ref().downcast_ref::<LegacyNetworkInterfaceInUse>()?),
            StructType::VmOnConflictDvPort => Some(from.as_any_ref().downcast_ref::<VmOnConflictDvPort>()?),
            StructType::VmOnVirtualIntranet => Some(from.as_any_ref().downcast_ref::<VmOnVirtualIntranet>()?),
            StructType::CannotAccessVmDisk => Some(from.as_any_ref().downcast_ref::<CannotAccessVmDisk>()?),
            StructType::RdmPointsToInaccessibleDisk => Some(from.as_any_ref().downcast_ref::<RdmPointsToInaccessibleDisk>()?),
            StructType::CannotDisableSnapshot => Some(from.as_any_ref().downcast_ref::<CannotDisableSnapshot>()?),
            StructType::CannotUseNetwork => Some(from.as_any_ref().downcast_ref::<CannotUseNetwork>()?),
            StructType::CpuHotPlugNotSupported => Some(from.as_any_ref().downcast_ref::<CpuHotPlugNotSupported>()?),
            StructType::DeltaDiskFormatNotSupported => Some(from.as_any_ref().downcast_ref::<DeltaDiskFormatNotSupported>()?),
            StructType::EightHostLimitViolated => Some(from.as_any_ref().downcast_ref::<EightHostLimitViolated>()?),
            StructType::FaultToleranceCannotEditMem => Some(from.as_any_ref().downcast_ref::<FaultToleranceCannotEditMem>()?),
            StructType::GenericVmConfigFault => Some(from.as_any_ref().downcast_ref::<GenericVmConfigFault>()?),
            StructType::InvalidFormat => Some(from.as_any_ref().downcast_ref::<InvalidFormat>()?),
            StructType::InvalidDiskFormat => Some(from.as_any_ref().downcast_ref::<InvalidDiskFormat>()?),
            StructType::InvalidSnapshotFormat => Some(from.as_any_ref().downcast_ref::<InvalidSnapshotFormat>()?),
            StructType::InvalidVmConfig => Some(from.as_any_ref().downcast_ref::<InvalidVmConfig>()?),
            StructType::InvalidDeviceSpec => Some(from.as_any_ref().downcast_ref::<InvalidDeviceSpec>()?),
            StructType::DeviceHotPlugNotSupported => Some(from.as_any_ref().downcast_ref::<DeviceHotPlugNotSupported>()?),
            StructType::DeviceNotFound => Some(from.as_any_ref().downcast_ref::<DeviceNotFound>()?),
            StructType::DeviceUnsupportedForVmPlatform => Some(from.as_any_ref().downcast_ref::<DeviceUnsupportedForVmPlatform>()?),
            StructType::DeviceUnsupportedForVmVersion => Some(from.as_any_ref().downcast_ref::<DeviceUnsupportedForVmVersion>()?),
            StructType::DisallowedDiskModeChange => Some(from.as_any_ref().downcast_ref::<DisallowedDiskModeChange>()?),
            StructType::InvalidController => Some(from.as_any_ref().downcast_ref::<InvalidController>()?),
            StructType::InvalidDeviceBacking => Some(from.as_any_ref().downcast_ref::<InvalidDeviceBacking>()?),
            StructType::InvalidDeviceOperation => Some(from.as_any_ref().downcast_ref::<InvalidDeviceOperation>()?),
            StructType::MissingController => Some(from.as_any_ref().downcast_ref::<MissingController>()?),
            StructType::SwapPlacementOverrideNotSupported => Some(from.as_any_ref().downcast_ref::<SwapPlacementOverrideNotSupported>()?),
            StructType::TooManyDevices => Some(from.as_any_ref().downcast_ref::<TooManyDevices>()?),
            StructType::UnsupportedGuest => Some(from.as_any_ref().downcast_ref::<UnsupportedGuest>()?),
            StructType::VmWwnConflict => Some(from.as_any_ref().downcast_ref::<VmWwnConflict>()?),
            StructType::LargeRdmNotSupportedOnDatastore => Some(from.as_any_ref().downcast_ref::<LargeRdmNotSupportedOnDatastore>()?),
            StructType::MemoryHotPlugNotSupported => Some(from.as_any_ref().downcast_ref::<MemoryHotPlugNotSupported>()?),
            StructType::NoCompatibleHardAffinityHost => Some(from.as_any_ref().downcast_ref::<NoCompatibleHardAffinityHost>()?),
            StructType::NoCompatibleSoftAffinityHost => Some(from.as_any_ref().downcast_ref::<NoCompatibleSoftAffinityHost>()?),
            StructType::NumVirtualCpusIncompatible => Some(from.as_any_ref().downcast_ref::<NumVirtualCpusIncompatible>()?),
            StructType::OvfConsumerValidationFault => Some(from.as_any_ref().downcast_ref::<OvfConsumerValidationFault>()?),
            StructType::QuarantineModeFault => Some(from.as_any_ref().downcast_ref::<QuarantineModeFault>()?),
            StructType::RdmNotSupportedOnDatastore => Some(from.as_any_ref().downcast_ref::<RdmNotSupportedOnDatastore>()?),
            StructType::RuleViolation => Some(from.as_any_ref().downcast_ref::<RuleViolation>()?),
            StructType::SoftRuleVioCorrectionDisallowed => Some(from.as_any_ref().downcast_ref::<SoftRuleVioCorrectionDisallowed>()?),
            StructType::SoftRuleVioCorrectionImpact => Some(from.as_any_ref().downcast_ref::<SoftRuleVioCorrectionImpact>()?),
            StructType::UnsupportedDatastore => Some(from.as_any_ref().downcast_ref::<UnsupportedDatastore>()?),
            StructType::MemoryFileFormatNotSupportedByDatastore => Some(from.as_any_ref().downcast_ref::<MemoryFileFormatNotSupportedByDatastore>()?),
            StructType::UnSupportedDatastoreForVFlash => Some(from.as_any_ref().downcast_ref::<UnSupportedDatastoreForVFlash>()?),
            StructType::UnsupportedVmxLocation => Some(from.as_any_ref().downcast_ref::<UnsupportedVmxLocation>()?),
            StructType::VAppNotRunning => Some(from.as_any_ref().downcast_ref::<VAppNotRunning>()?),
            StructType::VAppPropertyFault => Some(from.as_any_ref().downcast_ref::<VAppPropertyFault>()?),
            StructType::InvalidNetworkInType => Some(from.as_any_ref().downcast_ref::<InvalidNetworkInType>()?),
            StructType::InvalidPropertyType => Some(from.as_any_ref().downcast_ref::<InvalidPropertyType>()?),
            StructType::InvalidPropertyValue => Some(from.as_any_ref().downcast_ref::<InvalidPropertyValue>()?),
            StructType::UnconfiguredPropertyValue => Some(from.as_any_ref().downcast_ref::<UnconfiguredPropertyValue>()?),
            StructType::MissingIpPool => Some(from.as_any_ref().downcast_ref::<MissingIpPool>()?),
            StructType::MissingNetworkIpConfig => Some(from.as_any_ref().downcast_ref::<MissingNetworkIpConfig>()?),
            StructType::NoAvailableIp => Some(from.as_any_ref().downcast_ref::<NoAvailableIp>()?),
            StructType::NoVcManagedIpConfigured => Some(from.as_any_ref().downcast_ref::<NoVcManagedIpConfigured>()?),
            StructType::NotUserConfigurableProperty => Some(from.as_any_ref().downcast_ref::<NotUserConfigurableProperty>()?),
            StructType::VFlashCacheHotConfigNotSupported => Some(from.as_any_ref().downcast_ref::<VFlashCacheHotConfigNotSupported>()?),
            StructType::VFlashModuleNotSupported => Some(from.as_any_ref().downcast_ref::<VFlashModuleNotSupported>()?),
            StructType::VirtualHardwareCompatibilityIssue => Some(from.as_any_ref().downcast_ref::<VirtualHardwareCompatibilityIssue>()?),
            StructType::CpuIncompatible => Some(from.as_any_ref().downcast_ref::<CpuIncompatible>()?),
            StructType::CpuCompatibilityUnknown => Some(from.as_any_ref().downcast_ref::<CpuCompatibilityUnknown>()?),
            StructType::CpuIncompatible1Ecx => Some(from.as_any_ref().downcast_ref::<CpuIncompatible1Ecx>()?),
            StructType::CpuIncompatible81Edx => Some(from.as_any_ref().downcast_ref::<CpuIncompatible81Edx>()?),
            StructType::FaultToleranceCpuIncompatible => Some(from.as_any_ref().downcast_ref::<FaultToleranceCpuIncompatible>()?),
            StructType::DeviceNotSupported => Some(from.as_any_ref().downcast_ref::<DeviceNotSupported>()?),
            StructType::DeviceBackingNotSupported => Some(from.as_any_ref().downcast_ref::<DeviceBackingNotSupported>()?),
            StructType::DvPortNotSupported => Some(from.as_any_ref().downcast_ref::<DvPortNotSupported>()?),
            StructType::UnusedVirtualDiskBlocksNotScrubbed => Some(from.as_any_ref().downcast_ref::<UnusedVirtualDiskBlocksNotScrubbed>()?),
            StructType::VirtualDiskBlocksNotFullyProvisioned => Some(from.as_any_ref().downcast_ref::<VirtualDiskBlocksNotFullyProvisioned>()?),
            StructType::DeviceControllerNotSupported => Some(from.as_any_ref().downcast_ref::<DeviceControllerNotSupported>()?),
            StructType::DigestNotSupported => Some(from.as_any_ref().downcast_ref::<DigestNotSupported>()?),
            StructType::FileBackedPortNotSupported => Some(from.as_any_ref().downcast_ref::<FileBackedPortNotSupported>()?),
            StructType::MultiWriterNotSupported => Some(from.as_any_ref().downcast_ref::<MultiWriterNotSupported>()?),
            StructType::NonPersistentDisksNotSupported => Some(from.as_any_ref().downcast_ref::<NonPersistentDisksNotSupported>()?),
            StructType::RdmNotSupported => Some(from.as_any_ref().downcast_ref::<RdmNotSupported>()?),
            StructType::PhysCompatRdmNotSupported => Some(from.as_any_ref().downcast_ref::<PhysCompatRdmNotSupported>()?),
            StructType::RawDiskNotSupported => Some(from.as_any_ref().downcast_ref::<RawDiskNotSupported>()?),
            StructType::RemoteDeviceNotSupported => Some(from.as_any_ref().downcast_ref::<RemoteDeviceNotSupported>()?),
            StructType::SharedBusControllerNotSupported => Some(from.as_any_ref().downcast_ref::<SharedBusControllerNotSupported>()?),
            StructType::VmiNotSupported => Some(from.as_any_ref().downcast_ref::<VmiNotSupported>()?),
            StructType::VirtualDiskModeNotSupported => Some(from.as_any_ref().downcast_ref::<VirtualDiskModeNotSupported>()?),
            StructType::VirtualEthernetCardNotSupported => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardNotSupported>()?),
            StructType::DiskNotSupported => Some(from.as_any_ref().downcast_ref::<DiskNotSupported>()?),
            StructType::IdeDiskNotSupported => Some(from.as_any_ref().downcast_ref::<IdeDiskNotSupported>()?),
            StructType::DrsVmotionIncompatibleFault => Some(from.as_any_ref().downcast_ref::<DrsVmotionIncompatibleFault>()?),
            StructType::FeatureRequirementsNotMet => Some(from.as_any_ref().downcast_ref::<FeatureRequirementsNotMet>()?),
            StructType::MemorySizeNotRecommended => Some(from.as_any_ref().downcast_ref::<MemorySizeNotRecommended>()?),
            StructType::MemorySizeNotSupported => Some(from.as_any_ref().downcast_ref::<MemorySizeNotSupported>()?),
            StructType::MemorySizeNotSupportedByDatastore => Some(from.as_any_ref().downcast_ref::<MemorySizeNotSupportedByDatastore>()?),
            StructType::NotEnoughCpus => Some(from.as_any_ref().downcast_ref::<NotEnoughCpus>()?),
            StructType::NotEnoughLogicalCpus => Some(from.as_any_ref().downcast_ref::<NotEnoughLogicalCpus>()?),
            StructType::NumVirtualCoresPerSocketNotSupported => Some(from.as_any_ref().downcast_ref::<NumVirtualCoresPerSocketNotSupported>()?),
            StructType::NumVirtualCpusNotSupported => Some(from.as_any_ref().downcast_ref::<NumVirtualCpusNotSupported>()?),
            StructType::StorageVmotionIncompatible => Some(from.as_any_ref().downcast_ref::<StorageVmotionIncompatible>()?),
            StructType::VirtualHardwareVersionNotSupported => Some(from.as_any_ref().downcast_ref::<VirtualHardwareVersionNotSupported>()?),
            StructType::WakeOnLanNotSupported => Some(from.as_any_ref().downcast_ref::<WakeOnLanNotSupported>()?),
            StructType::VmConfigIncompatibleForFaultTolerance => Some(from.as_any_ref().downcast_ref::<VmConfigIncompatibleForFaultTolerance>()?),
            StructType::VmConfigIncompatibleForRecordReplay => Some(from.as_any_ref().downcast_ref::<VmConfigIncompatibleForRecordReplay>()?),
            StructType::VmHostAffinityRuleViolation => Some(from.as_any_ref().downcast_ref::<VmHostAffinityRuleViolation>()?),
            StructType::VmFaultToleranceIssue => Some(from.as_any_ref().downcast_ref::<VmFaultToleranceIssue>()?),
            StructType::CannotChangeDrsBehaviorForFtSecondary => Some(from.as_any_ref().downcast_ref::<CannotChangeDrsBehaviorForFtSecondary>()?),
            StructType::CannotChangeHaSettingsForFtSecondary => Some(from.as_any_ref().downcast_ref::<CannotChangeHaSettingsForFtSecondary>()?),
            StructType::CannotComputeFtCompatibleHosts => Some(from.as_any_ref().downcast_ref::<CannotComputeFtCompatibleHosts>()?),
            StructType::FaultToleranceNotLicensed => Some(from.as_any_ref().downcast_ref::<FaultToleranceNotLicensed>()?),
            StructType::FaultTolerancePrimaryPowerOnNotAttempted => Some(from.as_any_ref().downcast_ref::<FaultTolerancePrimaryPowerOnNotAttempted>()?),
            StructType::FtIssuesOnHost => Some(from.as_any_ref().downcast_ref::<FtIssuesOnHost>()?),
            StructType::HostIncompatibleForFaultTolerance => Some(from.as_any_ref().downcast_ref::<HostIncompatibleForFaultTolerance>()?),
            StructType::IncompatibleHostForFtSecondary => Some(from.as_any_ref().downcast_ref::<IncompatibleHostForFtSecondary>()?),
            StructType::InvalidOperationOnSecondaryVm => Some(from.as_any_ref().downcast_ref::<InvalidOperationOnSecondaryVm>()?),
            StructType::NoHostSuitableForFtSecondary => Some(from.as_any_ref().downcast_ref::<NoHostSuitableForFtSecondary>()?),
            StructType::NotSupportedDeviceForFt => Some(from.as_any_ref().downcast_ref::<NotSupportedDeviceForFt>()?),
            StructType::PowerOnFtSecondaryFailed => Some(from.as_any_ref().downcast_ref::<PowerOnFtSecondaryFailed>()?),
            StructType::SecondaryVmAlreadyDisabled => Some(from.as_any_ref().downcast_ref::<SecondaryVmAlreadyDisabled>()?),
            StructType::SecondaryVmAlreadyEnabled => Some(from.as_any_ref().downcast_ref::<SecondaryVmAlreadyEnabled>()?),
            StructType::SecondaryVmAlreadyRegistered => Some(from.as_any_ref().downcast_ref::<SecondaryVmAlreadyRegistered>()?),
            StructType::SecondaryVmNotRegistered => Some(from.as_any_ref().downcast_ref::<SecondaryVmNotRegistered>()?),
            StructType::VmFaultToleranceConfigIssue => Some(from.as_any_ref().downcast_ref::<VmFaultToleranceConfigIssue>()?),
            StructType::VmFaultToleranceConfigIssueWrapper => Some(from.as_any_ref().downcast_ref::<VmFaultToleranceConfigIssueWrapper>()?),
            StructType::VmFaultToleranceInvalidFileBacking => Some(from.as_any_ref().downcast_ref::<VmFaultToleranceInvalidFileBacking>()?),
            StructType::VmFaultToleranceOpIssuesList => Some(from.as_any_ref().downcast_ref::<VmFaultToleranceOpIssuesList>()?),
            StructType::VmMetadataManagerFault => Some(from.as_any_ref().downcast_ref::<VmMetadataManagerFault>()?),
            StructType::VmMonitorIncompatibleForFaultTolerance => Some(from.as_any_ref().downcast_ref::<VmMonitorIncompatibleForFaultTolerance>()?),
            StructType::VmToolsUpgradeFault => Some(from.as_any_ref().downcast_ref::<VmToolsUpgradeFault>()?),
            StructType::ToolsAlreadyUpgraded => Some(from.as_any_ref().downcast_ref::<ToolsAlreadyUpgraded>()?),
            StructType::ToolsAutoUpgradeNotSupported => Some(from.as_any_ref().downcast_ref::<ToolsAutoUpgradeNotSupported>()?),
            StructType::ToolsImageCopyFailed => Some(from.as_any_ref().downcast_ref::<ToolsImageCopyFailed>()?),
            StructType::ToolsImageNotAvailable => Some(from.as_any_ref().downcast_ref::<ToolsImageNotAvailable>()?),
            StructType::ToolsImageSignatureCheckFailed => Some(from.as_any_ref().downcast_ref::<ToolsImageSignatureCheckFailed>()?),
            StructType::ToolsUpgradeCancelled => Some(from.as_any_ref().downcast_ref::<ToolsUpgradeCancelled>()?),
            StructType::VmValidateMaxDevice => Some(from.as_any_ref().downcast_ref::<VmValidateMaxDevice>()?),
            StructType::VsanFault => Some(from.as_any_ref().downcast_ref::<VsanFault>()?),
            StructType::CannotChangeVsanClusterUuid => Some(from.as_any_ref().downcast_ref::<CannotChangeVsanClusterUuid>()?),
            StructType::CannotChangeVsanNodeUuid => Some(from.as_any_ref().downcast_ref::<CannotChangeVsanNodeUuid>()?),
            StructType::CannotMoveVsanEnabledHost => Some(from.as_any_ref().downcast_ref::<CannotMoveVsanEnabledHost>()?),
            StructType::DestinationVsanDisabled => Some(from.as_any_ref().downcast_ref::<DestinationVsanDisabled>()?),
            StructType::VsanClusterUuidMismatch => Some(from.as_any_ref().downcast_ref::<VsanClusterUuidMismatch>()?),
            StructType::CannotReconfigureVsanWhenHaEnabled => Some(from.as_any_ref().downcast_ref::<CannotReconfigureVsanWhenHaEnabled>()?),
            StructType::DuplicateVsanNetworkInterface => Some(from.as_any_ref().downcast_ref::<DuplicateVsanNetworkInterface>()?),
            StructType::VsanDiskFault => Some(from.as_any_ref().downcast_ref::<VsanDiskFault>()?),
            StructType::DiskHasPartitions => Some(from.as_any_ref().downcast_ref::<DiskHasPartitions>()?),
            StructType::DiskIsLastRemainingNonSsd => Some(from.as_any_ref().downcast_ref::<DiskIsLastRemainingNonSsd>()?),
            StructType::DiskIsNonLocal => Some(from.as_any_ref().downcast_ref::<DiskIsNonLocal>()?),
            StructType::DiskIsUsb => Some(from.as_any_ref().downcast_ref::<DiskIsUsb>()?),
            StructType::DiskTooSmall => Some(from.as_any_ref().downcast_ref::<DiskTooSmall>()?),
            StructType::DuplicateDisks => Some(from.as_any_ref().downcast_ref::<DuplicateDisks>()?),
            StructType::InsufficientDisks => Some(from.as_any_ref().downcast_ref::<InsufficientDisks>()?),
            StructType::VsanIncompatibleDiskMapping => Some(from.as_any_ref().downcast_ref::<VsanIncompatibleDiskMapping>()?),
            StructType::WipeDiskFault => Some(from.as_any_ref().downcast_ref::<WipeDiskFault>()?),
            StructType::RuntimeFault => Some(from.as_any_ref().downcast_ref::<RuntimeFault>()?),
            StructType::CannotDisableDrsOnClustersWithVApps => Some(from.as_any_ref().downcast_ref::<CannotDisableDrsOnClustersWithVApps>()?),
            StructType::ConflictingDatastoreFound => Some(from.as_any_ref().downcast_ref::<ConflictingDatastoreFound>()?),
            StructType::DatabaseError => Some(from.as_any_ref().downcast_ref::<DatabaseError>()?),
            StructType::DisallowedChangeByService => Some(from.as_any_ref().downcast_ref::<DisallowedChangeByService>()?),
            StructType::DisallowedOperationOnFailoverHost => Some(from.as_any_ref().downcast_ref::<DisallowedOperationOnFailoverHost>()?),
            StructType::FailToLockFaultToleranceVMs => Some(from.as_any_ref().downcast_ref::<FailToLockFaultToleranceVMs>()?),
            StructType::InvalidProfileReferenceHost => Some(from.as_any_ref().downcast_ref::<InvalidProfileReferenceHost>()?),
            StructType::InvalidScheduledTask => Some(from.as_any_ref().downcast_ref::<InvalidScheduledTask>()?),
            StructType::LicenseAssignmentFailed => Some(from.as_any_ref().downcast_ref::<LicenseAssignmentFailed>()?),
            StructType::MethodAlreadyDisabledFault => Some(from.as_any_ref().downcast_ref::<MethodAlreadyDisabledFault>()?),
            StructType::MethodDisabled => Some(from.as_any_ref().downcast_ref::<MethodDisabled>()?),
            StructType::OperationDisallowedOnHost => Some(from.as_any_ref().downcast_ref::<OperationDisallowedOnHost>()?),
            StructType::RestrictedByAdministrator => Some(from.as_any_ref().downcast_ref::<RestrictedByAdministrator>()?),
            StructType::ThirdPartyLicenseAssignmentFailed => Some(from.as_any_ref().downcast_ref::<ThirdPartyLicenseAssignmentFailed>()?),
            StructType::VAppOperationInProgress => Some(from.as_any_ref().downcast_ref::<VAppOperationInProgress>()?),
            StructType::HostCommunication => Some(from.as_any_ref().downcast_ref::<HostCommunication>()?),
            StructType::HostNotConnected => Some(from.as_any_ref().downcast_ref::<HostNotConnected>()?),
            StructType::HostNotReachable => Some(from.as_any_ref().downcast_ref::<HostNotReachable>()?),
            StructType::InvalidArgument => Some(from.as_any_ref().downcast_ref::<InvalidArgument>()?),
            StructType::IncompatibleSetting => Some(from.as_any_ref().downcast_ref::<IncompatibleSetting>()?),
            StructType::InvalidDasConfigArgument => Some(from.as_any_ref().downcast_ref::<InvalidDasConfigArgument>()?),
            StructType::InvalidDasRestartPriorityForFtVm => Some(from.as_any_ref().downcast_ref::<InvalidDasRestartPriorityForFtVm>()?),
            StructType::InvalidDrsBehaviorForFtVm => Some(from.as_any_ref().downcast_ref::<InvalidDrsBehaviorForFtVm>()?),
            StructType::InvalidIndexArgument => Some(from.as_any_ref().downcast_ref::<InvalidIndexArgument>()?),
            StructType::InvalidRequest => Some(from.as_any_ref().downcast_ref::<InvalidRequest>()?),
            StructType::InvalidType => Some(from.as_any_ref().downcast_ref::<InvalidType>()?),
            StructType::MethodNotFound => Some(from.as_any_ref().downcast_ref::<MethodNotFound>()?),
            StructType::ManagedObjectNotFound => Some(from.as_any_ref().downcast_ref::<ManagedObjectNotFound>()?),
            StructType::NotEnoughLicenses => Some(from.as_any_ref().downcast_ref::<NotEnoughLicenses>()?),
            StructType::ExpiredFeatureLicense => Some(from.as_any_ref().downcast_ref::<ExpiredFeatureLicense>()?),
            StructType::ExpiredAddonLicense => Some(from.as_any_ref().downcast_ref::<ExpiredAddonLicense>()?),
            StructType::ExpiredEditionLicense => Some(from.as_any_ref().downcast_ref::<ExpiredEditionLicense>()?),
            StructType::FailToEnableSpbm => Some(from.as_any_ref().downcast_ref::<FailToEnableSpbm>()?),
            StructType::HostInventoryFull => Some(from.as_any_ref().downcast_ref::<HostInventoryFull>()?),
            StructType::InUseFeatureManipulationDisallowed => Some(from.as_any_ref().downcast_ref::<InUseFeatureManipulationDisallowed>()?),
            StructType::IncorrectHostInformation => Some(from.as_any_ref().downcast_ref::<IncorrectHostInformation>()?),
            StructType::InvalidEditionLicense => Some(from.as_any_ref().downcast_ref::<InvalidEditionLicense>()?),
            StructType::InventoryHasStandardAloneHosts => Some(from.as_any_ref().downcast_ref::<InventoryHasStandardAloneHosts>()?),
            StructType::LicenseDowngradeDisallowed => Some(from.as_any_ref().downcast_ref::<LicenseDowngradeDisallowed>()?),
            StructType::LicenseExpired => Some(from.as_any_ref().downcast_ref::<LicenseExpired>()?),
            StructType::LicenseKeyEntityMismatch => Some(from.as_any_ref().downcast_ref::<LicenseKeyEntityMismatch>()?),
            StructType::LicenseRestricted => Some(from.as_any_ref().downcast_ref::<LicenseRestricted>()?),
            StructType::LicenseSourceUnavailable => Some(from.as_any_ref().downcast_ref::<LicenseSourceUnavailable>()?),
            StructType::NoLicenseServerConfigured => Some(from.as_any_ref().downcast_ref::<NoLicenseServerConfigured>()?),
            StructType::VmLimitLicense => Some(from.as_any_ref().downcast_ref::<VmLimitLicense>()?),
            StructType::VramLimitLicense => Some(from.as_any_ref().downcast_ref::<VramLimitLicense>()?),
            StructType::NotImplemented => Some(from.as_any_ref().downcast_ref::<NotImplemented>()?),
            StructType::NotSupported => Some(from.as_any_ref().downcast_ref::<NotSupported>()?),
            StructType::HostAccessRestrictedToManagementServer => Some(from.as_any_ref().downcast_ref::<HostAccessRestrictedToManagementServer>()?),
            StructType::RequestCanceled => Some(from.as_any_ref().downcast_ref::<RequestCanceled>()?),
            StructType::SecurityError => Some(from.as_any_ref().downcast_ref::<SecurityError>()?),
            StructType::NoPermission => Some(from.as_any_ref().downcast_ref::<NoPermission>()?),
            StructType::NotAuthenticated => Some(from.as_any_ref().downcast_ref::<NotAuthenticated>()?),
            StructType::RestrictedVersion => Some(from.as_any_ref().downcast_ref::<RestrictedVersion>()?),
            StructType::SolutionUserRequired => Some(from.as_any_ref().downcast_ref::<SolutionUserRequired>()?),
            StructType::SystemError => Some(from.as_any_ref().downcast_ref::<SystemError>()?),
            StructType::UnexpectedFault => Some(from.as_any_ref().downcast_ref::<UnexpectedFault>()?),
            StructType::InvalidCollectorVersion => Some(from.as_any_ref().downcast_ref::<InvalidCollectorVersion>()?),
            StructType::InvalidProperty => Some(from.as_any_ref().downcast_ref::<InvalidProperty>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::MethodFault => Ok(from.as_any_box().downcast::<MethodFault>()?),
            StructType::VimFault => Ok(from.as_any_box().downcast::<VimFault>()?),
            StructType::ActiveDirectoryFault => Ok(from.as_any_box().downcast::<ActiveDirectoryFault>()?),
            StructType::DomainNotFound => Ok(from.as_any_box().downcast::<DomainNotFound>()?),
            StructType::InvalidCamServer => Ok(from.as_any_box().downcast::<InvalidCamServer>()?),
            StructType::CamServerRefusedConnection => Ok(from.as_any_box().downcast::<CamServerRefusedConnection>()?),
            StructType::InvalidCamCertificate => Ok(from.as_any_box().downcast::<InvalidCamCertificate>()?),
            StructType::NoPermissionOnAd => Ok(from.as_any_box().downcast::<NoPermissionOnAd>()?),
            StructType::NonAdUserRequired => Ok(from.as_any_box().downcast::<NonAdUserRequired>()?),
            StructType::AlreadyExists => Ok(from.as_any_box().downcast::<AlreadyExists>()?),
            StructType::AlreadyUpgraded => Ok(from.as_any_box().downcast::<AlreadyUpgraded>()?),
            StructType::AnswerFileUpdateFailed => Ok(from.as_any_box().downcast::<AnswerFileUpdateFailed>()?),
            StructType::AuthMinimumAdminPermission => Ok(from.as_any_box().downcast::<AuthMinimumAdminPermission>()?),
            StructType::CannotAccessLocalSource => Ok(from.as_any_box().downcast::<CannotAccessLocalSource>()?),
            StructType::CannotDisconnectHostWithFaultToleranceVm => Ok(from.as_any_box().downcast::<CannotDisconnectHostWithFaultToleranceVm>()?),
            StructType::CannotEnableVmcpForCluster => Ok(from.as_any_box().downcast::<CannotEnableVmcpForCluster>()?),
            StructType::CannotMoveFaultToleranceVm => Ok(from.as_any_box().downcast::<CannotMoveFaultToleranceVm>()?),
            StructType::CannotMoveHostWithFaultToleranceVm => Ok(from.as_any_box().downcast::<CannotMoveHostWithFaultToleranceVm>()?),
            StructType::CannotPlaceWithoutPrerequisiteMoves => Ok(from.as_any_box().downcast::<CannotPlaceWithoutPrerequisiteMoves>()?),
            StructType::ConcurrentAccess => Ok(from.as_any_box().downcast::<ConcurrentAccess>()?),
            StructType::CustomizationFault => Ok(from.as_any_box().downcast::<CustomizationFault>()?),
            StructType::CannotDecryptPasswords => Ok(from.as_any_box().downcast::<CannotDecryptPasswords>()?),
            StructType::CustomizationPending => Ok(from.as_any_box().downcast::<CustomizationPending>()?),
            StructType::IpHostnameGeneratorError => Ok(from.as_any_box().downcast::<IpHostnameGeneratorError>()?),
            StructType::LinuxVolumeNotClean => Ok(from.as_any_box().downcast::<LinuxVolumeNotClean>()?),
            StructType::MissingLinuxCustResources => Ok(from.as_any_box().downcast::<MissingLinuxCustResources>()?),
            StructType::MissingWindowsCustResources => Ok(from.as_any_box().downcast::<MissingWindowsCustResources>()?),
            StructType::MountError => Ok(from.as_any_box().downcast::<MountError>()?),
            StructType::NicSettingMismatch => Ok(from.as_any_box().downcast::<NicSettingMismatch>()?),
            StructType::NoDisksToCustomize => Ok(from.as_any_box().downcast::<NoDisksToCustomize>()?),
            StructType::UncustomizableGuest => Ok(from.as_any_box().downcast::<UncustomizableGuest>()?),
            StructType::UnexpectedCustomizationFault => Ok(from.as_any_box().downcast::<UnexpectedCustomizationFault>()?),
            StructType::VolumeEditorError => Ok(from.as_any_box().downcast::<VolumeEditorError>()?),
            StructType::DasConfigFault => Ok(from.as_any_box().downcast::<DasConfigFault>()?),
            StructType::DrsDisabledOnVm => Ok(from.as_any_box().downcast::<DrsDisabledOnVm>()?),
            StructType::DuplicateName => Ok(from.as_any_box().downcast::<DuplicateName>()?),
            StructType::DvsFault => Ok(from.as_any_box().downcast::<DvsFault>()?),
            StructType::BackupBlobReadFailure => Ok(from.as_any_box().downcast::<BackupBlobReadFailure>()?),
            StructType::BackupBlobWriteFailure => Ok(from.as_any_box().downcast::<BackupBlobWriteFailure>()?),
            StructType::CollectorAddressUnset => Ok(from.as_any_box().downcast::<CollectorAddressUnset>()?),
            StructType::ConflictingConfiguration => Ok(from.as_any_box().downcast::<ConflictingConfiguration>()?),
            StructType::DvsApplyOperationFault => Ok(from.as_any_box().downcast::<DvsApplyOperationFault>()?),
            StructType::DvsNotAuthorized => Ok(from.as_any_box().downcast::<DvsNotAuthorized>()?),
            StructType::DvsOperationBulkFault => Ok(from.as_any_box().downcast::<DvsOperationBulkFault>()?),
            StructType::DvsScopeViolated => Ok(from.as_any_box().downcast::<DvsScopeViolated>()?),
            StructType::ImportHostAddFailure => Ok(from.as_any_box().downcast::<ImportHostAddFailure>()?),
            StructType::ImportOperationBulkFault => Ok(from.as_any_box().downcast::<ImportOperationBulkFault>()?),
            StructType::InvalidIpfixConfig => Ok(from.as_any_box().downcast::<InvalidIpfixConfig>()?),
            StructType::RollbackFailure => Ok(from.as_any_box().downcast::<RollbackFailure>()?),
            StructType::SwitchIpUnset => Ok(from.as_any_box().downcast::<SwitchIpUnset>()?),
            StructType::SwitchNotInUpgradeMode => Ok(from.as_any_box().downcast::<SwitchNotInUpgradeMode>()?),
            StructType::VspanDestPortConflict => Ok(from.as_any_box().downcast::<VspanDestPortConflict>()?),
            StructType::VspanPortConflict => Ok(from.as_any_box().downcast::<VspanPortConflict>()?),
            StructType::VspanPortMoveFault => Ok(from.as_any_box().downcast::<VspanPortMoveFault>()?),
            StructType::VspanPortPromiscChangeFault => Ok(from.as_any_box().downcast::<VspanPortPromiscChangeFault>()?),
            StructType::VspanPortgroupPromiscChangeFault => Ok(from.as_any_box().downcast::<VspanPortgroupPromiscChangeFault>()?),
            StructType::VspanPortgroupTypeChangeFault => Ok(from.as_any_box().downcast::<VspanPortgroupTypeChangeFault>()?),
            StructType::VspanPromiscuousPortNotSupported => Ok(from.as_any_box().downcast::<VspanPromiscuousPortNotSupported>()?),
            StructType::VspanSameSessionPortConflict => Ok(from.as_any_box().downcast::<VspanSameSessionPortConflict>()?),
            StructType::EvcConfigFault => Ok(from.as_any_box().downcast::<EvcConfigFault>()?),
            StructType::ActiveVMsBlockingEvc => Ok(from.as_any_box().downcast::<ActiveVMsBlockingEvc>()?),
            StructType::DisconnectedHostsBlockingEvc => Ok(from.as_any_box().downcast::<DisconnectedHostsBlockingEvc>()?),
            StructType::EvcModeIllegalByVendor => Ok(from.as_any_box().downcast::<EvcModeIllegalByVendor>()?),
            StructType::EvcModeUnsupportedByHosts => Ok(from.as_any_box().downcast::<EvcModeUnsupportedByHosts>()?),
            StructType::EvcUnsupportedByHostHardware => Ok(from.as_any_box().downcast::<EvcUnsupportedByHostHardware>()?),
            StructType::EvcUnsupportedByHostSoftware => Ok(from.as_any_box().downcast::<EvcUnsupportedByHostSoftware>()?),
            StructType::HeterogenousHostsBlockingEvc => Ok(from.as_any_box().downcast::<HeterogenousHostsBlockingEvc>()?),
            StructType::ExtendedFault => Ok(from.as_any_box().downcast::<ExtendedFault>()?),
            StructType::FaultToleranceVmNotDasProtected => Ok(from.as_any_box().downcast::<FaultToleranceVmNotDasProtected>()?),
            StructType::FcoeFault => Ok(from.as_any_box().downcast::<FcoeFault>()?),
            StructType::FcoeFaultPnicHasNoPortSet => Ok(from.as_any_box().downcast::<FcoeFaultPnicHasNoPortSet>()?),
            StructType::FileFault => Ok(from.as_any_box().downcast::<FileFault>()?),
            StructType::CannotAccessFile => Ok(from.as_any_box().downcast::<CannotAccessFile>()?),
            StructType::CannotCreateFile => Ok(from.as_any_box().downcast::<CannotCreateFile>()?),
            StructType::CannotDeleteFile => Ok(from.as_any_box().downcast::<CannotDeleteFile>()?),
            StructType::DirectoryNotEmpty => Ok(from.as_any_box().downcast::<DirectoryNotEmpty>()?),
            StructType::FileAlreadyExists => Ok(from.as_any_box().downcast::<FileAlreadyExists>()?),
            StructType::FileLocked => Ok(from.as_any_box().downcast::<FileLocked>()?),
            StructType::FileNameTooLong => Ok(from.as_any_box().downcast::<FileNameTooLong>()?),
            StructType::FileNotFound => Ok(from.as_any_box().downcast::<FileNotFound>()?),
            StructType::FileNotWritable => Ok(from.as_any_box().downcast::<FileNotWritable>()?),
            StructType::FileTooLarge => Ok(from.as_any_box().downcast::<FileTooLarge>()?),
            StructType::IncorrectFileType => Ok(from.as_any_box().downcast::<IncorrectFileType>()?),
            StructType::NetworkCopyFault => Ok(from.as_any_box().downcast::<NetworkCopyFault>()?),
            StructType::NoDiskSpace => Ok(from.as_any_box().downcast::<NoDiskSpace>()?),
            StructType::NotADirectory => Ok(from.as_any_box().downcast::<NotADirectory>()?),
            StructType::NotAFile => Ok(from.as_any_box().downcast::<NotAFile>()?),
            StructType::TooManyConcurrentNativeClones => Ok(from.as_any_box().downcast::<TooManyConcurrentNativeClones>()?),
            StructType::TooManyNativeCloneLevels => Ok(from.as_any_box().downcast::<TooManyNativeCloneLevels>()?),
            StructType::TooManyNativeClonesOnFile => Ok(from.as_any_box().downcast::<TooManyNativeClonesOnFile>()?),
            StructType::GenericDrsFault => Ok(from.as_any_box().downcast::<GenericDrsFault>()?),
            StructType::GuestOperationsFault => Ok(from.as_any_box().downcast::<GuestOperationsFault>()?),
            StructType::GuestAuthenticationChallenge => Ok(from.as_any_box().downcast::<GuestAuthenticationChallenge>()?),
            StructType::GuestComponentsOutOfDate => Ok(from.as_any_box().downcast::<GuestComponentsOutOfDate>()?),
            StructType::GuestMultipleMappings => Ok(from.as_any_box().downcast::<GuestMultipleMappings>()?),
            StructType::GuestOperationsUnavailable => Ok(from.as_any_box().downcast::<GuestOperationsUnavailable>()?),
            StructType::GuestPermissionDenied => Ok(from.as_any_box().downcast::<GuestPermissionDenied>()?),
            StructType::GuestProcessNotFound => Ok(from.as_any_box().downcast::<GuestProcessNotFound>()?),
            StructType::GuestRegistryFault => Ok(from.as_any_box().downcast::<GuestRegistryFault>()?),
            StructType::GuestRegistryKeyFault => Ok(from.as_any_box().downcast::<GuestRegistryKeyFault>()?),
            StructType::GuestRegistryKeyAlreadyExists => Ok(from.as_any_box().downcast::<GuestRegistryKeyAlreadyExists>()?),
            StructType::GuestRegistryKeyHasSubkeys => Ok(from.as_any_box().downcast::<GuestRegistryKeyHasSubkeys>()?),
            StructType::GuestRegistryKeyInvalid => Ok(from.as_any_box().downcast::<GuestRegistryKeyInvalid>()?),
            StructType::GuestRegistryKeyParentVolatile => Ok(from.as_any_box().downcast::<GuestRegistryKeyParentVolatile>()?),
            StructType::GuestRegistryValueFault => Ok(from.as_any_box().downcast::<GuestRegistryValueFault>()?),
            StructType::GuestRegistryValueNotFound => Ok(from.as_any_box().downcast::<GuestRegistryValueNotFound>()?),
            StructType::InvalidGuestLogin => Ok(from.as_any_box().downcast::<InvalidGuestLogin>()?),
            StructType::OperationDisabledByGuest => Ok(from.as_any_box().downcast::<OperationDisabledByGuest>()?),
            StructType::OperationNotSupportedByGuest => Ok(from.as_any_box().downcast::<OperationNotSupportedByGuest>()?),
            StructType::TooManyGuestLogons => Ok(from.as_any_box().downcast::<TooManyGuestLogons>()?),
            StructType::HostConfigFault => Ok(from.as_any_box().downcast::<HostConfigFault>()?),
            StructType::AdminDisabled => Ok(from.as_any_box().downcast::<AdminDisabled>()?),
            StructType::AdminNotDisabled => Ok(from.as_any_box().downcast::<AdminNotDisabled>()?),
            StructType::BlockedByFirewall => Ok(from.as_any_box().downcast::<BlockedByFirewall>()?),
            StructType::ClockSkew => Ok(from.as_any_box().downcast::<ClockSkew>()?),
            StructType::DisableAdminNotSupported => Ok(from.as_any_box().downcast::<DisableAdminNotSupported>()?),
            StructType::HostConfigFailed => Ok(from.as_any_box().downcast::<HostConfigFailed>()?),
            StructType::HostInDomain => Ok(from.as_any_box().downcast::<HostInDomain>()?),
            StructType::InvalidHostName => Ok(from.as_any_box().downcast::<InvalidHostName>()?),
            StructType::NasConfigFault => Ok(from.as_any_box().downcast::<NasConfigFault>()?),
            StructType::InvalidNasCredentials => Ok(from.as_any_box().downcast::<InvalidNasCredentials>()?),
            StructType::InvalidNetworkResource => Ok(from.as_any_box().downcast::<InvalidNetworkResource>()?),
            StructType::NasConnectionLimitReached => Ok(from.as_any_box().downcast::<NasConnectionLimitReached>()?),
            StructType::NasSessionCredentialConflict => Ok(from.as_any_box().downcast::<NasSessionCredentialConflict>()?),
            StructType::NasVolumeNotMounted => Ok(from.as_any_box().downcast::<NasVolumeNotMounted>()?),
            StructType::NetworkInaccessible => Ok(from.as_any_box().downcast::<NetworkInaccessible>()?),
            StructType::NoPermissionOnNasVolume => Ok(from.as_any_box().downcast::<NoPermissionOnNasVolume>()?),
            StructType::NoGateway => Ok(from.as_any_box().downcast::<NoGateway>()?),
            StructType::NoVirtualNic => Ok(from.as_any_box().downcast::<NoVirtualNic>()?),
            StructType::PlatformConfigFault => Ok(from.as_any_box().downcast::<PlatformConfigFault>()?),
            StructType::InvalidBundle => Ok(from.as_any_box().downcast::<InvalidBundle>()?),
            StructType::PatchInstallFailed => Ok(from.as_any_box().downcast::<PatchInstallFailed>()?),
            StructType::PatchIntegrityError => Ok(from.as_any_box().downcast::<PatchIntegrityError>()?),
            StructType::VmfsMountFault => Ok(from.as_any_box().downcast::<VmfsMountFault>()?),
            StructType::VmfsAlreadyMounted => Ok(from.as_any_box().downcast::<VmfsAlreadyMounted>()?),
            StructType::VmfsAmbiguousMount => Ok(from.as_any_box().downcast::<VmfsAmbiguousMount>()?),
            StructType::HostConnectFault => Ok(from.as_any_box().downcast::<HostConnectFault>()?),
            StructType::AgentInstallFailed => Ok(from.as_any_box().downcast::<AgentInstallFailed>()?),
            StructType::AlreadyBeingManaged => Ok(from.as_any_box().downcast::<AlreadyBeingManaged>()?),
            StructType::AlreadyConnected => Ok(from.as_any_box().downcast::<AlreadyConnected>()?),
            StructType::CannotAddHostWithFtVmAsStandalone => Ok(from.as_any_box().downcast::<CannotAddHostWithFtVmAsStandalone>()?),
            StructType::CannotAddHostWithFtVmToDifferentCluster => Ok(from.as_any_box().downcast::<CannotAddHostWithFtVmToDifferentCluster>()?),
            StructType::CannotAddHostWithFtVmToNonHaCluster => Ok(from.as_any_box().downcast::<CannotAddHostWithFtVmToNonHaCluster>()?),
            StructType::GatewayConnectFault => Ok(from.as_any_box().downcast::<GatewayConnectFault>()?),
            StructType::GatewayNotFound => Ok(from.as_any_box().downcast::<GatewayNotFound>()?),
            StructType::GatewayNotReachable => Ok(from.as_any_box().downcast::<GatewayNotReachable>()?),
            StructType::GatewayOperationRefused => Ok(from.as_any_box().downcast::<GatewayOperationRefused>()?),
            StructType::GatewayToHostConnectFault => Ok(from.as_any_box().downcast::<GatewayToHostConnectFault>()?),
            StructType::GatewayHostNotReachable => Ok(from.as_any_box().downcast::<GatewayHostNotReachable>()?),
            StructType::GatewayToHostAuthFault => Ok(from.as_any_box().downcast::<GatewayToHostAuthFault>()?),
            StructType::GatewayToHostTrustVerifyFault => Ok(from.as_any_box().downcast::<GatewayToHostTrustVerifyFault>()?),
            StructType::MultipleCertificatesVerifyFault => Ok(from.as_any_box().downcast::<MultipleCertificatesVerifyFault>()?),
            StructType::NoHost => Ok(from.as_any_box().downcast::<NoHost>()?),
            StructType::NoPermissionOnHost => Ok(from.as_any_box().downcast::<NoPermissionOnHost>()?),
            StructType::NotSupportedHost => Ok(from.as_any_box().downcast::<NotSupportedHost>()?),
            StructType::NonVmwareOuiMacNotSupportedHost => Ok(from.as_any_box().downcast::<NonVmwareOuiMacNotSupportedHost>()?),
            StructType::NotSupportedHostForVFlash => Ok(from.as_any_box().downcast::<NotSupportedHostForVFlash>()?),
            StructType::NotSupportedHostForVmcp => Ok(from.as_any_box().downcast::<NotSupportedHostForVmcp>()?),
            StructType::NotSupportedHostForVmemFile => Ok(from.as_any_box().downcast::<NotSupportedHostForVmemFile>()?),
            StructType::NotSupportedHostForVsan => Ok(from.as_any_box().downcast::<NotSupportedHostForVsan>()?),
            StructType::NotSupportedHostInCluster => Ok(from.as_any_box().downcast::<NotSupportedHostInCluster>()?),
            StructType::EvcAdmissionFailed => Ok(from.as_any_box().downcast::<EvcAdmissionFailed>()?),
            StructType::EvcAdmissionFailedCpuFeaturesForMode => Ok(from.as_any_box().downcast::<EvcAdmissionFailedCpuFeaturesForMode>()?),
            StructType::EvcAdmissionFailedCpuModel => Ok(from.as_any_box().downcast::<EvcAdmissionFailedCpuModel>()?),
            StructType::EvcAdmissionFailedCpuModelForMode => Ok(from.as_any_box().downcast::<EvcAdmissionFailedCpuModelForMode>()?),
            StructType::EvcAdmissionFailedCpuVendor => Ok(from.as_any_box().downcast::<EvcAdmissionFailedCpuVendor>()?),
            StructType::EvcAdmissionFailedCpuVendorUnknown => Ok(from.as_any_box().downcast::<EvcAdmissionFailedCpuVendorUnknown>()?),
            StructType::EvcAdmissionFailedHostDisconnected => Ok(from.as_any_box().downcast::<EvcAdmissionFailedHostDisconnected>()?),
            StructType::EvcAdmissionFailedHostSoftware => Ok(from.as_any_box().downcast::<EvcAdmissionFailedHostSoftware>()?),
            StructType::EvcAdmissionFailedHostSoftwareForMode => Ok(from.as_any_box().downcast::<EvcAdmissionFailedHostSoftwareForMode>()?),
            StructType::EvcAdmissionFailedVmActive => Ok(from.as_any_box().downcast::<EvcAdmissionFailedVmActive>()?),
            StructType::NotSupportedHostInDvs => Ok(from.as_any_box().downcast::<NotSupportedHostInDvs>()?),
            StructType::NotSupportedHostInHaCluster => Ok(from.as_any_box().downcast::<NotSupportedHostInHaCluster>()?),
            StructType::ReadHostResourcePoolTreeFailed => Ok(from.as_any_box().downcast::<ReadHostResourcePoolTreeFailed>()?),
            StructType::SslDisabledFault => Ok(from.as_any_box().downcast::<SslDisabledFault>()?),
            StructType::SslVerifyFault => Ok(from.as_any_box().downcast::<SslVerifyFault>()?),
            StructType::TooManyHosts => Ok(from.as_any_box().downcast::<TooManyHosts>()?),
            StructType::HostHasComponentFailure => Ok(from.as_any_box().downcast::<HostHasComponentFailure>()?),
            StructType::HostIncompatibleForRecordReplay => Ok(from.as_any_box().downcast::<HostIncompatibleForRecordReplay>()?),
            StructType::HostPowerOpFailed => Ok(from.as_any_box().downcast::<HostPowerOpFailed>()?),
            StructType::NoPeerHostFound => Ok(from.as_any_box().downcast::<NoPeerHostFound>()?),
            StructType::VmotionInterfaceNotEnabled => Ok(from.as_any_box().downcast::<VmotionInterfaceNotEnabled>()?),
            StructType::WakeOnLanNotSupportedByVmotionNic => Ok(from.as_any_box().downcast::<WakeOnLanNotSupportedByVmotionNic>()?),
            StructType::HostSpecificationOperationFailed => Ok(from.as_any_box().downcast::<HostSpecificationOperationFailed>()?),
            StructType::HttpFault => Ok(from.as_any_box().downcast::<HttpFault>()?),
            StructType::IormNotSupportedHostOnDatastore => Ok(from.as_any_box().downcast::<IormNotSupportedHostOnDatastore>()?),
            StructType::InaccessibleVFlashSource => Ok(from.as_any_box().downcast::<InaccessibleVFlashSource>()?),
            StructType::InsufficientResourcesFault => Ok(from.as_any_box().downcast::<InsufficientResourcesFault>()?),
            StructType::InsufficientAgentVmsDeployed => Ok(from.as_any_box().downcast::<InsufficientAgentVmsDeployed>()?),
            StructType::InsufficientCpuResourcesFault => Ok(from.as_any_box().downcast::<InsufficientCpuResourcesFault>()?),
            StructType::InsufficientFailoverResourcesFault => Ok(from.as_any_box().downcast::<InsufficientFailoverResourcesFault>()?),
            StructType::InsufficientGraphicsResourcesFault => Ok(from.as_any_box().downcast::<InsufficientGraphicsResourcesFault>()?),
            StructType::InsufficientHostCapacityFault => Ok(from.as_any_box().downcast::<InsufficientHostCapacityFault>()?),
            StructType::InsufficientHostCpuCapacityFault => Ok(from.as_any_box().downcast::<InsufficientHostCpuCapacityFault>()?),
            StructType::InsufficientHostMemoryCapacityFault => Ok(from.as_any_box().downcast::<InsufficientHostMemoryCapacityFault>()?),
            StructType::InsufficientPerCpuCapacity => Ok(from.as_any_box().downcast::<InsufficientPerCpuCapacity>()?),
            StructType::InsufficientMemoryResourcesFault => Ok(from.as_any_box().downcast::<InsufficientMemoryResourcesFault>()?),
            StructType::InsufficientNetworkCapacity => Ok(from.as_any_box().downcast::<InsufficientNetworkCapacity>()?),
            StructType::InsufficientNetworkResourcePoolCapacity => Ok(from.as_any_box().downcast::<InsufficientNetworkResourcePoolCapacity>()?),
            StructType::InsufficientStandbyResource => Ok(from.as_any_box().downcast::<InsufficientStandbyResource>()?),
            StructType::InsufficientStandbyCpuResource => Ok(from.as_any_box().downcast::<InsufficientStandbyCpuResource>()?),
            StructType::InsufficientStandbyMemoryResource => Ok(from.as_any_box().downcast::<InsufficientStandbyMemoryResource>()?),
            StructType::InsufficientStorageSpace => Ok(from.as_any_box().downcast::<InsufficientStorageSpace>()?),
            StructType::InsufficientVFlashResourcesFault => Ok(from.as_any_box().downcast::<InsufficientVFlashResourcesFault>()?),
            StructType::InvalidResourcePoolStructureFault => Ok(from.as_any_box().downcast::<InvalidResourcePoolStructureFault>()?),
            StructType::NumVirtualCpusExceedsLimit => Ok(from.as_any_box().downcast::<NumVirtualCpusExceedsLimit>()?),
            StructType::VmFaultToleranceTooManyFtVcpusOnHost => Ok(from.as_any_box().downcast::<VmFaultToleranceTooManyFtVcpusOnHost>()?),
            StructType::VmFaultToleranceTooManyVMsOnHost => Ok(from.as_any_box().downcast::<VmFaultToleranceTooManyVMsOnHost>()?),
            StructType::VmSmpFaultToleranceTooManyVMsOnHost => Ok(from.as_any_box().downcast::<VmSmpFaultToleranceTooManyVMsOnHost>()?),
            StructType::InsufficientStorageIops => Ok(from.as_any_box().downcast::<InsufficientStorageIops>()?),
            StructType::InvalidAffinitySettingFault => Ok(from.as_any_box().downcast::<InvalidAffinitySettingFault>()?),
            StructType::InvalidBmcRole => Ok(from.as_any_box().downcast::<InvalidBmcRole>()?),
            StructType::InvalidDatastore => Ok(from.as_any_box().downcast::<InvalidDatastore>()?),
            StructType::DatastoreNotWritableOnHost => Ok(from.as_any_box().downcast::<DatastoreNotWritableOnHost>()?),
            StructType::SwapDatastoreNotWritableOnHost => Ok(from.as_any_box().downcast::<SwapDatastoreNotWritableOnHost>()?),
            StructType::InaccessibleDatastore => Ok(from.as_any_box().downcast::<InaccessibleDatastore>()?),
            StructType::InaccessibleFtMetadataDatastore => Ok(from.as_any_box().downcast::<InaccessibleFtMetadataDatastore>()?),
            StructType::InvalidDatastorePath => Ok(from.as_any_box().downcast::<InvalidDatastorePath>()?),
            StructType::InvalidEvent => Ok(from.as_any_box().downcast::<InvalidEvent>()?),
            StructType::InvalidFolder => Ok(from.as_any_box().downcast::<InvalidFolder>()?),
            StructType::VmAlreadyExistsInDatacenter => Ok(from.as_any_box().downcast::<VmAlreadyExistsInDatacenter>()?),
            StructType::InvalidIpmiLoginInfo => Ok(from.as_any_box().downcast::<InvalidIpmiLoginInfo>()?),
            StructType::InvalidIpmiMacAddress => Ok(from.as_any_box().downcast::<InvalidIpmiMacAddress>()?),
            StructType::InvalidLicense => Ok(from.as_any_box().downcast::<InvalidLicense>()?),
            StructType::InvalidLocale => Ok(from.as_any_box().downcast::<InvalidLocale>()?),
            StructType::InvalidLogin => Ok(from.as_any_box().downcast::<InvalidLogin>()?),
            StructType::InvalidClientCertificate => Ok(from.as_any_box().downcast::<InvalidClientCertificate>()?),
            StructType::PasswordExpired => Ok(from.as_any_box().downcast::<PasswordExpired>()?),
            StructType::InvalidName => Ok(from.as_any_box().downcast::<InvalidName>()?),
            StructType::InvalidPrivilege => Ok(from.as_any_box().downcast::<InvalidPrivilege>()?),
            StructType::InvalidState => Ok(from.as_any_box().downcast::<InvalidState>()?),
            StructType::CannotPowerOffVmInCluster => Ok(from.as_any_box().downcast::<CannotPowerOffVmInCluster>()?),
            StructType::EncryptionKeyRequired => Ok(from.as_any_box().downcast::<EncryptionKeyRequired>()?),
            StructType::InvalidDatastoreState => Ok(from.as_any_box().downcast::<InvalidDatastoreState>()?),
            StructType::InvalidHostState => Ok(from.as_any_box().downcast::<InvalidHostState>()?),
            StructType::InvalidHostConnectionState => Ok(from.as_any_box().downcast::<InvalidHostConnectionState>()?),
            StructType::InvalidPowerState => Ok(from.as_any_box().downcast::<InvalidPowerState>()?),
            StructType::InvalidVmState => Ok(from.as_any_box().downcast::<InvalidVmState>()?),
            StructType::MksConnectionLimitReached => Ok(from.as_any_box().downcast::<MksConnectionLimitReached>()?),
            StructType::NoActiveHostInCluster => Ok(from.as_any_box().downcast::<NoActiveHostInCluster>()?),
            StructType::OvfConsumerPowerOnFault => Ok(from.as_any_box().downcast::<OvfConsumerPowerOnFault>()?),
            StructType::QuestionPending => Ok(from.as_any_box().downcast::<QuestionPending>()?),
            StructType::VmPowerOnDisabled => Ok(from.as_any_box().downcast::<VmPowerOnDisabled>()?),
            StructType::IscsiFault => Ok(from.as_any_box().downcast::<IscsiFault>()?),
            StructType::IscsiFaultInvalidVnic => Ok(from.as_any_box().downcast::<IscsiFaultInvalidVnic>()?),
            StructType::IscsiFaultPnicInUse => Ok(from.as_any_box().downcast::<IscsiFaultPnicInUse>()?),
            StructType::IscsiFaultVnicAlreadyBound => Ok(from.as_any_box().downcast::<IscsiFaultVnicAlreadyBound>()?),
            StructType::IscsiFaultVnicHasActivePaths => Ok(from.as_any_box().downcast::<IscsiFaultVnicHasActivePaths>()?),
            StructType::IscsiFaultVnicHasMultipleUplinks => Ok(from.as_any_box().downcast::<IscsiFaultVnicHasMultipleUplinks>()?),
            StructType::IscsiFaultVnicHasNoUplinks => Ok(from.as_any_box().downcast::<IscsiFaultVnicHasNoUplinks>()?),
            StructType::IscsiFaultVnicHasWrongUplink => Ok(from.as_any_box().downcast::<IscsiFaultVnicHasWrongUplink>()?),
            StructType::IscsiFaultVnicInUse => Ok(from.as_any_box().downcast::<IscsiFaultVnicInUse>()?),
            StructType::IscsiFaultVnicIsLastPath => Ok(from.as_any_box().downcast::<IscsiFaultVnicIsLastPath>()?),
            StructType::IscsiFaultVnicNotBound => Ok(from.as_any_box().downcast::<IscsiFaultVnicNotBound>()?),
            StructType::IscsiFaultVnicNotFound => Ok(from.as_any_box().downcast::<IscsiFaultVnicNotFound>()?),
            StructType::KeyNotFound => Ok(from.as_any_box().downcast::<KeyNotFound>()?),
            StructType::LicenseEntityNotFound => Ok(from.as_any_box().downcast::<LicenseEntityNotFound>()?),
            StructType::LicenseServerUnavailable => Ok(from.as_any_box().downcast::<LicenseServerUnavailable>()?),
            StructType::LimitExceeded => Ok(from.as_any_box().downcast::<LimitExceeded>()?),
            StructType::LogBundlingFailed => Ok(from.as_any_box().downcast::<LogBundlingFailed>()?),
            StructType::MigrationFault => Ok(from.as_any_box().downcast::<MigrationFault>()?),
            StructType::AffinityConfigured => Ok(from.as_any_box().downcast::<AffinityConfigured>()?),
            StructType::CannotModifyConfigCpuRequirements => Ok(from.as_any_box().downcast::<CannotModifyConfigCpuRequirements>()?),
            StructType::CannotMoveVmWithDeltaDisk => Ok(from.as_any_box().downcast::<CannotMoveVmWithDeltaDisk>()?),
            StructType::CannotMoveVmWithNativeDeltaDisk => Ok(from.as_any_box().downcast::<CannotMoveVmWithNativeDeltaDisk>()?),
            StructType::CloneFromSnapshotNotSupported => Ok(from.as_any_box().downcast::<CloneFromSnapshotNotSupported>()?),
            StructType::DatacenterMismatch => Ok(from.as_any_box().downcast::<DatacenterMismatch>()?),
            StructType::DisallowedMigrationDeviceAttached => Ok(from.as_any_box().downcast::<DisallowedMigrationDeviceAttached>()?),
            StructType::DiskMoveTypeNotSupported => Ok(from.as_any_box().downcast::<DiskMoveTypeNotSupported>()?),
            StructType::FaultToleranceAntiAffinityViolated => Ok(from.as_any_box().downcast::<FaultToleranceAntiAffinityViolated>()?),
            StructType::FaultToleranceNeedsThickDisk => Ok(from.as_any_box().downcast::<FaultToleranceNeedsThickDisk>()?),
            StructType::FaultToleranceNotSameBuild => Ok(from.as_any_box().downcast::<FaultToleranceNotSameBuild>()?),
            StructType::HaErrorsAtDest => Ok(from.as_any_box().downcast::<HaErrorsAtDest>()?),
            StructType::IncompatibleDefaultDevice => Ok(from.as_any_box().downcast::<IncompatibleDefaultDevice>()?),
            StructType::LargeRdmConversionNotSupported => Ok(from.as_any_box().downcast::<LargeRdmConversionNotSupported>()?),
            StructType::MaintenanceModeFileMove => Ok(from.as_any_box().downcast::<MaintenanceModeFileMove>()?),
            StructType::MigrationDisabled => Ok(from.as_any_box().downcast::<MigrationDisabled>()?),
            StructType::MigrationFeatureNotSupported => Ok(from.as_any_box().downcast::<MigrationFeatureNotSupported>()?),
            StructType::FullStorageVMotionNotSupported => Ok(from.as_any_box().downcast::<FullStorageVMotionNotSupported>()?),
            StructType::IndependentDiskVMotionNotSupported => Ok(from.as_any_box().downcast::<IndependentDiskVMotionNotSupported>()?),
            StructType::NonHomeRdmvMotionNotSupported => Ok(from.as_any_box().downcast::<NonHomeRdmvMotionNotSupported>()?),
            StructType::StorageVMotionNotSupported => Ok(from.as_any_box().downcast::<StorageVMotionNotSupported>()?),
            StructType::UnsharedSwapVMotionNotSupported => Ok(from.as_any_box().downcast::<UnsharedSwapVMotionNotSupported>()?),
            StructType::VMotionAcrossNetworkNotSupported => Ok(from.as_any_box().downcast::<VMotionAcrossNetworkNotSupported>()?),
            StructType::MigrationNotReady => Ok(from.as_any_box().downcast::<MigrationNotReady>()?),
            StructType::MismatchedNetworkPolicies => Ok(from.as_any_box().downcast::<MismatchedNetworkPolicies>()?),
            StructType::MismatchedVMotionNetworkNames => Ok(from.as_any_box().downcast::<MismatchedVMotionNetworkNames>()?),
            StructType::NetworksMayNotBeTheSame => Ok(from.as_any_box().downcast::<NetworksMayNotBeTheSame>()?),
            StructType::NoGuestHeartbeat => Ok(from.as_any_box().downcast::<NoGuestHeartbeat>()?),
            StructType::RdmConversionNotSupported => Ok(from.as_any_box().downcast::<RdmConversionNotSupported>()?),
            StructType::RdmNotPreserved => Ok(from.as_any_box().downcast::<RdmNotPreserved>()?),
            StructType::ReadOnlyDisksWithLegacyDestination => Ok(from.as_any_box().downcast::<ReadOnlyDisksWithLegacyDestination>()?),
            StructType::SnapshotCopyNotSupported => Ok(from.as_any_box().downcast::<SnapshotCopyNotSupported>()?),
            StructType::HotSnapshotMoveNotSupported => Ok(from.as_any_box().downcast::<HotSnapshotMoveNotSupported>()?),
            StructType::SnapshotCloneNotSupported => Ok(from.as_any_box().downcast::<SnapshotCloneNotSupported>()?),
            StructType::SnapshotMoveFromNonHomeNotSupported => Ok(from.as_any_box().downcast::<SnapshotMoveFromNonHomeNotSupported>()?),
            StructType::SnapshotMoveNotSupported => Ok(from.as_any_box().downcast::<SnapshotMoveNotSupported>()?),
            StructType::SnapshotMoveToNonHomeNotSupported => Ok(from.as_any_box().downcast::<SnapshotMoveToNonHomeNotSupported>()?),
            StructType::SnapshotRevertIssue => Ok(from.as_any_box().downcast::<SnapshotRevertIssue>()?),
            StructType::SuspendedRelocateNotSupported => Ok(from.as_any_box().downcast::<SuspendedRelocateNotSupported>()?),
            StructType::TooManyDisksOnLegacyHost => Ok(from.as_any_box().downcast::<TooManyDisksOnLegacyHost>()?),
            StructType::ToolsInstallationInProgress => Ok(from.as_any_box().downcast::<ToolsInstallationInProgress>()?),
            StructType::UncommittedUndoableDisk => Ok(from.as_any_box().downcast::<UncommittedUndoableDisk>()?),
            StructType::VMotionInterfaceIssue => Ok(from.as_any_box().downcast::<VMotionInterfaceIssue>()?),
            StructType::VMotionLinkCapacityLow => Ok(from.as_any_box().downcast::<VMotionLinkCapacityLow>()?),
            StructType::VMotionLinkDown => Ok(from.as_any_box().downcast::<VMotionLinkDown>()?),
            StructType::VMotionNotConfigured => Ok(from.as_any_box().downcast::<VMotionNotConfigured>()?),
            StructType::VMotionNotLicensed => Ok(from.as_any_box().downcast::<VMotionNotLicensed>()?),
            StructType::VMotionNotSupported => Ok(from.as_any_box().downcast::<VMotionNotSupported>()?),
            StructType::VMotionProtocolIncompatible => Ok(from.as_any_box().downcast::<VMotionProtocolIncompatible>()?),
            StructType::WillLoseHaProtection => Ok(from.as_any_box().downcast::<WillLoseHaProtection>()?),
            StructType::WillModifyConfigCpuRequirements => Ok(from.as_any_box().downcast::<WillModifyConfigCpuRequirements>()?),
            StructType::WillResetSnapshotDirectory => Ok(from.as_any_box().downcast::<WillResetSnapshotDirectory>()?),
            StructType::MismatchedBundle => Ok(from.as_any_box().downcast::<MismatchedBundle>()?),
            StructType::MissingBmcSupport => Ok(from.as_any_box().downcast::<MissingBmcSupport>()?),
            StructType::NamespaceFull => Ok(from.as_any_box().downcast::<NamespaceFull>()?),
            StructType::NamespaceLimitReached => Ok(from.as_any_box().downcast::<NamespaceLimitReached>()?),
            StructType::NamespaceWriteProtected => Ok(from.as_any_box().downcast::<NamespaceWriteProtected>()?),
            StructType::NetworkDisruptedAndConfigRolledBack => Ok(from.as_any_box().downcast::<NetworkDisruptedAndConfigRolledBack>()?),
            StructType::NoClientCertificate => Ok(from.as_any_box().downcast::<NoClientCertificate>()?),
            StructType::NoCompatibleDatastore => Ok(from.as_any_box().downcast::<NoCompatibleDatastore>()?),
            StructType::NoCompatibleHost => Ok(from.as_any_box().downcast::<NoCompatibleHost>()?),
            StructType::NoCompatibleHostWithAccessToDevice => Ok(from.as_any_box().downcast::<NoCompatibleHostWithAccessToDevice>()?),
            StructType::NoConnectedDatastore => Ok(from.as_any_box().downcast::<NoConnectedDatastore>()?),
            StructType::NoDiskFound => Ok(from.as_any_box().downcast::<NoDiskFound>()?),
            StructType::NoSubjectName => Ok(from.as_any_box().downcast::<NoSubjectName>()?),
            StructType::NotFound => Ok(from.as_any_box().downcast::<NotFound>()?),
            StructType::NotSupportedHostForChecksum => Ok(from.as_any_box().downcast::<NotSupportedHostForChecksum>()?),
            StructType::OutOfBounds => Ok(from.as_any_box().downcast::<OutOfBounds>()?),
            StructType::OvfFault => Ok(from.as_any_box().downcast::<OvfFault>()?),
            StructType::OvfConsumerCallbackFault => Ok(from.as_any_box().downcast::<OvfConsumerCallbackFault>()?),
            StructType::OvfConsumerCommunicationError => Ok(from.as_any_box().downcast::<OvfConsumerCommunicationError>()?),
            StructType::OvfConsumerFault => Ok(from.as_any_box().downcast::<OvfConsumerFault>()?),
            StructType::OvfConsumerInvalidSection => Ok(from.as_any_box().downcast::<OvfConsumerInvalidSection>()?),
            StructType::OvfConsumerUndeclaredSection => Ok(from.as_any_box().downcast::<OvfConsumerUndeclaredSection>()?),
            StructType::OvfConsumerUndefinedPrefix => Ok(from.as_any_box().downcast::<OvfConsumerUndefinedPrefix>()?),
            StructType::OvfExport => Ok(from.as_any_box().downcast::<OvfExport>()?),
            StructType::ConnectedIso => Ok(from.as_any_box().downcast::<ConnectedIso>()?),
            StructType::OvfDuplicatedPropertyIdExport => Ok(from.as_any_box().downcast::<OvfDuplicatedPropertyIdExport>()?),
            StructType::OvfDuplicatedPropertyIdImport => Ok(from.as_any_box().downcast::<OvfDuplicatedPropertyIdImport>()?),
            StructType::OvfExportFailed => Ok(from.as_any_box().downcast::<OvfExportFailed>()?),
            StructType::OvfHardwareExport => Ok(from.as_any_box().downcast::<OvfHardwareExport>()?),
            StructType::OvfConnectedDevice => Ok(from.as_any_box().downcast::<OvfConnectedDevice>()?),
            StructType::OvfConnectedDeviceFloppy => Ok(from.as_any_box().downcast::<OvfConnectedDeviceFloppy>()?),
            StructType::OvfConnectedDeviceIso => Ok(from.as_any_box().downcast::<OvfConnectedDeviceIso>()?),
            StructType::OvfUnableToExportDisk => Ok(from.as_any_box().downcast::<OvfUnableToExportDisk>()?),
            StructType::OvfUnknownDeviceBacking => Ok(from.as_any_box().downcast::<OvfUnknownDeviceBacking>()?),
            StructType::OvfUnsupportedDeviceExport => Ok(from.as_any_box().downcast::<OvfUnsupportedDeviceExport>()?),
            StructType::OvfPropertyExport => Ok(from.as_any_box().downcast::<OvfPropertyExport>()?),
            StructType::OvfPropertyNetworkExport => Ok(from.as_any_box().downcast::<OvfPropertyNetworkExport>()?),
            StructType::OvfImport => Ok(from.as_any_box().downcast::<OvfImport>()?),
            StructType::OvfCpuCompatibility => Ok(from.as_any_box().downcast::<OvfCpuCompatibility>()?),
            StructType::OvfCpuCompatibilityCheckNotSupported => Ok(from.as_any_box().downcast::<OvfCpuCompatibilityCheckNotSupported>()?),
            StructType::OvfHardwareCheck => Ok(from.as_any_box().downcast::<OvfHardwareCheck>()?),
            StructType::OvfImportFailed => Ok(from.as_any_box().downcast::<OvfImportFailed>()?),
            StructType::OvfMappedOsId => Ok(from.as_any_box().downcast::<OvfMappedOsId>()?),
            StructType::OvfMissingHardware => Ok(from.as_any_box().downcast::<OvfMissingHardware>()?),
            StructType::OvfNetworkMappingNotSupported => Ok(from.as_any_box().downcast::<OvfNetworkMappingNotSupported>()?),
            StructType::OvfUnsupportedDiskProvisioning => Ok(from.as_any_box().downcast::<OvfUnsupportedDiskProvisioning>()?),
            StructType::OvfInvalidPackage => Ok(from.as_any_box().downcast::<OvfInvalidPackage>()?),
            StructType::OvfAttribute => Ok(from.as_any_box().downcast::<OvfAttribute>()?),
            StructType::OvfInvalidValue => Ok(from.as_any_box().downcast::<OvfInvalidValue>()?),
            StructType::OvfInvalidValueConfiguration => Ok(from.as_any_box().downcast::<OvfInvalidValueConfiguration>()?),
            StructType::OvfInvalidValueEmpty => Ok(from.as_any_box().downcast::<OvfInvalidValueEmpty>()?),
            StructType::OvfInvalidValueFormatMalformed => Ok(from.as_any_box().downcast::<OvfInvalidValueFormatMalformed>()?),
            StructType::OvfInvalidValueReference => Ok(from.as_any_box().downcast::<OvfInvalidValueReference>()?),
            StructType::OvfMissingAttribute => Ok(from.as_any_box().downcast::<OvfMissingAttribute>()?),
            StructType::OvfConstraint => Ok(from.as_any_box().downcast::<OvfConstraint>()?),
            StructType::OvfDiskOrderConstraint => Ok(from.as_any_box().downcast::<OvfDiskOrderConstraint>()?),
            StructType::OvfHostResourceConstraint => Ok(from.as_any_box().downcast::<OvfHostResourceConstraint>()?),
            StructType::OvfElement => Ok(from.as_any_box().downcast::<OvfElement>()?),
            StructType::OvfDuplicateElement => Ok(from.as_any_box().downcast::<OvfDuplicateElement>()?),
            StructType::OvfDuplicatedElementBoundary => Ok(from.as_any_box().downcast::<OvfDuplicatedElementBoundary>()?),
            StructType::OvfElementInvalidValue => Ok(from.as_any_box().downcast::<OvfElementInvalidValue>()?),
            StructType::OvfMissingElement => Ok(from.as_any_box().downcast::<OvfMissingElement>()?),
            StructType::OvfMissingElementNormalBoundary => Ok(from.as_any_box().downcast::<OvfMissingElementNormalBoundary>()?),
            StructType::OvfUnexpectedElement => Ok(from.as_any_box().downcast::<OvfUnexpectedElement>()?),
            StructType::OvfWrongElement => Ok(from.as_any_box().downcast::<OvfWrongElement>()?),
            StructType::OvfProperty => Ok(from.as_any_box().downcast::<OvfProperty>()?),
            StructType::OvfPropertyNetwork => Ok(from.as_any_box().downcast::<OvfPropertyNetwork>()?),
            StructType::OvfPropertyQualifier => Ok(from.as_any_box().downcast::<OvfPropertyQualifier>()?),
            StructType::OvfPropertyQualifierDuplicate => Ok(from.as_any_box().downcast::<OvfPropertyQualifierDuplicate>()?),
            StructType::OvfPropertyQualifierIgnored => Ok(from.as_any_box().downcast::<OvfPropertyQualifierIgnored>()?),
            StructType::OvfPropertyType => Ok(from.as_any_box().downcast::<OvfPropertyType>()?),
            StructType::OvfPropertyValue => Ok(from.as_any_box().downcast::<OvfPropertyValue>()?),
            StructType::OvfWrongNamespace => Ok(from.as_any_box().downcast::<OvfWrongNamespace>()?),
            StructType::OvfXmlFormat => Ok(from.as_any_box().downcast::<OvfXmlFormat>()?),
            StructType::OvfSystemFault => Ok(from.as_any_box().downcast::<OvfSystemFault>()?),
            StructType::OvfDiskMappingNotFound => Ok(from.as_any_box().downcast::<OvfDiskMappingNotFound>()?),
            StructType::OvfHostValueNotParsed => Ok(from.as_any_box().downcast::<OvfHostValueNotParsed>()?),
            StructType::OvfInternalError => Ok(from.as_any_box().downcast::<OvfInternalError>()?),
            StructType::OvfToXmlUnsupportedElement => Ok(from.as_any_box().downcast::<OvfToXmlUnsupportedElement>()?),
            StructType::OvfUnknownDevice => Ok(from.as_any_box().downcast::<OvfUnknownDevice>()?),
            StructType::OvfUnknownEntity => Ok(from.as_any_box().downcast::<OvfUnknownEntity>()?),
            StructType::OvfUnsupportedDeviceBackingInfo => Ok(from.as_any_box().downcast::<OvfUnsupportedDeviceBackingInfo>()?),
            StructType::OvfUnsupportedDeviceBackingOption => Ok(from.as_any_box().downcast::<OvfUnsupportedDeviceBackingOption>()?),
            StructType::OvfUnsupportedPackage => Ok(from.as_any_box().downcast::<OvfUnsupportedPackage>()?),
            StructType::OvfInvalidVmName => Ok(from.as_any_box().downcast::<OvfInvalidVmName>()?),
            StructType::OvfNoHostNic => Ok(from.as_any_box().downcast::<OvfNoHostNic>()?),
            StructType::OvfNoSupportedHardwareFamily => Ok(from.as_any_box().downcast::<OvfNoSupportedHardwareFamily>()?),
            StructType::OvfUnsupportedAttribute => Ok(from.as_any_box().downcast::<OvfUnsupportedAttribute>()?),
            StructType::OvfUnsupportedAttributeValue => Ok(from.as_any_box().downcast::<OvfUnsupportedAttributeValue>()?),
            StructType::OvfUnsupportedElement => Ok(from.as_any_box().downcast::<OvfUnsupportedElement>()?),
            StructType::OvfNoSpaceOnController => Ok(from.as_any_box().downcast::<OvfNoSpaceOnController>()?),
            StructType::OvfUnsupportedElementValue => Ok(from.as_any_box().downcast::<OvfUnsupportedElementValue>()?),
            StructType::OvfUnsupportedSection => Ok(from.as_any_box().downcast::<OvfUnsupportedSection>()?),
            StructType::OvfUnsupportedSubType => Ok(from.as_any_box().downcast::<OvfUnsupportedSubType>()?),
            StructType::OvfUnsupportedType => Ok(from.as_any_box().downcast::<OvfUnsupportedType>()?),
            StructType::PatchBinariesNotFound => Ok(from.as_any_box().downcast::<PatchBinariesNotFound>()?),
            StructType::PatchMetadataInvalid => Ok(from.as_any_box().downcast::<PatchMetadataInvalid>()?),
            StructType::PatchMetadataCorrupted => Ok(from.as_any_box().downcast::<PatchMetadataCorrupted>()?),
            StructType::PatchMetadataNotFound => Ok(from.as_any_box().downcast::<PatchMetadataNotFound>()?),
            StructType::PatchNotApplicable => Ok(from.as_any_box().downcast::<PatchNotApplicable>()?),
            StructType::PatchAlreadyInstalled => Ok(from.as_any_box().downcast::<PatchAlreadyInstalled>()?),
            StructType::PatchMissingDependencies => Ok(from.as_any_box().downcast::<PatchMissingDependencies>()?),
            StructType::PatchSuperseded => Ok(from.as_any_box().downcast::<PatchSuperseded>()?),
            StructType::ProfileUpdateFailed => Ok(from.as_any_box().downcast::<ProfileUpdateFailed>()?),
            StructType::RebootRequired => Ok(from.as_any_box().downcast::<RebootRequired>()?),
            StructType::RecordReplayDisabled => Ok(from.as_any_box().downcast::<RecordReplayDisabled>()?),
            StructType::RemoveFailed => Ok(from.as_any_box().downcast::<RemoveFailed>()?),
            StructType::ReplicationFault => Ok(from.as_any_box().downcast::<ReplicationFault>()?),
            StructType::IncompatibleHostForVmReplication => Ok(from.as_any_box().downcast::<IncompatibleHostForVmReplication>()?),
            StructType::ReplicationConfigFault => Ok(from.as_any_box().downcast::<ReplicationConfigFault>()?),
            StructType::ReplicationDiskConfigFault => Ok(from.as_any_box().downcast::<ReplicationDiskConfigFault>()?),
            StructType::ReplicationVmConfigFault => Ok(from.as_any_box().downcast::<ReplicationVmConfigFault>()?),
            StructType::ReplicationIncompatibleWithFt => Ok(from.as_any_box().downcast::<ReplicationIncompatibleWithFt>()?),
            StructType::ReplicationInvalidOptions => Ok(from.as_any_box().downcast::<ReplicationInvalidOptions>()?),
            StructType::ReplicationNotSupportedOnHost => Ok(from.as_any_box().downcast::<ReplicationNotSupportedOnHost>()?),
            StructType::ReplicationVmFault => Ok(from.as_any_box().downcast::<ReplicationVmFault>()?),
            StructType::ReplicationVmInProgressFault => Ok(from.as_any_box().downcast::<ReplicationVmInProgressFault>()?),
            StructType::ResourceInUse => Ok(from.as_any_box().downcast::<ResourceInUse>()?),
            StructType::FilterInUse => Ok(from.as_any_box().downcast::<FilterInUse>()?),
            StructType::QuiesceDatastoreIoForHaFailed => Ok(from.as_any_box().downcast::<QuiesceDatastoreIoForHaFailed>()?),
            StructType::ResourceNotAvailable => Ok(from.as_any_box().downcast::<ResourceNotAvailable>()?),
            StructType::SspiChallenge => Ok(from.as_any_box().downcast::<SspiChallenge>()?),
            StructType::ShrinkDiskFault => Ok(from.as_any_box().downcast::<ShrinkDiskFault>()?),
            StructType::SnapshotFault => Ok(from.as_any_box().downcast::<SnapshotFault>()?),
            StructType::ApplicationQuiesceFault => Ok(from.as_any_box().downcast::<ApplicationQuiesceFault>()?),
            StructType::FilesystemQuiesceFault => Ok(from.as_any_box().downcast::<FilesystemQuiesceFault>()?),
            StructType::MemorySnapshotOnIndependentDisk => Ok(from.as_any_box().downcast::<MemorySnapshotOnIndependentDisk>()?),
            StructType::MultipleSnapshotsNotSupported => Ok(from.as_any_box().downcast::<MultipleSnapshotsNotSupported>()?),
            StructType::SnapshotDisabled => Ok(from.as_any_box().downcast::<SnapshotDisabled>()?),
            StructType::SnapshotIncompatibleDeviceInVm => Ok(from.as_any_box().downcast::<SnapshotIncompatibleDeviceInVm>()?),
            StructType::SnapshotLocked => Ok(from.as_any_box().downcast::<SnapshotLocked>()?),
            StructType::SnapshotNoChange => Ok(from.as_any_box().downcast::<SnapshotNoChange>()?),
            StructType::TooManySnapshotLevels => Ok(from.as_any_box().downcast::<TooManySnapshotLevels>()?),
            StructType::SsdDiskNotAvailable => Ok(from.as_any_box().downcast::<SsdDiskNotAvailable>()?),
            StructType::StorageDrsCannotMoveDiskInMultiWriterMode => Ok(from.as_any_box().downcast::<StorageDrsCannotMoveDiskInMultiWriterMode>()?),
            StructType::StorageDrsCannotMoveFtVm => Ok(from.as_any_box().downcast::<StorageDrsCannotMoveFtVm>()?),
            StructType::StorageDrsCannotMoveIndependentDisk => Ok(from.as_any_box().downcast::<StorageDrsCannotMoveIndependentDisk>()?),
            StructType::StorageDrsCannotMoveManuallyPlacedSwapFile => Ok(from.as_any_box().downcast::<StorageDrsCannotMoveManuallyPlacedSwapFile>()?),
            StructType::StorageDrsCannotMoveManuallyPlacedVm => Ok(from.as_any_box().downcast::<StorageDrsCannotMoveManuallyPlacedVm>()?),
            StructType::StorageDrsCannotMoveSharedDisk => Ok(from.as_any_box().downcast::<StorageDrsCannotMoveSharedDisk>()?),
            StructType::StorageDrsCannotMoveTemplate => Ok(from.as_any_box().downcast::<StorageDrsCannotMoveTemplate>()?),
            StructType::StorageDrsCannotMoveVmInUserFolder => Ok(from.as_any_box().downcast::<StorageDrsCannotMoveVmInUserFolder>()?),
            StructType::StorageDrsCannotMoveVmWithMountedCdrom => Ok(from.as_any_box().downcast::<StorageDrsCannotMoveVmWithMountedCdrom>()?),
            StructType::StorageDrsCannotMoveVmWithNoFilesInLayout => Ok(from.as_any_box().downcast::<StorageDrsCannotMoveVmWithNoFilesInLayout>()?),
            StructType::StorageDrsDatacentersCannotShareDatastore => Ok(from.as_any_box().downcast::<StorageDrsDatacentersCannotShareDatastore>()?),
            StructType::StorageDrsDisabledOnVm => Ok(from.as_any_box().downcast::<StorageDrsDisabledOnVm>()?),
            StructType::StorageDrsHbrDiskNotMovable => Ok(from.as_any_box().downcast::<StorageDrsHbrDiskNotMovable>()?),
            StructType::StorageDrsHmsMoveInProgress => Ok(from.as_any_box().downcast::<StorageDrsHmsMoveInProgress>()?),
            StructType::StorageDrsHmsUnreachable => Ok(from.as_any_box().downcast::<StorageDrsHmsUnreachable>()?),
            StructType::StorageDrsIolbDisabledInternally => Ok(from.as_any_box().downcast::<StorageDrsIolbDisabledInternally>()?),
            StructType::StorageDrsRelocateDisabled => Ok(from.as_any_box().downcast::<StorageDrsRelocateDisabled>()?),
            StructType::StorageDrsStaleHmsCollection => Ok(from.as_any_box().downcast::<StorageDrsStaleHmsCollection>()?),
            StructType::StorageDrsUnableToMoveFiles => Ok(from.as_any_box().downcast::<StorageDrsUnableToMoveFiles>()?),
            StructType::SwapDatastoreUnset => Ok(from.as_any_box().downcast::<SwapDatastoreUnset>()?),
            StructType::TaskInProgress => Ok(from.as_any_box().downcast::<TaskInProgress>()?),
            StructType::VAppTaskInProgress => Ok(from.as_any_box().downcast::<VAppTaskInProgress>()?),
            StructType::Timedout => Ok(from.as_any_box().downcast::<Timedout>()?),
            StructType::PowerOnFtSecondaryTimedout => Ok(from.as_any_box().downcast::<PowerOnFtSecondaryTimedout>()?),
            StructType::TooManyConsecutiveOverrides => Ok(from.as_any_box().downcast::<TooManyConsecutiveOverrides>()?),
            StructType::ToolsUnavailable => Ok(from.as_any_box().downcast::<ToolsUnavailable>()?),
            StructType::UnrecognizedHost => Ok(from.as_any_box().downcast::<UnrecognizedHost>()?),
            StructType::UnsupportedVimApiVersion => Ok(from.as_any_box().downcast::<UnsupportedVimApiVersion>()?),
            StructType::UserNotFound => Ok(from.as_any_box().downcast::<UserNotFound>()?),
            StructType::VAppConfigFault => Ok(from.as_any_box().downcast::<VAppConfigFault>()?),
            StructType::MissingPowerOffConfiguration => Ok(from.as_any_box().downcast::<MissingPowerOffConfiguration>()?),
            StructType::MissingPowerOnConfiguration => Ok(from.as_any_box().downcast::<MissingPowerOnConfiguration>()?),
            StructType::NoVmInVApp => Ok(from.as_any_box().downcast::<NoVmInVApp>()?),
            StructType::VFlashModuleVersionIncompatible => Ok(from.as_any_box().downcast::<VFlashModuleVersionIncompatible>()?),
            StructType::VmConfigFault => Ok(from.as_any_box().downcast::<VmConfigFault>()?),
            StructType::CannotAccessVmComponent => Ok(from.as_any_box().downcast::<CannotAccessVmComponent>()?),
            StructType::CannotAccessVmConfig => Ok(from.as_any_box().downcast::<CannotAccessVmConfig>()?),
            StructType::CannotAccessVmDevice => Ok(from.as_any_box().downcast::<CannotAccessVmDevice>()?),
            StructType::CannotAccessNetwork => Ok(from.as_any_box().downcast::<CannotAccessNetwork>()?),
            StructType::DestinationSwitchFull => Ok(from.as_any_box().downcast::<DestinationSwitchFull>()?),
            StructType::LegacyNetworkInterfaceInUse => Ok(from.as_any_box().downcast::<LegacyNetworkInterfaceInUse>()?),
            StructType::VmOnConflictDvPort => Ok(from.as_any_box().downcast::<VmOnConflictDvPort>()?),
            StructType::VmOnVirtualIntranet => Ok(from.as_any_box().downcast::<VmOnVirtualIntranet>()?),
            StructType::CannotAccessVmDisk => Ok(from.as_any_box().downcast::<CannotAccessVmDisk>()?),
            StructType::RdmPointsToInaccessibleDisk => Ok(from.as_any_box().downcast::<RdmPointsToInaccessibleDisk>()?),
            StructType::CannotDisableSnapshot => Ok(from.as_any_box().downcast::<CannotDisableSnapshot>()?),
            StructType::CannotUseNetwork => Ok(from.as_any_box().downcast::<CannotUseNetwork>()?),
            StructType::CpuHotPlugNotSupported => Ok(from.as_any_box().downcast::<CpuHotPlugNotSupported>()?),
            StructType::DeltaDiskFormatNotSupported => Ok(from.as_any_box().downcast::<DeltaDiskFormatNotSupported>()?),
            StructType::EightHostLimitViolated => Ok(from.as_any_box().downcast::<EightHostLimitViolated>()?),
            StructType::FaultToleranceCannotEditMem => Ok(from.as_any_box().downcast::<FaultToleranceCannotEditMem>()?),
            StructType::GenericVmConfigFault => Ok(from.as_any_box().downcast::<GenericVmConfigFault>()?),
            StructType::InvalidFormat => Ok(from.as_any_box().downcast::<InvalidFormat>()?),
            StructType::InvalidDiskFormat => Ok(from.as_any_box().downcast::<InvalidDiskFormat>()?),
            StructType::InvalidSnapshotFormat => Ok(from.as_any_box().downcast::<InvalidSnapshotFormat>()?),
            StructType::InvalidVmConfig => Ok(from.as_any_box().downcast::<InvalidVmConfig>()?),
            StructType::InvalidDeviceSpec => Ok(from.as_any_box().downcast::<InvalidDeviceSpec>()?),
            StructType::DeviceHotPlugNotSupported => Ok(from.as_any_box().downcast::<DeviceHotPlugNotSupported>()?),
            StructType::DeviceNotFound => Ok(from.as_any_box().downcast::<DeviceNotFound>()?),
            StructType::DeviceUnsupportedForVmPlatform => Ok(from.as_any_box().downcast::<DeviceUnsupportedForVmPlatform>()?),
            StructType::DeviceUnsupportedForVmVersion => Ok(from.as_any_box().downcast::<DeviceUnsupportedForVmVersion>()?),
            StructType::DisallowedDiskModeChange => Ok(from.as_any_box().downcast::<DisallowedDiskModeChange>()?),
            StructType::InvalidController => Ok(from.as_any_box().downcast::<InvalidController>()?),
            StructType::InvalidDeviceBacking => Ok(from.as_any_box().downcast::<InvalidDeviceBacking>()?),
            StructType::InvalidDeviceOperation => Ok(from.as_any_box().downcast::<InvalidDeviceOperation>()?),
            StructType::MissingController => Ok(from.as_any_box().downcast::<MissingController>()?),
            StructType::SwapPlacementOverrideNotSupported => Ok(from.as_any_box().downcast::<SwapPlacementOverrideNotSupported>()?),
            StructType::TooManyDevices => Ok(from.as_any_box().downcast::<TooManyDevices>()?),
            StructType::UnsupportedGuest => Ok(from.as_any_box().downcast::<UnsupportedGuest>()?),
            StructType::VmWwnConflict => Ok(from.as_any_box().downcast::<VmWwnConflict>()?),
            StructType::LargeRdmNotSupportedOnDatastore => Ok(from.as_any_box().downcast::<LargeRdmNotSupportedOnDatastore>()?),
            StructType::MemoryHotPlugNotSupported => Ok(from.as_any_box().downcast::<MemoryHotPlugNotSupported>()?),
            StructType::NoCompatibleHardAffinityHost => Ok(from.as_any_box().downcast::<NoCompatibleHardAffinityHost>()?),
            StructType::NoCompatibleSoftAffinityHost => Ok(from.as_any_box().downcast::<NoCompatibleSoftAffinityHost>()?),
            StructType::NumVirtualCpusIncompatible => Ok(from.as_any_box().downcast::<NumVirtualCpusIncompatible>()?),
            StructType::OvfConsumerValidationFault => Ok(from.as_any_box().downcast::<OvfConsumerValidationFault>()?),
            StructType::QuarantineModeFault => Ok(from.as_any_box().downcast::<QuarantineModeFault>()?),
            StructType::RdmNotSupportedOnDatastore => Ok(from.as_any_box().downcast::<RdmNotSupportedOnDatastore>()?),
            StructType::RuleViolation => Ok(from.as_any_box().downcast::<RuleViolation>()?),
            StructType::SoftRuleVioCorrectionDisallowed => Ok(from.as_any_box().downcast::<SoftRuleVioCorrectionDisallowed>()?),
            StructType::SoftRuleVioCorrectionImpact => Ok(from.as_any_box().downcast::<SoftRuleVioCorrectionImpact>()?),
            StructType::UnsupportedDatastore => Ok(from.as_any_box().downcast::<UnsupportedDatastore>()?),
            StructType::MemoryFileFormatNotSupportedByDatastore => Ok(from.as_any_box().downcast::<MemoryFileFormatNotSupportedByDatastore>()?),
            StructType::UnSupportedDatastoreForVFlash => Ok(from.as_any_box().downcast::<UnSupportedDatastoreForVFlash>()?),
            StructType::UnsupportedVmxLocation => Ok(from.as_any_box().downcast::<UnsupportedVmxLocation>()?),
            StructType::VAppNotRunning => Ok(from.as_any_box().downcast::<VAppNotRunning>()?),
            StructType::VAppPropertyFault => Ok(from.as_any_box().downcast::<VAppPropertyFault>()?),
            StructType::InvalidNetworkInType => Ok(from.as_any_box().downcast::<InvalidNetworkInType>()?),
            StructType::InvalidPropertyType => Ok(from.as_any_box().downcast::<InvalidPropertyType>()?),
            StructType::InvalidPropertyValue => Ok(from.as_any_box().downcast::<InvalidPropertyValue>()?),
            StructType::UnconfiguredPropertyValue => Ok(from.as_any_box().downcast::<UnconfiguredPropertyValue>()?),
            StructType::MissingIpPool => Ok(from.as_any_box().downcast::<MissingIpPool>()?),
            StructType::MissingNetworkIpConfig => Ok(from.as_any_box().downcast::<MissingNetworkIpConfig>()?),
            StructType::NoAvailableIp => Ok(from.as_any_box().downcast::<NoAvailableIp>()?),
            StructType::NoVcManagedIpConfigured => Ok(from.as_any_box().downcast::<NoVcManagedIpConfigured>()?),
            StructType::NotUserConfigurableProperty => Ok(from.as_any_box().downcast::<NotUserConfigurableProperty>()?),
            StructType::VFlashCacheHotConfigNotSupported => Ok(from.as_any_box().downcast::<VFlashCacheHotConfigNotSupported>()?),
            StructType::VFlashModuleNotSupported => Ok(from.as_any_box().downcast::<VFlashModuleNotSupported>()?),
            StructType::VirtualHardwareCompatibilityIssue => Ok(from.as_any_box().downcast::<VirtualHardwareCompatibilityIssue>()?),
            StructType::CpuIncompatible => Ok(from.as_any_box().downcast::<CpuIncompatible>()?),
            StructType::CpuCompatibilityUnknown => Ok(from.as_any_box().downcast::<CpuCompatibilityUnknown>()?),
            StructType::CpuIncompatible1Ecx => Ok(from.as_any_box().downcast::<CpuIncompatible1Ecx>()?),
            StructType::CpuIncompatible81Edx => Ok(from.as_any_box().downcast::<CpuIncompatible81Edx>()?),
            StructType::FaultToleranceCpuIncompatible => Ok(from.as_any_box().downcast::<FaultToleranceCpuIncompatible>()?),
            StructType::DeviceNotSupported => Ok(from.as_any_box().downcast::<DeviceNotSupported>()?),
            StructType::DeviceBackingNotSupported => Ok(from.as_any_box().downcast::<DeviceBackingNotSupported>()?),
            StructType::DvPortNotSupported => Ok(from.as_any_box().downcast::<DvPortNotSupported>()?),
            StructType::UnusedVirtualDiskBlocksNotScrubbed => Ok(from.as_any_box().downcast::<UnusedVirtualDiskBlocksNotScrubbed>()?),
            StructType::VirtualDiskBlocksNotFullyProvisioned => Ok(from.as_any_box().downcast::<VirtualDiskBlocksNotFullyProvisioned>()?),
            StructType::DeviceControllerNotSupported => Ok(from.as_any_box().downcast::<DeviceControllerNotSupported>()?),
            StructType::DigestNotSupported => Ok(from.as_any_box().downcast::<DigestNotSupported>()?),
            StructType::FileBackedPortNotSupported => Ok(from.as_any_box().downcast::<FileBackedPortNotSupported>()?),
            StructType::MultiWriterNotSupported => Ok(from.as_any_box().downcast::<MultiWriterNotSupported>()?),
            StructType::NonPersistentDisksNotSupported => Ok(from.as_any_box().downcast::<NonPersistentDisksNotSupported>()?),
            StructType::RdmNotSupported => Ok(from.as_any_box().downcast::<RdmNotSupported>()?),
            StructType::PhysCompatRdmNotSupported => Ok(from.as_any_box().downcast::<PhysCompatRdmNotSupported>()?),
            StructType::RawDiskNotSupported => Ok(from.as_any_box().downcast::<RawDiskNotSupported>()?),
            StructType::RemoteDeviceNotSupported => Ok(from.as_any_box().downcast::<RemoteDeviceNotSupported>()?),
            StructType::SharedBusControllerNotSupported => Ok(from.as_any_box().downcast::<SharedBusControllerNotSupported>()?),
            StructType::VmiNotSupported => Ok(from.as_any_box().downcast::<VmiNotSupported>()?),
            StructType::VirtualDiskModeNotSupported => Ok(from.as_any_box().downcast::<VirtualDiskModeNotSupported>()?),
            StructType::VirtualEthernetCardNotSupported => Ok(from.as_any_box().downcast::<VirtualEthernetCardNotSupported>()?),
            StructType::DiskNotSupported => Ok(from.as_any_box().downcast::<DiskNotSupported>()?),
            StructType::IdeDiskNotSupported => Ok(from.as_any_box().downcast::<IdeDiskNotSupported>()?),
            StructType::DrsVmotionIncompatibleFault => Ok(from.as_any_box().downcast::<DrsVmotionIncompatibleFault>()?),
            StructType::FeatureRequirementsNotMet => Ok(from.as_any_box().downcast::<FeatureRequirementsNotMet>()?),
            StructType::MemorySizeNotRecommended => Ok(from.as_any_box().downcast::<MemorySizeNotRecommended>()?),
            StructType::MemorySizeNotSupported => Ok(from.as_any_box().downcast::<MemorySizeNotSupported>()?),
            StructType::MemorySizeNotSupportedByDatastore => Ok(from.as_any_box().downcast::<MemorySizeNotSupportedByDatastore>()?),
            StructType::NotEnoughCpus => Ok(from.as_any_box().downcast::<NotEnoughCpus>()?),
            StructType::NotEnoughLogicalCpus => Ok(from.as_any_box().downcast::<NotEnoughLogicalCpus>()?),
            StructType::NumVirtualCoresPerSocketNotSupported => Ok(from.as_any_box().downcast::<NumVirtualCoresPerSocketNotSupported>()?),
            StructType::NumVirtualCpusNotSupported => Ok(from.as_any_box().downcast::<NumVirtualCpusNotSupported>()?),
            StructType::StorageVmotionIncompatible => Ok(from.as_any_box().downcast::<StorageVmotionIncompatible>()?),
            StructType::VirtualHardwareVersionNotSupported => Ok(from.as_any_box().downcast::<VirtualHardwareVersionNotSupported>()?),
            StructType::WakeOnLanNotSupported => Ok(from.as_any_box().downcast::<WakeOnLanNotSupported>()?),
            StructType::VmConfigIncompatibleForFaultTolerance => Ok(from.as_any_box().downcast::<VmConfigIncompatibleForFaultTolerance>()?),
            StructType::VmConfigIncompatibleForRecordReplay => Ok(from.as_any_box().downcast::<VmConfigIncompatibleForRecordReplay>()?),
            StructType::VmHostAffinityRuleViolation => Ok(from.as_any_box().downcast::<VmHostAffinityRuleViolation>()?),
            StructType::VmFaultToleranceIssue => Ok(from.as_any_box().downcast::<VmFaultToleranceIssue>()?),
            StructType::CannotChangeDrsBehaviorForFtSecondary => Ok(from.as_any_box().downcast::<CannotChangeDrsBehaviorForFtSecondary>()?),
            StructType::CannotChangeHaSettingsForFtSecondary => Ok(from.as_any_box().downcast::<CannotChangeHaSettingsForFtSecondary>()?),
            StructType::CannotComputeFtCompatibleHosts => Ok(from.as_any_box().downcast::<CannotComputeFtCompatibleHosts>()?),
            StructType::FaultToleranceNotLicensed => Ok(from.as_any_box().downcast::<FaultToleranceNotLicensed>()?),
            StructType::FaultTolerancePrimaryPowerOnNotAttempted => Ok(from.as_any_box().downcast::<FaultTolerancePrimaryPowerOnNotAttempted>()?),
            StructType::FtIssuesOnHost => Ok(from.as_any_box().downcast::<FtIssuesOnHost>()?),
            StructType::HostIncompatibleForFaultTolerance => Ok(from.as_any_box().downcast::<HostIncompatibleForFaultTolerance>()?),
            StructType::IncompatibleHostForFtSecondary => Ok(from.as_any_box().downcast::<IncompatibleHostForFtSecondary>()?),
            StructType::InvalidOperationOnSecondaryVm => Ok(from.as_any_box().downcast::<InvalidOperationOnSecondaryVm>()?),
            StructType::NoHostSuitableForFtSecondary => Ok(from.as_any_box().downcast::<NoHostSuitableForFtSecondary>()?),
            StructType::NotSupportedDeviceForFt => Ok(from.as_any_box().downcast::<NotSupportedDeviceForFt>()?),
            StructType::PowerOnFtSecondaryFailed => Ok(from.as_any_box().downcast::<PowerOnFtSecondaryFailed>()?),
            StructType::SecondaryVmAlreadyDisabled => Ok(from.as_any_box().downcast::<SecondaryVmAlreadyDisabled>()?),
            StructType::SecondaryVmAlreadyEnabled => Ok(from.as_any_box().downcast::<SecondaryVmAlreadyEnabled>()?),
            StructType::SecondaryVmAlreadyRegistered => Ok(from.as_any_box().downcast::<SecondaryVmAlreadyRegistered>()?),
            StructType::SecondaryVmNotRegistered => Ok(from.as_any_box().downcast::<SecondaryVmNotRegistered>()?),
            StructType::VmFaultToleranceConfigIssue => Ok(from.as_any_box().downcast::<VmFaultToleranceConfigIssue>()?),
            StructType::VmFaultToleranceConfigIssueWrapper => Ok(from.as_any_box().downcast::<VmFaultToleranceConfigIssueWrapper>()?),
            StructType::VmFaultToleranceInvalidFileBacking => Ok(from.as_any_box().downcast::<VmFaultToleranceInvalidFileBacking>()?),
            StructType::VmFaultToleranceOpIssuesList => Ok(from.as_any_box().downcast::<VmFaultToleranceOpIssuesList>()?),
            StructType::VmMetadataManagerFault => Ok(from.as_any_box().downcast::<VmMetadataManagerFault>()?),
            StructType::VmMonitorIncompatibleForFaultTolerance => Ok(from.as_any_box().downcast::<VmMonitorIncompatibleForFaultTolerance>()?),
            StructType::VmToolsUpgradeFault => Ok(from.as_any_box().downcast::<VmToolsUpgradeFault>()?),
            StructType::ToolsAlreadyUpgraded => Ok(from.as_any_box().downcast::<ToolsAlreadyUpgraded>()?),
            StructType::ToolsAutoUpgradeNotSupported => Ok(from.as_any_box().downcast::<ToolsAutoUpgradeNotSupported>()?),
            StructType::ToolsImageCopyFailed => Ok(from.as_any_box().downcast::<ToolsImageCopyFailed>()?),
            StructType::ToolsImageNotAvailable => Ok(from.as_any_box().downcast::<ToolsImageNotAvailable>()?),
            StructType::ToolsImageSignatureCheckFailed => Ok(from.as_any_box().downcast::<ToolsImageSignatureCheckFailed>()?),
            StructType::ToolsUpgradeCancelled => Ok(from.as_any_box().downcast::<ToolsUpgradeCancelled>()?),
            StructType::VmValidateMaxDevice => Ok(from.as_any_box().downcast::<VmValidateMaxDevice>()?),
            StructType::VsanFault => Ok(from.as_any_box().downcast::<VsanFault>()?),
            StructType::CannotChangeVsanClusterUuid => Ok(from.as_any_box().downcast::<CannotChangeVsanClusterUuid>()?),
            StructType::CannotChangeVsanNodeUuid => Ok(from.as_any_box().downcast::<CannotChangeVsanNodeUuid>()?),
            StructType::CannotMoveVsanEnabledHost => Ok(from.as_any_box().downcast::<CannotMoveVsanEnabledHost>()?),
            StructType::DestinationVsanDisabled => Ok(from.as_any_box().downcast::<DestinationVsanDisabled>()?),
            StructType::VsanClusterUuidMismatch => Ok(from.as_any_box().downcast::<VsanClusterUuidMismatch>()?),
            StructType::CannotReconfigureVsanWhenHaEnabled => Ok(from.as_any_box().downcast::<CannotReconfigureVsanWhenHaEnabled>()?),
            StructType::DuplicateVsanNetworkInterface => Ok(from.as_any_box().downcast::<DuplicateVsanNetworkInterface>()?),
            StructType::VsanDiskFault => Ok(from.as_any_box().downcast::<VsanDiskFault>()?),
            StructType::DiskHasPartitions => Ok(from.as_any_box().downcast::<DiskHasPartitions>()?),
            StructType::DiskIsLastRemainingNonSsd => Ok(from.as_any_box().downcast::<DiskIsLastRemainingNonSsd>()?),
            StructType::DiskIsNonLocal => Ok(from.as_any_box().downcast::<DiskIsNonLocal>()?),
            StructType::DiskIsUsb => Ok(from.as_any_box().downcast::<DiskIsUsb>()?),
            StructType::DiskTooSmall => Ok(from.as_any_box().downcast::<DiskTooSmall>()?),
            StructType::DuplicateDisks => Ok(from.as_any_box().downcast::<DuplicateDisks>()?),
            StructType::InsufficientDisks => Ok(from.as_any_box().downcast::<InsufficientDisks>()?),
            StructType::VsanIncompatibleDiskMapping => Ok(from.as_any_box().downcast::<VsanIncompatibleDiskMapping>()?),
            StructType::WipeDiskFault => Ok(from.as_any_box().downcast::<WipeDiskFault>()?),
            StructType::RuntimeFault => Ok(from.as_any_box().downcast::<RuntimeFault>()?),
            StructType::CannotDisableDrsOnClustersWithVApps => Ok(from.as_any_box().downcast::<CannotDisableDrsOnClustersWithVApps>()?),
            StructType::ConflictingDatastoreFound => Ok(from.as_any_box().downcast::<ConflictingDatastoreFound>()?),
            StructType::DatabaseError => Ok(from.as_any_box().downcast::<DatabaseError>()?),
            StructType::DisallowedChangeByService => Ok(from.as_any_box().downcast::<DisallowedChangeByService>()?),
            StructType::DisallowedOperationOnFailoverHost => Ok(from.as_any_box().downcast::<DisallowedOperationOnFailoverHost>()?),
            StructType::FailToLockFaultToleranceVMs => Ok(from.as_any_box().downcast::<FailToLockFaultToleranceVMs>()?),
            StructType::InvalidProfileReferenceHost => Ok(from.as_any_box().downcast::<InvalidProfileReferenceHost>()?),
            StructType::InvalidScheduledTask => Ok(from.as_any_box().downcast::<InvalidScheduledTask>()?),
            StructType::LicenseAssignmentFailed => Ok(from.as_any_box().downcast::<LicenseAssignmentFailed>()?),
            StructType::MethodAlreadyDisabledFault => Ok(from.as_any_box().downcast::<MethodAlreadyDisabledFault>()?),
            StructType::MethodDisabled => Ok(from.as_any_box().downcast::<MethodDisabled>()?),
            StructType::OperationDisallowedOnHost => Ok(from.as_any_box().downcast::<OperationDisallowedOnHost>()?),
            StructType::RestrictedByAdministrator => Ok(from.as_any_box().downcast::<RestrictedByAdministrator>()?),
            StructType::ThirdPartyLicenseAssignmentFailed => Ok(from.as_any_box().downcast::<ThirdPartyLicenseAssignmentFailed>()?),
            StructType::VAppOperationInProgress => Ok(from.as_any_box().downcast::<VAppOperationInProgress>()?),
            StructType::HostCommunication => Ok(from.as_any_box().downcast::<HostCommunication>()?),
            StructType::HostNotConnected => Ok(from.as_any_box().downcast::<HostNotConnected>()?),
            StructType::HostNotReachable => Ok(from.as_any_box().downcast::<HostNotReachable>()?),
            StructType::InvalidArgument => Ok(from.as_any_box().downcast::<InvalidArgument>()?),
            StructType::IncompatibleSetting => Ok(from.as_any_box().downcast::<IncompatibleSetting>()?),
            StructType::InvalidDasConfigArgument => Ok(from.as_any_box().downcast::<InvalidDasConfigArgument>()?),
            StructType::InvalidDasRestartPriorityForFtVm => Ok(from.as_any_box().downcast::<InvalidDasRestartPriorityForFtVm>()?),
            StructType::InvalidDrsBehaviorForFtVm => Ok(from.as_any_box().downcast::<InvalidDrsBehaviorForFtVm>()?),
            StructType::InvalidIndexArgument => Ok(from.as_any_box().downcast::<InvalidIndexArgument>()?),
            StructType::InvalidRequest => Ok(from.as_any_box().downcast::<InvalidRequest>()?),
            StructType::InvalidType => Ok(from.as_any_box().downcast::<InvalidType>()?),
            StructType::MethodNotFound => Ok(from.as_any_box().downcast::<MethodNotFound>()?),
            StructType::ManagedObjectNotFound => Ok(from.as_any_box().downcast::<ManagedObjectNotFound>()?),
            StructType::NotEnoughLicenses => Ok(from.as_any_box().downcast::<NotEnoughLicenses>()?),
            StructType::ExpiredFeatureLicense => Ok(from.as_any_box().downcast::<ExpiredFeatureLicense>()?),
            StructType::ExpiredAddonLicense => Ok(from.as_any_box().downcast::<ExpiredAddonLicense>()?),
            StructType::ExpiredEditionLicense => Ok(from.as_any_box().downcast::<ExpiredEditionLicense>()?),
            StructType::FailToEnableSpbm => Ok(from.as_any_box().downcast::<FailToEnableSpbm>()?),
            StructType::HostInventoryFull => Ok(from.as_any_box().downcast::<HostInventoryFull>()?),
            StructType::InUseFeatureManipulationDisallowed => Ok(from.as_any_box().downcast::<InUseFeatureManipulationDisallowed>()?),
            StructType::IncorrectHostInformation => Ok(from.as_any_box().downcast::<IncorrectHostInformation>()?),
            StructType::InvalidEditionLicense => Ok(from.as_any_box().downcast::<InvalidEditionLicense>()?),
            StructType::InventoryHasStandardAloneHosts => Ok(from.as_any_box().downcast::<InventoryHasStandardAloneHosts>()?),
            StructType::LicenseDowngradeDisallowed => Ok(from.as_any_box().downcast::<LicenseDowngradeDisallowed>()?),
            StructType::LicenseExpired => Ok(from.as_any_box().downcast::<LicenseExpired>()?),
            StructType::LicenseKeyEntityMismatch => Ok(from.as_any_box().downcast::<LicenseKeyEntityMismatch>()?),
            StructType::LicenseRestricted => Ok(from.as_any_box().downcast::<LicenseRestricted>()?),
            StructType::LicenseSourceUnavailable => Ok(from.as_any_box().downcast::<LicenseSourceUnavailable>()?),
            StructType::NoLicenseServerConfigured => Ok(from.as_any_box().downcast::<NoLicenseServerConfigured>()?),
            StructType::VmLimitLicense => Ok(from.as_any_box().downcast::<VmLimitLicense>()?),
            StructType::VramLimitLicense => Ok(from.as_any_box().downcast::<VramLimitLicense>()?),
            StructType::NotImplemented => Ok(from.as_any_box().downcast::<NotImplemented>()?),
            StructType::NotSupported => Ok(from.as_any_box().downcast::<NotSupported>()?),
            StructType::HostAccessRestrictedToManagementServer => Ok(from.as_any_box().downcast::<HostAccessRestrictedToManagementServer>()?),
            StructType::RequestCanceled => Ok(from.as_any_box().downcast::<RequestCanceled>()?),
            StructType::SecurityError => Ok(from.as_any_box().downcast::<SecurityError>()?),
            StructType::NoPermission => Ok(from.as_any_box().downcast::<NoPermission>()?),
            StructType::NotAuthenticated => Ok(from.as_any_box().downcast::<NotAuthenticated>()?),
            StructType::RestrictedVersion => Ok(from.as_any_box().downcast::<RestrictedVersion>()?),
            StructType::SolutionUserRequired => Ok(from.as_any_box().downcast::<SolutionUserRequired>()?),
            StructType::SystemError => Ok(from.as_any_box().downcast::<SystemError>()?),
            StructType::UnexpectedFault => Ok(from.as_any_box().downcast::<UnexpectedFault>()?),
            StructType::InvalidCollectorVersion => Ok(from.as_any_box().downcast::<InvalidCollectorVersion>()?),
            StructType::InvalidProperty => Ok(from.as_any_box().downcast::<InvalidProperty>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The common base type for all virtual infrastructure management
/// exceptions.
pub trait VimFaultTrait : super::traits::MethodFaultTrait {
}
impl<'s> serde::Serialize for dyn VimFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VimFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VimFaultVisitor)
            }
        }

struct VimFaultVisitor;

impl<'de> de::Visitor<'de> for VimFaultVisitor {
    type Value = Box<dyn VimFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VimFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VimFaultTrait for VimFault {
}
impl VimFaultTrait for ActiveDirectoryFault {
}
impl VimFaultTrait for DomainNotFound {
}
impl VimFaultTrait for InvalidCamServer {
}
impl VimFaultTrait for CamServerRefusedConnection {
}
impl VimFaultTrait for InvalidCamCertificate {
}
impl VimFaultTrait for NoPermissionOnAd {
}
impl VimFaultTrait for NonAdUserRequired {
}
impl VimFaultTrait for AlreadyExists {
}
impl VimFaultTrait for AlreadyUpgraded {
}
impl VimFaultTrait for AnswerFileUpdateFailed {
}
impl VimFaultTrait for AuthMinimumAdminPermission {
}
impl VimFaultTrait for CannotAccessLocalSource {
}
impl VimFaultTrait for CannotDisconnectHostWithFaultToleranceVm {
}
impl VimFaultTrait for CannotEnableVmcpForCluster {
}
impl VimFaultTrait for CannotMoveFaultToleranceVm {
}
impl VimFaultTrait for CannotMoveHostWithFaultToleranceVm {
}
impl VimFaultTrait for CannotPlaceWithoutPrerequisiteMoves {
}
impl VimFaultTrait for ConcurrentAccess {
}
impl VimFaultTrait for CustomizationFault {
}
impl VimFaultTrait for CannotDecryptPasswords {
}
impl VimFaultTrait for CustomizationPending {
}
impl VimFaultTrait for IpHostnameGeneratorError {
}
impl VimFaultTrait for LinuxVolumeNotClean {
}
impl VimFaultTrait for MissingLinuxCustResources {
}
impl VimFaultTrait for MissingWindowsCustResources {
}
impl VimFaultTrait for MountError {
}
impl VimFaultTrait for NicSettingMismatch {
}
impl VimFaultTrait for NoDisksToCustomize {
}
impl VimFaultTrait for UncustomizableGuest {
}
impl VimFaultTrait for UnexpectedCustomizationFault {
}
impl VimFaultTrait for VolumeEditorError {
}
impl VimFaultTrait for DasConfigFault {
}
impl VimFaultTrait for DrsDisabledOnVm {
}
impl VimFaultTrait for DuplicateName {
}
impl VimFaultTrait for DvsFault {
}
impl VimFaultTrait for BackupBlobReadFailure {
}
impl VimFaultTrait for BackupBlobWriteFailure {
}
impl VimFaultTrait for CollectorAddressUnset {
}
impl VimFaultTrait for ConflictingConfiguration {
}
impl VimFaultTrait for DvsApplyOperationFault {
}
impl VimFaultTrait for DvsNotAuthorized {
}
impl VimFaultTrait for DvsOperationBulkFault {
}
impl VimFaultTrait for DvsScopeViolated {
}
impl VimFaultTrait for ImportHostAddFailure {
}
impl VimFaultTrait for ImportOperationBulkFault {
}
impl VimFaultTrait for InvalidIpfixConfig {
}
impl VimFaultTrait for RollbackFailure {
}
impl VimFaultTrait for SwitchIpUnset {
}
impl VimFaultTrait for SwitchNotInUpgradeMode {
}
impl VimFaultTrait for VspanDestPortConflict {
}
impl VimFaultTrait for VspanPortConflict {
}
impl VimFaultTrait for VspanPortMoveFault {
}
impl VimFaultTrait for VspanPortPromiscChangeFault {
}
impl VimFaultTrait for VspanPortgroupPromiscChangeFault {
}
impl VimFaultTrait for VspanPortgroupTypeChangeFault {
}
impl VimFaultTrait for VspanPromiscuousPortNotSupported {
}
impl VimFaultTrait for VspanSameSessionPortConflict {
}
impl VimFaultTrait for EvcConfigFault {
}
impl VimFaultTrait for ActiveVMsBlockingEvc {
}
impl VimFaultTrait for DisconnectedHostsBlockingEvc {
}
impl VimFaultTrait for EvcModeIllegalByVendor {
}
impl VimFaultTrait for EvcModeUnsupportedByHosts {
}
impl VimFaultTrait for EvcUnsupportedByHostHardware {
}
impl VimFaultTrait for EvcUnsupportedByHostSoftware {
}
impl VimFaultTrait for HeterogenousHostsBlockingEvc {
}
impl VimFaultTrait for ExtendedFault {
}
impl VimFaultTrait for FaultToleranceVmNotDasProtected {
}
impl VimFaultTrait for FcoeFault {
}
impl VimFaultTrait for FcoeFaultPnicHasNoPortSet {
}
impl VimFaultTrait for FileFault {
}
impl VimFaultTrait for CannotAccessFile {
}
impl VimFaultTrait for CannotCreateFile {
}
impl VimFaultTrait for CannotDeleteFile {
}
impl VimFaultTrait for DirectoryNotEmpty {
}
impl VimFaultTrait for FileAlreadyExists {
}
impl VimFaultTrait for FileLocked {
}
impl VimFaultTrait for FileNameTooLong {
}
impl VimFaultTrait for FileNotFound {
}
impl VimFaultTrait for FileNotWritable {
}
impl VimFaultTrait for FileTooLarge {
}
impl VimFaultTrait for IncorrectFileType {
}
impl VimFaultTrait for NetworkCopyFault {
}
impl VimFaultTrait for NoDiskSpace {
}
impl VimFaultTrait for NotADirectory {
}
impl VimFaultTrait for NotAFile {
}
impl VimFaultTrait for TooManyConcurrentNativeClones {
}
impl VimFaultTrait for TooManyNativeCloneLevels {
}
impl VimFaultTrait for TooManyNativeClonesOnFile {
}
impl VimFaultTrait for GenericDrsFault {
}
impl VimFaultTrait for GuestOperationsFault {
}
impl VimFaultTrait for GuestAuthenticationChallenge {
}
impl VimFaultTrait for GuestComponentsOutOfDate {
}
impl VimFaultTrait for GuestMultipleMappings {
}
impl VimFaultTrait for GuestOperationsUnavailable {
}
impl VimFaultTrait for GuestPermissionDenied {
}
impl VimFaultTrait for GuestProcessNotFound {
}
impl VimFaultTrait for GuestRegistryFault {
}
impl VimFaultTrait for GuestRegistryKeyFault {
}
impl VimFaultTrait for GuestRegistryKeyAlreadyExists {
}
impl VimFaultTrait for GuestRegistryKeyHasSubkeys {
}
impl VimFaultTrait for GuestRegistryKeyInvalid {
}
impl VimFaultTrait for GuestRegistryKeyParentVolatile {
}
impl VimFaultTrait for GuestRegistryValueFault {
}
impl VimFaultTrait for GuestRegistryValueNotFound {
}
impl VimFaultTrait for InvalidGuestLogin {
}
impl VimFaultTrait for OperationDisabledByGuest {
}
impl VimFaultTrait for OperationNotSupportedByGuest {
}
impl VimFaultTrait for TooManyGuestLogons {
}
impl VimFaultTrait for HostConfigFault {
}
impl VimFaultTrait for AdminDisabled {
}
impl VimFaultTrait for AdminNotDisabled {
}
impl VimFaultTrait for BlockedByFirewall {
}
impl VimFaultTrait for ClockSkew {
}
impl VimFaultTrait for DisableAdminNotSupported {
}
impl VimFaultTrait for HostConfigFailed {
}
impl VimFaultTrait for HostInDomain {
}
impl VimFaultTrait for InvalidHostName {
}
impl VimFaultTrait for NasConfigFault {
}
impl VimFaultTrait for InvalidNasCredentials {
}
impl VimFaultTrait for InvalidNetworkResource {
}
impl VimFaultTrait for NasConnectionLimitReached {
}
impl VimFaultTrait for NasSessionCredentialConflict {
}
impl VimFaultTrait for NasVolumeNotMounted {
}
impl VimFaultTrait for NetworkInaccessible {
}
impl VimFaultTrait for NoPermissionOnNasVolume {
}
impl VimFaultTrait for NoGateway {
}
impl VimFaultTrait for NoVirtualNic {
}
impl VimFaultTrait for PlatformConfigFault {
}
impl VimFaultTrait for InvalidBundle {
}
impl VimFaultTrait for PatchInstallFailed {
}
impl VimFaultTrait for PatchIntegrityError {
}
impl VimFaultTrait for VmfsMountFault {
}
impl VimFaultTrait for VmfsAlreadyMounted {
}
impl VimFaultTrait for VmfsAmbiguousMount {
}
impl VimFaultTrait for HostConnectFault {
}
impl VimFaultTrait for AgentInstallFailed {
}
impl VimFaultTrait for AlreadyBeingManaged {
}
impl VimFaultTrait for AlreadyConnected {
}
impl VimFaultTrait for CannotAddHostWithFtVmAsStandalone {
}
impl VimFaultTrait for CannotAddHostWithFtVmToDifferentCluster {
}
impl VimFaultTrait for CannotAddHostWithFtVmToNonHaCluster {
}
impl VimFaultTrait for GatewayConnectFault {
}
impl VimFaultTrait for GatewayNotFound {
}
impl VimFaultTrait for GatewayNotReachable {
}
impl VimFaultTrait for GatewayOperationRefused {
}
impl VimFaultTrait for GatewayToHostConnectFault {
}
impl VimFaultTrait for GatewayHostNotReachable {
}
impl VimFaultTrait for GatewayToHostAuthFault {
}
impl VimFaultTrait for GatewayToHostTrustVerifyFault {
}
impl VimFaultTrait for MultipleCertificatesVerifyFault {
}
impl VimFaultTrait for NoHost {
}
impl VimFaultTrait for NoPermissionOnHost {
}
impl VimFaultTrait for NotSupportedHost {
}
impl VimFaultTrait for NonVmwareOuiMacNotSupportedHost {
}
impl VimFaultTrait for NotSupportedHostForVFlash {
}
impl VimFaultTrait for NotSupportedHostForVmcp {
}
impl VimFaultTrait for NotSupportedHostForVmemFile {
}
impl VimFaultTrait for NotSupportedHostForVsan {
}
impl VimFaultTrait for NotSupportedHostInCluster {
}
impl VimFaultTrait for EvcAdmissionFailed {
}
impl VimFaultTrait for EvcAdmissionFailedCpuFeaturesForMode {
}
impl VimFaultTrait for EvcAdmissionFailedCpuModel {
}
impl VimFaultTrait for EvcAdmissionFailedCpuModelForMode {
}
impl VimFaultTrait for EvcAdmissionFailedCpuVendor {
}
impl VimFaultTrait for EvcAdmissionFailedCpuVendorUnknown {
}
impl VimFaultTrait for EvcAdmissionFailedHostDisconnected {
}
impl VimFaultTrait for EvcAdmissionFailedHostSoftware {
}
impl VimFaultTrait for EvcAdmissionFailedHostSoftwareForMode {
}
impl VimFaultTrait for EvcAdmissionFailedVmActive {
}
impl VimFaultTrait for NotSupportedHostInDvs {
}
impl VimFaultTrait for NotSupportedHostInHaCluster {
}
impl VimFaultTrait for ReadHostResourcePoolTreeFailed {
}
impl VimFaultTrait for SslDisabledFault {
}
impl VimFaultTrait for SslVerifyFault {
}
impl VimFaultTrait for TooManyHosts {
}
impl VimFaultTrait for HostHasComponentFailure {
}
impl VimFaultTrait for HostIncompatibleForRecordReplay {
}
impl VimFaultTrait for HostPowerOpFailed {
}
impl VimFaultTrait for NoPeerHostFound {
}
impl VimFaultTrait for VmotionInterfaceNotEnabled {
}
impl VimFaultTrait for WakeOnLanNotSupportedByVmotionNic {
}
impl VimFaultTrait for HostSpecificationOperationFailed {
}
impl VimFaultTrait for HttpFault {
}
impl VimFaultTrait for IormNotSupportedHostOnDatastore {
}
impl VimFaultTrait for InaccessibleVFlashSource {
}
impl VimFaultTrait for InsufficientResourcesFault {
}
impl VimFaultTrait for InsufficientAgentVmsDeployed {
}
impl VimFaultTrait for InsufficientCpuResourcesFault {
}
impl VimFaultTrait for InsufficientFailoverResourcesFault {
}
impl VimFaultTrait for InsufficientGraphicsResourcesFault {
}
impl VimFaultTrait for InsufficientHostCapacityFault {
}
impl VimFaultTrait for InsufficientHostCpuCapacityFault {
}
impl VimFaultTrait for InsufficientHostMemoryCapacityFault {
}
impl VimFaultTrait for InsufficientPerCpuCapacity {
}
impl VimFaultTrait for InsufficientMemoryResourcesFault {
}
impl VimFaultTrait for InsufficientNetworkCapacity {
}
impl VimFaultTrait for InsufficientNetworkResourcePoolCapacity {
}
impl VimFaultTrait for InsufficientStandbyResource {
}
impl VimFaultTrait for InsufficientStandbyCpuResource {
}
impl VimFaultTrait for InsufficientStandbyMemoryResource {
}
impl VimFaultTrait for InsufficientStorageSpace {
}
impl VimFaultTrait for InsufficientVFlashResourcesFault {
}
impl VimFaultTrait for InvalidResourcePoolStructureFault {
}
impl VimFaultTrait for NumVirtualCpusExceedsLimit {
}
impl VimFaultTrait for VmFaultToleranceTooManyFtVcpusOnHost {
}
impl VimFaultTrait for VmFaultToleranceTooManyVMsOnHost {
}
impl VimFaultTrait for VmSmpFaultToleranceTooManyVMsOnHost {
}
impl VimFaultTrait for InsufficientStorageIops {
}
impl VimFaultTrait for InvalidAffinitySettingFault {
}
impl VimFaultTrait for InvalidBmcRole {
}
impl VimFaultTrait for InvalidDatastore {
}
impl VimFaultTrait for DatastoreNotWritableOnHost {
}
impl VimFaultTrait for SwapDatastoreNotWritableOnHost {
}
impl VimFaultTrait for InaccessibleDatastore {
}
impl VimFaultTrait for InaccessibleFtMetadataDatastore {
}
impl VimFaultTrait for InvalidDatastorePath {
}
impl VimFaultTrait for InvalidEvent {
}
impl VimFaultTrait for InvalidFolder {
}
impl VimFaultTrait for VmAlreadyExistsInDatacenter {
}
impl VimFaultTrait for InvalidIpmiLoginInfo {
}
impl VimFaultTrait for InvalidIpmiMacAddress {
}
impl VimFaultTrait for InvalidLicense {
}
impl VimFaultTrait for InvalidLocale {
}
impl VimFaultTrait for InvalidLogin {
}
impl VimFaultTrait for InvalidClientCertificate {
}
impl VimFaultTrait for PasswordExpired {
}
impl VimFaultTrait for InvalidName {
}
impl VimFaultTrait for InvalidPrivilege {
}
impl VimFaultTrait for InvalidState {
}
impl VimFaultTrait for CannotPowerOffVmInCluster {
}
impl VimFaultTrait for EncryptionKeyRequired {
}
impl VimFaultTrait for InvalidDatastoreState {
}
impl VimFaultTrait for InvalidHostState {
}
impl VimFaultTrait for InvalidHostConnectionState {
}
impl VimFaultTrait for InvalidPowerState {
}
impl VimFaultTrait for InvalidVmState {
}
impl VimFaultTrait for MksConnectionLimitReached {
}
impl VimFaultTrait for NoActiveHostInCluster {
}
impl VimFaultTrait for OvfConsumerPowerOnFault {
}
impl VimFaultTrait for QuestionPending {
}
impl VimFaultTrait for VmPowerOnDisabled {
}
impl VimFaultTrait for IscsiFault {
}
impl VimFaultTrait for IscsiFaultInvalidVnic {
}
impl VimFaultTrait for IscsiFaultPnicInUse {
}
impl VimFaultTrait for IscsiFaultVnicAlreadyBound {
}
impl VimFaultTrait for IscsiFaultVnicHasActivePaths {
}
impl VimFaultTrait for IscsiFaultVnicHasMultipleUplinks {
}
impl VimFaultTrait for IscsiFaultVnicHasNoUplinks {
}
impl VimFaultTrait for IscsiFaultVnicHasWrongUplink {
}
impl VimFaultTrait for IscsiFaultVnicInUse {
}
impl VimFaultTrait for IscsiFaultVnicIsLastPath {
}
impl VimFaultTrait for IscsiFaultVnicNotBound {
}
impl VimFaultTrait for IscsiFaultVnicNotFound {
}
impl VimFaultTrait for KeyNotFound {
}
impl VimFaultTrait for LicenseEntityNotFound {
}
impl VimFaultTrait for LicenseServerUnavailable {
}
impl VimFaultTrait for LimitExceeded {
}
impl VimFaultTrait for LogBundlingFailed {
}
impl VimFaultTrait for MigrationFault {
}
impl VimFaultTrait for AffinityConfigured {
}
impl VimFaultTrait for CannotModifyConfigCpuRequirements {
}
impl VimFaultTrait for CannotMoveVmWithDeltaDisk {
}
impl VimFaultTrait for CannotMoveVmWithNativeDeltaDisk {
}
impl VimFaultTrait for CloneFromSnapshotNotSupported {
}
impl VimFaultTrait for DatacenterMismatch {
}
impl VimFaultTrait for DisallowedMigrationDeviceAttached {
}
impl VimFaultTrait for DiskMoveTypeNotSupported {
}
impl VimFaultTrait for FaultToleranceAntiAffinityViolated {
}
impl VimFaultTrait for FaultToleranceNeedsThickDisk {
}
impl VimFaultTrait for FaultToleranceNotSameBuild {
}
impl VimFaultTrait for HaErrorsAtDest {
}
impl VimFaultTrait for IncompatibleDefaultDevice {
}
impl VimFaultTrait for LargeRdmConversionNotSupported {
}
impl VimFaultTrait for MaintenanceModeFileMove {
}
impl VimFaultTrait for MigrationDisabled {
}
impl VimFaultTrait for MigrationFeatureNotSupported {
}
impl VimFaultTrait for FullStorageVMotionNotSupported {
}
impl VimFaultTrait for IndependentDiskVMotionNotSupported {
}
impl VimFaultTrait for NonHomeRdmvMotionNotSupported {
}
impl VimFaultTrait for StorageVMotionNotSupported {
}
impl VimFaultTrait for UnsharedSwapVMotionNotSupported {
}
impl VimFaultTrait for VMotionAcrossNetworkNotSupported {
}
impl VimFaultTrait for MigrationNotReady {
}
impl VimFaultTrait for MismatchedNetworkPolicies {
}
impl VimFaultTrait for MismatchedVMotionNetworkNames {
}
impl VimFaultTrait for NetworksMayNotBeTheSame {
}
impl VimFaultTrait for NoGuestHeartbeat {
}
impl VimFaultTrait for RdmConversionNotSupported {
}
impl VimFaultTrait for RdmNotPreserved {
}
impl VimFaultTrait for ReadOnlyDisksWithLegacyDestination {
}
impl VimFaultTrait for SnapshotCopyNotSupported {
}
impl VimFaultTrait for HotSnapshotMoveNotSupported {
}
impl VimFaultTrait for SnapshotCloneNotSupported {
}
impl VimFaultTrait for SnapshotMoveFromNonHomeNotSupported {
}
impl VimFaultTrait for SnapshotMoveNotSupported {
}
impl VimFaultTrait for SnapshotMoveToNonHomeNotSupported {
}
impl VimFaultTrait for SnapshotRevertIssue {
}
impl VimFaultTrait for SuspendedRelocateNotSupported {
}
impl VimFaultTrait for TooManyDisksOnLegacyHost {
}
impl VimFaultTrait for ToolsInstallationInProgress {
}
impl VimFaultTrait for UncommittedUndoableDisk {
}
impl VimFaultTrait for VMotionInterfaceIssue {
}
impl VimFaultTrait for VMotionLinkCapacityLow {
}
impl VimFaultTrait for VMotionLinkDown {
}
impl VimFaultTrait for VMotionNotConfigured {
}
impl VimFaultTrait for VMotionNotLicensed {
}
impl VimFaultTrait for VMotionNotSupported {
}
impl VimFaultTrait for VMotionProtocolIncompatible {
}
impl VimFaultTrait for WillLoseHaProtection {
}
impl VimFaultTrait for WillModifyConfigCpuRequirements {
}
impl VimFaultTrait for WillResetSnapshotDirectory {
}
impl VimFaultTrait for MismatchedBundle {
}
impl VimFaultTrait for MissingBmcSupport {
}
impl VimFaultTrait for NamespaceFull {
}
impl VimFaultTrait for NamespaceLimitReached {
}
impl VimFaultTrait for NamespaceWriteProtected {
}
impl VimFaultTrait for NetworkDisruptedAndConfigRolledBack {
}
impl VimFaultTrait for NoClientCertificate {
}
impl VimFaultTrait for NoCompatibleDatastore {
}
impl VimFaultTrait for NoCompatibleHost {
}
impl VimFaultTrait for NoCompatibleHostWithAccessToDevice {
}
impl VimFaultTrait for NoConnectedDatastore {
}
impl VimFaultTrait for NoDiskFound {
}
impl VimFaultTrait for NoSubjectName {
}
impl VimFaultTrait for NotFound {
}
impl VimFaultTrait for NotSupportedHostForChecksum {
}
impl VimFaultTrait for OutOfBounds {
}
impl VimFaultTrait for OvfFault {
}
impl VimFaultTrait for OvfConsumerCallbackFault {
}
impl VimFaultTrait for OvfConsumerCommunicationError {
}
impl VimFaultTrait for OvfConsumerFault {
}
impl VimFaultTrait for OvfConsumerInvalidSection {
}
impl VimFaultTrait for OvfConsumerUndeclaredSection {
}
impl VimFaultTrait for OvfConsumerUndefinedPrefix {
}
impl VimFaultTrait for OvfExport {
}
impl VimFaultTrait for ConnectedIso {
}
impl VimFaultTrait for OvfDuplicatedPropertyIdExport {
}
impl VimFaultTrait for OvfDuplicatedPropertyIdImport {
}
impl VimFaultTrait for OvfExportFailed {
}
impl VimFaultTrait for OvfHardwareExport {
}
impl VimFaultTrait for OvfConnectedDevice {
}
impl VimFaultTrait for OvfConnectedDeviceFloppy {
}
impl VimFaultTrait for OvfConnectedDeviceIso {
}
impl VimFaultTrait for OvfUnableToExportDisk {
}
impl VimFaultTrait for OvfUnknownDeviceBacking {
}
impl VimFaultTrait for OvfUnsupportedDeviceExport {
}
impl VimFaultTrait for OvfPropertyExport {
}
impl VimFaultTrait for OvfPropertyNetworkExport {
}
impl VimFaultTrait for OvfImport {
}
impl VimFaultTrait for OvfCpuCompatibility {
}
impl VimFaultTrait for OvfCpuCompatibilityCheckNotSupported {
}
impl VimFaultTrait for OvfHardwareCheck {
}
impl VimFaultTrait for OvfImportFailed {
}
impl VimFaultTrait for OvfMappedOsId {
}
impl VimFaultTrait for OvfMissingHardware {
}
impl VimFaultTrait for OvfNetworkMappingNotSupported {
}
impl VimFaultTrait for OvfUnsupportedDiskProvisioning {
}
impl VimFaultTrait for OvfInvalidPackage {
}
impl VimFaultTrait for OvfAttribute {
}
impl VimFaultTrait for OvfInvalidValue {
}
impl VimFaultTrait for OvfInvalidValueConfiguration {
}
impl VimFaultTrait for OvfInvalidValueEmpty {
}
impl VimFaultTrait for OvfInvalidValueFormatMalformed {
}
impl VimFaultTrait for OvfInvalidValueReference {
}
impl VimFaultTrait for OvfMissingAttribute {
}
impl VimFaultTrait for OvfConstraint {
}
impl VimFaultTrait for OvfDiskOrderConstraint {
}
impl VimFaultTrait for OvfHostResourceConstraint {
}
impl VimFaultTrait for OvfElement {
}
impl VimFaultTrait for OvfDuplicateElement {
}
impl VimFaultTrait for OvfDuplicatedElementBoundary {
}
impl VimFaultTrait for OvfElementInvalidValue {
}
impl VimFaultTrait for OvfMissingElement {
}
impl VimFaultTrait for OvfMissingElementNormalBoundary {
}
impl VimFaultTrait for OvfUnexpectedElement {
}
impl VimFaultTrait for OvfWrongElement {
}
impl VimFaultTrait for OvfProperty {
}
impl VimFaultTrait for OvfPropertyNetwork {
}
impl VimFaultTrait for OvfPropertyQualifier {
}
impl VimFaultTrait for OvfPropertyQualifierDuplicate {
}
impl VimFaultTrait for OvfPropertyQualifierIgnored {
}
impl VimFaultTrait for OvfPropertyType {
}
impl VimFaultTrait for OvfPropertyValue {
}
impl VimFaultTrait for OvfWrongNamespace {
}
impl VimFaultTrait for OvfXmlFormat {
}
impl VimFaultTrait for OvfSystemFault {
}
impl VimFaultTrait for OvfDiskMappingNotFound {
}
impl VimFaultTrait for OvfHostValueNotParsed {
}
impl VimFaultTrait for OvfInternalError {
}
impl VimFaultTrait for OvfToXmlUnsupportedElement {
}
impl VimFaultTrait for OvfUnknownDevice {
}
impl VimFaultTrait for OvfUnknownEntity {
}
impl VimFaultTrait for OvfUnsupportedDeviceBackingInfo {
}
impl VimFaultTrait for OvfUnsupportedDeviceBackingOption {
}
impl VimFaultTrait for OvfUnsupportedPackage {
}
impl VimFaultTrait for OvfInvalidVmName {
}
impl VimFaultTrait for OvfNoHostNic {
}
impl VimFaultTrait for OvfNoSupportedHardwareFamily {
}
impl VimFaultTrait for OvfUnsupportedAttribute {
}
impl VimFaultTrait for OvfUnsupportedAttributeValue {
}
impl VimFaultTrait for OvfUnsupportedElement {
}
impl VimFaultTrait for OvfNoSpaceOnController {
}
impl VimFaultTrait for OvfUnsupportedElementValue {
}
impl VimFaultTrait for OvfUnsupportedSection {
}
impl VimFaultTrait for OvfUnsupportedSubType {
}
impl VimFaultTrait for OvfUnsupportedType {
}
impl VimFaultTrait for PatchBinariesNotFound {
}
impl VimFaultTrait for PatchMetadataInvalid {
}
impl VimFaultTrait for PatchMetadataCorrupted {
}
impl VimFaultTrait for PatchMetadataNotFound {
}
impl VimFaultTrait for PatchNotApplicable {
}
impl VimFaultTrait for PatchAlreadyInstalled {
}
impl VimFaultTrait for PatchMissingDependencies {
}
impl VimFaultTrait for PatchSuperseded {
}
impl VimFaultTrait for ProfileUpdateFailed {
}
impl VimFaultTrait for RebootRequired {
}
impl VimFaultTrait for RecordReplayDisabled {
}
impl VimFaultTrait for RemoveFailed {
}
impl VimFaultTrait for ReplicationFault {
}
impl VimFaultTrait for IncompatibleHostForVmReplication {
}
impl VimFaultTrait for ReplicationConfigFault {
}
impl VimFaultTrait for ReplicationDiskConfigFault {
}
impl VimFaultTrait for ReplicationVmConfigFault {
}
impl VimFaultTrait for ReplicationIncompatibleWithFt {
}
impl VimFaultTrait for ReplicationInvalidOptions {
}
impl VimFaultTrait for ReplicationNotSupportedOnHost {
}
impl VimFaultTrait for ReplicationVmFault {
}
impl VimFaultTrait for ReplicationVmInProgressFault {
}
impl VimFaultTrait for ResourceInUse {
}
impl VimFaultTrait for FilterInUse {
}
impl VimFaultTrait for QuiesceDatastoreIoForHaFailed {
}
impl VimFaultTrait for ResourceNotAvailable {
}
impl VimFaultTrait for SspiChallenge {
}
impl VimFaultTrait for ShrinkDiskFault {
}
impl VimFaultTrait for SnapshotFault {
}
impl VimFaultTrait for ApplicationQuiesceFault {
}
impl VimFaultTrait for FilesystemQuiesceFault {
}
impl VimFaultTrait for MemorySnapshotOnIndependentDisk {
}
impl VimFaultTrait for MultipleSnapshotsNotSupported {
}
impl VimFaultTrait for SnapshotDisabled {
}
impl VimFaultTrait for SnapshotIncompatibleDeviceInVm {
}
impl VimFaultTrait for SnapshotLocked {
}
impl VimFaultTrait for SnapshotNoChange {
}
impl VimFaultTrait for TooManySnapshotLevels {
}
impl VimFaultTrait for SsdDiskNotAvailable {
}
impl VimFaultTrait for StorageDrsCannotMoveDiskInMultiWriterMode {
}
impl VimFaultTrait for StorageDrsCannotMoveFtVm {
}
impl VimFaultTrait for StorageDrsCannotMoveIndependentDisk {
}
impl VimFaultTrait for StorageDrsCannotMoveManuallyPlacedSwapFile {
}
impl VimFaultTrait for StorageDrsCannotMoveManuallyPlacedVm {
}
impl VimFaultTrait for StorageDrsCannotMoveSharedDisk {
}
impl VimFaultTrait for StorageDrsCannotMoveTemplate {
}
impl VimFaultTrait for StorageDrsCannotMoveVmInUserFolder {
}
impl VimFaultTrait for StorageDrsCannotMoveVmWithMountedCdrom {
}
impl VimFaultTrait for StorageDrsCannotMoveVmWithNoFilesInLayout {
}
impl VimFaultTrait for StorageDrsDatacentersCannotShareDatastore {
}
impl VimFaultTrait for StorageDrsDisabledOnVm {
}
impl VimFaultTrait for StorageDrsHbrDiskNotMovable {
}
impl VimFaultTrait for StorageDrsHmsMoveInProgress {
}
impl VimFaultTrait for StorageDrsHmsUnreachable {
}
impl VimFaultTrait for StorageDrsIolbDisabledInternally {
}
impl VimFaultTrait for StorageDrsRelocateDisabled {
}
impl VimFaultTrait for StorageDrsStaleHmsCollection {
}
impl VimFaultTrait for StorageDrsUnableToMoveFiles {
}
impl VimFaultTrait for SwapDatastoreUnset {
}
impl VimFaultTrait for TaskInProgress {
}
impl VimFaultTrait for VAppTaskInProgress {
}
impl VimFaultTrait for Timedout {
}
impl VimFaultTrait for PowerOnFtSecondaryTimedout {
}
impl VimFaultTrait for TooManyConsecutiveOverrides {
}
impl VimFaultTrait for ToolsUnavailable {
}
impl VimFaultTrait for UnrecognizedHost {
}
impl VimFaultTrait for UnsupportedVimApiVersion {
}
impl VimFaultTrait for UserNotFound {
}
impl VimFaultTrait for VAppConfigFault {
}
impl VimFaultTrait for MissingPowerOffConfiguration {
}
impl VimFaultTrait for MissingPowerOnConfiguration {
}
impl VimFaultTrait for NoVmInVApp {
}
impl VimFaultTrait for VFlashModuleVersionIncompatible {
}
impl VimFaultTrait for VmConfigFault {
}
impl VimFaultTrait for CannotAccessVmComponent {
}
impl VimFaultTrait for CannotAccessVmConfig {
}
impl VimFaultTrait for CannotAccessVmDevice {
}
impl VimFaultTrait for CannotAccessNetwork {
}
impl VimFaultTrait for DestinationSwitchFull {
}
impl VimFaultTrait for LegacyNetworkInterfaceInUse {
}
impl VimFaultTrait for VmOnConflictDvPort {
}
impl VimFaultTrait for VmOnVirtualIntranet {
}
impl VimFaultTrait for CannotAccessVmDisk {
}
impl VimFaultTrait for RdmPointsToInaccessibleDisk {
}
impl VimFaultTrait for CannotDisableSnapshot {
}
impl VimFaultTrait for CannotUseNetwork {
}
impl VimFaultTrait for CpuHotPlugNotSupported {
}
impl VimFaultTrait for DeltaDiskFormatNotSupported {
}
impl VimFaultTrait for EightHostLimitViolated {
}
impl VimFaultTrait for FaultToleranceCannotEditMem {
}
impl VimFaultTrait for GenericVmConfigFault {
}
impl VimFaultTrait for InvalidFormat {
}
impl VimFaultTrait for InvalidDiskFormat {
}
impl VimFaultTrait for InvalidSnapshotFormat {
}
impl VimFaultTrait for InvalidVmConfig {
}
impl VimFaultTrait for InvalidDeviceSpec {
}
impl VimFaultTrait for DeviceHotPlugNotSupported {
}
impl VimFaultTrait for DeviceNotFound {
}
impl VimFaultTrait for DeviceUnsupportedForVmPlatform {
}
impl VimFaultTrait for DeviceUnsupportedForVmVersion {
}
impl VimFaultTrait for DisallowedDiskModeChange {
}
impl VimFaultTrait for InvalidController {
}
impl VimFaultTrait for InvalidDeviceBacking {
}
impl VimFaultTrait for InvalidDeviceOperation {
}
impl VimFaultTrait for MissingController {
}
impl VimFaultTrait for SwapPlacementOverrideNotSupported {
}
impl VimFaultTrait for TooManyDevices {
}
impl VimFaultTrait for UnsupportedGuest {
}
impl VimFaultTrait for VmWwnConflict {
}
impl VimFaultTrait for LargeRdmNotSupportedOnDatastore {
}
impl VimFaultTrait for MemoryHotPlugNotSupported {
}
impl VimFaultTrait for NoCompatibleHardAffinityHost {
}
impl VimFaultTrait for NoCompatibleSoftAffinityHost {
}
impl VimFaultTrait for NumVirtualCpusIncompatible {
}
impl VimFaultTrait for OvfConsumerValidationFault {
}
impl VimFaultTrait for QuarantineModeFault {
}
impl VimFaultTrait for RdmNotSupportedOnDatastore {
}
impl VimFaultTrait for RuleViolation {
}
impl VimFaultTrait for SoftRuleVioCorrectionDisallowed {
}
impl VimFaultTrait for SoftRuleVioCorrectionImpact {
}
impl VimFaultTrait for UnsupportedDatastore {
}
impl VimFaultTrait for MemoryFileFormatNotSupportedByDatastore {
}
impl VimFaultTrait for UnSupportedDatastoreForVFlash {
}
impl VimFaultTrait for UnsupportedVmxLocation {
}
impl VimFaultTrait for VAppNotRunning {
}
impl VimFaultTrait for VAppPropertyFault {
}
impl VimFaultTrait for InvalidNetworkInType {
}
impl VimFaultTrait for InvalidPropertyType {
}
impl VimFaultTrait for InvalidPropertyValue {
}
impl VimFaultTrait for UnconfiguredPropertyValue {
}
impl VimFaultTrait for MissingIpPool {
}
impl VimFaultTrait for MissingNetworkIpConfig {
}
impl VimFaultTrait for NoAvailableIp {
}
impl VimFaultTrait for NoVcManagedIpConfigured {
}
impl VimFaultTrait for NotUserConfigurableProperty {
}
impl VimFaultTrait for VFlashCacheHotConfigNotSupported {
}
impl VimFaultTrait for VFlashModuleNotSupported {
}
impl VimFaultTrait for VirtualHardwareCompatibilityIssue {
}
impl VimFaultTrait for CpuIncompatible {
}
impl VimFaultTrait for CpuCompatibilityUnknown {
}
impl VimFaultTrait for CpuIncompatible1Ecx {
}
impl VimFaultTrait for CpuIncompatible81Edx {
}
impl VimFaultTrait for FaultToleranceCpuIncompatible {
}
impl VimFaultTrait for DeviceNotSupported {
}
impl VimFaultTrait for DeviceBackingNotSupported {
}
impl VimFaultTrait for DvPortNotSupported {
}
impl VimFaultTrait for UnusedVirtualDiskBlocksNotScrubbed {
}
impl VimFaultTrait for VirtualDiskBlocksNotFullyProvisioned {
}
impl VimFaultTrait for DeviceControllerNotSupported {
}
impl VimFaultTrait for DigestNotSupported {
}
impl VimFaultTrait for FileBackedPortNotSupported {
}
impl VimFaultTrait for MultiWriterNotSupported {
}
impl VimFaultTrait for NonPersistentDisksNotSupported {
}
impl VimFaultTrait for RdmNotSupported {
}
impl VimFaultTrait for PhysCompatRdmNotSupported {
}
impl VimFaultTrait for RawDiskNotSupported {
}
impl VimFaultTrait for RemoteDeviceNotSupported {
}
impl VimFaultTrait for SharedBusControllerNotSupported {
}
impl VimFaultTrait for VmiNotSupported {
}
impl VimFaultTrait for VirtualDiskModeNotSupported {
}
impl VimFaultTrait for VirtualEthernetCardNotSupported {
}
impl VimFaultTrait for DiskNotSupported {
}
impl VimFaultTrait for IdeDiskNotSupported {
}
impl VimFaultTrait for DrsVmotionIncompatibleFault {
}
impl VimFaultTrait for FeatureRequirementsNotMet {
}
impl VimFaultTrait for MemorySizeNotRecommended {
}
impl VimFaultTrait for MemorySizeNotSupported {
}
impl VimFaultTrait for MemorySizeNotSupportedByDatastore {
}
impl VimFaultTrait for NotEnoughCpus {
}
impl VimFaultTrait for NotEnoughLogicalCpus {
}
impl VimFaultTrait for NumVirtualCoresPerSocketNotSupported {
}
impl VimFaultTrait for NumVirtualCpusNotSupported {
}
impl VimFaultTrait for StorageVmotionIncompatible {
}
impl VimFaultTrait for VirtualHardwareVersionNotSupported {
}
impl VimFaultTrait for WakeOnLanNotSupported {
}
impl VimFaultTrait for VmConfigIncompatibleForFaultTolerance {
}
impl VimFaultTrait for VmConfigIncompatibleForRecordReplay {
}
impl VimFaultTrait for VmHostAffinityRuleViolation {
}
impl VimFaultTrait for VmFaultToleranceIssue {
}
impl VimFaultTrait for CannotChangeDrsBehaviorForFtSecondary {
}
impl VimFaultTrait for CannotChangeHaSettingsForFtSecondary {
}
impl VimFaultTrait for CannotComputeFtCompatibleHosts {
}
impl VimFaultTrait for FaultToleranceNotLicensed {
}
impl VimFaultTrait for FaultTolerancePrimaryPowerOnNotAttempted {
}
impl VimFaultTrait for FtIssuesOnHost {
}
impl VimFaultTrait for HostIncompatibleForFaultTolerance {
}
impl VimFaultTrait for IncompatibleHostForFtSecondary {
}
impl VimFaultTrait for InvalidOperationOnSecondaryVm {
}
impl VimFaultTrait for NoHostSuitableForFtSecondary {
}
impl VimFaultTrait for NotSupportedDeviceForFt {
}
impl VimFaultTrait for PowerOnFtSecondaryFailed {
}
impl VimFaultTrait for SecondaryVmAlreadyDisabled {
}
impl VimFaultTrait for SecondaryVmAlreadyEnabled {
}
impl VimFaultTrait for SecondaryVmAlreadyRegistered {
}
impl VimFaultTrait for SecondaryVmNotRegistered {
}
impl VimFaultTrait for VmFaultToleranceConfigIssue {
}
impl VimFaultTrait for VmFaultToleranceConfigIssueWrapper {
}
impl VimFaultTrait for VmFaultToleranceInvalidFileBacking {
}
impl VimFaultTrait for VmFaultToleranceOpIssuesList {
}
impl VimFaultTrait for VmMetadataManagerFault {
}
impl VimFaultTrait for VmMonitorIncompatibleForFaultTolerance {
}
impl VimFaultTrait for VmToolsUpgradeFault {
}
impl VimFaultTrait for ToolsAlreadyUpgraded {
}
impl VimFaultTrait for ToolsAutoUpgradeNotSupported {
}
impl VimFaultTrait for ToolsImageCopyFailed {
}
impl VimFaultTrait for ToolsImageNotAvailable {
}
impl VimFaultTrait for ToolsImageSignatureCheckFailed {
}
impl VimFaultTrait for ToolsUpgradeCancelled {
}
impl VimFaultTrait for VmValidateMaxDevice {
}
impl VimFaultTrait for VsanFault {
}
impl VimFaultTrait for CannotChangeVsanClusterUuid {
}
impl VimFaultTrait for CannotChangeVsanNodeUuid {
}
impl VimFaultTrait for CannotMoveVsanEnabledHost {
}
impl VimFaultTrait for DestinationVsanDisabled {
}
impl VimFaultTrait for VsanClusterUuidMismatch {
}
impl VimFaultTrait for CannotReconfigureVsanWhenHaEnabled {
}
impl VimFaultTrait for DuplicateVsanNetworkInterface {
}
impl VimFaultTrait for VsanDiskFault {
}
impl VimFaultTrait for DiskHasPartitions {
}
impl VimFaultTrait for DiskIsLastRemainingNonSsd {
}
impl VimFaultTrait for DiskIsNonLocal {
}
impl VimFaultTrait for DiskIsUsb {
}
impl VimFaultTrait for DiskTooSmall {
}
impl VimFaultTrait for DuplicateDisks {
}
impl VimFaultTrait for InsufficientDisks {
}
impl VimFaultTrait for VsanIncompatibleDiskMapping {
}
impl VimFaultTrait for WipeDiskFault {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VimFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VimFault => Some(from.as_any_ref().downcast_ref::<VimFault>()?),
            StructType::ActiveDirectoryFault => Some(from.as_any_ref().downcast_ref::<ActiveDirectoryFault>()?),
            StructType::DomainNotFound => Some(from.as_any_ref().downcast_ref::<DomainNotFound>()?),
            StructType::InvalidCamServer => Some(from.as_any_ref().downcast_ref::<InvalidCamServer>()?),
            StructType::CamServerRefusedConnection => Some(from.as_any_ref().downcast_ref::<CamServerRefusedConnection>()?),
            StructType::InvalidCamCertificate => Some(from.as_any_ref().downcast_ref::<InvalidCamCertificate>()?),
            StructType::NoPermissionOnAd => Some(from.as_any_ref().downcast_ref::<NoPermissionOnAd>()?),
            StructType::NonAdUserRequired => Some(from.as_any_ref().downcast_ref::<NonAdUserRequired>()?),
            StructType::AlreadyExists => Some(from.as_any_ref().downcast_ref::<AlreadyExists>()?),
            StructType::AlreadyUpgraded => Some(from.as_any_ref().downcast_ref::<AlreadyUpgraded>()?),
            StructType::AnswerFileUpdateFailed => Some(from.as_any_ref().downcast_ref::<AnswerFileUpdateFailed>()?),
            StructType::AuthMinimumAdminPermission => Some(from.as_any_ref().downcast_ref::<AuthMinimumAdminPermission>()?),
            StructType::CannotAccessLocalSource => Some(from.as_any_ref().downcast_ref::<CannotAccessLocalSource>()?),
            StructType::CannotDisconnectHostWithFaultToleranceVm => Some(from.as_any_ref().downcast_ref::<CannotDisconnectHostWithFaultToleranceVm>()?),
            StructType::CannotEnableVmcpForCluster => Some(from.as_any_ref().downcast_ref::<CannotEnableVmcpForCluster>()?),
            StructType::CannotMoveFaultToleranceVm => Some(from.as_any_ref().downcast_ref::<CannotMoveFaultToleranceVm>()?),
            StructType::CannotMoveHostWithFaultToleranceVm => Some(from.as_any_ref().downcast_ref::<CannotMoveHostWithFaultToleranceVm>()?),
            StructType::CannotPlaceWithoutPrerequisiteMoves => Some(from.as_any_ref().downcast_ref::<CannotPlaceWithoutPrerequisiteMoves>()?),
            StructType::ConcurrentAccess => Some(from.as_any_ref().downcast_ref::<ConcurrentAccess>()?),
            StructType::CustomizationFault => Some(from.as_any_ref().downcast_ref::<CustomizationFault>()?),
            StructType::CannotDecryptPasswords => Some(from.as_any_ref().downcast_ref::<CannotDecryptPasswords>()?),
            StructType::CustomizationPending => Some(from.as_any_ref().downcast_ref::<CustomizationPending>()?),
            StructType::IpHostnameGeneratorError => Some(from.as_any_ref().downcast_ref::<IpHostnameGeneratorError>()?),
            StructType::LinuxVolumeNotClean => Some(from.as_any_ref().downcast_ref::<LinuxVolumeNotClean>()?),
            StructType::MissingLinuxCustResources => Some(from.as_any_ref().downcast_ref::<MissingLinuxCustResources>()?),
            StructType::MissingWindowsCustResources => Some(from.as_any_ref().downcast_ref::<MissingWindowsCustResources>()?),
            StructType::MountError => Some(from.as_any_ref().downcast_ref::<MountError>()?),
            StructType::NicSettingMismatch => Some(from.as_any_ref().downcast_ref::<NicSettingMismatch>()?),
            StructType::NoDisksToCustomize => Some(from.as_any_ref().downcast_ref::<NoDisksToCustomize>()?),
            StructType::UncustomizableGuest => Some(from.as_any_ref().downcast_ref::<UncustomizableGuest>()?),
            StructType::UnexpectedCustomizationFault => Some(from.as_any_ref().downcast_ref::<UnexpectedCustomizationFault>()?),
            StructType::VolumeEditorError => Some(from.as_any_ref().downcast_ref::<VolumeEditorError>()?),
            StructType::DasConfigFault => Some(from.as_any_ref().downcast_ref::<DasConfigFault>()?),
            StructType::DrsDisabledOnVm => Some(from.as_any_ref().downcast_ref::<DrsDisabledOnVm>()?),
            StructType::DuplicateName => Some(from.as_any_ref().downcast_ref::<DuplicateName>()?),
            StructType::DvsFault => Some(from.as_any_ref().downcast_ref::<DvsFault>()?),
            StructType::BackupBlobReadFailure => Some(from.as_any_ref().downcast_ref::<BackupBlobReadFailure>()?),
            StructType::BackupBlobWriteFailure => Some(from.as_any_ref().downcast_ref::<BackupBlobWriteFailure>()?),
            StructType::CollectorAddressUnset => Some(from.as_any_ref().downcast_ref::<CollectorAddressUnset>()?),
            StructType::ConflictingConfiguration => Some(from.as_any_ref().downcast_ref::<ConflictingConfiguration>()?),
            StructType::DvsApplyOperationFault => Some(from.as_any_ref().downcast_ref::<DvsApplyOperationFault>()?),
            StructType::DvsNotAuthorized => Some(from.as_any_ref().downcast_ref::<DvsNotAuthorized>()?),
            StructType::DvsOperationBulkFault => Some(from.as_any_ref().downcast_ref::<DvsOperationBulkFault>()?),
            StructType::DvsScopeViolated => Some(from.as_any_ref().downcast_ref::<DvsScopeViolated>()?),
            StructType::ImportHostAddFailure => Some(from.as_any_ref().downcast_ref::<ImportHostAddFailure>()?),
            StructType::ImportOperationBulkFault => Some(from.as_any_ref().downcast_ref::<ImportOperationBulkFault>()?),
            StructType::InvalidIpfixConfig => Some(from.as_any_ref().downcast_ref::<InvalidIpfixConfig>()?),
            StructType::RollbackFailure => Some(from.as_any_ref().downcast_ref::<RollbackFailure>()?),
            StructType::SwitchIpUnset => Some(from.as_any_ref().downcast_ref::<SwitchIpUnset>()?),
            StructType::SwitchNotInUpgradeMode => Some(from.as_any_ref().downcast_ref::<SwitchNotInUpgradeMode>()?),
            StructType::VspanDestPortConflict => Some(from.as_any_ref().downcast_ref::<VspanDestPortConflict>()?),
            StructType::VspanPortConflict => Some(from.as_any_ref().downcast_ref::<VspanPortConflict>()?),
            StructType::VspanPortMoveFault => Some(from.as_any_ref().downcast_ref::<VspanPortMoveFault>()?),
            StructType::VspanPortPromiscChangeFault => Some(from.as_any_ref().downcast_ref::<VspanPortPromiscChangeFault>()?),
            StructType::VspanPortgroupPromiscChangeFault => Some(from.as_any_ref().downcast_ref::<VspanPortgroupPromiscChangeFault>()?),
            StructType::VspanPortgroupTypeChangeFault => Some(from.as_any_ref().downcast_ref::<VspanPortgroupTypeChangeFault>()?),
            StructType::VspanPromiscuousPortNotSupported => Some(from.as_any_ref().downcast_ref::<VspanPromiscuousPortNotSupported>()?),
            StructType::VspanSameSessionPortConflict => Some(from.as_any_ref().downcast_ref::<VspanSameSessionPortConflict>()?),
            StructType::EvcConfigFault => Some(from.as_any_ref().downcast_ref::<EvcConfigFault>()?),
            StructType::ActiveVMsBlockingEvc => Some(from.as_any_ref().downcast_ref::<ActiveVMsBlockingEvc>()?),
            StructType::DisconnectedHostsBlockingEvc => Some(from.as_any_ref().downcast_ref::<DisconnectedHostsBlockingEvc>()?),
            StructType::EvcModeIllegalByVendor => Some(from.as_any_ref().downcast_ref::<EvcModeIllegalByVendor>()?),
            StructType::EvcModeUnsupportedByHosts => Some(from.as_any_ref().downcast_ref::<EvcModeUnsupportedByHosts>()?),
            StructType::EvcUnsupportedByHostHardware => Some(from.as_any_ref().downcast_ref::<EvcUnsupportedByHostHardware>()?),
            StructType::EvcUnsupportedByHostSoftware => Some(from.as_any_ref().downcast_ref::<EvcUnsupportedByHostSoftware>()?),
            StructType::HeterogenousHostsBlockingEvc => Some(from.as_any_ref().downcast_ref::<HeterogenousHostsBlockingEvc>()?),
            StructType::ExtendedFault => Some(from.as_any_ref().downcast_ref::<ExtendedFault>()?),
            StructType::FaultToleranceVmNotDasProtected => Some(from.as_any_ref().downcast_ref::<FaultToleranceVmNotDasProtected>()?),
            StructType::FcoeFault => Some(from.as_any_ref().downcast_ref::<FcoeFault>()?),
            StructType::FcoeFaultPnicHasNoPortSet => Some(from.as_any_ref().downcast_ref::<FcoeFaultPnicHasNoPortSet>()?),
            StructType::FileFault => Some(from.as_any_ref().downcast_ref::<FileFault>()?),
            StructType::CannotAccessFile => Some(from.as_any_ref().downcast_ref::<CannotAccessFile>()?),
            StructType::CannotCreateFile => Some(from.as_any_ref().downcast_ref::<CannotCreateFile>()?),
            StructType::CannotDeleteFile => Some(from.as_any_ref().downcast_ref::<CannotDeleteFile>()?),
            StructType::DirectoryNotEmpty => Some(from.as_any_ref().downcast_ref::<DirectoryNotEmpty>()?),
            StructType::FileAlreadyExists => Some(from.as_any_ref().downcast_ref::<FileAlreadyExists>()?),
            StructType::FileLocked => Some(from.as_any_ref().downcast_ref::<FileLocked>()?),
            StructType::FileNameTooLong => Some(from.as_any_ref().downcast_ref::<FileNameTooLong>()?),
            StructType::FileNotFound => Some(from.as_any_ref().downcast_ref::<FileNotFound>()?),
            StructType::FileNotWritable => Some(from.as_any_ref().downcast_ref::<FileNotWritable>()?),
            StructType::FileTooLarge => Some(from.as_any_ref().downcast_ref::<FileTooLarge>()?),
            StructType::IncorrectFileType => Some(from.as_any_ref().downcast_ref::<IncorrectFileType>()?),
            StructType::NetworkCopyFault => Some(from.as_any_ref().downcast_ref::<NetworkCopyFault>()?),
            StructType::NoDiskSpace => Some(from.as_any_ref().downcast_ref::<NoDiskSpace>()?),
            StructType::NotADirectory => Some(from.as_any_ref().downcast_ref::<NotADirectory>()?),
            StructType::NotAFile => Some(from.as_any_ref().downcast_ref::<NotAFile>()?),
            StructType::TooManyConcurrentNativeClones => Some(from.as_any_ref().downcast_ref::<TooManyConcurrentNativeClones>()?),
            StructType::TooManyNativeCloneLevels => Some(from.as_any_ref().downcast_ref::<TooManyNativeCloneLevels>()?),
            StructType::TooManyNativeClonesOnFile => Some(from.as_any_ref().downcast_ref::<TooManyNativeClonesOnFile>()?),
            StructType::GenericDrsFault => Some(from.as_any_ref().downcast_ref::<GenericDrsFault>()?),
            StructType::GuestOperationsFault => Some(from.as_any_ref().downcast_ref::<GuestOperationsFault>()?),
            StructType::GuestAuthenticationChallenge => Some(from.as_any_ref().downcast_ref::<GuestAuthenticationChallenge>()?),
            StructType::GuestComponentsOutOfDate => Some(from.as_any_ref().downcast_ref::<GuestComponentsOutOfDate>()?),
            StructType::GuestMultipleMappings => Some(from.as_any_ref().downcast_ref::<GuestMultipleMappings>()?),
            StructType::GuestOperationsUnavailable => Some(from.as_any_ref().downcast_ref::<GuestOperationsUnavailable>()?),
            StructType::GuestPermissionDenied => Some(from.as_any_ref().downcast_ref::<GuestPermissionDenied>()?),
            StructType::GuestProcessNotFound => Some(from.as_any_ref().downcast_ref::<GuestProcessNotFound>()?),
            StructType::GuestRegistryFault => Some(from.as_any_ref().downcast_ref::<GuestRegistryFault>()?),
            StructType::GuestRegistryKeyFault => Some(from.as_any_ref().downcast_ref::<GuestRegistryKeyFault>()?),
            StructType::GuestRegistryKeyAlreadyExists => Some(from.as_any_ref().downcast_ref::<GuestRegistryKeyAlreadyExists>()?),
            StructType::GuestRegistryKeyHasSubkeys => Some(from.as_any_ref().downcast_ref::<GuestRegistryKeyHasSubkeys>()?),
            StructType::GuestRegistryKeyInvalid => Some(from.as_any_ref().downcast_ref::<GuestRegistryKeyInvalid>()?),
            StructType::GuestRegistryKeyParentVolatile => Some(from.as_any_ref().downcast_ref::<GuestRegistryKeyParentVolatile>()?),
            StructType::GuestRegistryValueFault => Some(from.as_any_ref().downcast_ref::<GuestRegistryValueFault>()?),
            StructType::GuestRegistryValueNotFound => Some(from.as_any_ref().downcast_ref::<GuestRegistryValueNotFound>()?),
            StructType::InvalidGuestLogin => Some(from.as_any_ref().downcast_ref::<InvalidGuestLogin>()?),
            StructType::OperationDisabledByGuest => Some(from.as_any_ref().downcast_ref::<OperationDisabledByGuest>()?),
            StructType::OperationNotSupportedByGuest => Some(from.as_any_ref().downcast_ref::<OperationNotSupportedByGuest>()?),
            StructType::TooManyGuestLogons => Some(from.as_any_ref().downcast_ref::<TooManyGuestLogons>()?),
            StructType::HostConfigFault => Some(from.as_any_ref().downcast_ref::<HostConfigFault>()?),
            StructType::AdminDisabled => Some(from.as_any_ref().downcast_ref::<AdminDisabled>()?),
            StructType::AdminNotDisabled => Some(from.as_any_ref().downcast_ref::<AdminNotDisabled>()?),
            StructType::BlockedByFirewall => Some(from.as_any_ref().downcast_ref::<BlockedByFirewall>()?),
            StructType::ClockSkew => Some(from.as_any_ref().downcast_ref::<ClockSkew>()?),
            StructType::DisableAdminNotSupported => Some(from.as_any_ref().downcast_ref::<DisableAdminNotSupported>()?),
            StructType::HostConfigFailed => Some(from.as_any_ref().downcast_ref::<HostConfigFailed>()?),
            StructType::HostInDomain => Some(from.as_any_ref().downcast_ref::<HostInDomain>()?),
            StructType::InvalidHostName => Some(from.as_any_ref().downcast_ref::<InvalidHostName>()?),
            StructType::NasConfigFault => Some(from.as_any_ref().downcast_ref::<NasConfigFault>()?),
            StructType::InvalidNasCredentials => Some(from.as_any_ref().downcast_ref::<InvalidNasCredentials>()?),
            StructType::InvalidNetworkResource => Some(from.as_any_ref().downcast_ref::<InvalidNetworkResource>()?),
            StructType::NasConnectionLimitReached => Some(from.as_any_ref().downcast_ref::<NasConnectionLimitReached>()?),
            StructType::NasSessionCredentialConflict => Some(from.as_any_ref().downcast_ref::<NasSessionCredentialConflict>()?),
            StructType::NasVolumeNotMounted => Some(from.as_any_ref().downcast_ref::<NasVolumeNotMounted>()?),
            StructType::NetworkInaccessible => Some(from.as_any_ref().downcast_ref::<NetworkInaccessible>()?),
            StructType::NoPermissionOnNasVolume => Some(from.as_any_ref().downcast_ref::<NoPermissionOnNasVolume>()?),
            StructType::NoGateway => Some(from.as_any_ref().downcast_ref::<NoGateway>()?),
            StructType::NoVirtualNic => Some(from.as_any_ref().downcast_ref::<NoVirtualNic>()?),
            StructType::PlatformConfigFault => Some(from.as_any_ref().downcast_ref::<PlatformConfigFault>()?),
            StructType::InvalidBundle => Some(from.as_any_ref().downcast_ref::<InvalidBundle>()?),
            StructType::PatchInstallFailed => Some(from.as_any_ref().downcast_ref::<PatchInstallFailed>()?),
            StructType::PatchIntegrityError => Some(from.as_any_ref().downcast_ref::<PatchIntegrityError>()?),
            StructType::VmfsMountFault => Some(from.as_any_ref().downcast_ref::<VmfsMountFault>()?),
            StructType::VmfsAlreadyMounted => Some(from.as_any_ref().downcast_ref::<VmfsAlreadyMounted>()?),
            StructType::VmfsAmbiguousMount => Some(from.as_any_ref().downcast_ref::<VmfsAmbiguousMount>()?),
            StructType::HostConnectFault => Some(from.as_any_ref().downcast_ref::<HostConnectFault>()?),
            StructType::AgentInstallFailed => Some(from.as_any_ref().downcast_ref::<AgentInstallFailed>()?),
            StructType::AlreadyBeingManaged => Some(from.as_any_ref().downcast_ref::<AlreadyBeingManaged>()?),
            StructType::AlreadyConnected => Some(from.as_any_ref().downcast_ref::<AlreadyConnected>()?),
            StructType::CannotAddHostWithFtVmAsStandalone => Some(from.as_any_ref().downcast_ref::<CannotAddHostWithFtVmAsStandalone>()?),
            StructType::CannotAddHostWithFtVmToDifferentCluster => Some(from.as_any_ref().downcast_ref::<CannotAddHostWithFtVmToDifferentCluster>()?),
            StructType::CannotAddHostWithFtVmToNonHaCluster => Some(from.as_any_ref().downcast_ref::<CannotAddHostWithFtVmToNonHaCluster>()?),
            StructType::GatewayConnectFault => Some(from.as_any_ref().downcast_ref::<GatewayConnectFault>()?),
            StructType::GatewayNotFound => Some(from.as_any_ref().downcast_ref::<GatewayNotFound>()?),
            StructType::GatewayNotReachable => Some(from.as_any_ref().downcast_ref::<GatewayNotReachable>()?),
            StructType::GatewayOperationRefused => Some(from.as_any_ref().downcast_ref::<GatewayOperationRefused>()?),
            StructType::GatewayToHostConnectFault => Some(from.as_any_ref().downcast_ref::<GatewayToHostConnectFault>()?),
            StructType::GatewayHostNotReachable => Some(from.as_any_ref().downcast_ref::<GatewayHostNotReachable>()?),
            StructType::GatewayToHostAuthFault => Some(from.as_any_ref().downcast_ref::<GatewayToHostAuthFault>()?),
            StructType::GatewayToHostTrustVerifyFault => Some(from.as_any_ref().downcast_ref::<GatewayToHostTrustVerifyFault>()?),
            StructType::MultipleCertificatesVerifyFault => Some(from.as_any_ref().downcast_ref::<MultipleCertificatesVerifyFault>()?),
            StructType::NoHost => Some(from.as_any_ref().downcast_ref::<NoHost>()?),
            StructType::NoPermissionOnHost => Some(from.as_any_ref().downcast_ref::<NoPermissionOnHost>()?),
            StructType::NotSupportedHost => Some(from.as_any_ref().downcast_ref::<NotSupportedHost>()?),
            StructType::NonVmwareOuiMacNotSupportedHost => Some(from.as_any_ref().downcast_ref::<NonVmwareOuiMacNotSupportedHost>()?),
            StructType::NotSupportedHostForVFlash => Some(from.as_any_ref().downcast_ref::<NotSupportedHostForVFlash>()?),
            StructType::NotSupportedHostForVmcp => Some(from.as_any_ref().downcast_ref::<NotSupportedHostForVmcp>()?),
            StructType::NotSupportedHostForVmemFile => Some(from.as_any_ref().downcast_ref::<NotSupportedHostForVmemFile>()?),
            StructType::NotSupportedHostForVsan => Some(from.as_any_ref().downcast_ref::<NotSupportedHostForVsan>()?),
            StructType::NotSupportedHostInCluster => Some(from.as_any_ref().downcast_ref::<NotSupportedHostInCluster>()?),
            StructType::EvcAdmissionFailed => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailed>()?),
            StructType::EvcAdmissionFailedCpuFeaturesForMode => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedCpuFeaturesForMode>()?),
            StructType::EvcAdmissionFailedCpuModel => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedCpuModel>()?),
            StructType::EvcAdmissionFailedCpuModelForMode => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedCpuModelForMode>()?),
            StructType::EvcAdmissionFailedCpuVendor => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedCpuVendor>()?),
            StructType::EvcAdmissionFailedCpuVendorUnknown => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedCpuVendorUnknown>()?),
            StructType::EvcAdmissionFailedHostDisconnected => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedHostDisconnected>()?),
            StructType::EvcAdmissionFailedHostSoftware => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedHostSoftware>()?),
            StructType::EvcAdmissionFailedHostSoftwareForMode => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedHostSoftwareForMode>()?),
            StructType::EvcAdmissionFailedVmActive => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedVmActive>()?),
            StructType::NotSupportedHostInDvs => Some(from.as_any_ref().downcast_ref::<NotSupportedHostInDvs>()?),
            StructType::NotSupportedHostInHaCluster => Some(from.as_any_ref().downcast_ref::<NotSupportedHostInHaCluster>()?),
            StructType::ReadHostResourcePoolTreeFailed => Some(from.as_any_ref().downcast_ref::<ReadHostResourcePoolTreeFailed>()?),
            StructType::SslDisabledFault => Some(from.as_any_ref().downcast_ref::<SslDisabledFault>()?),
            StructType::SslVerifyFault => Some(from.as_any_ref().downcast_ref::<SslVerifyFault>()?),
            StructType::TooManyHosts => Some(from.as_any_ref().downcast_ref::<TooManyHosts>()?),
            StructType::HostHasComponentFailure => Some(from.as_any_ref().downcast_ref::<HostHasComponentFailure>()?),
            StructType::HostIncompatibleForRecordReplay => Some(from.as_any_ref().downcast_ref::<HostIncompatibleForRecordReplay>()?),
            StructType::HostPowerOpFailed => Some(from.as_any_ref().downcast_ref::<HostPowerOpFailed>()?),
            StructType::NoPeerHostFound => Some(from.as_any_ref().downcast_ref::<NoPeerHostFound>()?),
            StructType::VmotionInterfaceNotEnabled => Some(from.as_any_ref().downcast_ref::<VmotionInterfaceNotEnabled>()?),
            StructType::WakeOnLanNotSupportedByVmotionNic => Some(from.as_any_ref().downcast_ref::<WakeOnLanNotSupportedByVmotionNic>()?),
            StructType::HostSpecificationOperationFailed => Some(from.as_any_ref().downcast_ref::<HostSpecificationOperationFailed>()?),
            StructType::HttpFault => Some(from.as_any_ref().downcast_ref::<HttpFault>()?),
            StructType::IormNotSupportedHostOnDatastore => Some(from.as_any_ref().downcast_ref::<IormNotSupportedHostOnDatastore>()?),
            StructType::InaccessibleVFlashSource => Some(from.as_any_ref().downcast_ref::<InaccessibleVFlashSource>()?),
            StructType::InsufficientResourcesFault => Some(from.as_any_ref().downcast_ref::<InsufficientResourcesFault>()?),
            StructType::InsufficientAgentVmsDeployed => Some(from.as_any_ref().downcast_ref::<InsufficientAgentVmsDeployed>()?),
            StructType::InsufficientCpuResourcesFault => Some(from.as_any_ref().downcast_ref::<InsufficientCpuResourcesFault>()?),
            StructType::InsufficientFailoverResourcesFault => Some(from.as_any_ref().downcast_ref::<InsufficientFailoverResourcesFault>()?),
            StructType::InsufficientGraphicsResourcesFault => Some(from.as_any_ref().downcast_ref::<InsufficientGraphicsResourcesFault>()?),
            StructType::InsufficientHostCapacityFault => Some(from.as_any_ref().downcast_ref::<InsufficientHostCapacityFault>()?),
            StructType::InsufficientHostCpuCapacityFault => Some(from.as_any_ref().downcast_ref::<InsufficientHostCpuCapacityFault>()?),
            StructType::InsufficientHostMemoryCapacityFault => Some(from.as_any_ref().downcast_ref::<InsufficientHostMemoryCapacityFault>()?),
            StructType::InsufficientPerCpuCapacity => Some(from.as_any_ref().downcast_ref::<InsufficientPerCpuCapacity>()?),
            StructType::InsufficientMemoryResourcesFault => Some(from.as_any_ref().downcast_ref::<InsufficientMemoryResourcesFault>()?),
            StructType::InsufficientNetworkCapacity => Some(from.as_any_ref().downcast_ref::<InsufficientNetworkCapacity>()?),
            StructType::InsufficientNetworkResourcePoolCapacity => Some(from.as_any_ref().downcast_ref::<InsufficientNetworkResourcePoolCapacity>()?),
            StructType::InsufficientStandbyResource => Some(from.as_any_ref().downcast_ref::<InsufficientStandbyResource>()?),
            StructType::InsufficientStandbyCpuResource => Some(from.as_any_ref().downcast_ref::<InsufficientStandbyCpuResource>()?),
            StructType::InsufficientStandbyMemoryResource => Some(from.as_any_ref().downcast_ref::<InsufficientStandbyMemoryResource>()?),
            StructType::InsufficientStorageSpace => Some(from.as_any_ref().downcast_ref::<InsufficientStorageSpace>()?),
            StructType::InsufficientVFlashResourcesFault => Some(from.as_any_ref().downcast_ref::<InsufficientVFlashResourcesFault>()?),
            StructType::InvalidResourcePoolStructureFault => Some(from.as_any_ref().downcast_ref::<InvalidResourcePoolStructureFault>()?),
            StructType::NumVirtualCpusExceedsLimit => Some(from.as_any_ref().downcast_ref::<NumVirtualCpusExceedsLimit>()?),
            StructType::VmFaultToleranceTooManyFtVcpusOnHost => Some(from.as_any_ref().downcast_ref::<VmFaultToleranceTooManyFtVcpusOnHost>()?),
            StructType::VmFaultToleranceTooManyVMsOnHost => Some(from.as_any_ref().downcast_ref::<VmFaultToleranceTooManyVMsOnHost>()?),
            StructType::VmSmpFaultToleranceTooManyVMsOnHost => Some(from.as_any_ref().downcast_ref::<VmSmpFaultToleranceTooManyVMsOnHost>()?),
            StructType::InsufficientStorageIops => Some(from.as_any_ref().downcast_ref::<InsufficientStorageIops>()?),
            StructType::InvalidAffinitySettingFault => Some(from.as_any_ref().downcast_ref::<InvalidAffinitySettingFault>()?),
            StructType::InvalidBmcRole => Some(from.as_any_ref().downcast_ref::<InvalidBmcRole>()?),
            StructType::InvalidDatastore => Some(from.as_any_ref().downcast_ref::<InvalidDatastore>()?),
            StructType::DatastoreNotWritableOnHost => Some(from.as_any_ref().downcast_ref::<DatastoreNotWritableOnHost>()?),
            StructType::SwapDatastoreNotWritableOnHost => Some(from.as_any_ref().downcast_ref::<SwapDatastoreNotWritableOnHost>()?),
            StructType::InaccessibleDatastore => Some(from.as_any_ref().downcast_ref::<InaccessibleDatastore>()?),
            StructType::InaccessibleFtMetadataDatastore => Some(from.as_any_ref().downcast_ref::<InaccessibleFtMetadataDatastore>()?),
            StructType::InvalidDatastorePath => Some(from.as_any_ref().downcast_ref::<InvalidDatastorePath>()?),
            StructType::InvalidEvent => Some(from.as_any_ref().downcast_ref::<InvalidEvent>()?),
            StructType::InvalidFolder => Some(from.as_any_ref().downcast_ref::<InvalidFolder>()?),
            StructType::VmAlreadyExistsInDatacenter => Some(from.as_any_ref().downcast_ref::<VmAlreadyExistsInDatacenter>()?),
            StructType::InvalidIpmiLoginInfo => Some(from.as_any_ref().downcast_ref::<InvalidIpmiLoginInfo>()?),
            StructType::InvalidIpmiMacAddress => Some(from.as_any_ref().downcast_ref::<InvalidIpmiMacAddress>()?),
            StructType::InvalidLicense => Some(from.as_any_ref().downcast_ref::<InvalidLicense>()?),
            StructType::InvalidLocale => Some(from.as_any_ref().downcast_ref::<InvalidLocale>()?),
            StructType::InvalidLogin => Some(from.as_any_ref().downcast_ref::<InvalidLogin>()?),
            StructType::InvalidClientCertificate => Some(from.as_any_ref().downcast_ref::<InvalidClientCertificate>()?),
            StructType::PasswordExpired => Some(from.as_any_ref().downcast_ref::<PasswordExpired>()?),
            StructType::InvalidName => Some(from.as_any_ref().downcast_ref::<InvalidName>()?),
            StructType::InvalidPrivilege => Some(from.as_any_ref().downcast_ref::<InvalidPrivilege>()?),
            StructType::InvalidState => Some(from.as_any_ref().downcast_ref::<InvalidState>()?),
            StructType::CannotPowerOffVmInCluster => Some(from.as_any_ref().downcast_ref::<CannotPowerOffVmInCluster>()?),
            StructType::EncryptionKeyRequired => Some(from.as_any_ref().downcast_ref::<EncryptionKeyRequired>()?),
            StructType::InvalidDatastoreState => Some(from.as_any_ref().downcast_ref::<InvalidDatastoreState>()?),
            StructType::InvalidHostState => Some(from.as_any_ref().downcast_ref::<InvalidHostState>()?),
            StructType::InvalidHostConnectionState => Some(from.as_any_ref().downcast_ref::<InvalidHostConnectionState>()?),
            StructType::InvalidPowerState => Some(from.as_any_ref().downcast_ref::<InvalidPowerState>()?),
            StructType::InvalidVmState => Some(from.as_any_ref().downcast_ref::<InvalidVmState>()?),
            StructType::MksConnectionLimitReached => Some(from.as_any_ref().downcast_ref::<MksConnectionLimitReached>()?),
            StructType::NoActiveHostInCluster => Some(from.as_any_ref().downcast_ref::<NoActiveHostInCluster>()?),
            StructType::OvfConsumerPowerOnFault => Some(from.as_any_ref().downcast_ref::<OvfConsumerPowerOnFault>()?),
            StructType::QuestionPending => Some(from.as_any_ref().downcast_ref::<QuestionPending>()?),
            StructType::VmPowerOnDisabled => Some(from.as_any_ref().downcast_ref::<VmPowerOnDisabled>()?),
            StructType::IscsiFault => Some(from.as_any_ref().downcast_ref::<IscsiFault>()?),
            StructType::IscsiFaultInvalidVnic => Some(from.as_any_ref().downcast_ref::<IscsiFaultInvalidVnic>()?),
            StructType::IscsiFaultPnicInUse => Some(from.as_any_ref().downcast_ref::<IscsiFaultPnicInUse>()?),
            StructType::IscsiFaultVnicAlreadyBound => Some(from.as_any_ref().downcast_ref::<IscsiFaultVnicAlreadyBound>()?),
            StructType::IscsiFaultVnicHasActivePaths => Some(from.as_any_ref().downcast_ref::<IscsiFaultVnicHasActivePaths>()?),
            StructType::IscsiFaultVnicHasMultipleUplinks => Some(from.as_any_ref().downcast_ref::<IscsiFaultVnicHasMultipleUplinks>()?),
            StructType::IscsiFaultVnicHasNoUplinks => Some(from.as_any_ref().downcast_ref::<IscsiFaultVnicHasNoUplinks>()?),
            StructType::IscsiFaultVnicHasWrongUplink => Some(from.as_any_ref().downcast_ref::<IscsiFaultVnicHasWrongUplink>()?),
            StructType::IscsiFaultVnicInUse => Some(from.as_any_ref().downcast_ref::<IscsiFaultVnicInUse>()?),
            StructType::IscsiFaultVnicIsLastPath => Some(from.as_any_ref().downcast_ref::<IscsiFaultVnicIsLastPath>()?),
            StructType::IscsiFaultVnicNotBound => Some(from.as_any_ref().downcast_ref::<IscsiFaultVnicNotBound>()?),
            StructType::IscsiFaultVnicNotFound => Some(from.as_any_ref().downcast_ref::<IscsiFaultVnicNotFound>()?),
            StructType::KeyNotFound => Some(from.as_any_ref().downcast_ref::<KeyNotFound>()?),
            StructType::LicenseEntityNotFound => Some(from.as_any_ref().downcast_ref::<LicenseEntityNotFound>()?),
            StructType::LicenseServerUnavailable => Some(from.as_any_ref().downcast_ref::<LicenseServerUnavailable>()?),
            StructType::LimitExceeded => Some(from.as_any_ref().downcast_ref::<LimitExceeded>()?),
            StructType::LogBundlingFailed => Some(from.as_any_ref().downcast_ref::<LogBundlingFailed>()?),
            StructType::MigrationFault => Some(from.as_any_ref().downcast_ref::<MigrationFault>()?),
            StructType::AffinityConfigured => Some(from.as_any_ref().downcast_ref::<AffinityConfigured>()?),
            StructType::CannotModifyConfigCpuRequirements => Some(from.as_any_ref().downcast_ref::<CannotModifyConfigCpuRequirements>()?),
            StructType::CannotMoveVmWithDeltaDisk => Some(from.as_any_ref().downcast_ref::<CannotMoveVmWithDeltaDisk>()?),
            StructType::CannotMoveVmWithNativeDeltaDisk => Some(from.as_any_ref().downcast_ref::<CannotMoveVmWithNativeDeltaDisk>()?),
            StructType::CloneFromSnapshotNotSupported => Some(from.as_any_ref().downcast_ref::<CloneFromSnapshotNotSupported>()?),
            StructType::DatacenterMismatch => Some(from.as_any_ref().downcast_ref::<DatacenterMismatch>()?),
            StructType::DisallowedMigrationDeviceAttached => Some(from.as_any_ref().downcast_ref::<DisallowedMigrationDeviceAttached>()?),
            StructType::DiskMoveTypeNotSupported => Some(from.as_any_ref().downcast_ref::<DiskMoveTypeNotSupported>()?),
            StructType::FaultToleranceAntiAffinityViolated => Some(from.as_any_ref().downcast_ref::<FaultToleranceAntiAffinityViolated>()?),
            StructType::FaultToleranceNeedsThickDisk => Some(from.as_any_ref().downcast_ref::<FaultToleranceNeedsThickDisk>()?),
            StructType::FaultToleranceNotSameBuild => Some(from.as_any_ref().downcast_ref::<FaultToleranceNotSameBuild>()?),
            StructType::HaErrorsAtDest => Some(from.as_any_ref().downcast_ref::<HaErrorsAtDest>()?),
            StructType::IncompatibleDefaultDevice => Some(from.as_any_ref().downcast_ref::<IncompatibleDefaultDevice>()?),
            StructType::LargeRdmConversionNotSupported => Some(from.as_any_ref().downcast_ref::<LargeRdmConversionNotSupported>()?),
            StructType::MaintenanceModeFileMove => Some(from.as_any_ref().downcast_ref::<MaintenanceModeFileMove>()?),
            StructType::MigrationDisabled => Some(from.as_any_ref().downcast_ref::<MigrationDisabled>()?),
            StructType::MigrationFeatureNotSupported => Some(from.as_any_ref().downcast_ref::<MigrationFeatureNotSupported>()?),
            StructType::FullStorageVMotionNotSupported => Some(from.as_any_ref().downcast_ref::<FullStorageVMotionNotSupported>()?),
            StructType::IndependentDiskVMotionNotSupported => Some(from.as_any_ref().downcast_ref::<IndependentDiskVMotionNotSupported>()?),
            StructType::NonHomeRdmvMotionNotSupported => Some(from.as_any_ref().downcast_ref::<NonHomeRdmvMotionNotSupported>()?),
            StructType::StorageVMotionNotSupported => Some(from.as_any_ref().downcast_ref::<StorageVMotionNotSupported>()?),
            StructType::UnsharedSwapVMotionNotSupported => Some(from.as_any_ref().downcast_ref::<UnsharedSwapVMotionNotSupported>()?),
            StructType::VMotionAcrossNetworkNotSupported => Some(from.as_any_ref().downcast_ref::<VMotionAcrossNetworkNotSupported>()?),
            StructType::MigrationNotReady => Some(from.as_any_ref().downcast_ref::<MigrationNotReady>()?),
            StructType::MismatchedNetworkPolicies => Some(from.as_any_ref().downcast_ref::<MismatchedNetworkPolicies>()?),
            StructType::MismatchedVMotionNetworkNames => Some(from.as_any_ref().downcast_ref::<MismatchedVMotionNetworkNames>()?),
            StructType::NetworksMayNotBeTheSame => Some(from.as_any_ref().downcast_ref::<NetworksMayNotBeTheSame>()?),
            StructType::NoGuestHeartbeat => Some(from.as_any_ref().downcast_ref::<NoGuestHeartbeat>()?),
            StructType::RdmConversionNotSupported => Some(from.as_any_ref().downcast_ref::<RdmConversionNotSupported>()?),
            StructType::RdmNotPreserved => Some(from.as_any_ref().downcast_ref::<RdmNotPreserved>()?),
            StructType::ReadOnlyDisksWithLegacyDestination => Some(from.as_any_ref().downcast_ref::<ReadOnlyDisksWithLegacyDestination>()?),
            StructType::SnapshotCopyNotSupported => Some(from.as_any_ref().downcast_ref::<SnapshotCopyNotSupported>()?),
            StructType::HotSnapshotMoveNotSupported => Some(from.as_any_ref().downcast_ref::<HotSnapshotMoveNotSupported>()?),
            StructType::SnapshotCloneNotSupported => Some(from.as_any_ref().downcast_ref::<SnapshotCloneNotSupported>()?),
            StructType::SnapshotMoveFromNonHomeNotSupported => Some(from.as_any_ref().downcast_ref::<SnapshotMoveFromNonHomeNotSupported>()?),
            StructType::SnapshotMoveNotSupported => Some(from.as_any_ref().downcast_ref::<SnapshotMoveNotSupported>()?),
            StructType::SnapshotMoveToNonHomeNotSupported => Some(from.as_any_ref().downcast_ref::<SnapshotMoveToNonHomeNotSupported>()?),
            StructType::SnapshotRevertIssue => Some(from.as_any_ref().downcast_ref::<SnapshotRevertIssue>()?),
            StructType::SuspendedRelocateNotSupported => Some(from.as_any_ref().downcast_ref::<SuspendedRelocateNotSupported>()?),
            StructType::TooManyDisksOnLegacyHost => Some(from.as_any_ref().downcast_ref::<TooManyDisksOnLegacyHost>()?),
            StructType::ToolsInstallationInProgress => Some(from.as_any_ref().downcast_ref::<ToolsInstallationInProgress>()?),
            StructType::UncommittedUndoableDisk => Some(from.as_any_ref().downcast_ref::<UncommittedUndoableDisk>()?),
            StructType::VMotionInterfaceIssue => Some(from.as_any_ref().downcast_ref::<VMotionInterfaceIssue>()?),
            StructType::VMotionLinkCapacityLow => Some(from.as_any_ref().downcast_ref::<VMotionLinkCapacityLow>()?),
            StructType::VMotionLinkDown => Some(from.as_any_ref().downcast_ref::<VMotionLinkDown>()?),
            StructType::VMotionNotConfigured => Some(from.as_any_ref().downcast_ref::<VMotionNotConfigured>()?),
            StructType::VMotionNotLicensed => Some(from.as_any_ref().downcast_ref::<VMotionNotLicensed>()?),
            StructType::VMotionNotSupported => Some(from.as_any_ref().downcast_ref::<VMotionNotSupported>()?),
            StructType::VMotionProtocolIncompatible => Some(from.as_any_ref().downcast_ref::<VMotionProtocolIncompatible>()?),
            StructType::WillLoseHaProtection => Some(from.as_any_ref().downcast_ref::<WillLoseHaProtection>()?),
            StructType::WillModifyConfigCpuRequirements => Some(from.as_any_ref().downcast_ref::<WillModifyConfigCpuRequirements>()?),
            StructType::WillResetSnapshotDirectory => Some(from.as_any_ref().downcast_ref::<WillResetSnapshotDirectory>()?),
            StructType::MismatchedBundle => Some(from.as_any_ref().downcast_ref::<MismatchedBundle>()?),
            StructType::MissingBmcSupport => Some(from.as_any_ref().downcast_ref::<MissingBmcSupport>()?),
            StructType::NamespaceFull => Some(from.as_any_ref().downcast_ref::<NamespaceFull>()?),
            StructType::NamespaceLimitReached => Some(from.as_any_ref().downcast_ref::<NamespaceLimitReached>()?),
            StructType::NamespaceWriteProtected => Some(from.as_any_ref().downcast_ref::<NamespaceWriteProtected>()?),
            StructType::NetworkDisruptedAndConfigRolledBack => Some(from.as_any_ref().downcast_ref::<NetworkDisruptedAndConfigRolledBack>()?),
            StructType::NoClientCertificate => Some(from.as_any_ref().downcast_ref::<NoClientCertificate>()?),
            StructType::NoCompatibleDatastore => Some(from.as_any_ref().downcast_ref::<NoCompatibleDatastore>()?),
            StructType::NoCompatibleHost => Some(from.as_any_ref().downcast_ref::<NoCompatibleHost>()?),
            StructType::NoCompatibleHostWithAccessToDevice => Some(from.as_any_ref().downcast_ref::<NoCompatibleHostWithAccessToDevice>()?),
            StructType::NoConnectedDatastore => Some(from.as_any_ref().downcast_ref::<NoConnectedDatastore>()?),
            StructType::NoDiskFound => Some(from.as_any_ref().downcast_ref::<NoDiskFound>()?),
            StructType::NoSubjectName => Some(from.as_any_ref().downcast_ref::<NoSubjectName>()?),
            StructType::NotFound => Some(from.as_any_ref().downcast_ref::<NotFound>()?),
            StructType::NotSupportedHostForChecksum => Some(from.as_any_ref().downcast_ref::<NotSupportedHostForChecksum>()?),
            StructType::OutOfBounds => Some(from.as_any_ref().downcast_ref::<OutOfBounds>()?),
            StructType::OvfFault => Some(from.as_any_ref().downcast_ref::<OvfFault>()?),
            StructType::OvfConsumerCallbackFault => Some(from.as_any_ref().downcast_ref::<OvfConsumerCallbackFault>()?),
            StructType::OvfConsumerCommunicationError => Some(from.as_any_ref().downcast_ref::<OvfConsumerCommunicationError>()?),
            StructType::OvfConsumerFault => Some(from.as_any_ref().downcast_ref::<OvfConsumerFault>()?),
            StructType::OvfConsumerInvalidSection => Some(from.as_any_ref().downcast_ref::<OvfConsumerInvalidSection>()?),
            StructType::OvfConsumerUndeclaredSection => Some(from.as_any_ref().downcast_ref::<OvfConsumerUndeclaredSection>()?),
            StructType::OvfConsumerUndefinedPrefix => Some(from.as_any_ref().downcast_ref::<OvfConsumerUndefinedPrefix>()?),
            StructType::OvfExport => Some(from.as_any_ref().downcast_ref::<OvfExport>()?),
            StructType::ConnectedIso => Some(from.as_any_ref().downcast_ref::<ConnectedIso>()?),
            StructType::OvfDuplicatedPropertyIdExport => Some(from.as_any_ref().downcast_ref::<OvfDuplicatedPropertyIdExport>()?),
            StructType::OvfDuplicatedPropertyIdImport => Some(from.as_any_ref().downcast_ref::<OvfDuplicatedPropertyIdImport>()?),
            StructType::OvfExportFailed => Some(from.as_any_ref().downcast_ref::<OvfExportFailed>()?),
            StructType::OvfHardwareExport => Some(from.as_any_ref().downcast_ref::<OvfHardwareExport>()?),
            StructType::OvfConnectedDevice => Some(from.as_any_ref().downcast_ref::<OvfConnectedDevice>()?),
            StructType::OvfConnectedDeviceFloppy => Some(from.as_any_ref().downcast_ref::<OvfConnectedDeviceFloppy>()?),
            StructType::OvfConnectedDeviceIso => Some(from.as_any_ref().downcast_ref::<OvfConnectedDeviceIso>()?),
            StructType::OvfUnableToExportDisk => Some(from.as_any_ref().downcast_ref::<OvfUnableToExportDisk>()?),
            StructType::OvfUnknownDeviceBacking => Some(from.as_any_ref().downcast_ref::<OvfUnknownDeviceBacking>()?),
            StructType::OvfUnsupportedDeviceExport => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedDeviceExport>()?),
            StructType::OvfPropertyExport => Some(from.as_any_ref().downcast_ref::<OvfPropertyExport>()?),
            StructType::OvfPropertyNetworkExport => Some(from.as_any_ref().downcast_ref::<OvfPropertyNetworkExport>()?),
            StructType::OvfImport => Some(from.as_any_ref().downcast_ref::<OvfImport>()?),
            StructType::OvfCpuCompatibility => Some(from.as_any_ref().downcast_ref::<OvfCpuCompatibility>()?),
            StructType::OvfCpuCompatibilityCheckNotSupported => Some(from.as_any_ref().downcast_ref::<OvfCpuCompatibilityCheckNotSupported>()?),
            StructType::OvfHardwareCheck => Some(from.as_any_ref().downcast_ref::<OvfHardwareCheck>()?),
            StructType::OvfImportFailed => Some(from.as_any_ref().downcast_ref::<OvfImportFailed>()?),
            StructType::OvfMappedOsId => Some(from.as_any_ref().downcast_ref::<OvfMappedOsId>()?),
            StructType::OvfMissingHardware => Some(from.as_any_ref().downcast_ref::<OvfMissingHardware>()?),
            StructType::OvfNetworkMappingNotSupported => Some(from.as_any_ref().downcast_ref::<OvfNetworkMappingNotSupported>()?),
            StructType::OvfUnsupportedDiskProvisioning => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedDiskProvisioning>()?),
            StructType::OvfInvalidPackage => Some(from.as_any_ref().downcast_ref::<OvfInvalidPackage>()?),
            StructType::OvfAttribute => Some(from.as_any_ref().downcast_ref::<OvfAttribute>()?),
            StructType::OvfInvalidValue => Some(from.as_any_ref().downcast_ref::<OvfInvalidValue>()?),
            StructType::OvfInvalidValueConfiguration => Some(from.as_any_ref().downcast_ref::<OvfInvalidValueConfiguration>()?),
            StructType::OvfInvalidValueEmpty => Some(from.as_any_ref().downcast_ref::<OvfInvalidValueEmpty>()?),
            StructType::OvfInvalidValueFormatMalformed => Some(from.as_any_ref().downcast_ref::<OvfInvalidValueFormatMalformed>()?),
            StructType::OvfInvalidValueReference => Some(from.as_any_ref().downcast_ref::<OvfInvalidValueReference>()?),
            StructType::OvfMissingAttribute => Some(from.as_any_ref().downcast_ref::<OvfMissingAttribute>()?),
            StructType::OvfConstraint => Some(from.as_any_ref().downcast_ref::<OvfConstraint>()?),
            StructType::OvfDiskOrderConstraint => Some(from.as_any_ref().downcast_ref::<OvfDiskOrderConstraint>()?),
            StructType::OvfHostResourceConstraint => Some(from.as_any_ref().downcast_ref::<OvfHostResourceConstraint>()?),
            StructType::OvfElement => Some(from.as_any_ref().downcast_ref::<OvfElement>()?),
            StructType::OvfDuplicateElement => Some(from.as_any_ref().downcast_ref::<OvfDuplicateElement>()?),
            StructType::OvfDuplicatedElementBoundary => Some(from.as_any_ref().downcast_ref::<OvfDuplicatedElementBoundary>()?),
            StructType::OvfElementInvalidValue => Some(from.as_any_ref().downcast_ref::<OvfElementInvalidValue>()?),
            StructType::OvfMissingElement => Some(from.as_any_ref().downcast_ref::<OvfMissingElement>()?),
            StructType::OvfMissingElementNormalBoundary => Some(from.as_any_ref().downcast_ref::<OvfMissingElementNormalBoundary>()?),
            StructType::OvfUnexpectedElement => Some(from.as_any_ref().downcast_ref::<OvfUnexpectedElement>()?),
            StructType::OvfWrongElement => Some(from.as_any_ref().downcast_ref::<OvfWrongElement>()?),
            StructType::OvfProperty => Some(from.as_any_ref().downcast_ref::<OvfProperty>()?),
            StructType::OvfPropertyNetwork => Some(from.as_any_ref().downcast_ref::<OvfPropertyNetwork>()?),
            StructType::OvfPropertyQualifier => Some(from.as_any_ref().downcast_ref::<OvfPropertyQualifier>()?),
            StructType::OvfPropertyQualifierDuplicate => Some(from.as_any_ref().downcast_ref::<OvfPropertyQualifierDuplicate>()?),
            StructType::OvfPropertyQualifierIgnored => Some(from.as_any_ref().downcast_ref::<OvfPropertyQualifierIgnored>()?),
            StructType::OvfPropertyType => Some(from.as_any_ref().downcast_ref::<OvfPropertyType>()?),
            StructType::OvfPropertyValue => Some(from.as_any_ref().downcast_ref::<OvfPropertyValue>()?),
            StructType::OvfWrongNamespace => Some(from.as_any_ref().downcast_ref::<OvfWrongNamespace>()?),
            StructType::OvfXmlFormat => Some(from.as_any_ref().downcast_ref::<OvfXmlFormat>()?),
            StructType::OvfSystemFault => Some(from.as_any_ref().downcast_ref::<OvfSystemFault>()?),
            StructType::OvfDiskMappingNotFound => Some(from.as_any_ref().downcast_ref::<OvfDiskMappingNotFound>()?),
            StructType::OvfHostValueNotParsed => Some(from.as_any_ref().downcast_ref::<OvfHostValueNotParsed>()?),
            StructType::OvfInternalError => Some(from.as_any_ref().downcast_ref::<OvfInternalError>()?),
            StructType::OvfToXmlUnsupportedElement => Some(from.as_any_ref().downcast_ref::<OvfToXmlUnsupportedElement>()?),
            StructType::OvfUnknownDevice => Some(from.as_any_ref().downcast_ref::<OvfUnknownDevice>()?),
            StructType::OvfUnknownEntity => Some(from.as_any_ref().downcast_ref::<OvfUnknownEntity>()?),
            StructType::OvfUnsupportedDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedDeviceBackingInfo>()?),
            StructType::OvfUnsupportedDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedDeviceBackingOption>()?),
            StructType::OvfUnsupportedPackage => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedPackage>()?),
            StructType::OvfInvalidVmName => Some(from.as_any_ref().downcast_ref::<OvfInvalidVmName>()?),
            StructType::OvfNoHostNic => Some(from.as_any_ref().downcast_ref::<OvfNoHostNic>()?),
            StructType::OvfNoSupportedHardwareFamily => Some(from.as_any_ref().downcast_ref::<OvfNoSupportedHardwareFamily>()?),
            StructType::OvfUnsupportedAttribute => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedAttribute>()?),
            StructType::OvfUnsupportedAttributeValue => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedAttributeValue>()?),
            StructType::OvfUnsupportedElement => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedElement>()?),
            StructType::OvfNoSpaceOnController => Some(from.as_any_ref().downcast_ref::<OvfNoSpaceOnController>()?),
            StructType::OvfUnsupportedElementValue => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedElementValue>()?),
            StructType::OvfUnsupportedSection => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedSection>()?),
            StructType::OvfUnsupportedSubType => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedSubType>()?),
            StructType::OvfUnsupportedType => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedType>()?),
            StructType::PatchBinariesNotFound => Some(from.as_any_ref().downcast_ref::<PatchBinariesNotFound>()?),
            StructType::PatchMetadataInvalid => Some(from.as_any_ref().downcast_ref::<PatchMetadataInvalid>()?),
            StructType::PatchMetadataCorrupted => Some(from.as_any_ref().downcast_ref::<PatchMetadataCorrupted>()?),
            StructType::PatchMetadataNotFound => Some(from.as_any_ref().downcast_ref::<PatchMetadataNotFound>()?),
            StructType::PatchNotApplicable => Some(from.as_any_ref().downcast_ref::<PatchNotApplicable>()?),
            StructType::PatchAlreadyInstalled => Some(from.as_any_ref().downcast_ref::<PatchAlreadyInstalled>()?),
            StructType::PatchMissingDependencies => Some(from.as_any_ref().downcast_ref::<PatchMissingDependencies>()?),
            StructType::PatchSuperseded => Some(from.as_any_ref().downcast_ref::<PatchSuperseded>()?),
            StructType::ProfileUpdateFailed => Some(from.as_any_ref().downcast_ref::<ProfileUpdateFailed>()?),
            StructType::RebootRequired => Some(from.as_any_ref().downcast_ref::<RebootRequired>()?),
            StructType::RecordReplayDisabled => Some(from.as_any_ref().downcast_ref::<RecordReplayDisabled>()?),
            StructType::RemoveFailed => Some(from.as_any_ref().downcast_ref::<RemoveFailed>()?),
            StructType::ReplicationFault => Some(from.as_any_ref().downcast_ref::<ReplicationFault>()?),
            StructType::IncompatibleHostForVmReplication => Some(from.as_any_ref().downcast_ref::<IncompatibleHostForVmReplication>()?),
            StructType::ReplicationConfigFault => Some(from.as_any_ref().downcast_ref::<ReplicationConfigFault>()?),
            StructType::ReplicationDiskConfigFault => Some(from.as_any_ref().downcast_ref::<ReplicationDiskConfigFault>()?),
            StructType::ReplicationVmConfigFault => Some(from.as_any_ref().downcast_ref::<ReplicationVmConfigFault>()?),
            StructType::ReplicationIncompatibleWithFt => Some(from.as_any_ref().downcast_ref::<ReplicationIncompatibleWithFt>()?),
            StructType::ReplicationInvalidOptions => Some(from.as_any_ref().downcast_ref::<ReplicationInvalidOptions>()?),
            StructType::ReplicationNotSupportedOnHost => Some(from.as_any_ref().downcast_ref::<ReplicationNotSupportedOnHost>()?),
            StructType::ReplicationVmFault => Some(from.as_any_ref().downcast_ref::<ReplicationVmFault>()?),
            StructType::ReplicationVmInProgressFault => Some(from.as_any_ref().downcast_ref::<ReplicationVmInProgressFault>()?),
            StructType::ResourceInUse => Some(from.as_any_ref().downcast_ref::<ResourceInUse>()?),
            StructType::FilterInUse => Some(from.as_any_ref().downcast_ref::<FilterInUse>()?),
            StructType::QuiesceDatastoreIoForHaFailed => Some(from.as_any_ref().downcast_ref::<QuiesceDatastoreIoForHaFailed>()?),
            StructType::ResourceNotAvailable => Some(from.as_any_ref().downcast_ref::<ResourceNotAvailable>()?),
            StructType::SspiChallenge => Some(from.as_any_ref().downcast_ref::<SspiChallenge>()?),
            StructType::ShrinkDiskFault => Some(from.as_any_ref().downcast_ref::<ShrinkDiskFault>()?),
            StructType::SnapshotFault => Some(from.as_any_ref().downcast_ref::<SnapshotFault>()?),
            StructType::ApplicationQuiesceFault => Some(from.as_any_ref().downcast_ref::<ApplicationQuiesceFault>()?),
            StructType::FilesystemQuiesceFault => Some(from.as_any_ref().downcast_ref::<FilesystemQuiesceFault>()?),
            StructType::MemorySnapshotOnIndependentDisk => Some(from.as_any_ref().downcast_ref::<MemorySnapshotOnIndependentDisk>()?),
            StructType::MultipleSnapshotsNotSupported => Some(from.as_any_ref().downcast_ref::<MultipleSnapshotsNotSupported>()?),
            StructType::SnapshotDisabled => Some(from.as_any_ref().downcast_ref::<SnapshotDisabled>()?),
            StructType::SnapshotIncompatibleDeviceInVm => Some(from.as_any_ref().downcast_ref::<SnapshotIncompatibleDeviceInVm>()?),
            StructType::SnapshotLocked => Some(from.as_any_ref().downcast_ref::<SnapshotLocked>()?),
            StructType::SnapshotNoChange => Some(from.as_any_ref().downcast_ref::<SnapshotNoChange>()?),
            StructType::TooManySnapshotLevels => Some(from.as_any_ref().downcast_ref::<TooManySnapshotLevels>()?),
            StructType::SsdDiskNotAvailable => Some(from.as_any_ref().downcast_ref::<SsdDiskNotAvailable>()?),
            StructType::StorageDrsCannotMoveDiskInMultiWriterMode => Some(from.as_any_ref().downcast_ref::<StorageDrsCannotMoveDiskInMultiWriterMode>()?),
            StructType::StorageDrsCannotMoveFtVm => Some(from.as_any_ref().downcast_ref::<StorageDrsCannotMoveFtVm>()?),
            StructType::StorageDrsCannotMoveIndependentDisk => Some(from.as_any_ref().downcast_ref::<StorageDrsCannotMoveIndependentDisk>()?),
            StructType::StorageDrsCannotMoveManuallyPlacedSwapFile => Some(from.as_any_ref().downcast_ref::<StorageDrsCannotMoveManuallyPlacedSwapFile>()?),
            StructType::StorageDrsCannotMoveManuallyPlacedVm => Some(from.as_any_ref().downcast_ref::<StorageDrsCannotMoveManuallyPlacedVm>()?),
            StructType::StorageDrsCannotMoveSharedDisk => Some(from.as_any_ref().downcast_ref::<StorageDrsCannotMoveSharedDisk>()?),
            StructType::StorageDrsCannotMoveTemplate => Some(from.as_any_ref().downcast_ref::<StorageDrsCannotMoveTemplate>()?),
            StructType::StorageDrsCannotMoveVmInUserFolder => Some(from.as_any_ref().downcast_ref::<StorageDrsCannotMoveVmInUserFolder>()?),
            StructType::StorageDrsCannotMoveVmWithMountedCdrom => Some(from.as_any_ref().downcast_ref::<StorageDrsCannotMoveVmWithMountedCdrom>()?),
            StructType::StorageDrsCannotMoveVmWithNoFilesInLayout => Some(from.as_any_ref().downcast_ref::<StorageDrsCannotMoveVmWithNoFilesInLayout>()?),
            StructType::StorageDrsDatacentersCannotShareDatastore => Some(from.as_any_ref().downcast_ref::<StorageDrsDatacentersCannotShareDatastore>()?),
            StructType::StorageDrsDisabledOnVm => Some(from.as_any_ref().downcast_ref::<StorageDrsDisabledOnVm>()?),
            StructType::StorageDrsHbrDiskNotMovable => Some(from.as_any_ref().downcast_ref::<StorageDrsHbrDiskNotMovable>()?),
            StructType::StorageDrsHmsMoveInProgress => Some(from.as_any_ref().downcast_ref::<StorageDrsHmsMoveInProgress>()?),
            StructType::StorageDrsHmsUnreachable => Some(from.as_any_ref().downcast_ref::<StorageDrsHmsUnreachable>()?),
            StructType::StorageDrsIolbDisabledInternally => Some(from.as_any_ref().downcast_ref::<StorageDrsIolbDisabledInternally>()?),
            StructType::StorageDrsRelocateDisabled => Some(from.as_any_ref().downcast_ref::<StorageDrsRelocateDisabled>()?),
            StructType::StorageDrsStaleHmsCollection => Some(from.as_any_ref().downcast_ref::<StorageDrsStaleHmsCollection>()?),
            StructType::StorageDrsUnableToMoveFiles => Some(from.as_any_ref().downcast_ref::<StorageDrsUnableToMoveFiles>()?),
            StructType::SwapDatastoreUnset => Some(from.as_any_ref().downcast_ref::<SwapDatastoreUnset>()?),
            StructType::TaskInProgress => Some(from.as_any_ref().downcast_ref::<TaskInProgress>()?),
            StructType::VAppTaskInProgress => Some(from.as_any_ref().downcast_ref::<VAppTaskInProgress>()?),
            StructType::Timedout => Some(from.as_any_ref().downcast_ref::<Timedout>()?),
            StructType::PowerOnFtSecondaryTimedout => Some(from.as_any_ref().downcast_ref::<PowerOnFtSecondaryTimedout>()?),
            StructType::TooManyConsecutiveOverrides => Some(from.as_any_ref().downcast_ref::<TooManyConsecutiveOverrides>()?),
            StructType::ToolsUnavailable => Some(from.as_any_ref().downcast_ref::<ToolsUnavailable>()?),
            StructType::UnrecognizedHost => Some(from.as_any_ref().downcast_ref::<UnrecognizedHost>()?),
            StructType::UnsupportedVimApiVersion => Some(from.as_any_ref().downcast_ref::<UnsupportedVimApiVersion>()?),
            StructType::UserNotFound => Some(from.as_any_ref().downcast_ref::<UserNotFound>()?),
            StructType::VAppConfigFault => Some(from.as_any_ref().downcast_ref::<VAppConfigFault>()?),
            StructType::MissingPowerOffConfiguration => Some(from.as_any_ref().downcast_ref::<MissingPowerOffConfiguration>()?),
            StructType::MissingPowerOnConfiguration => Some(from.as_any_ref().downcast_ref::<MissingPowerOnConfiguration>()?),
            StructType::NoVmInVApp => Some(from.as_any_ref().downcast_ref::<NoVmInVApp>()?),
            StructType::VFlashModuleVersionIncompatible => Some(from.as_any_ref().downcast_ref::<VFlashModuleVersionIncompatible>()?),
            StructType::VmConfigFault => Some(from.as_any_ref().downcast_ref::<VmConfigFault>()?),
            StructType::CannotAccessVmComponent => Some(from.as_any_ref().downcast_ref::<CannotAccessVmComponent>()?),
            StructType::CannotAccessVmConfig => Some(from.as_any_ref().downcast_ref::<CannotAccessVmConfig>()?),
            StructType::CannotAccessVmDevice => Some(from.as_any_ref().downcast_ref::<CannotAccessVmDevice>()?),
            StructType::CannotAccessNetwork => Some(from.as_any_ref().downcast_ref::<CannotAccessNetwork>()?),
            StructType::DestinationSwitchFull => Some(from.as_any_ref().downcast_ref::<DestinationSwitchFull>()?),
            StructType::LegacyNetworkInterfaceInUse => Some(from.as_any_ref().downcast_ref::<LegacyNetworkInterfaceInUse>()?),
            StructType::VmOnConflictDvPort => Some(from.as_any_ref().downcast_ref::<VmOnConflictDvPort>()?),
            StructType::VmOnVirtualIntranet => Some(from.as_any_ref().downcast_ref::<VmOnVirtualIntranet>()?),
            StructType::CannotAccessVmDisk => Some(from.as_any_ref().downcast_ref::<CannotAccessVmDisk>()?),
            StructType::RdmPointsToInaccessibleDisk => Some(from.as_any_ref().downcast_ref::<RdmPointsToInaccessibleDisk>()?),
            StructType::CannotDisableSnapshot => Some(from.as_any_ref().downcast_ref::<CannotDisableSnapshot>()?),
            StructType::CannotUseNetwork => Some(from.as_any_ref().downcast_ref::<CannotUseNetwork>()?),
            StructType::CpuHotPlugNotSupported => Some(from.as_any_ref().downcast_ref::<CpuHotPlugNotSupported>()?),
            StructType::DeltaDiskFormatNotSupported => Some(from.as_any_ref().downcast_ref::<DeltaDiskFormatNotSupported>()?),
            StructType::EightHostLimitViolated => Some(from.as_any_ref().downcast_ref::<EightHostLimitViolated>()?),
            StructType::FaultToleranceCannotEditMem => Some(from.as_any_ref().downcast_ref::<FaultToleranceCannotEditMem>()?),
            StructType::GenericVmConfigFault => Some(from.as_any_ref().downcast_ref::<GenericVmConfigFault>()?),
            StructType::InvalidFormat => Some(from.as_any_ref().downcast_ref::<InvalidFormat>()?),
            StructType::InvalidDiskFormat => Some(from.as_any_ref().downcast_ref::<InvalidDiskFormat>()?),
            StructType::InvalidSnapshotFormat => Some(from.as_any_ref().downcast_ref::<InvalidSnapshotFormat>()?),
            StructType::InvalidVmConfig => Some(from.as_any_ref().downcast_ref::<InvalidVmConfig>()?),
            StructType::InvalidDeviceSpec => Some(from.as_any_ref().downcast_ref::<InvalidDeviceSpec>()?),
            StructType::DeviceHotPlugNotSupported => Some(from.as_any_ref().downcast_ref::<DeviceHotPlugNotSupported>()?),
            StructType::DeviceNotFound => Some(from.as_any_ref().downcast_ref::<DeviceNotFound>()?),
            StructType::DeviceUnsupportedForVmPlatform => Some(from.as_any_ref().downcast_ref::<DeviceUnsupportedForVmPlatform>()?),
            StructType::DeviceUnsupportedForVmVersion => Some(from.as_any_ref().downcast_ref::<DeviceUnsupportedForVmVersion>()?),
            StructType::DisallowedDiskModeChange => Some(from.as_any_ref().downcast_ref::<DisallowedDiskModeChange>()?),
            StructType::InvalidController => Some(from.as_any_ref().downcast_ref::<InvalidController>()?),
            StructType::InvalidDeviceBacking => Some(from.as_any_ref().downcast_ref::<InvalidDeviceBacking>()?),
            StructType::InvalidDeviceOperation => Some(from.as_any_ref().downcast_ref::<InvalidDeviceOperation>()?),
            StructType::MissingController => Some(from.as_any_ref().downcast_ref::<MissingController>()?),
            StructType::SwapPlacementOverrideNotSupported => Some(from.as_any_ref().downcast_ref::<SwapPlacementOverrideNotSupported>()?),
            StructType::TooManyDevices => Some(from.as_any_ref().downcast_ref::<TooManyDevices>()?),
            StructType::UnsupportedGuest => Some(from.as_any_ref().downcast_ref::<UnsupportedGuest>()?),
            StructType::VmWwnConflict => Some(from.as_any_ref().downcast_ref::<VmWwnConflict>()?),
            StructType::LargeRdmNotSupportedOnDatastore => Some(from.as_any_ref().downcast_ref::<LargeRdmNotSupportedOnDatastore>()?),
            StructType::MemoryHotPlugNotSupported => Some(from.as_any_ref().downcast_ref::<MemoryHotPlugNotSupported>()?),
            StructType::NoCompatibleHardAffinityHost => Some(from.as_any_ref().downcast_ref::<NoCompatibleHardAffinityHost>()?),
            StructType::NoCompatibleSoftAffinityHost => Some(from.as_any_ref().downcast_ref::<NoCompatibleSoftAffinityHost>()?),
            StructType::NumVirtualCpusIncompatible => Some(from.as_any_ref().downcast_ref::<NumVirtualCpusIncompatible>()?),
            StructType::OvfConsumerValidationFault => Some(from.as_any_ref().downcast_ref::<OvfConsumerValidationFault>()?),
            StructType::QuarantineModeFault => Some(from.as_any_ref().downcast_ref::<QuarantineModeFault>()?),
            StructType::RdmNotSupportedOnDatastore => Some(from.as_any_ref().downcast_ref::<RdmNotSupportedOnDatastore>()?),
            StructType::RuleViolation => Some(from.as_any_ref().downcast_ref::<RuleViolation>()?),
            StructType::SoftRuleVioCorrectionDisallowed => Some(from.as_any_ref().downcast_ref::<SoftRuleVioCorrectionDisallowed>()?),
            StructType::SoftRuleVioCorrectionImpact => Some(from.as_any_ref().downcast_ref::<SoftRuleVioCorrectionImpact>()?),
            StructType::UnsupportedDatastore => Some(from.as_any_ref().downcast_ref::<UnsupportedDatastore>()?),
            StructType::MemoryFileFormatNotSupportedByDatastore => Some(from.as_any_ref().downcast_ref::<MemoryFileFormatNotSupportedByDatastore>()?),
            StructType::UnSupportedDatastoreForVFlash => Some(from.as_any_ref().downcast_ref::<UnSupportedDatastoreForVFlash>()?),
            StructType::UnsupportedVmxLocation => Some(from.as_any_ref().downcast_ref::<UnsupportedVmxLocation>()?),
            StructType::VAppNotRunning => Some(from.as_any_ref().downcast_ref::<VAppNotRunning>()?),
            StructType::VAppPropertyFault => Some(from.as_any_ref().downcast_ref::<VAppPropertyFault>()?),
            StructType::InvalidNetworkInType => Some(from.as_any_ref().downcast_ref::<InvalidNetworkInType>()?),
            StructType::InvalidPropertyType => Some(from.as_any_ref().downcast_ref::<InvalidPropertyType>()?),
            StructType::InvalidPropertyValue => Some(from.as_any_ref().downcast_ref::<InvalidPropertyValue>()?),
            StructType::UnconfiguredPropertyValue => Some(from.as_any_ref().downcast_ref::<UnconfiguredPropertyValue>()?),
            StructType::MissingIpPool => Some(from.as_any_ref().downcast_ref::<MissingIpPool>()?),
            StructType::MissingNetworkIpConfig => Some(from.as_any_ref().downcast_ref::<MissingNetworkIpConfig>()?),
            StructType::NoAvailableIp => Some(from.as_any_ref().downcast_ref::<NoAvailableIp>()?),
            StructType::NoVcManagedIpConfigured => Some(from.as_any_ref().downcast_ref::<NoVcManagedIpConfigured>()?),
            StructType::NotUserConfigurableProperty => Some(from.as_any_ref().downcast_ref::<NotUserConfigurableProperty>()?),
            StructType::VFlashCacheHotConfigNotSupported => Some(from.as_any_ref().downcast_ref::<VFlashCacheHotConfigNotSupported>()?),
            StructType::VFlashModuleNotSupported => Some(from.as_any_ref().downcast_ref::<VFlashModuleNotSupported>()?),
            StructType::VirtualHardwareCompatibilityIssue => Some(from.as_any_ref().downcast_ref::<VirtualHardwareCompatibilityIssue>()?),
            StructType::CpuIncompatible => Some(from.as_any_ref().downcast_ref::<CpuIncompatible>()?),
            StructType::CpuCompatibilityUnknown => Some(from.as_any_ref().downcast_ref::<CpuCompatibilityUnknown>()?),
            StructType::CpuIncompatible1Ecx => Some(from.as_any_ref().downcast_ref::<CpuIncompatible1Ecx>()?),
            StructType::CpuIncompatible81Edx => Some(from.as_any_ref().downcast_ref::<CpuIncompatible81Edx>()?),
            StructType::FaultToleranceCpuIncompatible => Some(from.as_any_ref().downcast_ref::<FaultToleranceCpuIncompatible>()?),
            StructType::DeviceNotSupported => Some(from.as_any_ref().downcast_ref::<DeviceNotSupported>()?),
            StructType::DeviceBackingNotSupported => Some(from.as_any_ref().downcast_ref::<DeviceBackingNotSupported>()?),
            StructType::DvPortNotSupported => Some(from.as_any_ref().downcast_ref::<DvPortNotSupported>()?),
            StructType::UnusedVirtualDiskBlocksNotScrubbed => Some(from.as_any_ref().downcast_ref::<UnusedVirtualDiskBlocksNotScrubbed>()?),
            StructType::VirtualDiskBlocksNotFullyProvisioned => Some(from.as_any_ref().downcast_ref::<VirtualDiskBlocksNotFullyProvisioned>()?),
            StructType::DeviceControllerNotSupported => Some(from.as_any_ref().downcast_ref::<DeviceControllerNotSupported>()?),
            StructType::DigestNotSupported => Some(from.as_any_ref().downcast_ref::<DigestNotSupported>()?),
            StructType::FileBackedPortNotSupported => Some(from.as_any_ref().downcast_ref::<FileBackedPortNotSupported>()?),
            StructType::MultiWriterNotSupported => Some(from.as_any_ref().downcast_ref::<MultiWriterNotSupported>()?),
            StructType::NonPersistentDisksNotSupported => Some(from.as_any_ref().downcast_ref::<NonPersistentDisksNotSupported>()?),
            StructType::RdmNotSupported => Some(from.as_any_ref().downcast_ref::<RdmNotSupported>()?),
            StructType::PhysCompatRdmNotSupported => Some(from.as_any_ref().downcast_ref::<PhysCompatRdmNotSupported>()?),
            StructType::RawDiskNotSupported => Some(from.as_any_ref().downcast_ref::<RawDiskNotSupported>()?),
            StructType::RemoteDeviceNotSupported => Some(from.as_any_ref().downcast_ref::<RemoteDeviceNotSupported>()?),
            StructType::SharedBusControllerNotSupported => Some(from.as_any_ref().downcast_ref::<SharedBusControllerNotSupported>()?),
            StructType::VmiNotSupported => Some(from.as_any_ref().downcast_ref::<VmiNotSupported>()?),
            StructType::VirtualDiskModeNotSupported => Some(from.as_any_ref().downcast_ref::<VirtualDiskModeNotSupported>()?),
            StructType::VirtualEthernetCardNotSupported => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardNotSupported>()?),
            StructType::DiskNotSupported => Some(from.as_any_ref().downcast_ref::<DiskNotSupported>()?),
            StructType::IdeDiskNotSupported => Some(from.as_any_ref().downcast_ref::<IdeDiskNotSupported>()?),
            StructType::DrsVmotionIncompatibleFault => Some(from.as_any_ref().downcast_ref::<DrsVmotionIncompatibleFault>()?),
            StructType::FeatureRequirementsNotMet => Some(from.as_any_ref().downcast_ref::<FeatureRequirementsNotMet>()?),
            StructType::MemorySizeNotRecommended => Some(from.as_any_ref().downcast_ref::<MemorySizeNotRecommended>()?),
            StructType::MemorySizeNotSupported => Some(from.as_any_ref().downcast_ref::<MemorySizeNotSupported>()?),
            StructType::MemorySizeNotSupportedByDatastore => Some(from.as_any_ref().downcast_ref::<MemorySizeNotSupportedByDatastore>()?),
            StructType::NotEnoughCpus => Some(from.as_any_ref().downcast_ref::<NotEnoughCpus>()?),
            StructType::NotEnoughLogicalCpus => Some(from.as_any_ref().downcast_ref::<NotEnoughLogicalCpus>()?),
            StructType::NumVirtualCoresPerSocketNotSupported => Some(from.as_any_ref().downcast_ref::<NumVirtualCoresPerSocketNotSupported>()?),
            StructType::NumVirtualCpusNotSupported => Some(from.as_any_ref().downcast_ref::<NumVirtualCpusNotSupported>()?),
            StructType::StorageVmotionIncompatible => Some(from.as_any_ref().downcast_ref::<StorageVmotionIncompatible>()?),
            StructType::VirtualHardwareVersionNotSupported => Some(from.as_any_ref().downcast_ref::<VirtualHardwareVersionNotSupported>()?),
            StructType::WakeOnLanNotSupported => Some(from.as_any_ref().downcast_ref::<WakeOnLanNotSupported>()?),
            StructType::VmConfigIncompatibleForFaultTolerance => Some(from.as_any_ref().downcast_ref::<VmConfigIncompatibleForFaultTolerance>()?),
            StructType::VmConfigIncompatibleForRecordReplay => Some(from.as_any_ref().downcast_ref::<VmConfigIncompatibleForRecordReplay>()?),
            StructType::VmHostAffinityRuleViolation => Some(from.as_any_ref().downcast_ref::<VmHostAffinityRuleViolation>()?),
            StructType::VmFaultToleranceIssue => Some(from.as_any_ref().downcast_ref::<VmFaultToleranceIssue>()?),
            StructType::CannotChangeDrsBehaviorForFtSecondary => Some(from.as_any_ref().downcast_ref::<CannotChangeDrsBehaviorForFtSecondary>()?),
            StructType::CannotChangeHaSettingsForFtSecondary => Some(from.as_any_ref().downcast_ref::<CannotChangeHaSettingsForFtSecondary>()?),
            StructType::CannotComputeFtCompatibleHosts => Some(from.as_any_ref().downcast_ref::<CannotComputeFtCompatibleHosts>()?),
            StructType::FaultToleranceNotLicensed => Some(from.as_any_ref().downcast_ref::<FaultToleranceNotLicensed>()?),
            StructType::FaultTolerancePrimaryPowerOnNotAttempted => Some(from.as_any_ref().downcast_ref::<FaultTolerancePrimaryPowerOnNotAttempted>()?),
            StructType::FtIssuesOnHost => Some(from.as_any_ref().downcast_ref::<FtIssuesOnHost>()?),
            StructType::HostIncompatibleForFaultTolerance => Some(from.as_any_ref().downcast_ref::<HostIncompatibleForFaultTolerance>()?),
            StructType::IncompatibleHostForFtSecondary => Some(from.as_any_ref().downcast_ref::<IncompatibleHostForFtSecondary>()?),
            StructType::InvalidOperationOnSecondaryVm => Some(from.as_any_ref().downcast_ref::<InvalidOperationOnSecondaryVm>()?),
            StructType::NoHostSuitableForFtSecondary => Some(from.as_any_ref().downcast_ref::<NoHostSuitableForFtSecondary>()?),
            StructType::NotSupportedDeviceForFt => Some(from.as_any_ref().downcast_ref::<NotSupportedDeviceForFt>()?),
            StructType::PowerOnFtSecondaryFailed => Some(from.as_any_ref().downcast_ref::<PowerOnFtSecondaryFailed>()?),
            StructType::SecondaryVmAlreadyDisabled => Some(from.as_any_ref().downcast_ref::<SecondaryVmAlreadyDisabled>()?),
            StructType::SecondaryVmAlreadyEnabled => Some(from.as_any_ref().downcast_ref::<SecondaryVmAlreadyEnabled>()?),
            StructType::SecondaryVmAlreadyRegistered => Some(from.as_any_ref().downcast_ref::<SecondaryVmAlreadyRegistered>()?),
            StructType::SecondaryVmNotRegistered => Some(from.as_any_ref().downcast_ref::<SecondaryVmNotRegistered>()?),
            StructType::VmFaultToleranceConfigIssue => Some(from.as_any_ref().downcast_ref::<VmFaultToleranceConfigIssue>()?),
            StructType::VmFaultToleranceConfigIssueWrapper => Some(from.as_any_ref().downcast_ref::<VmFaultToleranceConfigIssueWrapper>()?),
            StructType::VmFaultToleranceInvalidFileBacking => Some(from.as_any_ref().downcast_ref::<VmFaultToleranceInvalidFileBacking>()?),
            StructType::VmFaultToleranceOpIssuesList => Some(from.as_any_ref().downcast_ref::<VmFaultToleranceOpIssuesList>()?),
            StructType::VmMetadataManagerFault => Some(from.as_any_ref().downcast_ref::<VmMetadataManagerFault>()?),
            StructType::VmMonitorIncompatibleForFaultTolerance => Some(from.as_any_ref().downcast_ref::<VmMonitorIncompatibleForFaultTolerance>()?),
            StructType::VmToolsUpgradeFault => Some(from.as_any_ref().downcast_ref::<VmToolsUpgradeFault>()?),
            StructType::ToolsAlreadyUpgraded => Some(from.as_any_ref().downcast_ref::<ToolsAlreadyUpgraded>()?),
            StructType::ToolsAutoUpgradeNotSupported => Some(from.as_any_ref().downcast_ref::<ToolsAutoUpgradeNotSupported>()?),
            StructType::ToolsImageCopyFailed => Some(from.as_any_ref().downcast_ref::<ToolsImageCopyFailed>()?),
            StructType::ToolsImageNotAvailable => Some(from.as_any_ref().downcast_ref::<ToolsImageNotAvailable>()?),
            StructType::ToolsImageSignatureCheckFailed => Some(from.as_any_ref().downcast_ref::<ToolsImageSignatureCheckFailed>()?),
            StructType::ToolsUpgradeCancelled => Some(from.as_any_ref().downcast_ref::<ToolsUpgradeCancelled>()?),
            StructType::VmValidateMaxDevice => Some(from.as_any_ref().downcast_ref::<VmValidateMaxDevice>()?),
            StructType::VsanFault => Some(from.as_any_ref().downcast_ref::<VsanFault>()?),
            StructType::CannotChangeVsanClusterUuid => Some(from.as_any_ref().downcast_ref::<CannotChangeVsanClusterUuid>()?),
            StructType::CannotChangeVsanNodeUuid => Some(from.as_any_ref().downcast_ref::<CannotChangeVsanNodeUuid>()?),
            StructType::CannotMoveVsanEnabledHost => Some(from.as_any_ref().downcast_ref::<CannotMoveVsanEnabledHost>()?),
            StructType::DestinationVsanDisabled => Some(from.as_any_ref().downcast_ref::<DestinationVsanDisabled>()?),
            StructType::VsanClusterUuidMismatch => Some(from.as_any_ref().downcast_ref::<VsanClusterUuidMismatch>()?),
            StructType::CannotReconfigureVsanWhenHaEnabled => Some(from.as_any_ref().downcast_ref::<CannotReconfigureVsanWhenHaEnabled>()?),
            StructType::DuplicateVsanNetworkInterface => Some(from.as_any_ref().downcast_ref::<DuplicateVsanNetworkInterface>()?),
            StructType::VsanDiskFault => Some(from.as_any_ref().downcast_ref::<VsanDiskFault>()?),
            StructType::DiskHasPartitions => Some(from.as_any_ref().downcast_ref::<DiskHasPartitions>()?),
            StructType::DiskIsLastRemainingNonSsd => Some(from.as_any_ref().downcast_ref::<DiskIsLastRemainingNonSsd>()?),
            StructType::DiskIsNonLocal => Some(from.as_any_ref().downcast_ref::<DiskIsNonLocal>()?),
            StructType::DiskIsUsb => Some(from.as_any_ref().downcast_ref::<DiskIsUsb>()?),
            StructType::DiskTooSmall => Some(from.as_any_ref().downcast_ref::<DiskTooSmall>()?),
            StructType::DuplicateDisks => Some(from.as_any_ref().downcast_ref::<DuplicateDisks>()?),
            StructType::InsufficientDisks => Some(from.as_any_ref().downcast_ref::<InsufficientDisks>()?),
            StructType::VsanIncompatibleDiskMapping => Some(from.as_any_ref().downcast_ref::<VsanIncompatibleDiskMapping>()?),
            StructType::WipeDiskFault => Some(from.as_any_ref().downcast_ref::<WipeDiskFault>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VimFault => Ok(from.as_any_box().downcast::<VimFault>()?),
            StructType::ActiveDirectoryFault => Ok(from.as_any_box().downcast::<ActiveDirectoryFault>()?),
            StructType::DomainNotFound => Ok(from.as_any_box().downcast::<DomainNotFound>()?),
            StructType::InvalidCamServer => Ok(from.as_any_box().downcast::<InvalidCamServer>()?),
            StructType::CamServerRefusedConnection => Ok(from.as_any_box().downcast::<CamServerRefusedConnection>()?),
            StructType::InvalidCamCertificate => Ok(from.as_any_box().downcast::<InvalidCamCertificate>()?),
            StructType::NoPermissionOnAd => Ok(from.as_any_box().downcast::<NoPermissionOnAd>()?),
            StructType::NonAdUserRequired => Ok(from.as_any_box().downcast::<NonAdUserRequired>()?),
            StructType::AlreadyExists => Ok(from.as_any_box().downcast::<AlreadyExists>()?),
            StructType::AlreadyUpgraded => Ok(from.as_any_box().downcast::<AlreadyUpgraded>()?),
            StructType::AnswerFileUpdateFailed => Ok(from.as_any_box().downcast::<AnswerFileUpdateFailed>()?),
            StructType::AuthMinimumAdminPermission => Ok(from.as_any_box().downcast::<AuthMinimumAdminPermission>()?),
            StructType::CannotAccessLocalSource => Ok(from.as_any_box().downcast::<CannotAccessLocalSource>()?),
            StructType::CannotDisconnectHostWithFaultToleranceVm => Ok(from.as_any_box().downcast::<CannotDisconnectHostWithFaultToleranceVm>()?),
            StructType::CannotEnableVmcpForCluster => Ok(from.as_any_box().downcast::<CannotEnableVmcpForCluster>()?),
            StructType::CannotMoveFaultToleranceVm => Ok(from.as_any_box().downcast::<CannotMoveFaultToleranceVm>()?),
            StructType::CannotMoveHostWithFaultToleranceVm => Ok(from.as_any_box().downcast::<CannotMoveHostWithFaultToleranceVm>()?),
            StructType::CannotPlaceWithoutPrerequisiteMoves => Ok(from.as_any_box().downcast::<CannotPlaceWithoutPrerequisiteMoves>()?),
            StructType::ConcurrentAccess => Ok(from.as_any_box().downcast::<ConcurrentAccess>()?),
            StructType::CustomizationFault => Ok(from.as_any_box().downcast::<CustomizationFault>()?),
            StructType::CannotDecryptPasswords => Ok(from.as_any_box().downcast::<CannotDecryptPasswords>()?),
            StructType::CustomizationPending => Ok(from.as_any_box().downcast::<CustomizationPending>()?),
            StructType::IpHostnameGeneratorError => Ok(from.as_any_box().downcast::<IpHostnameGeneratorError>()?),
            StructType::LinuxVolumeNotClean => Ok(from.as_any_box().downcast::<LinuxVolumeNotClean>()?),
            StructType::MissingLinuxCustResources => Ok(from.as_any_box().downcast::<MissingLinuxCustResources>()?),
            StructType::MissingWindowsCustResources => Ok(from.as_any_box().downcast::<MissingWindowsCustResources>()?),
            StructType::MountError => Ok(from.as_any_box().downcast::<MountError>()?),
            StructType::NicSettingMismatch => Ok(from.as_any_box().downcast::<NicSettingMismatch>()?),
            StructType::NoDisksToCustomize => Ok(from.as_any_box().downcast::<NoDisksToCustomize>()?),
            StructType::UncustomizableGuest => Ok(from.as_any_box().downcast::<UncustomizableGuest>()?),
            StructType::UnexpectedCustomizationFault => Ok(from.as_any_box().downcast::<UnexpectedCustomizationFault>()?),
            StructType::VolumeEditorError => Ok(from.as_any_box().downcast::<VolumeEditorError>()?),
            StructType::DasConfigFault => Ok(from.as_any_box().downcast::<DasConfigFault>()?),
            StructType::DrsDisabledOnVm => Ok(from.as_any_box().downcast::<DrsDisabledOnVm>()?),
            StructType::DuplicateName => Ok(from.as_any_box().downcast::<DuplicateName>()?),
            StructType::DvsFault => Ok(from.as_any_box().downcast::<DvsFault>()?),
            StructType::BackupBlobReadFailure => Ok(from.as_any_box().downcast::<BackupBlobReadFailure>()?),
            StructType::BackupBlobWriteFailure => Ok(from.as_any_box().downcast::<BackupBlobWriteFailure>()?),
            StructType::CollectorAddressUnset => Ok(from.as_any_box().downcast::<CollectorAddressUnset>()?),
            StructType::ConflictingConfiguration => Ok(from.as_any_box().downcast::<ConflictingConfiguration>()?),
            StructType::DvsApplyOperationFault => Ok(from.as_any_box().downcast::<DvsApplyOperationFault>()?),
            StructType::DvsNotAuthorized => Ok(from.as_any_box().downcast::<DvsNotAuthorized>()?),
            StructType::DvsOperationBulkFault => Ok(from.as_any_box().downcast::<DvsOperationBulkFault>()?),
            StructType::DvsScopeViolated => Ok(from.as_any_box().downcast::<DvsScopeViolated>()?),
            StructType::ImportHostAddFailure => Ok(from.as_any_box().downcast::<ImportHostAddFailure>()?),
            StructType::ImportOperationBulkFault => Ok(from.as_any_box().downcast::<ImportOperationBulkFault>()?),
            StructType::InvalidIpfixConfig => Ok(from.as_any_box().downcast::<InvalidIpfixConfig>()?),
            StructType::RollbackFailure => Ok(from.as_any_box().downcast::<RollbackFailure>()?),
            StructType::SwitchIpUnset => Ok(from.as_any_box().downcast::<SwitchIpUnset>()?),
            StructType::SwitchNotInUpgradeMode => Ok(from.as_any_box().downcast::<SwitchNotInUpgradeMode>()?),
            StructType::VspanDestPortConflict => Ok(from.as_any_box().downcast::<VspanDestPortConflict>()?),
            StructType::VspanPortConflict => Ok(from.as_any_box().downcast::<VspanPortConflict>()?),
            StructType::VspanPortMoveFault => Ok(from.as_any_box().downcast::<VspanPortMoveFault>()?),
            StructType::VspanPortPromiscChangeFault => Ok(from.as_any_box().downcast::<VspanPortPromiscChangeFault>()?),
            StructType::VspanPortgroupPromiscChangeFault => Ok(from.as_any_box().downcast::<VspanPortgroupPromiscChangeFault>()?),
            StructType::VspanPortgroupTypeChangeFault => Ok(from.as_any_box().downcast::<VspanPortgroupTypeChangeFault>()?),
            StructType::VspanPromiscuousPortNotSupported => Ok(from.as_any_box().downcast::<VspanPromiscuousPortNotSupported>()?),
            StructType::VspanSameSessionPortConflict => Ok(from.as_any_box().downcast::<VspanSameSessionPortConflict>()?),
            StructType::EvcConfigFault => Ok(from.as_any_box().downcast::<EvcConfigFault>()?),
            StructType::ActiveVMsBlockingEvc => Ok(from.as_any_box().downcast::<ActiveVMsBlockingEvc>()?),
            StructType::DisconnectedHostsBlockingEvc => Ok(from.as_any_box().downcast::<DisconnectedHostsBlockingEvc>()?),
            StructType::EvcModeIllegalByVendor => Ok(from.as_any_box().downcast::<EvcModeIllegalByVendor>()?),
            StructType::EvcModeUnsupportedByHosts => Ok(from.as_any_box().downcast::<EvcModeUnsupportedByHosts>()?),
            StructType::EvcUnsupportedByHostHardware => Ok(from.as_any_box().downcast::<EvcUnsupportedByHostHardware>()?),
            StructType::EvcUnsupportedByHostSoftware => Ok(from.as_any_box().downcast::<EvcUnsupportedByHostSoftware>()?),
            StructType::HeterogenousHostsBlockingEvc => Ok(from.as_any_box().downcast::<HeterogenousHostsBlockingEvc>()?),
            StructType::ExtendedFault => Ok(from.as_any_box().downcast::<ExtendedFault>()?),
            StructType::FaultToleranceVmNotDasProtected => Ok(from.as_any_box().downcast::<FaultToleranceVmNotDasProtected>()?),
            StructType::FcoeFault => Ok(from.as_any_box().downcast::<FcoeFault>()?),
            StructType::FcoeFaultPnicHasNoPortSet => Ok(from.as_any_box().downcast::<FcoeFaultPnicHasNoPortSet>()?),
            StructType::FileFault => Ok(from.as_any_box().downcast::<FileFault>()?),
            StructType::CannotAccessFile => Ok(from.as_any_box().downcast::<CannotAccessFile>()?),
            StructType::CannotCreateFile => Ok(from.as_any_box().downcast::<CannotCreateFile>()?),
            StructType::CannotDeleteFile => Ok(from.as_any_box().downcast::<CannotDeleteFile>()?),
            StructType::DirectoryNotEmpty => Ok(from.as_any_box().downcast::<DirectoryNotEmpty>()?),
            StructType::FileAlreadyExists => Ok(from.as_any_box().downcast::<FileAlreadyExists>()?),
            StructType::FileLocked => Ok(from.as_any_box().downcast::<FileLocked>()?),
            StructType::FileNameTooLong => Ok(from.as_any_box().downcast::<FileNameTooLong>()?),
            StructType::FileNotFound => Ok(from.as_any_box().downcast::<FileNotFound>()?),
            StructType::FileNotWritable => Ok(from.as_any_box().downcast::<FileNotWritable>()?),
            StructType::FileTooLarge => Ok(from.as_any_box().downcast::<FileTooLarge>()?),
            StructType::IncorrectFileType => Ok(from.as_any_box().downcast::<IncorrectFileType>()?),
            StructType::NetworkCopyFault => Ok(from.as_any_box().downcast::<NetworkCopyFault>()?),
            StructType::NoDiskSpace => Ok(from.as_any_box().downcast::<NoDiskSpace>()?),
            StructType::NotADirectory => Ok(from.as_any_box().downcast::<NotADirectory>()?),
            StructType::NotAFile => Ok(from.as_any_box().downcast::<NotAFile>()?),
            StructType::TooManyConcurrentNativeClones => Ok(from.as_any_box().downcast::<TooManyConcurrentNativeClones>()?),
            StructType::TooManyNativeCloneLevels => Ok(from.as_any_box().downcast::<TooManyNativeCloneLevels>()?),
            StructType::TooManyNativeClonesOnFile => Ok(from.as_any_box().downcast::<TooManyNativeClonesOnFile>()?),
            StructType::GenericDrsFault => Ok(from.as_any_box().downcast::<GenericDrsFault>()?),
            StructType::GuestOperationsFault => Ok(from.as_any_box().downcast::<GuestOperationsFault>()?),
            StructType::GuestAuthenticationChallenge => Ok(from.as_any_box().downcast::<GuestAuthenticationChallenge>()?),
            StructType::GuestComponentsOutOfDate => Ok(from.as_any_box().downcast::<GuestComponentsOutOfDate>()?),
            StructType::GuestMultipleMappings => Ok(from.as_any_box().downcast::<GuestMultipleMappings>()?),
            StructType::GuestOperationsUnavailable => Ok(from.as_any_box().downcast::<GuestOperationsUnavailable>()?),
            StructType::GuestPermissionDenied => Ok(from.as_any_box().downcast::<GuestPermissionDenied>()?),
            StructType::GuestProcessNotFound => Ok(from.as_any_box().downcast::<GuestProcessNotFound>()?),
            StructType::GuestRegistryFault => Ok(from.as_any_box().downcast::<GuestRegistryFault>()?),
            StructType::GuestRegistryKeyFault => Ok(from.as_any_box().downcast::<GuestRegistryKeyFault>()?),
            StructType::GuestRegistryKeyAlreadyExists => Ok(from.as_any_box().downcast::<GuestRegistryKeyAlreadyExists>()?),
            StructType::GuestRegistryKeyHasSubkeys => Ok(from.as_any_box().downcast::<GuestRegistryKeyHasSubkeys>()?),
            StructType::GuestRegistryKeyInvalid => Ok(from.as_any_box().downcast::<GuestRegistryKeyInvalid>()?),
            StructType::GuestRegistryKeyParentVolatile => Ok(from.as_any_box().downcast::<GuestRegistryKeyParentVolatile>()?),
            StructType::GuestRegistryValueFault => Ok(from.as_any_box().downcast::<GuestRegistryValueFault>()?),
            StructType::GuestRegistryValueNotFound => Ok(from.as_any_box().downcast::<GuestRegistryValueNotFound>()?),
            StructType::InvalidGuestLogin => Ok(from.as_any_box().downcast::<InvalidGuestLogin>()?),
            StructType::OperationDisabledByGuest => Ok(from.as_any_box().downcast::<OperationDisabledByGuest>()?),
            StructType::OperationNotSupportedByGuest => Ok(from.as_any_box().downcast::<OperationNotSupportedByGuest>()?),
            StructType::TooManyGuestLogons => Ok(from.as_any_box().downcast::<TooManyGuestLogons>()?),
            StructType::HostConfigFault => Ok(from.as_any_box().downcast::<HostConfigFault>()?),
            StructType::AdminDisabled => Ok(from.as_any_box().downcast::<AdminDisabled>()?),
            StructType::AdminNotDisabled => Ok(from.as_any_box().downcast::<AdminNotDisabled>()?),
            StructType::BlockedByFirewall => Ok(from.as_any_box().downcast::<BlockedByFirewall>()?),
            StructType::ClockSkew => Ok(from.as_any_box().downcast::<ClockSkew>()?),
            StructType::DisableAdminNotSupported => Ok(from.as_any_box().downcast::<DisableAdminNotSupported>()?),
            StructType::HostConfigFailed => Ok(from.as_any_box().downcast::<HostConfigFailed>()?),
            StructType::HostInDomain => Ok(from.as_any_box().downcast::<HostInDomain>()?),
            StructType::InvalidHostName => Ok(from.as_any_box().downcast::<InvalidHostName>()?),
            StructType::NasConfigFault => Ok(from.as_any_box().downcast::<NasConfigFault>()?),
            StructType::InvalidNasCredentials => Ok(from.as_any_box().downcast::<InvalidNasCredentials>()?),
            StructType::InvalidNetworkResource => Ok(from.as_any_box().downcast::<InvalidNetworkResource>()?),
            StructType::NasConnectionLimitReached => Ok(from.as_any_box().downcast::<NasConnectionLimitReached>()?),
            StructType::NasSessionCredentialConflict => Ok(from.as_any_box().downcast::<NasSessionCredentialConflict>()?),
            StructType::NasVolumeNotMounted => Ok(from.as_any_box().downcast::<NasVolumeNotMounted>()?),
            StructType::NetworkInaccessible => Ok(from.as_any_box().downcast::<NetworkInaccessible>()?),
            StructType::NoPermissionOnNasVolume => Ok(from.as_any_box().downcast::<NoPermissionOnNasVolume>()?),
            StructType::NoGateway => Ok(from.as_any_box().downcast::<NoGateway>()?),
            StructType::NoVirtualNic => Ok(from.as_any_box().downcast::<NoVirtualNic>()?),
            StructType::PlatformConfigFault => Ok(from.as_any_box().downcast::<PlatformConfigFault>()?),
            StructType::InvalidBundle => Ok(from.as_any_box().downcast::<InvalidBundle>()?),
            StructType::PatchInstallFailed => Ok(from.as_any_box().downcast::<PatchInstallFailed>()?),
            StructType::PatchIntegrityError => Ok(from.as_any_box().downcast::<PatchIntegrityError>()?),
            StructType::VmfsMountFault => Ok(from.as_any_box().downcast::<VmfsMountFault>()?),
            StructType::VmfsAlreadyMounted => Ok(from.as_any_box().downcast::<VmfsAlreadyMounted>()?),
            StructType::VmfsAmbiguousMount => Ok(from.as_any_box().downcast::<VmfsAmbiguousMount>()?),
            StructType::HostConnectFault => Ok(from.as_any_box().downcast::<HostConnectFault>()?),
            StructType::AgentInstallFailed => Ok(from.as_any_box().downcast::<AgentInstallFailed>()?),
            StructType::AlreadyBeingManaged => Ok(from.as_any_box().downcast::<AlreadyBeingManaged>()?),
            StructType::AlreadyConnected => Ok(from.as_any_box().downcast::<AlreadyConnected>()?),
            StructType::CannotAddHostWithFtVmAsStandalone => Ok(from.as_any_box().downcast::<CannotAddHostWithFtVmAsStandalone>()?),
            StructType::CannotAddHostWithFtVmToDifferentCluster => Ok(from.as_any_box().downcast::<CannotAddHostWithFtVmToDifferentCluster>()?),
            StructType::CannotAddHostWithFtVmToNonHaCluster => Ok(from.as_any_box().downcast::<CannotAddHostWithFtVmToNonHaCluster>()?),
            StructType::GatewayConnectFault => Ok(from.as_any_box().downcast::<GatewayConnectFault>()?),
            StructType::GatewayNotFound => Ok(from.as_any_box().downcast::<GatewayNotFound>()?),
            StructType::GatewayNotReachable => Ok(from.as_any_box().downcast::<GatewayNotReachable>()?),
            StructType::GatewayOperationRefused => Ok(from.as_any_box().downcast::<GatewayOperationRefused>()?),
            StructType::GatewayToHostConnectFault => Ok(from.as_any_box().downcast::<GatewayToHostConnectFault>()?),
            StructType::GatewayHostNotReachable => Ok(from.as_any_box().downcast::<GatewayHostNotReachable>()?),
            StructType::GatewayToHostAuthFault => Ok(from.as_any_box().downcast::<GatewayToHostAuthFault>()?),
            StructType::GatewayToHostTrustVerifyFault => Ok(from.as_any_box().downcast::<GatewayToHostTrustVerifyFault>()?),
            StructType::MultipleCertificatesVerifyFault => Ok(from.as_any_box().downcast::<MultipleCertificatesVerifyFault>()?),
            StructType::NoHost => Ok(from.as_any_box().downcast::<NoHost>()?),
            StructType::NoPermissionOnHost => Ok(from.as_any_box().downcast::<NoPermissionOnHost>()?),
            StructType::NotSupportedHost => Ok(from.as_any_box().downcast::<NotSupportedHost>()?),
            StructType::NonVmwareOuiMacNotSupportedHost => Ok(from.as_any_box().downcast::<NonVmwareOuiMacNotSupportedHost>()?),
            StructType::NotSupportedHostForVFlash => Ok(from.as_any_box().downcast::<NotSupportedHostForVFlash>()?),
            StructType::NotSupportedHostForVmcp => Ok(from.as_any_box().downcast::<NotSupportedHostForVmcp>()?),
            StructType::NotSupportedHostForVmemFile => Ok(from.as_any_box().downcast::<NotSupportedHostForVmemFile>()?),
            StructType::NotSupportedHostForVsan => Ok(from.as_any_box().downcast::<NotSupportedHostForVsan>()?),
            StructType::NotSupportedHostInCluster => Ok(from.as_any_box().downcast::<NotSupportedHostInCluster>()?),
            StructType::EvcAdmissionFailed => Ok(from.as_any_box().downcast::<EvcAdmissionFailed>()?),
            StructType::EvcAdmissionFailedCpuFeaturesForMode => Ok(from.as_any_box().downcast::<EvcAdmissionFailedCpuFeaturesForMode>()?),
            StructType::EvcAdmissionFailedCpuModel => Ok(from.as_any_box().downcast::<EvcAdmissionFailedCpuModel>()?),
            StructType::EvcAdmissionFailedCpuModelForMode => Ok(from.as_any_box().downcast::<EvcAdmissionFailedCpuModelForMode>()?),
            StructType::EvcAdmissionFailedCpuVendor => Ok(from.as_any_box().downcast::<EvcAdmissionFailedCpuVendor>()?),
            StructType::EvcAdmissionFailedCpuVendorUnknown => Ok(from.as_any_box().downcast::<EvcAdmissionFailedCpuVendorUnknown>()?),
            StructType::EvcAdmissionFailedHostDisconnected => Ok(from.as_any_box().downcast::<EvcAdmissionFailedHostDisconnected>()?),
            StructType::EvcAdmissionFailedHostSoftware => Ok(from.as_any_box().downcast::<EvcAdmissionFailedHostSoftware>()?),
            StructType::EvcAdmissionFailedHostSoftwareForMode => Ok(from.as_any_box().downcast::<EvcAdmissionFailedHostSoftwareForMode>()?),
            StructType::EvcAdmissionFailedVmActive => Ok(from.as_any_box().downcast::<EvcAdmissionFailedVmActive>()?),
            StructType::NotSupportedHostInDvs => Ok(from.as_any_box().downcast::<NotSupportedHostInDvs>()?),
            StructType::NotSupportedHostInHaCluster => Ok(from.as_any_box().downcast::<NotSupportedHostInHaCluster>()?),
            StructType::ReadHostResourcePoolTreeFailed => Ok(from.as_any_box().downcast::<ReadHostResourcePoolTreeFailed>()?),
            StructType::SslDisabledFault => Ok(from.as_any_box().downcast::<SslDisabledFault>()?),
            StructType::SslVerifyFault => Ok(from.as_any_box().downcast::<SslVerifyFault>()?),
            StructType::TooManyHosts => Ok(from.as_any_box().downcast::<TooManyHosts>()?),
            StructType::HostHasComponentFailure => Ok(from.as_any_box().downcast::<HostHasComponentFailure>()?),
            StructType::HostIncompatibleForRecordReplay => Ok(from.as_any_box().downcast::<HostIncompatibleForRecordReplay>()?),
            StructType::HostPowerOpFailed => Ok(from.as_any_box().downcast::<HostPowerOpFailed>()?),
            StructType::NoPeerHostFound => Ok(from.as_any_box().downcast::<NoPeerHostFound>()?),
            StructType::VmotionInterfaceNotEnabled => Ok(from.as_any_box().downcast::<VmotionInterfaceNotEnabled>()?),
            StructType::WakeOnLanNotSupportedByVmotionNic => Ok(from.as_any_box().downcast::<WakeOnLanNotSupportedByVmotionNic>()?),
            StructType::HostSpecificationOperationFailed => Ok(from.as_any_box().downcast::<HostSpecificationOperationFailed>()?),
            StructType::HttpFault => Ok(from.as_any_box().downcast::<HttpFault>()?),
            StructType::IormNotSupportedHostOnDatastore => Ok(from.as_any_box().downcast::<IormNotSupportedHostOnDatastore>()?),
            StructType::InaccessibleVFlashSource => Ok(from.as_any_box().downcast::<InaccessibleVFlashSource>()?),
            StructType::InsufficientResourcesFault => Ok(from.as_any_box().downcast::<InsufficientResourcesFault>()?),
            StructType::InsufficientAgentVmsDeployed => Ok(from.as_any_box().downcast::<InsufficientAgentVmsDeployed>()?),
            StructType::InsufficientCpuResourcesFault => Ok(from.as_any_box().downcast::<InsufficientCpuResourcesFault>()?),
            StructType::InsufficientFailoverResourcesFault => Ok(from.as_any_box().downcast::<InsufficientFailoverResourcesFault>()?),
            StructType::InsufficientGraphicsResourcesFault => Ok(from.as_any_box().downcast::<InsufficientGraphicsResourcesFault>()?),
            StructType::InsufficientHostCapacityFault => Ok(from.as_any_box().downcast::<InsufficientHostCapacityFault>()?),
            StructType::InsufficientHostCpuCapacityFault => Ok(from.as_any_box().downcast::<InsufficientHostCpuCapacityFault>()?),
            StructType::InsufficientHostMemoryCapacityFault => Ok(from.as_any_box().downcast::<InsufficientHostMemoryCapacityFault>()?),
            StructType::InsufficientPerCpuCapacity => Ok(from.as_any_box().downcast::<InsufficientPerCpuCapacity>()?),
            StructType::InsufficientMemoryResourcesFault => Ok(from.as_any_box().downcast::<InsufficientMemoryResourcesFault>()?),
            StructType::InsufficientNetworkCapacity => Ok(from.as_any_box().downcast::<InsufficientNetworkCapacity>()?),
            StructType::InsufficientNetworkResourcePoolCapacity => Ok(from.as_any_box().downcast::<InsufficientNetworkResourcePoolCapacity>()?),
            StructType::InsufficientStandbyResource => Ok(from.as_any_box().downcast::<InsufficientStandbyResource>()?),
            StructType::InsufficientStandbyCpuResource => Ok(from.as_any_box().downcast::<InsufficientStandbyCpuResource>()?),
            StructType::InsufficientStandbyMemoryResource => Ok(from.as_any_box().downcast::<InsufficientStandbyMemoryResource>()?),
            StructType::InsufficientStorageSpace => Ok(from.as_any_box().downcast::<InsufficientStorageSpace>()?),
            StructType::InsufficientVFlashResourcesFault => Ok(from.as_any_box().downcast::<InsufficientVFlashResourcesFault>()?),
            StructType::InvalidResourcePoolStructureFault => Ok(from.as_any_box().downcast::<InvalidResourcePoolStructureFault>()?),
            StructType::NumVirtualCpusExceedsLimit => Ok(from.as_any_box().downcast::<NumVirtualCpusExceedsLimit>()?),
            StructType::VmFaultToleranceTooManyFtVcpusOnHost => Ok(from.as_any_box().downcast::<VmFaultToleranceTooManyFtVcpusOnHost>()?),
            StructType::VmFaultToleranceTooManyVMsOnHost => Ok(from.as_any_box().downcast::<VmFaultToleranceTooManyVMsOnHost>()?),
            StructType::VmSmpFaultToleranceTooManyVMsOnHost => Ok(from.as_any_box().downcast::<VmSmpFaultToleranceTooManyVMsOnHost>()?),
            StructType::InsufficientStorageIops => Ok(from.as_any_box().downcast::<InsufficientStorageIops>()?),
            StructType::InvalidAffinitySettingFault => Ok(from.as_any_box().downcast::<InvalidAffinitySettingFault>()?),
            StructType::InvalidBmcRole => Ok(from.as_any_box().downcast::<InvalidBmcRole>()?),
            StructType::InvalidDatastore => Ok(from.as_any_box().downcast::<InvalidDatastore>()?),
            StructType::DatastoreNotWritableOnHost => Ok(from.as_any_box().downcast::<DatastoreNotWritableOnHost>()?),
            StructType::SwapDatastoreNotWritableOnHost => Ok(from.as_any_box().downcast::<SwapDatastoreNotWritableOnHost>()?),
            StructType::InaccessibleDatastore => Ok(from.as_any_box().downcast::<InaccessibleDatastore>()?),
            StructType::InaccessibleFtMetadataDatastore => Ok(from.as_any_box().downcast::<InaccessibleFtMetadataDatastore>()?),
            StructType::InvalidDatastorePath => Ok(from.as_any_box().downcast::<InvalidDatastorePath>()?),
            StructType::InvalidEvent => Ok(from.as_any_box().downcast::<InvalidEvent>()?),
            StructType::InvalidFolder => Ok(from.as_any_box().downcast::<InvalidFolder>()?),
            StructType::VmAlreadyExistsInDatacenter => Ok(from.as_any_box().downcast::<VmAlreadyExistsInDatacenter>()?),
            StructType::InvalidIpmiLoginInfo => Ok(from.as_any_box().downcast::<InvalidIpmiLoginInfo>()?),
            StructType::InvalidIpmiMacAddress => Ok(from.as_any_box().downcast::<InvalidIpmiMacAddress>()?),
            StructType::InvalidLicense => Ok(from.as_any_box().downcast::<InvalidLicense>()?),
            StructType::InvalidLocale => Ok(from.as_any_box().downcast::<InvalidLocale>()?),
            StructType::InvalidLogin => Ok(from.as_any_box().downcast::<InvalidLogin>()?),
            StructType::InvalidClientCertificate => Ok(from.as_any_box().downcast::<InvalidClientCertificate>()?),
            StructType::PasswordExpired => Ok(from.as_any_box().downcast::<PasswordExpired>()?),
            StructType::InvalidName => Ok(from.as_any_box().downcast::<InvalidName>()?),
            StructType::InvalidPrivilege => Ok(from.as_any_box().downcast::<InvalidPrivilege>()?),
            StructType::InvalidState => Ok(from.as_any_box().downcast::<InvalidState>()?),
            StructType::CannotPowerOffVmInCluster => Ok(from.as_any_box().downcast::<CannotPowerOffVmInCluster>()?),
            StructType::EncryptionKeyRequired => Ok(from.as_any_box().downcast::<EncryptionKeyRequired>()?),
            StructType::InvalidDatastoreState => Ok(from.as_any_box().downcast::<InvalidDatastoreState>()?),
            StructType::InvalidHostState => Ok(from.as_any_box().downcast::<InvalidHostState>()?),
            StructType::InvalidHostConnectionState => Ok(from.as_any_box().downcast::<InvalidHostConnectionState>()?),
            StructType::InvalidPowerState => Ok(from.as_any_box().downcast::<InvalidPowerState>()?),
            StructType::InvalidVmState => Ok(from.as_any_box().downcast::<InvalidVmState>()?),
            StructType::MksConnectionLimitReached => Ok(from.as_any_box().downcast::<MksConnectionLimitReached>()?),
            StructType::NoActiveHostInCluster => Ok(from.as_any_box().downcast::<NoActiveHostInCluster>()?),
            StructType::OvfConsumerPowerOnFault => Ok(from.as_any_box().downcast::<OvfConsumerPowerOnFault>()?),
            StructType::QuestionPending => Ok(from.as_any_box().downcast::<QuestionPending>()?),
            StructType::VmPowerOnDisabled => Ok(from.as_any_box().downcast::<VmPowerOnDisabled>()?),
            StructType::IscsiFault => Ok(from.as_any_box().downcast::<IscsiFault>()?),
            StructType::IscsiFaultInvalidVnic => Ok(from.as_any_box().downcast::<IscsiFaultInvalidVnic>()?),
            StructType::IscsiFaultPnicInUse => Ok(from.as_any_box().downcast::<IscsiFaultPnicInUse>()?),
            StructType::IscsiFaultVnicAlreadyBound => Ok(from.as_any_box().downcast::<IscsiFaultVnicAlreadyBound>()?),
            StructType::IscsiFaultVnicHasActivePaths => Ok(from.as_any_box().downcast::<IscsiFaultVnicHasActivePaths>()?),
            StructType::IscsiFaultVnicHasMultipleUplinks => Ok(from.as_any_box().downcast::<IscsiFaultVnicHasMultipleUplinks>()?),
            StructType::IscsiFaultVnicHasNoUplinks => Ok(from.as_any_box().downcast::<IscsiFaultVnicHasNoUplinks>()?),
            StructType::IscsiFaultVnicHasWrongUplink => Ok(from.as_any_box().downcast::<IscsiFaultVnicHasWrongUplink>()?),
            StructType::IscsiFaultVnicInUse => Ok(from.as_any_box().downcast::<IscsiFaultVnicInUse>()?),
            StructType::IscsiFaultVnicIsLastPath => Ok(from.as_any_box().downcast::<IscsiFaultVnicIsLastPath>()?),
            StructType::IscsiFaultVnicNotBound => Ok(from.as_any_box().downcast::<IscsiFaultVnicNotBound>()?),
            StructType::IscsiFaultVnicNotFound => Ok(from.as_any_box().downcast::<IscsiFaultVnicNotFound>()?),
            StructType::KeyNotFound => Ok(from.as_any_box().downcast::<KeyNotFound>()?),
            StructType::LicenseEntityNotFound => Ok(from.as_any_box().downcast::<LicenseEntityNotFound>()?),
            StructType::LicenseServerUnavailable => Ok(from.as_any_box().downcast::<LicenseServerUnavailable>()?),
            StructType::LimitExceeded => Ok(from.as_any_box().downcast::<LimitExceeded>()?),
            StructType::LogBundlingFailed => Ok(from.as_any_box().downcast::<LogBundlingFailed>()?),
            StructType::MigrationFault => Ok(from.as_any_box().downcast::<MigrationFault>()?),
            StructType::AffinityConfigured => Ok(from.as_any_box().downcast::<AffinityConfigured>()?),
            StructType::CannotModifyConfigCpuRequirements => Ok(from.as_any_box().downcast::<CannotModifyConfigCpuRequirements>()?),
            StructType::CannotMoveVmWithDeltaDisk => Ok(from.as_any_box().downcast::<CannotMoveVmWithDeltaDisk>()?),
            StructType::CannotMoveVmWithNativeDeltaDisk => Ok(from.as_any_box().downcast::<CannotMoveVmWithNativeDeltaDisk>()?),
            StructType::CloneFromSnapshotNotSupported => Ok(from.as_any_box().downcast::<CloneFromSnapshotNotSupported>()?),
            StructType::DatacenterMismatch => Ok(from.as_any_box().downcast::<DatacenterMismatch>()?),
            StructType::DisallowedMigrationDeviceAttached => Ok(from.as_any_box().downcast::<DisallowedMigrationDeviceAttached>()?),
            StructType::DiskMoveTypeNotSupported => Ok(from.as_any_box().downcast::<DiskMoveTypeNotSupported>()?),
            StructType::FaultToleranceAntiAffinityViolated => Ok(from.as_any_box().downcast::<FaultToleranceAntiAffinityViolated>()?),
            StructType::FaultToleranceNeedsThickDisk => Ok(from.as_any_box().downcast::<FaultToleranceNeedsThickDisk>()?),
            StructType::FaultToleranceNotSameBuild => Ok(from.as_any_box().downcast::<FaultToleranceNotSameBuild>()?),
            StructType::HaErrorsAtDest => Ok(from.as_any_box().downcast::<HaErrorsAtDest>()?),
            StructType::IncompatibleDefaultDevice => Ok(from.as_any_box().downcast::<IncompatibleDefaultDevice>()?),
            StructType::LargeRdmConversionNotSupported => Ok(from.as_any_box().downcast::<LargeRdmConversionNotSupported>()?),
            StructType::MaintenanceModeFileMove => Ok(from.as_any_box().downcast::<MaintenanceModeFileMove>()?),
            StructType::MigrationDisabled => Ok(from.as_any_box().downcast::<MigrationDisabled>()?),
            StructType::MigrationFeatureNotSupported => Ok(from.as_any_box().downcast::<MigrationFeatureNotSupported>()?),
            StructType::FullStorageVMotionNotSupported => Ok(from.as_any_box().downcast::<FullStorageVMotionNotSupported>()?),
            StructType::IndependentDiskVMotionNotSupported => Ok(from.as_any_box().downcast::<IndependentDiskVMotionNotSupported>()?),
            StructType::NonHomeRdmvMotionNotSupported => Ok(from.as_any_box().downcast::<NonHomeRdmvMotionNotSupported>()?),
            StructType::StorageVMotionNotSupported => Ok(from.as_any_box().downcast::<StorageVMotionNotSupported>()?),
            StructType::UnsharedSwapVMotionNotSupported => Ok(from.as_any_box().downcast::<UnsharedSwapVMotionNotSupported>()?),
            StructType::VMotionAcrossNetworkNotSupported => Ok(from.as_any_box().downcast::<VMotionAcrossNetworkNotSupported>()?),
            StructType::MigrationNotReady => Ok(from.as_any_box().downcast::<MigrationNotReady>()?),
            StructType::MismatchedNetworkPolicies => Ok(from.as_any_box().downcast::<MismatchedNetworkPolicies>()?),
            StructType::MismatchedVMotionNetworkNames => Ok(from.as_any_box().downcast::<MismatchedVMotionNetworkNames>()?),
            StructType::NetworksMayNotBeTheSame => Ok(from.as_any_box().downcast::<NetworksMayNotBeTheSame>()?),
            StructType::NoGuestHeartbeat => Ok(from.as_any_box().downcast::<NoGuestHeartbeat>()?),
            StructType::RdmConversionNotSupported => Ok(from.as_any_box().downcast::<RdmConversionNotSupported>()?),
            StructType::RdmNotPreserved => Ok(from.as_any_box().downcast::<RdmNotPreserved>()?),
            StructType::ReadOnlyDisksWithLegacyDestination => Ok(from.as_any_box().downcast::<ReadOnlyDisksWithLegacyDestination>()?),
            StructType::SnapshotCopyNotSupported => Ok(from.as_any_box().downcast::<SnapshotCopyNotSupported>()?),
            StructType::HotSnapshotMoveNotSupported => Ok(from.as_any_box().downcast::<HotSnapshotMoveNotSupported>()?),
            StructType::SnapshotCloneNotSupported => Ok(from.as_any_box().downcast::<SnapshotCloneNotSupported>()?),
            StructType::SnapshotMoveFromNonHomeNotSupported => Ok(from.as_any_box().downcast::<SnapshotMoveFromNonHomeNotSupported>()?),
            StructType::SnapshotMoveNotSupported => Ok(from.as_any_box().downcast::<SnapshotMoveNotSupported>()?),
            StructType::SnapshotMoveToNonHomeNotSupported => Ok(from.as_any_box().downcast::<SnapshotMoveToNonHomeNotSupported>()?),
            StructType::SnapshotRevertIssue => Ok(from.as_any_box().downcast::<SnapshotRevertIssue>()?),
            StructType::SuspendedRelocateNotSupported => Ok(from.as_any_box().downcast::<SuspendedRelocateNotSupported>()?),
            StructType::TooManyDisksOnLegacyHost => Ok(from.as_any_box().downcast::<TooManyDisksOnLegacyHost>()?),
            StructType::ToolsInstallationInProgress => Ok(from.as_any_box().downcast::<ToolsInstallationInProgress>()?),
            StructType::UncommittedUndoableDisk => Ok(from.as_any_box().downcast::<UncommittedUndoableDisk>()?),
            StructType::VMotionInterfaceIssue => Ok(from.as_any_box().downcast::<VMotionInterfaceIssue>()?),
            StructType::VMotionLinkCapacityLow => Ok(from.as_any_box().downcast::<VMotionLinkCapacityLow>()?),
            StructType::VMotionLinkDown => Ok(from.as_any_box().downcast::<VMotionLinkDown>()?),
            StructType::VMotionNotConfigured => Ok(from.as_any_box().downcast::<VMotionNotConfigured>()?),
            StructType::VMotionNotLicensed => Ok(from.as_any_box().downcast::<VMotionNotLicensed>()?),
            StructType::VMotionNotSupported => Ok(from.as_any_box().downcast::<VMotionNotSupported>()?),
            StructType::VMotionProtocolIncompatible => Ok(from.as_any_box().downcast::<VMotionProtocolIncompatible>()?),
            StructType::WillLoseHaProtection => Ok(from.as_any_box().downcast::<WillLoseHaProtection>()?),
            StructType::WillModifyConfigCpuRequirements => Ok(from.as_any_box().downcast::<WillModifyConfigCpuRequirements>()?),
            StructType::WillResetSnapshotDirectory => Ok(from.as_any_box().downcast::<WillResetSnapshotDirectory>()?),
            StructType::MismatchedBundle => Ok(from.as_any_box().downcast::<MismatchedBundle>()?),
            StructType::MissingBmcSupport => Ok(from.as_any_box().downcast::<MissingBmcSupport>()?),
            StructType::NamespaceFull => Ok(from.as_any_box().downcast::<NamespaceFull>()?),
            StructType::NamespaceLimitReached => Ok(from.as_any_box().downcast::<NamespaceLimitReached>()?),
            StructType::NamespaceWriteProtected => Ok(from.as_any_box().downcast::<NamespaceWriteProtected>()?),
            StructType::NetworkDisruptedAndConfigRolledBack => Ok(from.as_any_box().downcast::<NetworkDisruptedAndConfigRolledBack>()?),
            StructType::NoClientCertificate => Ok(from.as_any_box().downcast::<NoClientCertificate>()?),
            StructType::NoCompatibleDatastore => Ok(from.as_any_box().downcast::<NoCompatibleDatastore>()?),
            StructType::NoCompatibleHost => Ok(from.as_any_box().downcast::<NoCompatibleHost>()?),
            StructType::NoCompatibleHostWithAccessToDevice => Ok(from.as_any_box().downcast::<NoCompatibleHostWithAccessToDevice>()?),
            StructType::NoConnectedDatastore => Ok(from.as_any_box().downcast::<NoConnectedDatastore>()?),
            StructType::NoDiskFound => Ok(from.as_any_box().downcast::<NoDiskFound>()?),
            StructType::NoSubjectName => Ok(from.as_any_box().downcast::<NoSubjectName>()?),
            StructType::NotFound => Ok(from.as_any_box().downcast::<NotFound>()?),
            StructType::NotSupportedHostForChecksum => Ok(from.as_any_box().downcast::<NotSupportedHostForChecksum>()?),
            StructType::OutOfBounds => Ok(from.as_any_box().downcast::<OutOfBounds>()?),
            StructType::OvfFault => Ok(from.as_any_box().downcast::<OvfFault>()?),
            StructType::OvfConsumerCallbackFault => Ok(from.as_any_box().downcast::<OvfConsumerCallbackFault>()?),
            StructType::OvfConsumerCommunicationError => Ok(from.as_any_box().downcast::<OvfConsumerCommunicationError>()?),
            StructType::OvfConsumerFault => Ok(from.as_any_box().downcast::<OvfConsumerFault>()?),
            StructType::OvfConsumerInvalidSection => Ok(from.as_any_box().downcast::<OvfConsumerInvalidSection>()?),
            StructType::OvfConsumerUndeclaredSection => Ok(from.as_any_box().downcast::<OvfConsumerUndeclaredSection>()?),
            StructType::OvfConsumerUndefinedPrefix => Ok(from.as_any_box().downcast::<OvfConsumerUndefinedPrefix>()?),
            StructType::OvfExport => Ok(from.as_any_box().downcast::<OvfExport>()?),
            StructType::ConnectedIso => Ok(from.as_any_box().downcast::<ConnectedIso>()?),
            StructType::OvfDuplicatedPropertyIdExport => Ok(from.as_any_box().downcast::<OvfDuplicatedPropertyIdExport>()?),
            StructType::OvfDuplicatedPropertyIdImport => Ok(from.as_any_box().downcast::<OvfDuplicatedPropertyIdImport>()?),
            StructType::OvfExportFailed => Ok(from.as_any_box().downcast::<OvfExportFailed>()?),
            StructType::OvfHardwareExport => Ok(from.as_any_box().downcast::<OvfHardwareExport>()?),
            StructType::OvfConnectedDevice => Ok(from.as_any_box().downcast::<OvfConnectedDevice>()?),
            StructType::OvfConnectedDeviceFloppy => Ok(from.as_any_box().downcast::<OvfConnectedDeviceFloppy>()?),
            StructType::OvfConnectedDeviceIso => Ok(from.as_any_box().downcast::<OvfConnectedDeviceIso>()?),
            StructType::OvfUnableToExportDisk => Ok(from.as_any_box().downcast::<OvfUnableToExportDisk>()?),
            StructType::OvfUnknownDeviceBacking => Ok(from.as_any_box().downcast::<OvfUnknownDeviceBacking>()?),
            StructType::OvfUnsupportedDeviceExport => Ok(from.as_any_box().downcast::<OvfUnsupportedDeviceExport>()?),
            StructType::OvfPropertyExport => Ok(from.as_any_box().downcast::<OvfPropertyExport>()?),
            StructType::OvfPropertyNetworkExport => Ok(from.as_any_box().downcast::<OvfPropertyNetworkExport>()?),
            StructType::OvfImport => Ok(from.as_any_box().downcast::<OvfImport>()?),
            StructType::OvfCpuCompatibility => Ok(from.as_any_box().downcast::<OvfCpuCompatibility>()?),
            StructType::OvfCpuCompatibilityCheckNotSupported => Ok(from.as_any_box().downcast::<OvfCpuCompatibilityCheckNotSupported>()?),
            StructType::OvfHardwareCheck => Ok(from.as_any_box().downcast::<OvfHardwareCheck>()?),
            StructType::OvfImportFailed => Ok(from.as_any_box().downcast::<OvfImportFailed>()?),
            StructType::OvfMappedOsId => Ok(from.as_any_box().downcast::<OvfMappedOsId>()?),
            StructType::OvfMissingHardware => Ok(from.as_any_box().downcast::<OvfMissingHardware>()?),
            StructType::OvfNetworkMappingNotSupported => Ok(from.as_any_box().downcast::<OvfNetworkMappingNotSupported>()?),
            StructType::OvfUnsupportedDiskProvisioning => Ok(from.as_any_box().downcast::<OvfUnsupportedDiskProvisioning>()?),
            StructType::OvfInvalidPackage => Ok(from.as_any_box().downcast::<OvfInvalidPackage>()?),
            StructType::OvfAttribute => Ok(from.as_any_box().downcast::<OvfAttribute>()?),
            StructType::OvfInvalidValue => Ok(from.as_any_box().downcast::<OvfInvalidValue>()?),
            StructType::OvfInvalidValueConfiguration => Ok(from.as_any_box().downcast::<OvfInvalidValueConfiguration>()?),
            StructType::OvfInvalidValueEmpty => Ok(from.as_any_box().downcast::<OvfInvalidValueEmpty>()?),
            StructType::OvfInvalidValueFormatMalformed => Ok(from.as_any_box().downcast::<OvfInvalidValueFormatMalformed>()?),
            StructType::OvfInvalidValueReference => Ok(from.as_any_box().downcast::<OvfInvalidValueReference>()?),
            StructType::OvfMissingAttribute => Ok(from.as_any_box().downcast::<OvfMissingAttribute>()?),
            StructType::OvfConstraint => Ok(from.as_any_box().downcast::<OvfConstraint>()?),
            StructType::OvfDiskOrderConstraint => Ok(from.as_any_box().downcast::<OvfDiskOrderConstraint>()?),
            StructType::OvfHostResourceConstraint => Ok(from.as_any_box().downcast::<OvfHostResourceConstraint>()?),
            StructType::OvfElement => Ok(from.as_any_box().downcast::<OvfElement>()?),
            StructType::OvfDuplicateElement => Ok(from.as_any_box().downcast::<OvfDuplicateElement>()?),
            StructType::OvfDuplicatedElementBoundary => Ok(from.as_any_box().downcast::<OvfDuplicatedElementBoundary>()?),
            StructType::OvfElementInvalidValue => Ok(from.as_any_box().downcast::<OvfElementInvalidValue>()?),
            StructType::OvfMissingElement => Ok(from.as_any_box().downcast::<OvfMissingElement>()?),
            StructType::OvfMissingElementNormalBoundary => Ok(from.as_any_box().downcast::<OvfMissingElementNormalBoundary>()?),
            StructType::OvfUnexpectedElement => Ok(from.as_any_box().downcast::<OvfUnexpectedElement>()?),
            StructType::OvfWrongElement => Ok(from.as_any_box().downcast::<OvfWrongElement>()?),
            StructType::OvfProperty => Ok(from.as_any_box().downcast::<OvfProperty>()?),
            StructType::OvfPropertyNetwork => Ok(from.as_any_box().downcast::<OvfPropertyNetwork>()?),
            StructType::OvfPropertyQualifier => Ok(from.as_any_box().downcast::<OvfPropertyQualifier>()?),
            StructType::OvfPropertyQualifierDuplicate => Ok(from.as_any_box().downcast::<OvfPropertyQualifierDuplicate>()?),
            StructType::OvfPropertyQualifierIgnored => Ok(from.as_any_box().downcast::<OvfPropertyQualifierIgnored>()?),
            StructType::OvfPropertyType => Ok(from.as_any_box().downcast::<OvfPropertyType>()?),
            StructType::OvfPropertyValue => Ok(from.as_any_box().downcast::<OvfPropertyValue>()?),
            StructType::OvfWrongNamespace => Ok(from.as_any_box().downcast::<OvfWrongNamespace>()?),
            StructType::OvfXmlFormat => Ok(from.as_any_box().downcast::<OvfXmlFormat>()?),
            StructType::OvfSystemFault => Ok(from.as_any_box().downcast::<OvfSystemFault>()?),
            StructType::OvfDiskMappingNotFound => Ok(from.as_any_box().downcast::<OvfDiskMappingNotFound>()?),
            StructType::OvfHostValueNotParsed => Ok(from.as_any_box().downcast::<OvfHostValueNotParsed>()?),
            StructType::OvfInternalError => Ok(from.as_any_box().downcast::<OvfInternalError>()?),
            StructType::OvfToXmlUnsupportedElement => Ok(from.as_any_box().downcast::<OvfToXmlUnsupportedElement>()?),
            StructType::OvfUnknownDevice => Ok(from.as_any_box().downcast::<OvfUnknownDevice>()?),
            StructType::OvfUnknownEntity => Ok(from.as_any_box().downcast::<OvfUnknownEntity>()?),
            StructType::OvfUnsupportedDeviceBackingInfo => Ok(from.as_any_box().downcast::<OvfUnsupportedDeviceBackingInfo>()?),
            StructType::OvfUnsupportedDeviceBackingOption => Ok(from.as_any_box().downcast::<OvfUnsupportedDeviceBackingOption>()?),
            StructType::OvfUnsupportedPackage => Ok(from.as_any_box().downcast::<OvfUnsupportedPackage>()?),
            StructType::OvfInvalidVmName => Ok(from.as_any_box().downcast::<OvfInvalidVmName>()?),
            StructType::OvfNoHostNic => Ok(from.as_any_box().downcast::<OvfNoHostNic>()?),
            StructType::OvfNoSupportedHardwareFamily => Ok(from.as_any_box().downcast::<OvfNoSupportedHardwareFamily>()?),
            StructType::OvfUnsupportedAttribute => Ok(from.as_any_box().downcast::<OvfUnsupportedAttribute>()?),
            StructType::OvfUnsupportedAttributeValue => Ok(from.as_any_box().downcast::<OvfUnsupportedAttributeValue>()?),
            StructType::OvfUnsupportedElement => Ok(from.as_any_box().downcast::<OvfUnsupportedElement>()?),
            StructType::OvfNoSpaceOnController => Ok(from.as_any_box().downcast::<OvfNoSpaceOnController>()?),
            StructType::OvfUnsupportedElementValue => Ok(from.as_any_box().downcast::<OvfUnsupportedElementValue>()?),
            StructType::OvfUnsupportedSection => Ok(from.as_any_box().downcast::<OvfUnsupportedSection>()?),
            StructType::OvfUnsupportedSubType => Ok(from.as_any_box().downcast::<OvfUnsupportedSubType>()?),
            StructType::OvfUnsupportedType => Ok(from.as_any_box().downcast::<OvfUnsupportedType>()?),
            StructType::PatchBinariesNotFound => Ok(from.as_any_box().downcast::<PatchBinariesNotFound>()?),
            StructType::PatchMetadataInvalid => Ok(from.as_any_box().downcast::<PatchMetadataInvalid>()?),
            StructType::PatchMetadataCorrupted => Ok(from.as_any_box().downcast::<PatchMetadataCorrupted>()?),
            StructType::PatchMetadataNotFound => Ok(from.as_any_box().downcast::<PatchMetadataNotFound>()?),
            StructType::PatchNotApplicable => Ok(from.as_any_box().downcast::<PatchNotApplicable>()?),
            StructType::PatchAlreadyInstalled => Ok(from.as_any_box().downcast::<PatchAlreadyInstalled>()?),
            StructType::PatchMissingDependencies => Ok(from.as_any_box().downcast::<PatchMissingDependencies>()?),
            StructType::PatchSuperseded => Ok(from.as_any_box().downcast::<PatchSuperseded>()?),
            StructType::ProfileUpdateFailed => Ok(from.as_any_box().downcast::<ProfileUpdateFailed>()?),
            StructType::RebootRequired => Ok(from.as_any_box().downcast::<RebootRequired>()?),
            StructType::RecordReplayDisabled => Ok(from.as_any_box().downcast::<RecordReplayDisabled>()?),
            StructType::RemoveFailed => Ok(from.as_any_box().downcast::<RemoveFailed>()?),
            StructType::ReplicationFault => Ok(from.as_any_box().downcast::<ReplicationFault>()?),
            StructType::IncompatibleHostForVmReplication => Ok(from.as_any_box().downcast::<IncompatibleHostForVmReplication>()?),
            StructType::ReplicationConfigFault => Ok(from.as_any_box().downcast::<ReplicationConfigFault>()?),
            StructType::ReplicationDiskConfigFault => Ok(from.as_any_box().downcast::<ReplicationDiskConfigFault>()?),
            StructType::ReplicationVmConfigFault => Ok(from.as_any_box().downcast::<ReplicationVmConfigFault>()?),
            StructType::ReplicationIncompatibleWithFt => Ok(from.as_any_box().downcast::<ReplicationIncompatibleWithFt>()?),
            StructType::ReplicationInvalidOptions => Ok(from.as_any_box().downcast::<ReplicationInvalidOptions>()?),
            StructType::ReplicationNotSupportedOnHost => Ok(from.as_any_box().downcast::<ReplicationNotSupportedOnHost>()?),
            StructType::ReplicationVmFault => Ok(from.as_any_box().downcast::<ReplicationVmFault>()?),
            StructType::ReplicationVmInProgressFault => Ok(from.as_any_box().downcast::<ReplicationVmInProgressFault>()?),
            StructType::ResourceInUse => Ok(from.as_any_box().downcast::<ResourceInUse>()?),
            StructType::FilterInUse => Ok(from.as_any_box().downcast::<FilterInUse>()?),
            StructType::QuiesceDatastoreIoForHaFailed => Ok(from.as_any_box().downcast::<QuiesceDatastoreIoForHaFailed>()?),
            StructType::ResourceNotAvailable => Ok(from.as_any_box().downcast::<ResourceNotAvailable>()?),
            StructType::SspiChallenge => Ok(from.as_any_box().downcast::<SspiChallenge>()?),
            StructType::ShrinkDiskFault => Ok(from.as_any_box().downcast::<ShrinkDiskFault>()?),
            StructType::SnapshotFault => Ok(from.as_any_box().downcast::<SnapshotFault>()?),
            StructType::ApplicationQuiesceFault => Ok(from.as_any_box().downcast::<ApplicationQuiesceFault>()?),
            StructType::FilesystemQuiesceFault => Ok(from.as_any_box().downcast::<FilesystemQuiesceFault>()?),
            StructType::MemorySnapshotOnIndependentDisk => Ok(from.as_any_box().downcast::<MemorySnapshotOnIndependentDisk>()?),
            StructType::MultipleSnapshotsNotSupported => Ok(from.as_any_box().downcast::<MultipleSnapshotsNotSupported>()?),
            StructType::SnapshotDisabled => Ok(from.as_any_box().downcast::<SnapshotDisabled>()?),
            StructType::SnapshotIncompatibleDeviceInVm => Ok(from.as_any_box().downcast::<SnapshotIncompatibleDeviceInVm>()?),
            StructType::SnapshotLocked => Ok(from.as_any_box().downcast::<SnapshotLocked>()?),
            StructType::SnapshotNoChange => Ok(from.as_any_box().downcast::<SnapshotNoChange>()?),
            StructType::TooManySnapshotLevels => Ok(from.as_any_box().downcast::<TooManySnapshotLevels>()?),
            StructType::SsdDiskNotAvailable => Ok(from.as_any_box().downcast::<SsdDiskNotAvailable>()?),
            StructType::StorageDrsCannotMoveDiskInMultiWriterMode => Ok(from.as_any_box().downcast::<StorageDrsCannotMoveDiskInMultiWriterMode>()?),
            StructType::StorageDrsCannotMoveFtVm => Ok(from.as_any_box().downcast::<StorageDrsCannotMoveFtVm>()?),
            StructType::StorageDrsCannotMoveIndependentDisk => Ok(from.as_any_box().downcast::<StorageDrsCannotMoveIndependentDisk>()?),
            StructType::StorageDrsCannotMoveManuallyPlacedSwapFile => Ok(from.as_any_box().downcast::<StorageDrsCannotMoveManuallyPlacedSwapFile>()?),
            StructType::StorageDrsCannotMoveManuallyPlacedVm => Ok(from.as_any_box().downcast::<StorageDrsCannotMoveManuallyPlacedVm>()?),
            StructType::StorageDrsCannotMoveSharedDisk => Ok(from.as_any_box().downcast::<StorageDrsCannotMoveSharedDisk>()?),
            StructType::StorageDrsCannotMoveTemplate => Ok(from.as_any_box().downcast::<StorageDrsCannotMoveTemplate>()?),
            StructType::StorageDrsCannotMoveVmInUserFolder => Ok(from.as_any_box().downcast::<StorageDrsCannotMoveVmInUserFolder>()?),
            StructType::StorageDrsCannotMoveVmWithMountedCdrom => Ok(from.as_any_box().downcast::<StorageDrsCannotMoveVmWithMountedCdrom>()?),
            StructType::StorageDrsCannotMoveVmWithNoFilesInLayout => Ok(from.as_any_box().downcast::<StorageDrsCannotMoveVmWithNoFilesInLayout>()?),
            StructType::StorageDrsDatacentersCannotShareDatastore => Ok(from.as_any_box().downcast::<StorageDrsDatacentersCannotShareDatastore>()?),
            StructType::StorageDrsDisabledOnVm => Ok(from.as_any_box().downcast::<StorageDrsDisabledOnVm>()?),
            StructType::StorageDrsHbrDiskNotMovable => Ok(from.as_any_box().downcast::<StorageDrsHbrDiskNotMovable>()?),
            StructType::StorageDrsHmsMoveInProgress => Ok(from.as_any_box().downcast::<StorageDrsHmsMoveInProgress>()?),
            StructType::StorageDrsHmsUnreachable => Ok(from.as_any_box().downcast::<StorageDrsHmsUnreachable>()?),
            StructType::StorageDrsIolbDisabledInternally => Ok(from.as_any_box().downcast::<StorageDrsIolbDisabledInternally>()?),
            StructType::StorageDrsRelocateDisabled => Ok(from.as_any_box().downcast::<StorageDrsRelocateDisabled>()?),
            StructType::StorageDrsStaleHmsCollection => Ok(from.as_any_box().downcast::<StorageDrsStaleHmsCollection>()?),
            StructType::StorageDrsUnableToMoveFiles => Ok(from.as_any_box().downcast::<StorageDrsUnableToMoveFiles>()?),
            StructType::SwapDatastoreUnset => Ok(from.as_any_box().downcast::<SwapDatastoreUnset>()?),
            StructType::TaskInProgress => Ok(from.as_any_box().downcast::<TaskInProgress>()?),
            StructType::VAppTaskInProgress => Ok(from.as_any_box().downcast::<VAppTaskInProgress>()?),
            StructType::Timedout => Ok(from.as_any_box().downcast::<Timedout>()?),
            StructType::PowerOnFtSecondaryTimedout => Ok(from.as_any_box().downcast::<PowerOnFtSecondaryTimedout>()?),
            StructType::TooManyConsecutiveOverrides => Ok(from.as_any_box().downcast::<TooManyConsecutiveOverrides>()?),
            StructType::ToolsUnavailable => Ok(from.as_any_box().downcast::<ToolsUnavailable>()?),
            StructType::UnrecognizedHost => Ok(from.as_any_box().downcast::<UnrecognizedHost>()?),
            StructType::UnsupportedVimApiVersion => Ok(from.as_any_box().downcast::<UnsupportedVimApiVersion>()?),
            StructType::UserNotFound => Ok(from.as_any_box().downcast::<UserNotFound>()?),
            StructType::VAppConfigFault => Ok(from.as_any_box().downcast::<VAppConfigFault>()?),
            StructType::MissingPowerOffConfiguration => Ok(from.as_any_box().downcast::<MissingPowerOffConfiguration>()?),
            StructType::MissingPowerOnConfiguration => Ok(from.as_any_box().downcast::<MissingPowerOnConfiguration>()?),
            StructType::NoVmInVApp => Ok(from.as_any_box().downcast::<NoVmInVApp>()?),
            StructType::VFlashModuleVersionIncompatible => Ok(from.as_any_box().downcast::<VFlashModuleVersionIncompatible>()?),
            StructType::VmConfigFault => Ok(from.as_any_box().downcast::<VmConfigFault>()?),
            StructType::CannotAccessVmComponent => Ok(from.as_any_box().downcast::<CannotAccessVmComponent>()?),
            StructType::CannotAccessVmConfig => Ok(from.as_any_box().downcast::<CannotAccessVmConfig>()?),
            StructType::CannotAccessVmDevice => Ok(from.as_any_box().downcast::<CannotAccessVmDevice>()?),
            StructType::CannotAccessNetwork => Ok(from.as_any_box().downcast::<CannotAccessNetwork>()?),
            StructType::DestinationSwitchFull => Ok(from.as_any_box().downcast::<DestinationSwitchFull>()?),
            StructType::LegacyNetworkInterfaceInUse => Ok(from.as_any_box().downcast::<LegacyNetworkInterfaceInUse>()?),
            StructType::VmOnConflictDvPort => Ok(from.as_any_box().downcast::<VmOnConflictDvPort>()?),
            StructType::VmOnVirtualIntranet => Ok(from.as_any_box().downcast::<VmOnVirtualIntranet>()?),
            StructType::CannotAccessVmDisk => Ok(from.as_any_box().downcast::<CannotAccessVmDisk>()?),
            StructType::RdmPointsToInaccessibleDisk => Ok(from.as_any_box().downcast::<RdmPointsToInaccessibleDisk>()?),
            StructType::CannotDisableSnapshot => Ok(from.as_any_box().downcast::<CannotDisableSnapshot>()?),
            StructType::CannotUseNetwork => Ok(from.as_any_box().downcast::<CannotUseNetwork>()?),
            StructType::CpuHotPlugNotSupported => Ok(from.as_any_box().downcast::<CpuHotPlugNotSupported>()?),
            StructType::DeltaDiskFormatNotSupported => Ok(from.as_any_box().downcast::<DeltaDiskFormatNotSupported>()?),
            StructType::EightHostLimitViolated => Ok(from.as_any_box().downcast::<EightHostLimitViolated>()?),
            StructType::FaultToleranceCannotEditMem => Ok(from.as_any_box().downcast::<FaultToleranceCannotEditMem>()?),
            StructType::GenericVmConfigFault => Ok(from.as_any_box().downcast::<GenericVmConfigFault>()?),
            StructType::InvalidFormat => Ok(from.as_any_box().downcast::<InvalidFormat>()?),
            StructType::InvalidDiskFormat => Ok(from.as_any_box().downcast::<InvalidDiskFormat>()?),
            StructType::InvalidSnapshotFormat => Ok(from.as_any_box().downcast::<InvalidSnapshotFormat>()?),
            StructType::InvalidVmConfig => Ok(from.as_any_box().downcast::<InvalidVmConfig>()?),
            StructType::InvalidDeviceSpec => Ok(from.as_any_box().downcast::<InvalidDeviceSpec>()?),
            StructType::DeviceHotPlugNotSupported => Ok(from.as_any_box().downcast::<DeviceHotPlugNotSupported>()?),
            StructType::DeviceNotFound => Ok(from.as_any_box().downcast::<DeviceNotFound>()?),
            StructType::DeviceUnsupportedForVmPlatform => Ok(from.as_any_box().downcast::<DeviceUnsupportedForVmPlatform>()?),
            StructType::DeviceUnsupportedForVmVersion => Ok(from.as_any_box().downcast::<DeviceUnsupportedForVmVersion>()?),
            StructType::DisallowedDiskModeChange => Ok(from.as_any_box().downcast::<DisallowedDiskModeChange>()?),
            StructType::InvalidController => Ok(from.as_any_box().downcast::<InvalidController>()?),
            StructType::InvalidDeviceBacking => Ok(from.as_any_box().downcast::<InvalidDeviceBacking>()?),
            StructType::InvalidDeviceOperation => Ok(from.as_any_box().downcast::<InvalidDeviceOperation>()?),
            StructType::MissingController => Ok(from.as_any_box().downcast::<MissingController>()?),
            StructType::SwapPlacementOverrideNotSupported => Ok(from.as_any_box().downcast::<SwapPlacementOverrideNotSupported>()?),
            StructType::TooManyDevices => Ok(from.as_any_box().downcast::<TooManyDevices>()?),
            StructType::UnsupportedGuest => Ok(from.as_any_box().downcast::<UnsupportedGuest>()?),
            StructType::VmWwnConflict => Ok(from.as_any_box().downcast::<VmWwnConflict>()?),
            StructType::LargeRdmNotSupportedOnDatastore => Ok(from.as_any_box().downcast::<LargeRdmNotSupportedOnDatastore>()?),
            StructType::MemoryHotPlugNotSupported => Ok(from.as_any_box().downcast::<MemoryHotPlugNotSupported>()?),
            StructType::NoCompatibleHardAffinityHost => Ok(from.as_any_box().downcast::<NoCompatibleHardAffinityHost>()?),
            StructType::NoCompatibleSoftAffinityHost => Ok(from.as_any_box().downcast::<NoCompatibleSoftAffinityHost>()?),
            StructType::NumVirtualCpusIncompatible => Ok(from.as_any_box().downcast::<NumVirtualCpusIncompatible>()?),
            StructType::OvfConsumerValidationFault => Ok(from.as_any_box().downcast::<OvfConsumerValidationFault>()?),
            StructType::QuarantineModeFault => Ok(from.as_any_box().downcast::<QuarantineModeFault>()?),
            StructType::RdmNotSupportedOnDatastore => Ok(from.as_any_box().downcast::<RdmNotSupportedOnDatastore>()?),
            StructType::RuleViolation => Ok(from.as_any_box().downcast::<RuleViolation>()?),
            StructType::SoftRuleVioCorrectionDisallowed => Ok(from.as_any_box().downcast::<SoftRuleVioCorrectionDisallowed>()?),
            StructType::SoftRuleVioCorrectionImpact => Ok(from.as_any_box().downcast::<SoftRuleVioCorrectionImpact>()?),
            StructType::UnsupportedDatastore => Ok(from.as_any_box().downcast::<UnsupportedDatastore>()?),
            StructType::MemoryFileFormatNotSupportedByDatastore => Ok(from.as_any_box().downcast::<MemoryFileFormatNotSupportedByDatastore>()?),
            StructType::UnSupportedDatastoreForVFlash => Ok(from.as_any_box().downcast::<UnSupportedDatastoreForVFlash>()?),
            StructType::UnsupportedVmxLocation => Ok(from.as_any_box().downcast::<UnsupportedVmxLocation>()?),
            StructType::VAppNotRunning => Ok(from.as_any_box().downcast::<VAppNotRunning>()?),
            StructType::VAppPropertyFault => Ok(from.as_any_box().downcast::<VAppPropertyFault>()?),
            StructType::InvalidNetworkInType => Ok(from.as_any_box().downcast::<InvalidNetworkInType>()?),
            StructType::InvalidPropertyType => Ok(from.as_any_box().downcast::<InvalidPropertyType>()?),
            StructType::InvalidPropertyValue => Ok(from.as_any_box().downcast::<InvalidPropertyValue>()?),
            StructType::UnconfiguredPropertyValue => Ok(from.as_any_box().downcast::<UnconfiguredPropertyValue>()?),
            StructType::MissingIpPool => Ok(from.as_any_box().downcast::<MissingIpPool>()?),
            StructType::MissingNetworkIpConfig => Ok(from.as_any_box().downcast::<MissingNetworkIpConfig>()?),
            StructType::NoAvailableIp => Ok(from.as_any_box().downcast::<NoAvailableIp>()?),
            StructType::NoVcManagedIpConfigured => Ok(from.as_any_box().downcast::<NoVcManagedIpConfigured>()?),
            StructType::NotUserConfigurableProperty => Ok(from.as_any_box().downcast::<NotUserConfigurableProperty>()?),
            StructType::VFlashCacheHotConfigNotSupported => Ok(from.as_any_box().downcast::<VFlashCacheHotConfigNotSupported>()?),
            StructType::VFlashModuleNotSupported => Ok(from.as_any_box().downcast::<VFlashModuleNotSupported>()?),
            StructType::VirtualHardwareCompatibilityIssue => Ok(from.as_any_box().downcast::<VirtualHardwareCompatibilityIssue>()?),
            StructType::CpuIncompatible => Ok(from.as_any_box().downcast::<CpuIncompatible>()?),
            StructType::CpuCompatibilityUnknown => Ok(from.as_any_box().downcast::<CpuCompatibilityUnknown>()?),
            StructType::CpuIncompatible1Ecx => Ok(from.as_any_box().downcast::<CpuIncompatible1Ecx>()?),
            StructType::CpuIncompatible81Edx => Ok(from.as_any_box().downcast::<CpuIncompatible81Edx>()?),
            StructType::FaultToleranceCpuIncompatible => Ok(from.as_any_box().downcast::<FaultToleranceCpuIncompatible>()?),
            StructType::DeviceNotSupported => Ok(from.as_any_box().downcast::<DeviceNotSupported>()?),
            StructType::DeviceBackingNotSupported => Ok(from.as_any_box().downcast::<DeviceBackingNotSupported>()?),
            StructType::DvPortNotSupported => Ok(from.as_any_box().downcast::<DvPortNotSupported>()?),
            StructType::UnusedVirtualDiskBlocksNotScrubbed => Ok(from.as_any_box().downcast::<UnusedVirtualDiskBlocksNotScrubbed>()?),
            StructType::VirtualDiskBlocksNotFullyProvisioned => Ok(from.as_any_box().downcast::<VirtualDiskBlocksNotFullyProvisioned>()?),
            StructType::DeviceControllerNotSupported => Ok(from.as_any_box().downcast::<DeviceControllerNotSupported>()?),
            StructType::DigestNotSupported => Ok(from.as_any_box().downcast::<DigestNotSupported>()?),
            StructType::FileBackedPortNotSupported => Ok(from.as_any_box().downcast::<FileBackedPortNotSupported>()?),
            StructType::MultiWriterNotSupported => Ok(from.as_any_box().downcast::<MultiWriterNotSupported>()?),
            StructType::NonPersistentDisksNotSupported => Ok(from.as_any_box().downcast::<NonPersistentDisksNotSupported>()?),
            StructType::RdmNotSupported => Ok(from.as_any_box().downcast::<RdmNotSupported>()?),
            StructType::PhysCompatRdmNotSupported => Ok(from.as_any_box().downcast::<PhysCompatRdmNotSupported>()?),
            StructType::RawDiskNotSupported => Ok(from.as_any_box().downcast::<RawDiskNotSupported>()?),
            StructType::RemoteDeviceNotSupported => Ok(from.as_any_box().downcast::<RemoteDeviceNotSupported>()?),
            StructType::SharedBusControllerNotSupported => Ok(from.as_any_box().downcast::<SharedBusControllerNotSupported>()?),
            StructType::VmiNotSupported => Ok(from.as_any_box().downcast::<VmiNotSupported>()?),
            StructType::VirtualDiskModeNotSupported => Ok(from.as_any_box().downcast::<VirtualDiskModeNotSupported>()?),
            StructType::VirtualEthernetCardNotSupported => Ok(from.as_any_box().downcast::<VirtualEthernetCardNotSupported>()?),
            StructType::DiskNotSupported => Ok(from.as_any_box().downcast::<DiskNotSupported>()?),
            StructType::IdeDiskNotSupported => Ok(from.as_any_box().downcast::<IdeDiskNotSupported>()?),
            StructType::DrsVmotionIncompatibleFault => Ok(from.as_any_box().downcast::<DrsVmotionIncompatibleFault>()?),
            StructType::FeatureRequirementsNotMet => Ok(from.as_any_box().downcast::<FeatureRequirementsNotMet>()?),
            StructType::MemorySizeNotRecommended => Ok(from.as_any_box().downcast::<MemorySizeNotRecommended>()?),
            StructType::MemorySizeNotSupported => Ok(from.as_any_box().downcast::<MemorySizeNotSupported>()?),
            StructType::MemorySizeNotSupportedByDatastore => Ok(from.as_any_box().downcast::<MemorySizeNotSupportedByDatastore>()?),
            StructType::NotEnoughCpus => Ok(from.as_any_box().downcast::<NotEnoughCpus>()?),
            StructType::NotEnoughLogicalCpus => Ok(from.as_any_box().downcast::<NotEnoughLogicalCpus>()?),
            StructType::NumVirtualCoresPerSocketNotSupported => Ok(from.as_any_box().downcast::<NumVirtualCoresPerSocketNotSupported>()?),
            StructType::NumVirtualCpusNotSupported => Ok(from.as_any_box().downcast::<NumVirtualCpusNotSupported>()?),
            StructType::StorageVmotionIncompatible => Ok(from.as_any_box().downcast::<StorageVmotionIncompatible>()?),
            StructType::VirtualHardwareVersionNotSupported => Ok(from.as_any_box().downcast::<VirtualHardwareVersionNotSupported>()?),
            StructType::WakeOnLanNotSupported => Ok(from.as_any_box().downcast::<WakeOnLanNotSupported>()?),
            StructType::VmConfigIncompatibleForFaultTolerance => Ok(from.as_any_box().downcast::<VmConfigIncompatibleForFaultTolerance>()?),
            StructType::VmConfigIncompatibleForRecordReplay => Ok(from.as_any_box().downcast::<VmConfigIncompatibleForRecordReplay>()?),
            StructType::VmHostAffinityRuleViolation => Ok(from.as_any_box().downcast::<VmHostAffinityRuleViolation>()?),
            StructType::VmFaultToleranceIssue => Ok(from.as_any_box().downcast::<VmFaultToleranceIssue>()?),
            StructType::CannotChangeDrsBehaviorForFtSecondary => Ok(from.as_any_box().downcast::<CannotChangeDrsBehaviorForFtSecondary>()?),
            StructType::CannotChangeHaSettingsForFtSecondary => Ok(from.as_any_box().downcast::<CannotChangeHaSettingsForFtSecondary>()?),
            StructType::CannotComputeFtCompatibleHosts => Ok(from.as_any_box().downcast::<CannotComputeFtCompatibleHosts>()?),
            StructType::FaultToleranceNotLicensed => Ok(from.as_any_box().downcast::<FaultToleranceNotLicensed>()?),
            StructType::FaultTolerancePrimaryPowerOnNotAttempted => Ok(from.as_any_box().downcast::<FaultTolerancePrimaryPowerOnNotAttempted>()?),
            StructType::FtIssuesOnHost => Ok(from.as_any_box().downcast::<FtIssuesOnHost>()?),
            StructType::HostIncompatibleForFaultTolerance => Ok(from.as_any_box().downcast::<HostIncompatibleForFaultTolerance>()?),
            StructType::IncompatibleHostForFtSecondary => Ok(from.as_any_box().downcast::<IncompatibleHostForFtSecondary>()?),
            StructType::InvalidOperationOnSecondaryVm => Ok(from.as_any_box().downcast::<InvalidOperationOnSecondaryVm>()?),
            StructType::NoHostSuitableForFtSecondary => Ok(from.as_any_box().downcast::<NoHostSuitableForFtSecondary>()?),
            StructType::NotSupportedDeviceForFt => Ok(from.as_any_box().downcast::<NotSupportedDeviceForFt>()?),
            StructType::PowerOnFtSecondaryFailed => Ok(from.as_any_box().downcast::<PowerOnFtSecondaryFailed>()?),
            StructType::SecondaryVmAlreadyDisabled => Ok(from.as_any_box().downcast::<SecondaryVmAlreadyDisabled>()?),
            StructType::SecondaryVmAlreadyEnabled => Ok(from.as_any_box().downcast::<SecondaryVmAlreadyEnabled>()?),
            StructType::SecondaryVmAlreadyRegistered => Ok(from.as_any_box().downcast::<SecondaryVmAlreadyRegistered>()?),
            StructType::SecondaryVmNotRegistered => Ok(from.as_any_box().downcast::<SecondaryVmNotRegistered>()?),
            StructType::VmFaultToleranceConfigIssue => Ok(from.as_any_box().downcast::<VmFaultToleranceConfigIssue>()?),
            StructType::VmFaultToleranceConfigIssueWrapper => Ok(from.as_any_box().downcast::<VmFaultToleranceConfigIssueWrapper>()?),
            StructType::VmFaultToleranceInvalidFileBacking => Ok(from.as_any_box().downcast::<VmFaultToleranceInvalidFileBacking>()?),
            StructType::VmFaultToleranceOpIssuesList => Ok(from.as_any_box().downcast::<VmFaultToleranceOpIssuesList>()?),
            StructType::VmMetadataManagerFault => Ok(from.as_any_box().downcast::<VmMetadataManagerFault>()?),
            StructType::VmMonitorIncompatibleForFaultTolerance => Ok(from.as_any_box().downcast::<VmMonitorIncompatibleForFaultTolerance>()?),
            StructType::VmToolsUpgradeFault => Ok(from.as_any_box().downcast::<VmToolsUpgradeFault>()?),
            StructType::ToolsAlreadyUpgraded => Ok(from.as_any_box().downcast::<ToolsAlreadyUpgraded>()?),
            StructType::ToolsAutoUpgradeNotSupported => Ok(from.as_any_box().downcast::<ToolsAutoUpgradeNotSupported>()?),
            StructType::ToolsImageCopyFailed => Ok(from.as_any_box().downcast::<ToolsImageCopyFailed>()?),
            StructType::ToolsImageNotAvailable => Ok(from.as_any_box().downcast::<ToolsImageNotAvailable>()?),
            StructType::ToolsImageSignatureCheckFailed => Ok(from.as_any_box().downcast::<ToolsImageSignatureCheckFailed>()?),
            StructType::ToolsUpgradeCancelled => Ok(from.as_any_box().downcast::<ToolsUpgradeCancelled>()?),
            StructType::VmValidateMaxDevice => Ok(from.as_any_box().downcast::<VmValidateMaxDevice>()?),
            StructType::VsanFault => Ok(from.as_any_box().downcast::<VsanFault>()?),
            StructType::CannotChangeVsanClusterUuid => Ok(from.as_any_box().downcast::<CannotChangeVsanClusterUuid>()?),
            StructType::CannotChangeVsanNodeUuid => Ok(from.as_any_box().downcast::<CannotChangeVsanNodeUuid>()?),
            StructType::CannotMoveVsanEnabledHost => Ok(from.as_any_box().downcast::<CannotMoveVsanEnabledHost>()?),
            StructType::DestinationVsanDisabled => Ok(from.as_any_box().downcast::<DestinationVsanDisabled>()?),
            StructType::VsanClusterUuidMismatch => Ok(from.as_any_box().downcast::<VsanClusterUuidMismatch>()?),
            StructType::CannotReconfigureVsanWhenHaEnabled => Ok(from.as_any_box().downcast::<CannotReconfigureVsanWhenHaEnabled>()?),
            StructType::DuplicateVsanNetworkInterface => Ok(from.as_any_box().downcast::<DuplicateVsanNetworkInterface>()?),
            StructType::VsanDiskFault => Ok(from.as_any_box().downcast::<VsanDiskFault>()?),
            StructType::DiskHasPartitions => Ok(from.as_any_box().downcast::<DiskHasPartitions>()?),
            StructType::DiskIsLastRemainingNonSsd => Ok(from.as_any_box().downcast::<DiskIsLastRemainingNonSsd>()?),
            StructType::DiskIsNonLocal => Ok(from.as_any_box().downcast::<DiskIsNonLocal>()?),
            StructType::DiskIsUsb => Ok(from.as_any_box().downcast::<DiskIsUsb>()?),
            StructType::DiskTooSmall => Ok(from.as_any_box().downcast::<DiskTooSmall>()?),
            StructType::DuplicateDisks => Ok(from.as_any_box().downcast::<DuplicateDisks>()?),
            StructType::InsufficientDisks => Ok(from.as_any_box().downcast::<InsufficientDisks>()?),
            StructType::VsanIncompatibleDiskMapping => Ok(from.as_any_box().downcast::<VsanIncompatibleDiskMapping>()?),
            StructType::WipeDiskFault => Ok(from.as_any_box().downcast::<WipeDiskFault>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base fault for Active Directory related problems.
pub trait ActiveDirectoryFaultTrait : super::traits::VimFaultTrait {
    /// The error code reported by the Active Directory API.
    fn get_error_code(&self) -> Option<i32>;
}
impl<'s> serde::Serialize for dyn ActiveDirectoryFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ActiveDirectoryFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ActiveDirectoryFaultVisitor)
            }
        }

struct ActiveDirectoryFaultVisitor;

impl<'de> de::Visitor<'de> for ActiveDirectoryFaultVisitor {
    type Value = Box<dyn ActiveDirectoryFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ActiveDirectoryFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ActiveDirectoryFaultTrait for ActiveDirectoryFault {
    fn get_error_code(&self) -> Option<i32> { self.error_code }
}
impl ActiveDirectoryFaultTrait for DomainNotFound {
    fn get_error_code(&self) -> Option<i32> { self.error_code }
}
impl ActiveDirectoryFaultTrait for InvalidCamServer {
    fn get_error_code(&self) -> Option<i32> { self.error_code }
}
impl ActiveDirectoryFaultTrait for CamServerRefusedConnection {
    fn get_error_code(&self) -> Option<i32> { self.error_code }
}
impl ActiveDirectoryFaultTrait for InvalidCamCertificate {
    fn get_error_code(&self) -> Option<i32> { self.error_code }
}
impl ActiveDirectoryFaultTrait for NoPermissionOnAd {
    fn get_error_code(&self) -> Option<i32> { self.error_code }
}
impl ActiveDirectoryFaultTrait for NonAdUserRequired {
    fn get_error_code(&self) -> Option<i32> { self.error_code }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ActiveDirectoryFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ActiveDirectoryFault => Some(from.as_any_ref().downcast_ref::<ActiveDirectoryFault>()?),
            StructType::DomainNotFound => Some(from.as_any_ref().downcast_ref::<DomainNotFound>()?),
            StructType::InvalidCamServer => Some(from.as_any_ref().downcast_ref::<InvalidCamServer>()?),
            StructType::CamServerRefusedConnection => Some(from.as_any_ref().downcast_ref::<CamServerRefusedConnection>()?),
            StructType::InvalidCamCertificate => Some(from.as_any_ref().downcast_ref::<InvalidCamCertificate>()?),
            StructType::NoPermissionOnAd => Some(from.as_any_ref().downcast_ref::<NoPermissionOnAd>()?),
            StructType::NonAdUserRequired => Some(from.as_any_ref().downcast_ref::<NonAdUserRequired>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ActiveDirectoryFault => Ok(from.as_any_box().downcast::<ActiveDirectoryFault>()?),
            StructType::DomainNotFound => Ok(from.as_any_box().downcast::<DomainNotFound>()?),
            StructType::InvalidCamServer => Ok(from.as_any_box().downcast::<InvalidCamServer>()?),
            StructType::CamServerRefusedConnection => Ok(from.as_any_box().downcast::<CamServerRefusedConnection>()?),
            StructType::InvalidCamCertificate => Ok(from.as_any_box().downcast::<InvalidCamCertificate>()?),
            StructType::NoPermissionOnAd => Ok(from.as_any_box().downcast::<NoPermissionOnAd>()?),
            StructType::NonAdUserRequired => Ok(from.as_any_box().downcast::<NonAdUserRequired>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Fault indicating that the CAM server
/// for camServer cannot be reached,
/// or is not a valid IP address.
pub trait InvalidCamServerTrait : super::traits::ActiveDirectoryFaultTrait {
    /// The address of the CAM server.
    fn get_cam_server(&self) -> &str;
}
impl<'s> serde::Serialize for dyn InvalidCamServerTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn InvalidCamServerTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(InvalidCamServerVisitor)
            }
        }

struct InvalidCamServerVisitor;

impl<'de> de::Visitor<'de> for InvalidCamServerVisitor {
    type Value = Box<dyn InvalidCamServerTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid InvalidCamServerTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl InvalidCamServerTrait for InvalidCamServer {
    fn get_cam_server(&self) -> &str { &self.cam_server }
}
impl InvalidCamServerTrait for CamServerRefusedConnection {
    fn get_cam_server(&self) -> &str { &self.cam_server }
}
impl InvalidCamServerTrait for InvalidCamCertificate {
    fn get_cam_server(&self) -> &str { &self.cam_server }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn InvalidCamServerTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::InvalidCamServer => Some(from.as_any_ref().downcast_ref::<InvalidCamServer>()?),
            StructType::CamServerRefusedConnection => Some(from.as_any_ref().downcast_ref::<CamServerRefusedConnection>()?),
            StructType::InvalidCamCertificate => Some(from.as_any_ref().downcast_ref::<InvalidCamCertificate>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::InvalidCamServer => Ok(from.as_any_box().downcast::<InvalidCamServer>()?),
            StructType::CamServerRefusedConnection => Ok(from.as_any_box().downcast::<CamServerRefusedConnection>()?),
            StructType::InvalidCamCertificate => Ok(from.as_any_box().downcast::<InvalidCamCertificate>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base for exceptions that can be thrown from the customizer.
pub trait CustomizationFaultTrait : super::traits::VimFaultTrait {
}
impl<'s> serde::Serialize for dyn CustomizationFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn CustomizationFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(CustomizationFaultVisitor)
            }
        }

struct CustomizationFaultVisitor;

impl<'de> de::Visitor<'de> for CustomizationFaultVisitor {
    type Value = Box<dyn CustomizationFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid CustomizationFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl CustomizationFaultTrait for CustomizationFault {
}
impl CustomizationFaultTrait for CannotDecryptPasswords {
}
impl CustomizationFaultTrait for CustomizationPending {
}
impl CustomizationFaultTrait for IpHostnameGeneratorError {
}
impl CustomizationFaultTrait for LinuxVolumeNotClean {
}
impl CustomizationFaultTrait for MissingLinuxCustResources {
}
impl CustomizationFaultTrait for MissingWindowsCustResources {
}
impl CustomizationFaultTrait for MountError {
}
impl CustomizationFaultTrait for NicSettingMismatch {
}
impl CustomizationFaultTrait for NoDisksToCustomize {
}
impl CustomizationFaultTrait for UncustomizableGuest {
}
impl CustomizationFaultTrait for UnexpectedCustomizationFault {
}
impl CustomizationFaultTrait for VolumeEditorError {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn CustomizationFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::CustomizationFault => Some(from.as_any_ref().downcast_ref::<CustomizationFault>()?),
            StructType::CannotDecryptPasswords => Some(from.as_any_ref().downcast_ref::<CannotDecryptPasswords>()?),
            StructType::CustomizationPending => Some(from.as_any_ref().downcast_ref::<CustomizationPending>()?),
            StructType::IpHostnameGeneratorError => Some(from.as_any_ref().downcast_ref::<IpHostnameGeneratorError>()?),
            StructType::LinuxVolumeNotClean => Some(from.as_any_ref().downcast_ref::<LinuxVolumeNotClean>()?),
            StructType::MissingLinuxCustResources => Some(from.as_any_ref().downcast_ref::<MissingLinuxCustResources>()?),
            StructType::MissingWindowsCustResources => Some(from.as_any_ref().downcast_ref::<MissingWindowsCustResources>()?),
            StructType::MountError => Some(from.as_any_ref().downcast_ref::<MountError>()?),
            StructType::NicSettingMismatch => Some(from.as_any_ref().downcast_ref::<NicSettingMismatch>()?),
            StructType::NoDisksToCustomize => Some(from.as_any_ref().downcast_ref::<NoDisksToCustomize>()?),
            StructType::UncustomizableGuest => Some(from.as_any_ref().downcast_ref::<UncustomizableGuest>()?),
            StructType::UnexpectedCustomizationFault => Some(from.as_any_ref().downcast_ref::<UnexpectedCustomizationFault>()?),
            StructType::VolumeEditorError => Some(from.as_any_ref().downcast_ref::<VolumeEditorError>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::CustomizationFault => Ok(from.as_any_box().downcast::<CustomizationFault>()?),
            StructType::CannotDecryptPasswords => Ok(from.as_any_box().downcast::<CannotDecryptPasswords>()?),
            StructType::CustomizationPending => Ok(from.as_any_box().downcast::<CustomizationPending>()?),
            StructType::IpHostnameGeneratorError => Ok(from.as_any_box().downcast::<IpHostnameGeneratorError>()?),
            StructType::LinuxVolumeNotClean => Ok(from.as_any_box().downcast::<LinuxVolumeNotClean>()?),
            StructType::MissingLinuxCustResources => Ok(from.as_any_box().downcast::<MissingLinuxCustResources>()?),
            StructType::MissingWindowsCustResources => Ok(from.as_any_box().downcast::<MissingWindowsCustResources>()?),
            StructType::MountError => Ok(from.as_any_box().downcast::<MountError>()?),
            StructType::NicSettingMismatch => Ok(from.as_any_box().downcast::<NicSettingMismatch>()?),
            StructType::NoDisksToCustomize => Ok(from.as_any_box().downcast::<NoDisksToCustomize>()?),
            StructType::UncustomizableGuest => Ok(from.as_any_box().downcast::<UncustomizableGuest>()?),
            StructType::UnexpectedCustomizationFault => Ok(from.as_any_box().downcast::<UnexpectedCustomizationFault>()?),
            StructType::VolumeEditorError => Ok(from.as_any_box().downcast::<VolumeEditorError>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class for faults that can be thrown while invoking a distributed virtual switch
/// operation.
pub trait DvsFaultTrait : super::traits::VimFaultTrait {
}
impl<'s> serde::Serialize for dyn DvsFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DvsFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DvsFaultVisitor)
            }
        }

struct DvsFaultVisitor;

impl<'de> de::Visitor<'de> for DvsFaultVisitor {
    type Value = Box<dyn DvsFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DvsFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DvsFaultTrait for DvsFault {
}
impl DvsFaultTrait for BackupBlobReadFailure {
}
impl DvsFaultTrait for BackupBlobWriteFailure {
}
impl DvsFaultTrait for CollectorAddressUnset {
}
impl DvsFaultTrait for ConflictingConfiguration {
}
impl DvsFaultTrait for DvsApplyOperationFault {
}
impl DvsFaultTrait for DvsNotAuthorized {
}
impl DvsFaultTrait for DvsOperationBulkFault {
}
impl DvsFaultTrait for DvsScopeViolated {
}
impl DvsFaultTrait for ImportHostAddFailure {
}
impl DvsFaultTrait for ImportOperationBulkFault {
}
impl DvsFaultTrait for InvalidIpfixConfig {
}
impl DvsFaultTrait for RollbackFailure {
}
impl DvsFaultTrait for SwitchIpUnset {
}
impl DvsFaultTrait for SwitchNotInUpgradeMode {
}
impl DvsFaultTrait for VspanDestPortConflict {
}
impl DvsFaultTrait for VspanPortConflict {
}
impl DvsFaultTrait for VspanPortMoveFault {
}
impl DvsFaultTrait for VspanPortPromiscChangeFault {
}
impl DvsFaultTrait for VspanPortgroupPromiscChangeFault {
}
impl DvsFaultTrait for VspanPortgroupTypeChangeFault {
}
impl DvsFaultTrait for VspanPromiscuousPortNotSupported {
}
impl DvsFaultTrait for VspanSameSessionPortConflict {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DvsFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsFault => Some(from.as_any_ref().downcast_ref::<DvsFault>()?),
            StructType::BackupBlobReadFailure => Some(from.as_any_ref().downcast_ref::<BackupBlobReadFailure>()?),
            StructType::BackupBlobWriteFailure => Some(from.as_any_ref().downcast_ref::<BackupBlobWriteFailure>()?),
            StructType::CollectorAddressUnset => Some(from.as_any_ref().downcast_ref::<CollectorAddressUnset>()?),
            StructType::ConflictingConfiguration => Some(from.as_any_ref().downcast_ref::<ConflictingConfiguration>()?),
            StructType::DvsApplyOperationFault => Some(from.as_any_ref().downcast_ref::<DvsApplyOperationFault>()?),
            StructType::DvsNotAuthorized => Some(from.as_any_ref().downcast_ref::<DvsNotAuthorized>()?),
            StructType::DvsOperationBulkFault => Some(from.as_any_ref().downcast_ref::<DvsOperationBulkFault>()?),
            StructType::DvsScopeViolated => Some(from.as_any_ref().downcast_ref::<DvsScopeViolated>()?),
            StructType::ImportHostAddFailure => Some(from.as_any_ref().downcast_ref::<ImportHostAddFailure>()?),
            StructType::ImportOperationBulkFault => Some(from.as_any_ref().downcast_ref::<ImportOperationBulkFault>()?),
            StructType::InvalidIpfixConfig => Some(from.as_any_ref().downcast_ref::<InvalidIpfixConfig>()?),
            StructType::RollbackFailure => Some(from.as_any_ref().downcast_ref::<RollbackFailure>()?),
            StructType::SwitchIpUnset => Some(from.as_any_ref().downcast_ref::<SwitchIpUnset>()?),
            StructType::SwitchNotInUpgradeMode => Some(from.as_any_ref().downcast_ref::<SwitchNotInUpgradeMode>()?),
            StructType::VspanDestPortConflict => Some(from.as_any_ref().downcast_ref::<VspanDestPortConflict>()?),
            StructType::VspanPortConflict => Some(from.as_any_ref().downcast_ref::<VspanPortConflict>()?),
            StructType::VspanPortMoveFault => Some(from.as_any_ref().downcast_ref::<VspanPortMoveFault>()?),
            StructType::VspanPortPromiscChangeFault => Some(from.as_any_ref().downcast_ref::<VspanPortPromiscChangeFault>()?),
            StructType::VspanPortgroupPromiscChangeFault => Some(from.as_any_ref().downcast_ref::<VspanPortgroupPromiscChangeFault>()?),
            StructType::VspanPortgroupTypeChangeFault => Some(from.as_any_ref().downcast_ref::<VspanPortgroupTypeChangeFault>()?),
            StructType::VspanPromiscuousPortNotSupported => Some(from.as_any_ref().downcast_ref::<VspanPromiscuousPortNotSupported>()?),
            StructType::VspanSameSessionPortConflict => Some(from.as_any_ref().downcast_ref::<VspanSameSessionPortConflict>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DvsFault => Ok(from.as_any_box().downcast::<DvsFault>()?),
            StructType::BackupBlobReadFailure => Ok(from.as_any_box().downcast::<BackupBlobReadFailure>()?),
            StructType::BackupBlobWriteFailure => Ok(from.as_any_box().downcast::<BackupBlobWriteFailure>()?),
            StructType::CollectorAddressUnset => Ok(from.as_any_box().downcast::<CollectorAddressUnset>()?),
            StructType::ConflictingConfiguration => Ok(from.as_any_box().downcast::<ConflictingConfiguration>()?),
            StructType::DvsApplyOperationFault => Ok(from.as_any_box().downcast::<DvsApplyOperationFault>()?),
            StructType::DvsNotAuthorized => Ok(from.as_any_box().downcast::<DvsNotAuthorized>()?),
            StructType::DvsOperationBulkFault => Ok(from.as_any_box().downcast::<DvsOperationBulkFault>()?),
            StructType::DvsScopeViolated => Ok(from.as_any_box().downcast::<DvsScopeViolated>()?),
            StructType::ImportHostAddFailure => Ok(from.as_any_box().downcast::<ImportHostAddFailure>()?),
            StructType::ImportOperationBulkFault => Ok(from.as_any_box().downcast::<ImportOperationBulkFault>()?),
            StructType::InvalidIpfixConfig => Ok(from.as_any_box().downcast::<InvalidIpfixConfig>()?),
            StructType::RollbackFailure => Ok(from.as_any_box().downcast::<RollbackFailure>()?),
            StructType::SwitchIpUnset => Ok(from.as_any_box().downcast::<SwitchIpUnset>()?),
            StructType::SwitchNotInUpgradeMode => Ok(from.as_any_box().downcast::<SwitchNotInUpgradeMode>()?),
            StructType::VspanDestPortConflict => Ok(from.as_any_box().downcast::<VspanDestPortConflict>()?),
            StructType::VspanPortConflict => Ok(from.as_any_box().downcast::<VspanPortConflict>()?),
            StructType::VspanPortMoveFault => Ok(from.as_any_box().downcast::<VspanPortMoveFault>()?),
            StructType::VspanPortPromiscChangeFault => Ok(from.as_any_box().downcast::<VspanPortPromiscChangeFault>()?),
            StructType::VspanPortgroupPromiscChangeFault => Ok(from.as_any_box().downcast::<VspanPortgroupPromiscChangeFault>()?),
            StructType::VspanPortgroupTypeChangeFault => Ok(from.as_any_box().downcast::<VspanPortgroupTypeChangeFault>()?),
            StructType::VspanPromiscuousPortNotSupported => Ok(from.as_any_box().downcast::<VspanPromiscuousPortNotSupported>()?),
            StructType::VspanSameSessionPortConflict => Ok(from.as_any_box().downcast::<VspanSameSessionPortConflict>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// An attempt to enable Enhanced VMotion Compatibility on a cluster has failed.
pub trait EvcConfigFaultTrait : super::traits::VimFaultTrait {
    /// The faults that caused this EVC test to fail,
    /// such as *FeatureRequirementsNotMet* faults.
    fn get_faults(&self) -> &Option<Vec<Box<dyn super::traits::MethodFaultTrait>>>;
}
impl<'s> serde::Serialize for dyn EvcConfigFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn EvcConfigFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(EvcConfigFaultVisitor)
            }
        }

struct EvcConfigFaultVisitor;

impl<'de> de::Visitor<'de> for EvcConfigFaultVisitor {
    type Value = Box<dyn EvcConfigFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid EvcConfigFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl EvcConfigFaultTrait for EvcConfigFault {
    fn get_faults(&self) -> &Option<Vec<Box<dyn super::traits::MethodFaultTrait>>> { &self.faults }
}
impl EvcConfigFaultTrait for ActiveVMsBlockingEvc {
    fn get_faults(&self) -> &Option<Vec<Box<dyn super::traits::MethodFaultTrait>>> { &self.faults }
}
impl EvcConfigFaultTrait for DisconnectedHostsBlockingEvc {
    fn get_faults(&self) -> &Option<Vec<Box<dyn super::traits::MethodFaultTrait>>> { &self.faults }
}
impl EvcConfigFaultTrait for EvcModeIllegalByVendor {
    fn get_faults(&self) -> &Option<Vec<Box<dyn super::traits::MethodFaultTrait>>> { &self.faults }
}
impl EvcConfigFaultTrait for EvcModeUnsupportedByHosts {
    fn get_faults(&self) -> &Option<Vec<Box<dyn super::traits::MethodFaultTrait>>> { &self.faults }
}
impl EvcConfigFaultTrait for EvcUnsupportedByHostHardware {
    fn get_faults(&self) -> &Option<Vec<Box<dyn super::traits::MethodFaultTrait>>> { &self.faults }
}
impl EvcConfigFaultTrait for EvcUnsupportedByHostSoftware {
    fn get_faults(&self) -> &Option<Vec<Box<dyn super::traits::MethodFaultTrait>>> { &self.faults }
}
impl EvcConfigFaultTrait for HeterogenousHostsBlockingEvc {
    fn get_faults(&self) -> &Option<Vec<Box<dyn super::traits::MethodFaultTrait>>> { &self.faults }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn EvcConfigFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::EvcConfigFault => Some(from.as_any_ref().downcast_ref::<EvcConfigFault>()?),
            StructType::ActiveVMsBlockingEvc => Some(from.as_any_ref().downcast_ref::<ActiveVMsBlockingEvc>()?),
            StructType::DisconnectedHostsBlockingEvc => Some(from.as_any_ref().downcast_ref::<DisconnectedHostsBlockingEvc>()?),
            StructType::EvcModeIllegalByVendor => Some(from.as_any_ref().downcast_ref::<EvcModeIllegalByVendor>()?),
            StructType::EvcModeUnsupportedByHosts => Some(from.as_any_ref().downcast_ref::<EvcModeUnsupportedByHosts>()?),
            StructType::EvcUnsupportedByHostHardware => Some(from.as_any_ref().downcast_ref::<EvcUnsupportedByHostHardware>()?),
            StructType::EvcUnsupportedByHostSoftware => Some(from.as_any_ref().downcast_ref::<EvcUnsupportedByHostSoftware>()?),
            StructType::HeterogenousHostsBlockingEvc => Some(from.as_any_ref().downcast_ref::<HeterogenousHostsBlockingEvc>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::EvcConfigFault => Ok(from.as_any_box().downcast::<EvcConfigFault>()?),
            StructType::ActiveVMsBlockingEvc => Ok(from.as_any_box().downcast::<ActiveVMsBlockingEvc>()?),
            StructType::DisconnectedHostsBlockingEvc => Ok(from.as_any_box().downcast::<DisconnectedHostsBlockingEvc>()?),
            StructType::EvcModeIllegalByVendor => Ok(from.as_any_box().downcast::<EvcModeIllegalByVendor>()?),
            StructType::EvcModeUnsupportedByHosts => Ok(from.as_any_box().downcast::<EvcModeUnsupportedByHosts>()?),
            StructType::EvcUnsupportedByHostHardware => Ok(from.as_any_box().downcast::<EvcUnsupportedByHostHardware>()?),
            StructType::EvcUnsupportedByHostSoftware => Ok(from.as_any_box().downcast::<EvcUnsupportedByHostSoftware>()?),
            StructType::HeterogenousHostsBlockingEvc => Ok(from.as_any_box().downcast::<HeterogenousHostsBlockingEvc>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Deprecated as of vSphere API 8.0. Software FCoE not supported.
/// 
/// Base class for faults that can be thrown while invoking FCoE management operations.
pub trait FcoeFaultTrait : super::traits::VimFaultTrait {
}
impl<'s> serde::Serialize for dyn FcoeFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn FcoeFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(FcoeFaultVisitor)
            }
        }

struct FcoeFaultVisitor;

impl<'de> de::Visitor<'de> for FcoeFaultVisitor {
    type Value = Box<dyn FcoeFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid FcoeFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl FcoeFaultTrait for FcoeFault {
}
impl FcoeFaultTrait for FcoeFaultPnicHasNoPortSet {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn FcoeFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::FcoeFault => Some(from.as_any_ref().downcast_ref::<FcoeFault>()?),
            StructType::FcoeFaultPnicHasNoPortSet => Some(from.as_any_ref().downcast_ref::<FcoeFaultPnicHasNoPortSet>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::FcoeFault => Ok(from.as_any_box().downcast::<FcoeFault>()?),
            StructType::FcoeFaultPnicHasNoPortSet => Ok(from.as_any_box().downcast::<FcoeFaultPnicHasNoPortSet>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The common base type for all file-related exceptions.
pub trait FileFaultTrait : super::traits::VimFaultTrait {
    /// The file in question.
    fn get_file(&self) -> &str;
}
impl<'s> serde::Serialize for dyn FileFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn FileFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(FileFaultVisitor)
            }
        }

struct FileFaultVisitor;

impl<'de> de::Visitor<'de> for FileFaultVisitor {
    type Value = Box<dyn FileFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid FileFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl FileFaultTrait for FileFault {
    fn get_file(&self) -> &str { &self.file }
}
impl FileFaultTrait for CannotAccessFile {
    fn get_file(&self) -> &str { &self.file }
}
impl FileFaultTrait for CannotCreateFile {
    fn get_file(&self) -> &str { &self.file }
}
impl FileFaultTrait for CannotDeleteFile {
    fn get_file(&self) -> &str { &self.file }
}
impl FileFaultTrait for DirectoryNotEmpty {
    fn get_file(&self) -> &str { &self.file }
}
impl FileFaultTrait for FileAlreadyExists {
    fn get_file(&self) -> &str { &self.file }
}
impl FileFaultTrait for FileLocked {
    fn get_file(&self) -> &str { &self.file }
}
impl FileFaultTrait for FileNameTooLong {
    fn get_file(&self) -> &str { &self.file }
}
impl FileFaultTrait for FileNotFound {
    fn get_file(&self) -> &str { &self.file }
}
impl FileFaultTrait for FileNotWritable {
    fn get_file(&self) -> &str { &self.file }
}
impl FileFaultTrait for FileTooLarge {
    fn get_file(&self) -> &str { &self.file }
}
impl FileFaultTrait for IncorrectFileType {
    fn get_file(&self) -> &str { &self.file }
}
impl FileFaultTrait for NetworkCopyFault {
    fn get_file(&self) -> &str { &self.file }
}
impl FileFaultTrait for NoDiskSpace {
    fn get_file(&self) -> &str { &self.file }
}
impl FileFaultTrait for NotADirectory {
    fn get_file(&self) -> &str { &self.file }
}
impl FileFaultTrait for NotAFile {
    fn get_file(&self) -> &str { &self.file }
}
impl FileFaultTrait for TooManyConcurrentNativeClones {
    fn get_file(&self) -> &str { &self.file }
}
impl FileFaultTrait for TooManyNativeCloneLevels {
    fn get_file(&self) -> &str { &self.file }
}
impl FileFaultTrait for TooManyNativeClonesOnFile {
    fn get_file(&self) -> &str { &self.file }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn FileFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::FileFault => Some(from.as_any_ref().downcast_ref::<FileFault>()?),
            StructType::CannotAccessFile => Some(from.as_any_ref().downcast_ref::<CannotAccessFile>()?),
            StructType::CannotCreateFile => Some(from.as_any_ref().downcast_ref::<CannotCreateFile>()?),
            StructType::CannotDeleteFile => Some(from.as_any_ref().downcast_ref::<CannotDeleteFile>()?),
            StructType::DirectoryNotEmpty => Some(from.as_any_ref().downcast_ref::<DirectoryNotEmpty>()?),
            StructType::FileAlreadyExists => Some(from.as_any_ref().downcast_ref::<FileAlreadyExists>()?),
            StructType::FileLocked => Some(from.as_any_ref().downcast_ref::<FileLocked>()?),
            StructType::FileNameTooLong => Some(from.as_any_ref().downcast_ref::<FileNameTooLong>()?),
            StructType::FileNotFound => Some(from.as_any_ref().downcast_ref::<FileNotFound>()?),
            StructType::FileNotWritable => Some(from.as_any_ref().downcast_ref::<FileNotWritable>()?),
            StructType::FileTooLarge => Some(from.as_any_ref().downcast_ref::<FileTooLarge>()?),
            StructType::IncorrectFileType => Some(from.as_any_ref().downcast_ref::<IncorrectFileType>()?),
            StructType::NetworkCopyFault => Some(from.as_any_ref().downcast_ref::<NetworkCopyFault>()?),
            StructType::NoDiskSpace => Some(from.as_any_ref().downcast_ref::<NoDiskSpace>()?),
            StructType::NotADirectory => Some(from.as_any_ref().downcast_ref::<NotADirectory>()?),
            StructType::NotAFile => Some(from.as_any_ref().downcast_ref::<NotAFile>()?),
            StructType::TooManyConcurrentNativeClones => Some(from.as_any_ref().downcast_ref::<TooManyConcurrentNativeClones>()?),
            StructType::TooManyNativeCloneLevels => Some(from.as_any_ref().downcast_ref::<TooManyNativeCloneLevels>()?),
            StructType::TooManyNativeClonesOnFile => Some(from.as_any_ref().downcast_ref::<TooManyNativeClonesOnFile>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::FileFault => Ok(from.as_any_box().downcast::<FileFault>()?),
            StructType::CannotAccessFile => Ok(from.as_any_box().downcast::<CannotAccessFile>()?),
            StructType::CannotCreateFile => Ok(from.as_any_box().downcast::<CannotCreateFile>()?),
            StructType::CannotDeleteFile => Ok(from.as_any_box().downcast::<CannotDeleteFile>()?),
            StructType::DirectoryNotEmpty => Ok(from.as_any_box().downcast::<DirectoryNotEmpty>()?),
            StructType::FileAlreadyExists => Ok(from.as_any_box().downcast::<FileAlreadyExists>()?),
            StructType::FileLocked => Ok(from.as_any_box().downcast::<FileLocked>()?),
            StructType::FileNameTooLong => Ok(from.as_any_box().downcast::<FileNameTooLong>()?),
            StructType::FileNotFound => Ok(from.as_any_box().downcast::<FileNotFound>()?),
            StructType::FileNotWritable => Ok(from.as_any_box().downcast::<FileNotWritable>()?),
            StructType::FileTooLarge => Ok(from.as_any_box().downcast::<FileTooLarge>()?),
            StructType::IncorrectFileType => Ok(from.as_any_box().downcast::<IncorrectFileType>()?),
            StructType::NetworkCopyFault => Ok(from.as_any_box().downcast::<NetworkCopyFault>()?),
            StructType::NoDiskSpace => Ok(from.as_any_box().downcast::<NoDiskSpace>()?),
            StructType::NotADirectory => Ok(from.as_any_box().downcast::<NotADirectory>()?),
            StructType::NotAFile => Ok(from.as_any_box().downcast::<NotAFile>()?),
            StructType::TooManyConcurrentNativeClones => Ok(from.as_any_box().downcast::<TooManyConcurrentNativeClones>()?),
            StructType::TooManyNativeCloneLevels => Ok(from.as_any_box().downcast::<TooManyNativeCloneLevels>()?),
            StructType::TooManyNativeClonesOnFile => Ok(from.as_any_box().downcast::<TooManyNativeClonesOnFile>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The common base type for all guest operations faults.
pub trait GuestOperationsFaultTrait : super::traits::VimFaultTrait {
}
impl<'s> serde::Serialize for dyn GuestOperationsFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn GuestOperationsFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(GuestOperationsFaultVisitor)
            }
        }

struct GuestOperationsFaultVisitor;

impl<'de> de::Visitor<'de> for GuestOperationsFaultVisitor {
    type Value = Box<dyn GuestOperationsFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid GuestOperationsFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl GuestOperationsFaultTrait for GuestOperationsFault {
}
impl GuestOperationsFaultTrait for GuestAuthenticationChallenge {
}
impl GuestOperationsFaultTrait for GuestComponentsOutOfDate {
}
impl GuestOperationsFaultTrait for GuestMultipleMappings {
}
impl GuestOperationsFaultTrait for GuestOperationsUnavailable {
}
impl GuestOperationsFaultTrait for GuestPermissionDenied {
}
impl GuestOperationsFaultTrait for GuestProcessNotFound {
}
impl GuestOperationsFaultTrait for GuestRegistryFault {
}
impl GuestOperationsFaultTrait for GuestRegistryKeyFault {
}
impl GuestOperationsFaultTrait for GuestRegistryKeyAlreadyExists {
}
impl GuestOperationsFaultTrait for GuestRegistryKeyHasSubkeys {
}
impl GuestOperationsFaultTrait for GuestRegistryKeyInvalid {
}
impl GuestOperationsFaultTrait for GuestRegistryKeyParentVolatile {
}
impl GuestOperationsFaultTrait for GuestRegistryValueFault {
}
impl GuestOperationsFaultTrait for GuestRegistryValueNotFound {
}
impl GuestOperationsFaultTrait for InvalidGuestLogin {
}
impl GuestOperationsFaultTrait for OperationDisabledByGuest {
}
impl GuestOperationsFaultTrait for OperationNotSupportedByGuest {
}
impl GuestOperationsFaultTrait for TooManyGuestLogons {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn GuestOperationsFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::GuestOperationsFault => Some(from.as_any_ref().downcast_ref::<GuestOperationsFault>()?),
            StructType::GuestAuthenticationChallenge => Some(from.as_any_ref().downcast_ref::<GuestAuthenticationChallenge>()?),
            StructType::GuestComponentsOutOfDate => Some(from.as_any_ref().downcast_ref::<GuestComponentsOutOfDate>()?),
            StructType::GuestMultipleMappings => Some(from.as_any_ref().downcast_ref::<GuestMultipleMappings>()?),
            StructType::GuestOperationsUnavailable => Some(from.as_any_ref().downcast_ref::<GuestOperationsUnavailable>()?),
            StructType::GuestPermissionDenied => Some(from.as_any_ref().downcast_ref::<GuestPermissionDenied>()?),
            StructType::GuestProcessNotFound => Some(from.as_any_ref().downcast_ref::<GuestProcessNotFound>()?),
            StructType::GuestRegistryFault => Some(from.as_any_ref().downcast_ref::<GuestRegistryFault>()?),
            StructType::GuestRegistryKeyFault => Some(from.as_any_ref().downcast_ref::<GuestRegistryKeyFault>()?),
            StructType::GuestRegistryKeyAlreadyExists => Some(from.as_any_ref().downcast_ref::<GuestRegistryKeyAlreadyExists>()?),
            StructType::GuestRegistryKeyHasSubkeys => Some(from.as_any_ref().downcast_ref::<GuestRegistryKeyHasSubkeys>()?),
            StructType::GuestRegistryKeyInvalid => Some(from.as_any_ref().downcast_ref::<GuestRegistryKeyInvalid>()?),
            StructType::GuestRegistryKeyParentVolatile => Some(from.as_any_ref().downcast_ref::<GuestRegistryKeyParentVolatile>()?),
            StructType::GuestRegistryValueFault => Some(from.as_any_ref().downcast_ref::<GuestRegistryValueFault>()?),
            StructType::GuestRegistryValueNotFound => Some(from.as_any_ref().downcast_ref::<GuestRegistryValueNotFound>()?),
            StructType::InvalidGuestLogin => Some(from.as_any_ref().downcast_ref::<InvalidGuestLogin>()?),
            StructType::OperationDisabledByGuest => Some(from.as_any_ref().downcast_ref::<OperationDisabledByGuest>()?),
            StructType::OperationNotSupportedByGuest => Some(from.as_any_ref().downcast_ref::<OperationNotSupportedByGuest>()?),
            StructType::TooManyGuestLogons => Some(from.as_any_ref().downcast_ref::<TooManyGuestLogons>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::GuestOperationsFault => Ok(from.as_any_box().downcast::<GuestOperationsFault>()?),
            StructType::GuestAuthenticationChallenge => Ok(from.as_any_box().downcast::<GuestAuthenticationChallenge>()?),
            StructType::GuestComponentsOutOfDate => Ok(from.as_any_box().downcast::<GuestComponentsOutOfDate>()?),
            StructType::GuestMultipleMappings => Ok(from.as_any_box().downcast::<GuestMultipleMappings>()?),
            StructType::GuestOperationsUnavailable => Ok(from.as_any_box().downcast::<GuestOperationsUnavailable>()?),
            StructType::GuestPermissionDenied => Ok(from.as_any_box().downcast::<GuestPermissionDenied>()?),
            StructType::GuestProcessNotFound => Ok(from.as_any_box().downcast::<GuestProcessNotFound>()?),
            StructType::GuestRegistryFault => Ok(from.as_any_box().downcast::<GuestRegistryFault>()?),
            StructType::GuestRegistryKeyFault => Ok(from.as_any_box().downcast::<GuestRegistryKeyFault>()?),
            StructType::GuestRegistryKeyAlreadyExists => Ok(from.as_any_box().downcast::<GuestRegistryKeyAlreadyExists>()?),
            StructType::GuestRegistryKeyHasSubkeys => Ok(from.as_any_box().downcast::<GuestRegistryKeyHasSubkeys>()?),
            StructType::GuestRegistryKeyInvalid => Ok(from.as_any_box().downcast::<GuestRegistryKeyInvalid>()?),
            StructType::GuestRegistryKeyParentVolatile => Ok(from.as_any_box().downcast::<GuestRegistryKeyParentVolatile>()?),
            StructType::GuestRegistryValueFault => Ok(from.as_any_box().downcast::<GuestRegistryValueFault>()?),
            StructType::GuestRegistryValueNotFound => Ok(from.as_any_box().downcast::<GuestRegistryValueNotFound>()?),
            StructType::InvalidGuestLogin => Ok(from.as_any_box().downcast::<InvalidGuestLogin>()?),
            StructType::OperationDisabledByGuest => Ok(from.as_any_box().downcast::<OperationDisabledByGuest>()?),
            StructType::OperationNotSupportedByGuest => Ok(from.as_any_box().downcast::<OperationNotSupportedByGuest>()?),
            StructType::TooManyGuestLogons => Ok(from.as_any_box().downcast::<TooManyGuestLogons>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// A GuestRegistryFault exception is thrown when an operation fails
/// because of some errors in accessing/modifying the guest registry.
pub trait GuestRegistryFaultTrait : super::traits::GuestOperationsFaultTrait {
    /// The windows system error number from GetLastError().
    fn get_windows_system_error_code(&self) -> i64;
}
impl<'s> serde::Serialize for dyn GuestRegistryFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn GuestRegistryFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(GuestRegistryFaultVisitor)
            }
        }

struct GuestRegistryFaultVisitor;

impl<'de> de::Visitor<'de> for GuestRegistryFaultVisitor {
    type Value = Box<dyn GuestRegistryFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid GuestRegistryFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl GuestRegistryFaultTrait for GuestRegistryFault {
    fn get_windows_system_error_code(&self) -> i64 { self.windows_system_error_code }
}
impl GuestRegistryFaultTrait for GuestRegistryKeyFault {
    fn get_windows_system_error_code(&self) -> i64 { self.windows_system_error_code }
}
impl GuestRegistryFaultTrait for GuestRegistryKeyAlreadyExists {
    fn get_windows_system_error_code(&self) -> i64 { self.windows_system_error_code }
}
impl GuestRegistryFaultTrait for GuestRegistryKeyHasSubkeys {
    fn get_windows_system_error_code(&self) -> i64 { self.windows_system_error_code }
}
impl GuestRegistryFaultTrait for GuestRegistryKeyInvalid {
    fn get_windows_system_error_code(&self) -> i64 { self.windows_system_error_code }
}
impl GuestRegistryFaultTrait for GuestRegistryKeyParentVolatile {
    fn get_windows_system_error_code(&self) -> i64 { self.windows_system_error_code }
}
impl GuestRegistryFaultTrait for GuestRegistryValueFault {
    fn get_windows_system_error_code(&self) -> i64 { self.windows_system_error_code }
}
impl GuestRegistryFaultTrait for GuestRegistryValueNotFound {
    fn get_windows_system_error_code(&self) -> i64 { self.windows_system_error_code }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn GuestRegistryFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::GuestRegistryFault => Some(from.as_any_ref().downcast_ref::<GuestRegistryFault>()?),
            StructType::GuestRegistryKeyFault => Some(from.as_any_ref().downcast_ref::<GuestRegistryKeyFault>()?),
            StructType::GuestRegistryKeyAlreadyExists => Some(from.as_any_ref().downcast_ref::<GuestRegistryKeyAlreadyExists>()?),
            StructType::GuestRegistryKeyHasSubkeys => Some(from.as_any_ref().downcast_ref::<GuestRegistryKeyHasSubkeys>()?),
            StructType::GuestRegistryKeyInvalid => Some(from.as_any_ref().downcast_ref::<GuestRegistryKeyInvalid>()?),
            StructType::GuestRegistryKeyParentVolatile => Some(from.as_any_ref().downcast_ref::<GuestRegistryKeyParentVolatile>()?),
            StructType::GuestRegistryValueFault => Some(from.as_any_ref().downcast_ref::<GuestRegistryValueFault>()?),
            StructType::GuestRegistryValueNotFound => Some(from.as_any_ref().downcast_ref::<GuestRegistryValueNotFound>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::GuestRegistryFault => Ok(from.as_any_box().downcast::<GuestRegistryFault>()?),
            StructType::GuestRegistryKeyFault => Ok(from.as_any_box().downcast::<GuestRegistryKeyFault>()?),
            StructType::GuestRegistryKeyAlreadyExists => Ok(from.as_any_box().downcast::<GuestRegistryKeyAlreadyExists>()?),
            StructType::GuestRegistryKeyHasSubkeys => Ok(from.as_any_box().downcast::<GuestRegistryKeyHasSubkeys>()?),
            StructType::GuestRegistryKeyInvalid => Ok(from.as_any_box().downcast::<GuestRegistryKeyInvalid>()?),
            StructType::GuestRegistryKeyParentVolatile => Ok(from.as_any_box().downcast::<GuestRegistryKeyParentVolatile>()?),
            StructType::GuestRegistryValueFault => Ok(from.as_any_box().downcast::<GuestRegistryValueFault>()?),
            StructType::GuestRegistryValueNotFound => Ok(from.as_any_box().downcast::<GuestRegistryValueNotFound>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// A GuestRegistryKeyFault exception is thrown when an operation fails
/// because of some errors in accessing/modifying a guest registry key.
pub trait GuestRegistryKeyFaultTrait : super::traits::GuestRegistryFaultTrait {
    /// The full path to the windows registry key.
    fn get_key_name(&self) -> &str;
}
impl<'s> serde::Serialize for dyn GuestRegistryKeyFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn GuestRegistryKeyFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(GuestRegistryKeyFaultVisitor)
            }
        }

struct GuestRegistryKeyFaultVisitor;

impl<'de> de::Visitor<'de> for GuestRegistryKeyFaultVisitor {
    type Value = Box<dyn GuestRegistryKeyFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid GuestRegistryKeyFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl GuestRegistryKeyFaultTrait for GuestRegistryKeyFault {
    fn get_key_name(&self) -> &str { &self.key_name }
}
impl GuestRegistryKeyFaultTrait for GuestRegistryKeyAlreadyExists {
    fn get_key_name(&self) -> &str { &self.key_name }
}
impl GuestRegistryKeyFaultTrait for GuestRegistryKeyHasSubkeys {
    fn get_key_name(&self) -> &str { &self.key_name }
}
impl GuestRegistryKeyFaultTrait for GuestRegistryKeyInvalid {
    fn get_key_name(&self) -> &str { &self.key_name }
}
impl GuestRegistryKeyFaultTrait for GuestRegistryKeyParentVolatile {
    fn get_key_name(&self) -> &str { &self.key_name }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn GuestRegistryKeyFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::GuestRegistryKeyFault => Some(from.as_any_ref().downcast_ref::<GuestRegistryKeyFault>()?),
            StructType::GuestRegistryKeyAlreadyExists => Some(from.as_any_ref().downcast_ref::<GuestRegistryKeyAlreadyExists>()?),
            StructType::GuestRegistryKeyHasSubkeys => Some(from.as_any_ref().downcast_ref::<GuestRegistryKeyHasSubkeys>()?),
            StructType::GuestRegistryKeyInvalid => Some(from.as_any_ref().downcast_ref::<GuestRegistryKeyInvalid>()?),
            StructType::GuestRegistryKeyParentVolatile => Some(from.as_any_ref().downcast_ref::<GuestRegistryKeyParentVolatile>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::GuestRegistryKeyFault => Ok(from.as_any_box().downcast::<GuestRegistryKeyFault>()?),
            StructType::GuestRegistryKeyAlreadyExists => Ok(from.as_any_box().downcast::<GuestRegistryKeyAlreadyExists>()?),
            StructType::GuestRegistryKeyHasSubkeys => Ok(from.as_any_box().downcast::<GuestRegistryKeyHasSubkeys>()?),
            StructType::GuestRegistryKeyInvalid => Ok(from.as_any_box().downcast::<GuestRegistryKeyInvalid>()?),
            StructType::GuestRegistryKeyParentVolatile => Ok(from.as_any_box().downcast::<GuestRegistryKeyParentVolatile>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// A GuestRegistryValueFault exception is thrown when an operation fails
/// because of some errors in accessing/modifying a guest registry value.
pub trait GuestRegistryValueFaultTrait : super::traits::GuestRegistryFaultTrait {
    /// The full path to the windows registry key containing the value.
    fn get_key_name(&self) -> &str;
    /// The name of the value.
    fn get_value_name(&self) -> &str;
}
impl<'s> serde::Serialize for dyn GuestRegistryValueFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn GuestRegistryValueFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(GuestRegistryValueFaultVisitor)
            }
        }

struct GuestRegistryValueFaultVisitor;

impl<'de> de::Visitor<'de> for GuestRegistryValueFaultVisitor {
    type Value = Box<dyn GuestRegistryValueFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid GuestRegistryValueFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl GuestRegistryValueFaultTrait for GuestRegistryValueFault {
    fn get_key_name(&self) -> &str { &self.key_name }
    fn get_value_name(&self) -> &str { &self.value_name }
}
impl GuestRegistryValueFaultTrait for GuestRegistryValueNotFound {
    fn get_key_name(&self) -> &str { &self.key_name }
    fn get_value_name(&self) -> &str { &self.value_name }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn GuestRegistryValueFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::GuestRegistryValueFault => Some(from.as_any_ref().downcast_ref::<GuestRegistryValueFault>()?),
            StructType::GuestRegistryValueNotFound => Some(from.as_any_ref().downcast_ref::<GuestRegistryValueNotFound>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::GuestRegistryValueFault => Ok(from.as_any_box().downcast::<GuestRegistryValueFault>()?),
            StructType::GuestRegistryValueNotFound => Ok(from.as_any_box().downcast::<GuestRegistryValueNotFound>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class for all Host configuration related faults
pub trait HostConfigFaultTrait : super::traits::VimFaultTrait {
}
impl<'s> serde::Serialize for dyn HostConfigFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostConfigFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostConfigFaultVisitor)
            }
        }

struct HostConfigFaultVisitor;

impl<'de> de::Visitor<'de> for HostConfigFaultVisitor {
    type Value = Box<dyn HostConfigFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostConfigFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostConfigFaultTrait for HostConfigFault {
}
impl HostConfigFaultTrait for AdminDisabled {
}
impl HostConfigFaultTrait for AdminNotDisabled {
}
impl HostConfigFaultTrait for BlockedByFirewall {
}
impl HostConfigFaultTrait for ClockSkew {
}
impl HostConfigFaultTrait for DisableAdminNotSupported {
}
impl HostConfigFaultTrait for HostConfigFailed {
}
impl HostConfigFaultTrait for HostInDomain {
}
impl HostConfigFaultTrait for InvalidHostName {
}
impl HostConfigFaultTrait for NasConfigFault {
}
impl HostConfigFaultTrait for InvalidNasCredentials {
}
impl HostConfigFaultTrait for InvalidNetworkResource {
}
impl HostConfigFaultTrait for NasConnectionLimitReached {
}
impl HostConfigFaultTrait for NasSessionCredentialConflict {
}
impl HostConfigFaultTrait for NasVolumeNotMounted {
}
impl HostConfigFaultTrait for NetworkInaccessible {
}
impl HostConfigFaultTrait for NoPermissionOnNasVolume {
}
impl HostConfigFaultTrait for NoGateway {
}
impl HostConfigFaultTrait for NoVirtualNic {
}
impl HostConfigFaultTrait for PlatformConfigFault {
}
impl HostConfigFaultTrait for InvalidBundle {
}
impl HostConfigFaultTrait for PatchInstallFailed {
}
impl HostConfigFaultTrait for PatchIntegrityError {
}
impl HostConfigFaultTrait for VmfsMountFault {
}
impl HostConfigFaultTrait for VmfsAlreadyMounted {
}
impl HostConfigFaultTrait for VmfsAmbiguousMount {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostConfigFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostConfigFault => Some(from.as_any_ref().downcast_ref::<HostConfigFault>()?),
            StructType::AdminDisabled => Some(from.as_any_ref().downcast_ref::<AdminDisabled>()?),
            StructType::AdminNotDisabled => Some(from.as_any_ref().downcast_ref::<AdminNotDisabled>()?),
            StructType::BlockedByFirewall => Some(from.as_any_ref().downcast_ref::<BlockedByFirewall>()?),
            StructType::ClockSkew => Some(from.as_any_ref().downcast_ref::<ClockSkew>()?),
            StructType::DisableAdminNotSupported => Some(from.as_any_ref().downcast_ref::<DisableAdminNotSupported>()?),
            StructType::HostConfigFailed => Some(from.as_any_ref().downcast_ref::<HostConfigFailed>()?),
            StructType::HostInDomain => Some(from.as_any_ref().downcast_ref::<HostInDomain>()?),
            StructType::InvalidHostName => Some(from.as_any_ref().downcast_ref::<InvalidHostName>()?),
            StructType::NasConfigFault => Some(from.as_any_ref().downcast_ref::<NasConfigFault>()?),
            StructType::InvalidNasCredentials => Some(from.as_any_ref().downcast_ref::<InvalidNasCredentials>()?),
            StructType::InvalidNetworkResource => Some(from.as_any_ref().downcast_ref::<InvalidNetworkResource>()?),
            StructType::NasConnectionLimitReached => Some(from.as_any_ref().downcast_ref::<NasConnectionLimitReached>()?),
            StructType::NasSessionCredentialConflict => Some(from.as_any_ref().downcast_ref::<NasSessionCredentialConflict>()?),
            StructType::NasVolumeNotMounted => Some(from.as_any_ref().downcast_ref::<NasVolumeNotMounted>()?),
            StructType::NetworkInaccessible => Some(from.as_any_ref().downcast_ref::<NetworkInaccessible>()?),
            StructType::NoPermissionOnNasVolume => Some(from.as_any_ref().downcast_ref::<NoPermissionOnNasVolume>()?),
            StructType::NoGateway => Some(from.as_any_ref().downcast_ref::<NoGateway>()?),
            StructType::NoVirtualNic => Some(from.as_any_ref().downcast_ref::<NoVirtualNic>()?),
            StructType::PlatformConfigFault => Some(from.as_any_ref().downcast_ref::<PlatformConfigFault>()?),
            StructType::InvalidBundle => Some(from.as_any_ref().downcast_ref::<InvalidBundle>()?),
            StructType::PatchInstallFailed => Some(from.as_any_ref().downcast_ref::<PatchInstallFailed>()?),
            StructType::PatchIntegrityError => Some(from.as_any_ref().downcast_ref::<PatchIntegrityError>()?),
            StructType::VmfsMountFault => Some(from.as_any_ref().downcast_ref::<VmfsMountFault>()?),
            StructType::VmfsAlreadyMounted => Some(from.as_any_ref().downcast_ref::<VmfsAlreadyMounted>()?),
            StructType::VmfsAmbiguousMount => Some(from.as_any_ref().downcast_ref::<VmfsAmbiguousMount>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostConfigFault => Ok(from.as_any_box().downcast::<HostConfigFault>()?),
            StructType::AdminDisabled => Ok(from.as_any_box().downcast::<AdminDisabled>()?),
            StructType::AdminNotDisabled => Ok(from.as_any_box().downcast::<AdminNotDisabled>()?),
            StructType::BlockedByFirewall => Ok(from.as_any_box().downcast::<BlockedByFirewall>()?),
            StructType::ClockSkew => Ok(from.as_any_box().downcast::<ClockSkew>()?),
            StructType::DisableAdminNotSupported => Ok(from.as_any_box().downcast::<DisableAdminNotSupported>()?),
            StructType::HostConfigFailed => Ok(from.as_any_box().downcast::<HostConfigFailed>()?),
            StructType::HostInDomain => Ok(from.as_any_box().downcast::<HostInDomain>()?),
            StructType::InvalidHostName => Ok(from.as_any_box().downcast::<InvalidHostName>()?),
            StructType::NasConfigFault => Ok(from.as_any_box().downcast::<NasConfigFault>()?),
            StructType::InvalidNasCredentials => Ok(from.as_any_box().downcast::<InvalidNasCredentials>()?),
            StructType::InvalidNetworkResource => Ok(from.as_any_box().downcast::<InvalidNetworkResource>()?),
            StructType::NasConnectionLimitReached => Ok(from.as_any_box().downcast::<NasConnectionLimitReached>()?),
            StructType::NasSessionCredentialConflict => Ok(from.as_any_box().downcast::<NasSessionCredentialConflict>()?),
            StructType::NasVolumeNotMounted => Ok(from.as_any_box().downcast::<NasVolumeNotMounted>()?),
            StructType::NetworkInaccessible => Ok(from.as_any_box().downcast::<NetworkInaccessible>()?),
            StructType::NoPermissionOnNasVolume => Ok(from.as_any_box().downcast::<NoPermissionOnNasVolume>()?),
            StructType::NoGateway => Ok(from.as_any_box().downcast::<NoGateway>()?),
            StructType::NoVirtualNic => Ok(from.as_any_box().downcast::<NoVirtualNic>()?),
            StructType::PlatformConfigFault => Ok(from.as_any_box().downcast::<PlatformConfigFault>()?),
            StructType::InvalidBundle => Ok(from.as_any_box().downcast::<InvalidBundle>()?),
            StructType::PatchInstallFailed => Ok(from.as_any_box().downcast::<PatchInstallFailed>()?),
            StructType::PatchIntegrityError => Ok(from.as_any_box().downcast::<PatchIntegrityError>()?),
            StructType::VmfsMountFault => Ok(from.as_any_box().downcast::<VmfsMountFault>()?),
            StructType::VmfsAlreadyMounted => Ok(from.as_any_box().downcast::<VmfsAlreadyMounted>()?),
            StructType::VmfsAmbiguousMount => Ok(from.as_any_box().downcast::<VmfsAmbiguousMount>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class for all network-attached storage configuration faults.
pub trait NasConfigFaultTrait : super::traits::HostConfigFaultTrait {
    /// Name of the Nas datastore being configured.
    fn get_name(&self) -> &str;
}
impl<'s> serde::Serialize for dyn NasConfigFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn NasConfigFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(NasConfigFaultVisitor)
            }
        }

struct NasConfigFaultVisitor;

impl<'de> de::Visitor<'de> for NasConfigFaultVisitor {
    type Value = Box<dyn NasConfigFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid NasConfigFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl NasConfigFaultTrait for NasConfigFault {
    fn get_name(&self) -> &str { &self.name }
}
impl NasConfigFaultTrait for InvalidNasCredentials {
    fn get_name(&self) -> &str { &self.name }
}
impl NasConfigFaultTrait for InvalidNetworkResource {
    fn get_name(&self) -> &str { &self.name }
}
impl NasConfigFaultTrait for NasConnectionLimitReached {
    fn get_name(&self) -> &str { &self.name }
}
impl NasConfigFaultTrait for NasSessionCredentialConflict {
    fn get_name(&self) -> &str { &self.name }
}
impl NasConfigFaultTrait for NasVolumeNotMounted {
    fn get_name(&self) -> &str { &self.name }
}
impl NasConfigFaultTrait for NetworkInaccessible {
    fn get_name(&self) -> &str { &self.name }
}
impl NasConfigFaultTrait for NoPermissionOnNasVolume {
    fn get_name(&self) -> &str { &self.name }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn NasConfigFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::NasConfigFault => Some(from.as_any_ref().downcast_ref::<NasConfigFault>()?),
            StructType::InvalidNasCredentials => Some(from.as_any_ref().downcast_ref::<InvalidNasCredentials>()?),
            StructType::InvalidNetworkResource => Some(from.as_any_ref().downcast_ref::<InvalidNetworkResource>()?),
            StructType::NasConnectionLimitReached => Some(from.as_any_ref().downcast_ref::<NasConnectionLimitReached>()?),
            StructType::NasSessionCredentialConflict => Some(from.as_any_ref().downcast_ref::<NasSessionCredentialConflict>()?),
            StructType::NasVolumeNotMounted => Some(from.as_any_ref().downcast_ref::<NasVolumeNotMounted>()?),
            StructType::NetworkInaccessible => Some(from.as_any_ref().downcast_ref::<NetworkInaccessible>()?),
            StructType::NoPermissionOnNasVolume => Some(from.as_any_ref().downcast_ref::<NoPermissionOnNasVolume>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::NasConfigFault => Ok(from.as_any_box().downcast::<NasConfigFault>()?),
            StructType::InvalidNasCredentials => Ok(from.as_any_box().downcast::<InvalidNasCredentials>()?),
            StructType::InvalidNetworkResource => Ok(from.as_any_box().downcast::<InvalidNetworkResource>()?),
            StructType::NasConnectionLimitReached => Ok(from.as_any_box().downcast::<NasConnectionLimitReached>()?),
            StructType::NasSessionCredentialConflict => Ok(from.as_any_box().downcast::<NasSessionCredentialConflict>()?),
            StructType::NasVolumeNotMounted => Ok(from.as_any_box().downcast::<NasVolumeNotMounted>()?),
            StructType::NetworkInaccessible => Ok(from.as_any_box().downcast::<NetworkInaccessible>()?),
            StructType::NoPermissionOnNasVolume => Ok(from.as_any_box().downcast::<NoPermissionOnNasVolume>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// A PlatformConfigFault is a catch-all fault indicating that some error has
/// occurred regarding the configuration of the host.
/// 
/// Data about the fault is
/// available and will be presented as a platform specific string.
/// 
/// This information carried by this fault cannot be localized. Most likely
/// this information will already have been localized to the locale of the
/// server that generated this fault. Where possible, a more specific fault
/// will be thrown.
pub trait PlatformConfigFaultTrait : super::traits::HostConfigFaultTrait {
    /// Platform specific text string describing this error.
    fn get_text(&self) -> &str;
}
impl<'s> serde::Serialize for dyn PlatformConfigFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn PlatformConfigFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(PlatformConfigFaultVisitor)
            }
        }

struct PlatformConfigFaultVisitor;

impl<'de> de::Visitor<'de> for PlatformConfigFaultVisitor {
    type Value = Box<dyn PlatformConfigFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid PlatformConfigFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl PlatformConfigFaultTrait for PlatformConfigFault {
    fn get_text(&self) -> &str { &self.text }
}
impl PlatformConfigFaultTrait for InvalidBundle {
    fn get_text(&self) -> &str { &self.text }
}
impl PlatformConfigFaultTrait for PatchInstallFailed {
    fn get_text(&self) -> &str { &self.text }
}
impl PlatformConfigFaultTrait for PatchIntegrityError {
    fn get_text(&self) -> &str { &self.text }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn PlatformConfigFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::PlatformConfigFault => Some(from.as_any_ref().downcast_ref::<PlatformConfigFault>()?),
            StructType::InvalidBundle => Some(from.as_any_ref().downcast_ref::<InvalidBundle>()?),
            StructType::PatchInstallFailed => Some(from.as_any_ref().downcast_ref::<PatchInstallFailed>()?),
            StructType::PatchIntegrityError => Some(from.as_any_ref().downcast_ref::<PatchIntegrityError>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::PlatformConfigFault => Ok(from.as_any_box().downcast::<PlatformConfigFault>()?),
            StructType::InvalidBundle => Ok(from.as_any_box().downcast::<InvalidBundle>()?),
            StructType::PatchInstallFailed => Ok(from.as_any_box().downcast::<PatchInstallFailed>()?),
            StructType::PatchIntegrityError => Ok(from.as_any_box().downcast::<PatchIntegrityError>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This is a base class for all VMFS volume mount related faults.
pub trait VmfsMountFaultTrait : super::traits::HostConfigFaultTrait {
    /// Vmfs volume uuid
    fn get_uuid(&self) -> &str;
}
impl<'s> serde::Serialize for dyn VmfsMountFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VmfsMountFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VmfsMountFaultVisitor)
            }
        }

struct VmfsMountFaultVisitor;

impl<'de> de::Visitor<'de> for VmfsMountFaultVisitor {
    type Value = Box<dyn VmfsMountFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VmfsMountFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VmfsMountFaultTrait for VmfsMountFault {
    fn get_uuid(&self) -> &str { &self.uuid }
}
impl VmfsMountFaultTrait for VmfsAlreadyMounted {
    fn get_uuid(&self) -> &str { &self.uuid }
}
impl VmfsMountFaultTrait for VmfsAmbiguousMount {
    fn get_uuid(&self) -> &str { &self.uuid }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VmfsMountFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmfsMountFault => Some(from.as_any_ref().downcast_ref::<VmfsMountFault>()?),
            StructType::VmfsAlreadyMounted => Some(from.as_any_ref().downcast_ref::<VmfsAlreadyMounted>()?),
            StructType::VmfsAmbiguousMount => Some(from.as_any_ref().downcast_ref::<VmfsAmbiguousMount>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmfsMountFault => Ok(from.as_any_box().downcast::<VmfsMountFault>()?),
            StructType::VmfsAlreadyMounted => Ok(from.as_any_box().downcast::<VmfsAlreadyMounted>()?),
            StructType::VmfsAmbiguousMount => Ok(from.as_any_box().downcast::<VmfsAmbiguousMount>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// A base clase for faults that are related to connecting or
/// adding a host to the inventory.
pub trait HostConnectFaultTrait : super::traits::VimFaultTrait {
}
impl<'s> serde::Serialize for dyn HostConnectFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostConnectFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostConnectFaultVisitor)
            }
        }

struct HostConnectFaultVisitor;

impl<'de> de::Visitor<'de> for HostConnectFaultVisitor {
    type Value = Box<dyn HostConnectFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostConnectFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostConnectFaultTrait for HostConnectFault {
}
impl HostConnectFaultTrait for AgentInstallFailed {
}
impl HostConnectFaultTrait for AlreadyBeingManaged {
}
impl HostConnectFaultTrait for AlreadyConnected {
}
impl HostConnectFaultTrait for CannotAddHostWithFtVmAsStandalone {
}
impl HostConnectFaultTrait for CannotAddHostWithFtVmToDifferentCluster {
}
impl HostConnectFaultTrait for CannotAddHostWithFtVmToNonHaCluster {
}
impl HostConnectFaultTrait for GatewayConnectFault {
}
impl HostConnectFaultTrait for GatewayNotFound {
}
impl HostConnectFaultTrait for GatewayNotReachable {
}
impl HostConnectFaultTrait for GatewayOperationRefused {
}
impl HostConnectFaultTrait for GatewayToHostConnectFault {
}
impl HostConnectFaultTrait for GatewayHostNotReachable {
}
impl HostConnectFaultTrait for GatewayToHostAuthFault {
}
impl HostConnectFaultTrait for GatewayToHostTrustVerifyFault {
}
impl HostConnectFaultTrait for MultipleCertificatesVerifyFault {
}
impl HostConnectFaultTrait for NoHost {
}
impl HostConnectFaultTrait for NoPermissionOnHost {
}
impl HostConnectFaultTrait for NotSupportedHost {
}
impl HostConnectFaultTrait for NonVmwareOuiMacNotSupportedHost {
}
impl HostConnectFaultTrait for NotSupportedHostForVFlash {
}
impl HostConnectFaultTrait for NotSupportedHostForVmcp {
}
impl HostConnectFaultTrait for NotSupportedHostForVmemFile {
}
impl HostConnectFaultTrait for NotSupportedHostForVsan {
}
impl HostConnectFaultTrait for NotSupportedHostInCluster {
}
impl HostConnectFaultTrait for EvcAdmissionFailed {
}
impl HostConnectFaultTrait for EvcAdmissionFailedCpuFeaturesForMode {
}
impl HostConnectFaultTrait for EvcAdmissionFailedCpuModel {
}
impl HostConnectFaultTrait for EvcAdmissionFailedCpuModelForMode {
}
impl HostConnectFaultTrait for EvcAdmissionFailedCpuVendor {
}
impl HostConnectFaultTrait for EvcAdmissionFailedCpuVendorUnknown {
}
impl HostConnectFaultTrait for EvcAdmissionFailedHostDisconnected {
}
impl HostConnectFaultTrait for EvcAdmissionFailedHostSoftware {
}
impl HostConnectFaultTrait for EvcAdmissionFailedHostSoftwareForMode {
}
impl HostConnectFaultTrait for EvcAdmissionFailedVmActive {
}
impl HostConnectFaultTrait for NotSupportedHostInDvs {
}
impl HostConnectFaultTrait for NotSupportedHostInHaCluster {
}
impl HostConnectFaultTrait for ReadHostResourcePoolTreeFailed {
}
impl HostConnectFaultTrait for SslDisabledFault {
}
impl HostConnectFaultTrait for SslVerifyFault {
}
impl HostConnectFaultTrait for TooManyHosts {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostConnectFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostConnectFault => Some(from.as_any_ref().downcast_ref::<HostConnectFault>()?),
            StructType::AgentInstallFailed => Some(from.as_any_ref().downcast_ref::<AgentInstallFailed>()?),
            StructType::AlreadyBeingManaged => Some(from.as_any_ref().downcast_ref::<AlreadyBeingManaged>()?),
            StructType::AlreadyConnected => Some(from.as_any_ref().downcast_ref::<AlreadyConnected>()?),
            StructType::CannotAddHostWithFtVmAsStandalone => Some(from.as_any_ref().downcast_ref::<CannotAddHostWithFtVmAsStandalone>()?),
            StructType::CannotAddHostWithFtVmToDifferentCluster => Some(from.as_any_ref().downcast_ref::<CannotAddHostWithFtVmToDifferentCluster>()?),
            StructType::CannotAddHostWithFtVmToNonHaCluster => Some(from.as_any_ref().downcast_ref::<CannotAddHostWithFtVmToNonHaCluster>()?),
            StructType::GatewayConnectFault => Some(from.as_any_ref().downcast_ref::<GatewayConnectFault>()?),
            StructType::GatewayNotFound => Some(from.as_any_ref().downcast_ref::<GatewayNotFound>()?),
            StructType::GatewayNotReachable => Some(from.as_any_ref().downcast_ref::<GatewayNotReachable>()?),
            StructType::GatewayOperationRefused => Some(from.as_any_ref().downcast_ref::<GatewayOperationRefused>()?),
            StructType::GatewayToHostConnectFault => Some(from.as_any_ref().downcast_ref::<GatewayToHostConnectFault>()?),
            StructType::GatewayHostNotReachable => Some(from.as_any_ref().downcast_ref::<GatewayHostNotReachable>()?),
            StructType::GatewayToHostAuthFault => Some(from.as_any_ref().downcast_ref::<GatewayToHostAuthFault>()?),
            StructType::GatewayToHostTrustVerifyFault => Some(from.as_any_ref().downcast_ref::<GatewayToHostTrustVerifyFault>()?),
            StructType::MultipleCertificatesVerifyFault => Some(from.as_any_ref().downcast_ref::<MultipleCertificatesVerifyFault>()?),
            StructType::NoHost => Some(from.as_any_ref().downcast_ref::<NoHost>()?),
            StructType::NoPermissionOnHost => Some(from.as_any_ref().downcast_ref::<NoPermissionOnHost>()?),
            StructType::NotSupportedHost => Some(from.as_any_ref().downcast_ref::<NotSupportedHost>()?),
            StructType::NonVmwareOuiMacNotSupportedHost => Some(from.as_any_ref().downcast_ref::<NonVmwareOuiMacNotSupportedHost>()?),
            StructType::NotSupportedHostForVFlash => Some(from.as_any_ref().downcast_ref::<NotSupportedHostForVFlash>()?),
            StructType::NotSupportedHostForVmcp => Some(from.as_any_ref().downcast_ref::<NotSupportedHostForVmcp>()?),
            StructType::NotSupportedHostForVmemFile => Some(from.as_any_ref().downcast_ref::<NotSupportedHostForVmemFile>()?),
            StructType::NotSupportedHostForVsan => Some(from.as_any_ref().downcast_ref::<NotSupportedHostForVsan>()?),
            StructType::NotSupportedHostInCluster => Some(from.as_any_ref().downcast_ref::<NotSupportedHostInCluster>()?),
            StructType::EvcAdmissionFailed => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailed>()?),
            StructType::EvcAdmissionFailedCpuFeaturesForMode => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedCpuFeaturesForMode>()?),
            StructType::EvcAdmissionFailedCpuModel => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedCpuModel>()?),
            StructType::EvcAdmissionFailedCpuModelForMode => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedCpuModelForMode>()?),
            StructType::EvcAdmissionFailedCpuVendor => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedCpuVendor>()?),
            StructType::EvcAdmissionFailedCpuVendorUnknown => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedCpuVendorUnknown>()?),
            StructType::EvcAdmissionFailedHostDisconnected => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedHostDisconnected>()?),
            StructType::EvcAdmissionFailedHostSoftware => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedHostSoftware>()?),
            StructType::EvcAdmissionFailedHostSoftwareForMode => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedHostSoftwareForMode>()?),
            StructType::EvcAdmissionFailedVmActive => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedVmActive>()?),
            StructType::NotSupportedHostInDvs => Some(from.as_any_ref().downcast_ref::<NotSupportedHostInDvs>()?),
            StructType::NotSupportedHostInHaCluster => Some(from.as_any_ref().downcast_ref::<NotSupportedHostInHaCluster>()?),
            StructType::ReadHostResourcePoolTreeFailed => Some(from.as_any_ref().downcast_ref::<ReadHostResourcePoolTreeFailed>()?),
            StructType::SslDisabledFault => Some(from.as_any_ref().downcast_ref::<SslDisabledFault>()?),
            StructType::SslVerifyFault => Some(from.as_any_ref().downcast_ref::<SslVerifyFault>()?),
            StructType::TooManyHosts => Some(from.as_any_ref().downcast_ref::<TooManyHosts>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostConnectFault => Ok(from.as_any_box().downcast::<HostConnectFault>()?),
            StructType::AgentInstallFailed => Ok(from.as_any_box().downcast::<AgentInstallFailed>()?),
            StructType::AlreadyBeingManaged => Ok(from.as_any_box().downcast::<AlreadyBeingManaged>()?),
            StructType::AlreadyConnected => Ok(from.as_any_box().downcast::<AlreadyConnected>()?),
            StructType::CannotAddHostWithFtVmAsStandalone => Ok(from.as_any_box().downcast::<CannotAddHostWithFtVmAsStandalone>()?),
            StructType::CannotAddHostWithFtVmToDifferentCluster => Ok(from.as_any_box().downcast::<CannotAddHostWithFtVmToDifferentCluster>()?),
            StructType::CannotAddHostWithFtVmToNonHaCluster => Ok(from.as_any_box().downcast::<CannotAddHostWithFtVmToNonHaCluster>()?),
            StructType::GatewayConnectFault => Ok(from.as_any_box().downcast::<GatewayConnectFault>()?),
            StructType::GatewayNotFound => Ok(from.as_any_box().downcast::<GatewayNotFound>()?),
            StructType::GatewayNotReachable => Ok(from.as_any_box().downcast::<GatewayNotReachable>()?),
            StructType::GatewayOperationRefused => Ok(from.as_any_box().downcast::<GatewayOperationRefused>()?),
            StructType::GatewayToHostConnectFault => Ok(from.as_any_box().downcast::<GatewayToHostConnectFault>()?),
            StructType::GatewayHostNotReachable => Ok(from.as_any_box().downcast::<GatewayHostNotReachable>()?),
            StructType::GatewayToHostAuthFault => Ok(from.as_any_box().downcast::<GatewayToHostAuthFault>()?),
            StructType::GatewayToHostTrustVerifyFault => Ok(from.as_any_box().downcast::<GatewayToHostTrustVerifyFault>()?),
            StructType::MultipleCertificatesVerifyFault => Ok(from.as_any_box().downcast::<MultipleCertificatesVerifyFault>()?),
            StructType::NoHost => Ok(from.as_any_box().downcast::<NoHost>()?),
            StructType::NoPermissionOnHost => Ok(from.as_any_box().downcast::<NoPermissionOnHost>()?),
            StructType::NotSupportedHost => Ok(from.as_any_box().downcast::<NotSupportedHost>()?),
            StructType::NonVmwareOuiMacNotSupportedHost => Ok(from.as_any_box().downcast::<NonVmwareOuiMacNotSupportedHost>()?),
            StructType::NotSupportedHostForVFlash => Ok(from.as_any_box().downcast::<NotSupportedHostForVFlash>()?),
            StructType::NotSupportedHostForVmcp => Ok(from.as_any_box().downcast::<NotSupportedHostForVmcp>()?),
            StructType::NotSupportedHostForVmemFile => Ok(from.as_any_box().downcast::<NotSupportedHostForVmemFile>()?),
            StructType::NotSupportedHostForVsan => Ok(from.as_any_box().downcast::<NotSupportedHostForVsan>()?),
            StructType::NotSupportedHostInCluster => Ok(from.as_any_box().downcast::<NotSupportedHostInCluster>()?),
            StructType::EvcAdmissionFailed => Ok(from.as_any_box().downcast::<EvcAdmissionFailed>()?),
            StructType::EvcAdmissionFailedCpuFeaturesForMode => Ok(from.as_any_box().downcast::<EvcAdmissionFailedCpuFeaturesForMode>()?),
            StructType::EvcAdmissionFailedCpuModel => Ok(from.as_any_box().downcast::<EvcAdmissionFailedCpuModel>()?),
            StructType::EvcAdmissionFailedCpuModelForMode => Ok(from.as_any_box().downcast::<EvcAdmissionFailedCpuModelForMode>()?),
            StructType::EvcAdmissionFailedCpuVendor => Ok(from.as_any_box().downcast::<EvcAdmissionFailedCpuVendor>()?),
            StructType::EvcAdmissionFailedCpuVendorUnknown => Ok(from.as_any_box().downcast::<EvcAdmissionFailedCpuVendorUnknown>()?),
            StructType::EvcAdmissionFailedHostDisconnected => Ok(from.as_any_box().downcast::<EvcAdmissionFailedHostDisconnected>()?),
            StructType::EvcAdmissionFailedHostSoftware => Ok(from.as_any_box().downcast::<EvcAdmissionFailedHostSoftware>()?),
            StructType::EvcAdmissionFailedHostSoftwareForMode => Ok(from.as_any_box().downcast::<EvcAdmissionFailedHostSoftwareForMode>()?),
            StructType::EvcAdmissionFailedVmActive => Ok(from.as_any_box().downcast::<EvcAdmissionFailedVmActive>()?),
            StructType::NotSupportedHostInDvs => Ok(from.as_any_box().downcast::<NotSupportedHostInDvs>()?),
            StructType::NotSupportedHostInHaCluster => Ok(from.as_any_box().downcast::<NotSupportedHostInHaCluster>()?),
            StructType::ReadHostResourcePoolTreeFailed => Ok(from.as_any_box().downcast::<ReadHostResourcePoolTreeFailed>()?),
            StructType::SslDisabledFault => Ok(from.as_any_box().downcast::<SslDisabledFault>()?),
            StructType::SslVerifyFault => Ok(from.as_any_box().downcast::<SslVerifyFault>()?),
            StructType::TooManyHosts => Ok(from.as_any_box().downcast::<TooManyHosts>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Deprecated not used since vSphere 6.5.
/// 
/// GatewayConnectFault is a base fault type for the faults thrown by a gateway
/// server used to connect to a host.
pub trait GatewayConnectFaultTrait : super::traits::HostConnectFaultTrait {
    /// The type of the gateway used for the connection to the host.
    fn get_gateway_type(&self) -> &str;
    /// Identifier of the gateway that is used for the connection to the host.
    fn get_gateway_id(&self) -> &str;
    /// Human-readable information about the host gateway server.
    fn get_gateway_info(&self) -> &str;
    /// Details of the cause for this fault.
    /// 
    /// This is the way in which Host
    /// Gateway servers propagate opaque error messages through vCenter Server.
    fn get_details(&self) -> &Option<LocalizableMessage>;
}
impl<'s> serde::Serialize for dyn GatewayConnectFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn GatewayConnectFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(GatewayConnectFaultVisitor)
            }
        }

struct GatewayConnectFaultVisitor;

impl<'de> de::Visitor<'de> for GatewayConnectFaultVisitor {
    type Value = Box<dyn GatewayConnectFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid GatewayConnectFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl GatewayConnectFaultTrait for GatewayConnectFault {
    fn get_gateway_type(&self) -> &str { &self.gateway_type }
    fn get_gateway_id(&self) -> &str { &self.gateway_id }
    fn get_gateway_info(&self) -> &str { &self.gateway_info }
    fn get_details(&self) -> &Option<LocalizableMessage> { &self.details }
}
impl GatewayConnectFaultTrait for GatewayNotFound {
    fn get_gateway_type(&self) -> &str { &self.gateway_type }
    fn get_gateway_id(&self) -> &str { &self.gateway_id }
    fn get_gateway_info(&self) -> &str { &self.gateway_info }
    fn get_details(&self) -> &Option<LocalizableMessage> { &self.details }
}
impl GatewayConnectFaultTrait for GatewayNotReachable {
    fn get_gateway_type(&self) -> &str { &self.gateway_type }
    fn get_gateway_id(&self) -> &str { &self.gateway_id }
    fn get_gateway_info(&self) -> &str { &self.gateway_info }
    fn get_details(&self) -> &Option<LocalizableMessage> { &self.details }
}
impl GatewayConnectFaultTrait for GatewayOperationRefused {
    fn get_gateway_type(&self) -> &str { &self.gateway_type }
    fn get_gateway_id(&self) -> &str { &self.gateway_id }
    fn get_gateway_info(&self) -> &str { &self.gateway_info }
    fn get_details(&self) -> &Option<LocalizableMessage> { &self.details }
}
impl GatewayConnectFaultTrait for GatewayToHostConnectFault {
    fn get_gateway_type(&self) -> &str { &self.gateway_type }
    fn get_gateway_id(&self) -> &str { &self.gateway_id }
    fn get_gateway_info(&self) -> &str { &self.gateway_info }
    fn get_details(&self) -> &Option<LocalizableMessage> { &self.details }
}
impl GatewayConnectFaultTrait for GatewayHostNotReachable {
    fn get_gateway_type(&self) -> &str { &self.gateway_type }
    fn get_gateway_id(&self) -> &str { &self.gateway_id }
    fn get_gateway_info(&self) -> &str { &self.gateway_info }
    fn get_details(&self) -> &Option<LocalizableMessage> { &self.details }
}
impl GatewayConnectFaultTrait for GatewayToHostAuthFault {
    fn get_gateway_type(&self) -> &str { &self.gateway_type }
    fn get_gateway_id(&self) -> &str { &self.gateway_id }
    fn get_gateway_info(&self) -> &str { &self.gateway_info }
    fn get_details(&self) -> &Option<LocalizableMessage> { &self.details }
}
impl GatewayConnectFaultTrait for GatewayToHostTrustVerifyFault {
    fn get_gateway_type(&self) -> &str { &self.gateway_type }
    fn get_gateway_id(&self) -> &str { &self.gateway_id }
    fn get_gateway_info(&self) -> &str { &self.gateway_info }
    fn get_details(&self) -> &Option<LocalizableMessage> { &self.details }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn GatewayConnectFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::GatewayConnectFault => Some(from.as_any_ref().downcast_ref::<GatewayConnectFault>()?),
            StructType::GatewayNotFound => Some(from.as_any_ref().downcast_ref::<GatewayNotFound>()?),
            StructType::GatewayNotReachable => Some(from.as_any_ref().downcast_ref::<GatewayNotReachable>()?),
            StructType::GatewayOperationRefused => Some(from.as_any_ref().downcast_ref::<GatewayOperationRefused>()?),
            StructType::GatewayToHostConnectFault => Some(from.as_any_ref().downcast_ref::<GatewayToHostConnectFault>()?),
            StructType::GatewayHostNotReachable => Some(from.as_any_ref().downcast_ref::<GatewayHostNotReachable>()?),
            StructType::GatewayToHostAuthFault => Some(from.as_any_ref().downcast_ref::<GatewayToHostAuthFault>()?),
            StructType::GatewayToHostTrustVerifyFault => Some(from.as_any_ref().downcast_ref::<GatewayToHostTrustVerifyFault>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::GatewayConnectFault => Ok(from.as_any_box().downcast::<GatewayConnectFault>()?),
            StructType::GatewayNotFound => Ok(from.as_any_box().downcast::<GatewayNotFound>()?),
            StructType::GatewayNotReachable => Ok(from.as_any_box().downcast::<GatewayNotReachable>()?),
            StructType::GatewayOperationRefused => Ok(from.as_any_box().downcast::<GatewayOperationRefused>()?),
            StructType::GatewayToHostConnectFault => Ok(from.as_any_box().downcast::<GatewayToHostConnectFault>()?),
            StructType::GatewayHostNotReachable => Ok(from.as_any_box().downcast::<GatewayHostNotReachable>()?),
            StructType::GatewayToHostAuthFault => Ok(from.as_any_box().downcast::<GatewayToHostAuthFault>()?),
            StructType::GatewayToHostTrustVerifyFault => Ok(from.as_any_box().downcast::<GatewayToHostTrustVerifyFault>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Deprecated not used since vSphere 6.5.
/// 
/// GatewayToHostConnectFault is thrown by the gateway used to communicate
/// with a host, if an error occurs in the communication between the gateway and
/// the host.
/// 
/// More details may be provided by a subfault.
pub trait GatewayToHostConnectFaultTrait : super::traits::GatewayConnectFaultTrait {
    /// Hostname of the host that the gateway is communicating with.
    fn get_hostname(&self) -> &str;
    /// Port specified for the connection between the gateway and the host.
    fn get_port(&self) -> Option<i32>;
}
impl<'s> serde::Serialize for dyn GatewayToHostConnectFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn GatewayToHostConnectFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(GatewayToHostConnectFaultVisitor)
            }
        }

struct GatewayToHostConnectFaultVisitor;

impl<'de> de::Visitor<'de> for GatewayToHostConnectFaultVisitor {
    type Value = Box<dyn GatewayToHostConnectFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid GatewayToHostConnectFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl GatewayToHostConnectFaultTrait for GatewayToHostConnectFault {
    fn get_hostname(&self) -> &str { &self.hostname }
    fn get_port(&self) -> Option<i32> { self.port }
}
impl GatewayToHostConnectFaultTrait for GatewayHostNotReachable {
    fn get_hostname(&self) -> &str { &self.hostname }
    fn get_port(&self) -> Option<i32> { self.port }
}
impl GatewayToHostConnectFaultTrait for GatewayToHostAuthFault {
    fn get_hostname(&self) -> &str { &self.hostname }
    fn get_port(&self) -> Option<i32> { self.port }
}
impl GatewayToHostConnectFaultTrait for GatewayToHostTrustVerifyFault {
    fn get_hostname(&self) -> &str { &self.hostname }
    fn get_port(&self) -> Option<i32> { self.port }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn GatewayToHostConnectFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::GatewayToHostConnectFault => Some(from.as_any_ref().downcast_ref::<GatewayToHostConnectFault>()?),
            StructType::GatewayHostNotReachable => Some(from.as_any_ref().downcast_ref::<GatewayHostNotReachable>()?),
            StructType::GatewayToHostAuthFault => Some(from.as_any_ref().downcast_ref::<GatewayToHostAuthFault>()?),
            StructType::GatewayToHostTrustVerifyFault => Some(from.as_any_ref().downcast_ref::<GatewayToHostTrustVerifyFault>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::GatewayToHostConnectFault => Ok(from.as_any_box().downcast::<GatewayToHostConnectFault>()?),
            StructType::GatewayHostNotReachable => Ok(from.as_any_box().downcast::<GatewayHostNotReachable>()?),
            StructType::GatewayToHostAuthFault => Ok(from.as_any_box().downcast::<GatewayToHostAuthFault>()?),
            StructType::GatewayToHostTrustVerifyFault => Ok(from.as_any_box().downcast::<GatewayToHostTrustVerifyFault>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// A NotSupportedHostFault occurs when the host is of a type
/// that is not supported.
pub trait NotSupportedHostTrait : super::traits::HostConnectFaultTrait {
    /// The name of the unsupported product if available;
    /// for example, "VMware ESX Server".
    fn get_product_name(&self) -> &Option<String>;
    /// The version of the unsupported product; for example, "1.5.2"
    fn get_product_version(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn NotSupportedHostTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn NotSupportedHostTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(NotSupportedHostVisitor)
            }
        }

struct NotSupportedHostVisitor;

impl<'de> de::Visitor<'de> for NotSupportedHostVisitor {
    type Value = Box<dyn NotSupportedHostTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid NotSupportedHostTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl NotSupportedHostTrait for NotSupportedHost {
    fn get_product_name(&self) -> &Option<String> { &self.product_name }
    fn get_product_version(&self) -> &Option<String> { &self.product_version }
}
impl NotSupportedHostTrait for NonVmwareOuiMacNotSupportedHost {
    fn get_product_name(&self) -> &Option<String> { &self.product_name }
    fn get_product_version(&self) -> &Option<String> { &self.product_version }
}
impl NotSupportedHostTrait for NotSupportedHostForVFlash {
    fn get_product_name(&self) -> &Option<String> { &self.product_name }
    fn get_product_version(&self) -> &Option<String> { &self.product_version }
}
impl NotSupportedHostTrait for NotSupportedHostForVmcp {
    fn get_product_name(&self) -> &Option<String> { &self.product_name }
    fn get_product_version(&self) -> &Option<String> { &self.product_version }
}
impl NotSupportedHostTrait for NotSupportedHostForVmemFile {
    fn get_product_name(&self) -> &Option<String> { &self.product_name }
    fn get_product_version(&self) -> &Option<String> { &self.product_version }
}
impl NotSupportedHostTrait for NotSupportedHostForVsan {
    fn get_product_name(&self) -> &Option<String> { &self.product_name }
    fn get_product_version(&self) -> &Option<String> { &self.product_version }
}
impl NotSupportedHostTrait for NotSupportedHostInCluster {
    fn get_product_name(&self) -> &Option<String> { &self.product_name }
    fn get_product_version(&self) -> &Option<String> { &self.product_version }
}
impl NotSupportedHostTrait for EvcAdmissionFailed {
    fn get_product_name(&self) -> &Option<String> { &self.product_name }
    fn get_product_version(&self) -> &Option<String> { &self.product_version }
}
impl NotSupportedHostTrait for EvcAdmissionFailedCpuFeaturesForMode {
    fn get_product_name(&self) -> &Option<String> { &self.product_name }
    fn get_product_version(&self) -> &Option<String> { &self.product_version }
}
impl NotSupportedHostTrait for EvcAdmissionFailedCpuModel {
    fn get_product_name(&self) -> &Option<String> { &self.product_name }
    fn get_product_version(&self) -> &Option<String> { &self.product_version }
}
impl NotSupportedHostTrait for EvcAdmissionFailedCpuModelForMode {
    fn get_product_name(&self) -> &Option<String> { &self.product_name }
    fn get_product_version(&self) -> &Option<String> { &self.product_version }
}
impl NotSupportedHostTrait for EvcAdmissionFailedCpuVendor {
    fn get_product_name(&self) -> &Option<String> { &self.product_name }
    fn get_product_version(&self) -> &Option<String> { &self.product_version }
}
impl NotSupportedHostTrait for EvcAdmissionFailedCpuVendorUnknown {
    fn get_product_name(&self) -> &Option<String> { &self.product_name }
    fn get_product_version(&self) -> &Option<String> { &self.product_version }
}
impl NotSupportedHostTrait for EvcAdmissionFailedHostDisconnected {
    fn get_product_name(&self) -> &Option<String> { &self.product_name }
    fn get_product_version(&self) -> &Option<String> { &self.product_version }
}
impl NotSupportedHostTrait for EvcAdmissionFailedHostSoftware {
    fn get_product_name(&self) -> &Option<String> { &self.product_name }
    fn get_product_version(&self) -> &Option<String> { &self.product_version }
}
impl NotSupportedHostTrait for EvcAdmissionFailedHostSoftwareForMode {
    fn get_product_name(&self) -> &Option<String> { &self.product_name }
    fn get_product_version(&self) -> &Option<String> { &self.product_version }
}
impl NotSupportedHostTrait for EvcAdmissionFailedVmActive {
    fn get_product_name(&self) -> &Option<String> { &self.product_name }
    fn get_product_version(&self) -> &Option<String> { &self.product_version }
}
impl NotSupportedHostTrait for NotSupportedHostInDvs {
    fn get_product_name(&self) -> &Option<String> { &self.product_name }
    fn get_product_version(&self) -> &Option<String> { &self.product_version }
}
impl NotSupportedHostTrait for NotSupportedHostInHaCluster {
    fn get_product_name(&self) -> &Option<String> { &self.product_name }
    fn get_product_version(&self) -> &Option<String> { &self.product_version }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn NotSupportedHostTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::NotSupportedHost => Some(from.as_any_ref().downcast_ref::<NotSupportedHost>()?),
            StructType::NonVmwareOuiMacNotSupportedHost => Some(from.as_any_ref().downcast_ref::<NonVmwareOuiMacNotSupportedHost>()?),
            StructType::NotSupportedHostForVFlash => Some(from.as_any_ref().downcast_ref::<NotSupportedHostForVFlash>()?),
            StructType::NotSupportedHostForVmcp => Some(from.as_any_ref().downcast_ref::<NotSupportedHostForVmcp>()?),
            StructType::NotSupportedHostForVmemFile => Some(from.as_any_ref().downcast_ref::<NotSupportedHostForVmemFile>()?),
            StructType::NotSupportedHostForVsan => Some(from.as_any_ref().downcast_ref::<NotSupportedHostForVsan>()?),
            StructType::NotSupportedHostInCluster => Some(from.as_any_ref().downcast_ref::<NotSupportedHostInCluster>()?),
            StructType::EvcAdmissionFailed => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailed>()?),
            StructType::EvcAdmissionFailedCpuFeaturesForMode => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedCpuFeaturesForMode>()?),
            StructType::EvcAdmissionFailedCpuModel => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedCpuModel>()?),
            StructType::EvcAdmissionFailedCpuModelForMode => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedCpuModelForMode>()?),
            StructType::EvcAdmissionFailedCpuVendor => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedCpuVendor>()?),
            StructType::EvcAdmissionFailedCpuVendorUnknown => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedCpuVendorUnknown>()?),
            StructType::EvcAdmissionFailedHostDisconnected => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedHostDisconnected>()?),
            StructType::EvcAdmissionFailedHostSoftware => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedHostSoftware>()?),
            StructType::EvcAdmissionFailedHostSoftwareForMode => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedHostSoftwareForMode>()?),
            StructType::EvcAdmissionFailedVmActive => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedVmActive>()?),
            StructType::NotSupportedHostInDvs => Some(from.as_any_ref().downcast_ref::<NotSupportedHostInDvs>()?),
            StructType::NotSupportedHostInHaCluster => Some(from.as_any_ref().downcast_ref::<NotSupportedHostInHaCluster>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::NotSupportedHost => Ok(from.as_any_box().downcast::<NotSupportedHost>()?),
            StructType::NonVmwareOuiMacNotSupportedHost => Ok(from.as_any_box().downcast::<NonVmwareOuiMacNotSupportedHost>()?),
            StructType::NotSupportedHostForVFlash => Ok(from.as_any_box().downcast::<NotSupportedHostForVFlash>()?),
            StructType::NotSupportedHostForVmcp => Ok(from.as_any_box().downcast::<NotSupportedHostForVmcp>()?),
            StructType::NotSupportedHostForVmemFile => Ok(from.as_any_box().downcast::<NotSupportedHostForVmemFile>()?),
            StructType::NotSupportedHostForVsan => Ok(from.as_any_box().downcast::<NotSupportedHostForVsan>()?),
            StructType::NotSupportedHostInCluster => Ok(from.as_any_box().downcast::<NotSupportedHostInCluster>()?),
            StructType::EvcAdmissionFailed => Ok(from.as_any_box().downcast::<EvcAdmissionFailed>()?),
            StructType::EvcAdmissionFailedCpuFeaturesForMode => Ok(from.as_any_box().downcast::<EvcAdmissionFailedCpuFeaturesForMode>()?),
            StructType::EvcAdmissionFailedCpuModel => Ok(from.as_any_box().downcast::<EvcAdmissionFailedCpuModel>()?),
            StructType::EvcAdmissionFailedCpuModelForMode => Ok(from.as_any_box().downcast::<EvcAdmissionFailedCpuModelForMode>()?),
            StructType::EvcAdmissionFailedCpuVendor => Ok(from.as_any_box().downcast::<EvcAdmissionFailedCpuVendor>()?),
            StructType::EvcAdmissionFailedCpuVendorUnknown => Ok(from.as_any_box().downcast::<EvcAdmissionFailedCpuVendorUnknown>()?),
            StructType::EvcAdmissionFailedHostDisconnected => Ok(from.as_any_box().downcast::<EvcAdmissionFailedHostDisconnected>()?),
            StructType::EvcAdmissionFailedHostSoftware => Ok(from.as_any_box().downcast::<EvcAdmissionFailedHostSoftware>()?),
            StructType::EvcAdmissionFailedHostSoftwareForMode => Ok(from.as_any_box().downcast::<EvcAdmissionFailedHostSoftwareForMode>()?),
            StructType::EvcAdmissionFailedVmActive => Ok(from.as_any_box().downcast::<EvcAdmissionFailedVmActive>()?),
            StructType::NotSupportedHostInDvs => Ok(from.as_any_box().downcast::<NotSupportedHostInDvs>()?),
            StructType::NotSupportedHostInHaCluster => Ok(from.as_any_box().downcast::<NotSupportedHostInHaCluster>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// A NotSupportedHostInCluster fault occurs when the host does not support
/// the necessary features to participate in the cluster.
pub trait NotSupportedHostInClusterTrait : super::traits::NotSupportedHostTrait {
}
impl<'s> serde::Serialize for dyn NotSupportedHostInClusterTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn NotSupportedHostInClusterTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(NotSupportedHostInClusterVisitor)
            }
        }

struct NotSupportedHostInClusterVisitor;

impl<'de> de::Visitor<'de> for NotSupportedHostInClusterVisitor {
    type Value = Box<dyn NotSupportedHostInClusterTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid NotSupportedHostInClusterTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl NotSupportedHostInClusterTrait for NotSupportedHostInCluster {
}
impl NotSupportedHostInClusterTrait for EvcAdmissionFailed {
}
impl NotSupportedHostInClusterTrait for EvcAdmissionFailedCpuFeaturesForMode {
}
impl NotSupportedHostInClusterTrait for EvcAdmissionFailedCpuModel {
}
impl NotSupportedHostInClusterTrait for EvcAdmissionFailedCpuModelForMode {
}
impl NotSupportedHostInClusterTrait for EvcAdmissionFailedCpuVendor {
}
impl NotSupportedHostInClusterTrait for EvcAdmissionFailedCpuVendorUnknown {
}
impl NotSupportedHostInClusterTrait for EvcAdmissionFailedHostDisconnected {
}
impl NotSupportedHostInClusterTrait for EvcAdmissionFailedHostSoftware {
}
impl NotSupportedHostInClusterTrait for EvcAdmissionFailedHostSoftwareForMode {
}
impl NotSupportedHostInClusterTrait for EvcAdmissionFailedVmActive {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn NotSupportedHostInClusterTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::NotSupportedHostInCluster => Some(from.as_any_ref().downcast_ref::<NotSupportedHostInCluster>()?),
            StructType::EvcAdmissionFailed => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailed>()?),
            StructType::EvcAdmissionFailedCpuFeaturesForMode => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedCpuFeaturesForMode>()?),
            StructType::EvcAdmissionFailedCpuModel => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedCpuModel>()?),
            StructType::EvcAdmissionFailedCpuModelForMode => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedCpuModelForMode>()?),
            StructType::EvcAdmissionFailedCpuVendor => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedCpuVendor>()?),
            StructType::EvcAdmissionFailedCpuVendorUnknown => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedCpuVendorUnknown>()?),
            StructType::EvcAdmissionFailedHostDisconnected => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedHostDisconnected>()?),
            StructType::EvcAdmissionFailedHostSoftware => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedHostSoftware>()?),
            StructType::EvcAdmissionFailedHostSoftwareForMode => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedHostSoftwareForMode>()?),
            StructType::EvcAdmissionFailedVmActive => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedVmActive>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::NotSupportedHostInCluster => Ok(from.as_any_box().downcast::<NotSupportedHostInCluster>()?),
            StructType::EvcAdmissionFailed => Ok(from.as_any_box().downcast::<EvcAdmissionFailed>()?),
            StructType::EvcAdmissionFailedCpuFeaturesForMode => Ok(from.as_any_box().downcast::<EvcAdmissionFailedCpuFeaturesForMode>()?),
            StructType::EvcAdmissionFailedCpuModel => Ok(from.as_any_box().downcast::<EvcAdmissionFailedCpuModel>()?),
            StructType::EvcAdmissionFailedCpuModelForMode => Ok(from.as_any_box().downcast::<EvcAdmissionFailedCpuModelForMode>()?),
            StructType::EvcAdmissionFailedCpuVendor => Ok(from.as_any_box().downcast::<EvcAdmissionFailedCpuVendor>()?),
            StructType::EvcAdmissionFailedCpuVendorUnknown => Ok(from.as_any_box().downcast::<EvcAdmissionFailedCpuVendorUnknown>()?),
            StructType::EvcAdmissionFailedHostDisconnected => Ok(from.as_any_box().downcast::<EvcAdmissionFailedHostDisconnected>()?),
            StructType::EvcAdmissionFailedHostSoftware => Ok(from.as_any_box().downcast::<EvcAdmissionFailedHostSoftware>()?),
            StructType::EvcAdmissionFailedHostSoftwareForMode => Ok(from.as_any_box().downcast::<EvcAdmissionFailedHostSoftwareForMode>()?),
            StructType::EvcAdmissionFailedVmActive => Ok(from.as_any_box().downcast::<EvcAdmissionFailedVmActive>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The host does not satisfy the admission requirements for the Enhanced
/// VMotion Compatibility mode of the cluster.
pub trait EvcAdmissionFailedTrait : super::traits::NotSupportedHostInClusterTrait {
    /// The faults that caused this EVC test to fail
    /// (e.g.
    /// 
    /// FeatureRequirementsNotMet faults).
    fn get_faults(&self) -> &Option<Vec<Box<dyn super::traits::MethodFaultTrait>>>;
}
impl<'s> serde::Serialize for dyn EvcAdmissionFailedTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn EvcAdmissionFailedTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(EvcAdmissionFailedVisitor)
            }
        }

struct EvcAdmissionFailedVisitor;

impl<'de> de::Visitor<'de> for EvcAdmissionFailedVisitor {
    type Value = Box<dyn EvcAdmissionFailedTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid EvcAdmissionFailedTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl EvcAdmissionFailedTrait for EvcAdmissionFailed {
    fn get_faults(&self) -> &Option<Vec<Box<dyn super::traits::MethodFaultTrait>>> { &self.faults }
}
impl EvcAdmissionFailedTrait for EvcAdmissionFailedCpuFeaturesForMode {
    fn get_faults(&self) -> &Option<Vec<Box<dyn super::traits::MethodFaultTrait>>> { &self.faults }
}
impl EvcAdmissionFailedTrait for EvcAdmissionFailedCpuModel {
    fn get_faults(&self) -> &Option<Vec<Box<dyn super::traits::MethodFaultTrait>>> { &self.faults }
}
impl EvcAdmissionFailedTrait for EvcAdmissionFailedCpuModelForMode {
    fn get_faults(&self) -> &Option<Vec<Box<dyn super::traits::MethodFaultTrait>>> { &self.faults }
}
impl EvcAdmissionFailedTrait for EvcAdmissionFailedCpuVendor {
    fn get_faults(&self) -> &Option<Vec<Box<dyn super::traits::MethodFaultTrait>>> { &self.faults }
}
impl EvcAdmissionFailedTrait for EvcAdmissionFailedCpuVendorUnknown {
    fn get_faults(&self) -> &Option<Vec<Box<dyn super::traits::MethodFaultTrait>>> { &self.faults }
}
impl EvcAdmissionFailedTrait for EvcAdmissionFailedHostDisconnected {
    fn get_faults(&self) -> &Option<Vec<Box<dyn super::traits::MethodFaultTrait>>> { &self.faults }
}
impl EvcAdmissionFailedTrait for EvcAdmissionFailedHostSoftware {
    fn get_faults(&self) -> &Option<Vec<Box<dyn super::traits::MethodFaultTrait>>> { &self.faults }
}
impl EvcAdmissionFailedTrait for EvcAdmissionFailedHostSoftwareForMode {
    fn get_faults(&self) -> &Option<Vec<Box<dyn super::traits::MethodFaultTrait>>> { &self.faults }
}
impl EvcAdmissionFailedTrait for EvcAdmissionFailedVmActive {
    fn get_faults(&self) -> &Option<Vec<Box<dyn super::traits::MethodFaultTrait>>> { &self.faults }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn EvcAdmissionFailedTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::EvcAdmissionFailed => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailed>()?),
            StructType::EvcAdmissionFailedCpuFeaturesForMode => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedCpuFeaturesForMode>()?),
            StructType::EvcAdmissionFailedCpuModel => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedCpuModel>()?),
            StructType::EvcAdmissionFailedCpuModelForMode => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedCpuModelForMode>()?),
            StructType::EvcAdmissionFailedCpuVendor => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedCpuVendor>()?),
            StructType::EvcAdmissionFailedCpuVendorUnknown => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedCpuVendorUnknown>()?),
            StructType::EvcAdmissionFailedHostDisconnected => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedHostDisconnected>()?),
            StructType::EvcAdmissionFailedHostSoftware => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedHostSoftware>()?),
            StructType::EvcAdmissionFailedHostSoftwareForMode => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedHostSoftwareForMode>()?),
            StructType::EvcAdmissionFailedVmActive => Some(from.as_any_ref().downcast_ref::<EvcAdmissionFailedVmActive>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::EvcAdmissionFailed => Ok(from.as_any_box().downcast::<EvcAdmissionFailed>()?),
            StructType::EvcAdmissionFailedCpuFeaturesForMode => Ok(from.as_any_box().downcast::<EvcAdmissionFailedCpuFeaturesForMode>()?),
            StructType::EvcAdmissionFailedCpuModel => Ok(from.as_any_box().downcast::<EvcAdmissionFailedCpuModel>()?),
            StructType::EvcAdmissionFailedCpuModelForMode => Ok(from.as_any_box().downcast::<EvcAdmissionFailedCpuModelForMode>()?),
            StructType::EvcAdmissionFailedCpuVendor => Ok(from.as_any_box().downcast::<EvcAdmissionFailedCpuVendor>()?),
            StructType::EvcAdmissionFailedCpuVendorUnknown => Ok(from.as_any_box().downcast::<EvcAdmissionFailedCpuVendorUnknown>()?),
            StructType::EvcAdmissionFailedHostDisconnected => Ok(from.as_any_box().downcast::<EvcAdmissionFailedHostDisconnected>()?),
            StructType::EvcAdmissionFailedHostSoftware => Ok(from.as_any_box().downcast::<EvcAdmissionFailedHostSoftware>()?),
            StructType::EvcAdmissionFailedHostSoftwareForMode => Ok(from.as_any_box().downcast::<EvcAdmissionFailedHostSoftwareForMode>()?),
            StructType::EvcAdmissionFailedVmActive => Ok(from.as_any_box().downcast::<EvcAdmissionFailedVmActive>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This fault is thrown when a host power operation fails.
pub trait HostPowerOpFailedTrait : super::traits::VimFaultTrait {
}
impl<'s> serde::Serialize for dyn HostPowerOpFailedTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostPowerOpFailedTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostPowerOpFailedVisitor)
            }
        }

struct HostPowerOpFailedVisitor;

impl<'de> de::Visitor<'de> for HostPowerOpFailedVisitor {
    type Value = Box<dyn HostPowerOpFailedTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostPowerOpFailedTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostPowerOpFailedTrait for HostPowerOpFailed {
}
impl HostPowerOpFailedTrait for NoPeerHostFound {
}
impl HostPowerOpFailedTrait for VmotionInterfaceNotEnabled {
}
impl HostPowerOpFailedTrait for WakeOnLanNotSupportedByVmotionNic {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostPowerOpFailedTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostPowerOpFailed => Some(from.as_any_ref().downcast_ref::<HostPowerOpFailed>()?),
            StructType::NoPeerHostFound => Some(from.as_any_ref().downcast_ref::<NoPeerHostFound>()?),
            StructType::VmotionInterfaceNotEnabled => Some(from.as_any_ref().downcast_ref::<VmotionInterfaceNotEnabled>()?),
            StructType::WakeOnLanNotSupportedByVmotionNic => Some(from.as_any_ref().downcast_ref::<WakeOnLanNotSupportedByVmotionNic>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostPowerOpFailed => Ok(from.as_any_box().downcast::<HostPowerOpFailed>()?),
            StructType::NoPeerHostFound => Ok(from.as_any_box().downcast::<NoPeerHostFound>()?),
            StructType::VmotionInterfaceNotEnabled => Ok(from.as_any_box().downcast::<VmotionInterfaceNotEnabled>()?),
            StructType::WakeOnLanNotSupportedByVmotionNic => Ok(from.as_any_box().downcast::<WakeOnLanNotSupportedByVmotionNic>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base fault that occurs when an operation conflicts with a resource configuration
/// policy.
/// 
/// For example, this fault occurs if a power-on operation reserves more memory
/// than is allocated to a resource pool.
pub trait InsufficientResourcesFaultTrait : super::traits::VimFaultTrait {
}
impl<'s> serde::Serialize for dyn InsufficientResourcesFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn InsufficientResourcesFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(InsufficientResourcesFaultVisitor)
            }
        }

struct InsufficientResourcesFaultVisitor;

impl<'de> de::Visitor<'de> for InsufficientResourcesFaultVisitor {
    type Value = Box<dyn InsufficientResourcesFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid InsufficientResourcesFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl InsufficientResourcesFaultTrait for InsufficientResourcesFault {
}
impl InsufficientResourcesFaultTrait for InsufficientAgentVmsDeployed {
}
impl InsufficientResourcesFaultTrait for InsufficientCpuResourcesFault {
}
impl InsufficientResourcesFaultTrait for InsufficientFailoverResourcesFault {
}
impl InsufficientResourcesFaultTrait for InsufficientGraphicsResourcesFault {
}
impl InsufficientResourcesFaultTrait for InsufficientHostCapacityFault {
}
impl InsufficientResourcesFaultTrait for InsufficientHostCpuCapacityFault {
}
impl InsufficientResourcesFaultTrait for InsufficientHostMemoryCapacityFault {
}
impl InsufficientResourcesFaultTrait for InsufficientPerCpuCapacity {
}
impl InsufficientResourcesFaultTrait for InsufficientMemoryResourcesFault {
}
impl InsufficientResourcesFaultTrait for InsufficientNetworkCapacity {
}
impl InsufficientResourcesFaultTrait for InsufficientNetworkResourcePoolCapacity {
}
impl InsufficientResourcesFaultTrait for InsufficientStandbyResource {
}
impl InsufficientResourcesFaultTrait for InsufficientStandbyCpuResource {
}
impl InsufficientResourcesFaultTrait for InsufficientStandbyMemoryResource {
}
impl InsufficientResourcesFaultTrait for InsufficientStorageSpace {
}
impl InsufficientResourcesFaultTrait for InsufficientVFlashResourcesFault {
}
impl InsufficientResourcesFaultTrait for InvalidResourcePoolStructureFault {
}
impl InsufficientResourcesFaultTrait for NumVirtualCpusExceedsLimit {
}
impl InsufficientResourcesFaultTrait for VmFaultToleranceTooManyFtVcpusOnHost {
}
impl InsufficientResourcesFaultTrait for VmFaultToleranceTooManyVMsOnHost {
}
impl InsufficientResourcesFaultTrait for VmSmpFaultToleranceTooManyVMsOnHost {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn InsufficientResourcesFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::InsufficientResourcesFault => Some(from.as_any_ref().downcast_ref::<InsufficientResourcesFault>()?),
            StructType::InsufficientAgentVmsDeployed => Some(from.as_any_ref().downcast_ref::<InsufficientAgentVmsDeployed>()?),
            StructType::InsufficientCpuResourcesFault => Some(from.as_any_ref().downcast_ref::<InsufficientCpuResourcesFault>()?),
            StructType::InsufficientFailoverResourcesFault => Some(from.as_any_ref().downcast_ref::<InsufficientFailoverResourcesFault>()?),
            StructType::InsufficientGraphicsResourcesFault => Some(from.as_any_ref().downcast_ref::<InsufficientGraphicsResourcesFault>()?),
            StructType::InsufficientHostCapacityFault => Some(from.as_any_ref().downcast_ref::<InsufficientHostCapacityFault>()?),
            StructType::InsufficientHostCpuCapacityFault => Some(from.as_any_ref().downcast_ref::<InsufficientHostCpuCapacityFault>()?),
            StructType::InsufficientHostMemoryCapacityFault => Some(from.as_any_ref().downcast_ref::<InsufficientHostMemoryCapacityFault>()?),
            StructType::InsufficientPerCpuCapacity => Some(from.as_any_ref().downcast_ref::<InsufficientPerCpuCapacity>()?),
            StructType::InsufficientMemoryResourcesFault => Some(from.as_any_ref().downcast_ref::<InsufficientMemoryResourcesFault>()?),
            StructType::InsufficientNetworkCapacity => Some(from.as_any_ref().downcast_ref::<InsufficientNetworkCapacity>()?),
            StructType::InsufficientNetworkResourcePoolCapacity => Some(from.as_any_ref().downcast_ref::<InsufficientNetworkResourcePoolCapacity>()?),
            StructType::InsufficientStandbyResource => Some(from.as_any_ref().downcast_ref::<InsufficientStandbyResource>()?),
            StructType::InsufficientStandbyCpuResource => Some(from.as_any_ref().downcast_ref::<InsufficientStandbyCpuResource>()?),
            StructType::InsufficientStandbyMemoryResource => Some(from.as_any_ref().downcast_ref::<InsufficientStandbyMemoryResource>()?),
            StructType::InsufficientStorageSpace => Some(from.as_any_ref().downcast_ref::<InsufficientStorageSpace>()?),
            StructType::InsufficientVFlashResourcesFault => Some(from.as_any_ref().downcast_ref::<InsufficientVFlashResourcesFault>()?),
            StructType::InvalidResourcePoolStructureFault => Some(from.as_any_ref().downcast_ref::<InvalidResourcePoolStructureFault>()?),
            StructType::NumVirtualCpusExceedsLimit => Some(from.as_any_ref().downcast_ref::<NumVirtualCpusExceedsLimit>()?),
            StructType::VmFaultToleranceTooManyFtVcpusOnHost => Some(from.as_any_ref().downcast_ref::<VmFaultToleranceTooManyFtVcpusOnHost>()?),
            StructType::VmFaultToleranceTooManyVMsOnHost => Some(from.as_any_ref().downcast_ref::<VmFaultToleranceTooManyVMsOnHost>()?),
            StructType::VmSmpFaultToleranceTooManyVMsOnHost => Some(from.as_any_ref().downcast_ref::<VmSmpFaultToleranceTooManyVMsOnHost>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::InsufficientResourcesFault => Ok(from.as_any_box().downcast::<InsufficientResourcesFault>()?),
            StructType::InsufficientAgentVmsDeployed => Ok(from.as_any_box().downcast::<InsufficientAgentVmsDeployed>()?),
            StructType::InsufficientCpuResourcesFault => Ok(from.as_any_box().downcast::<InsufficientCpuResourcesFault>()?),
            StructType::InsufficientFailoverResourcesFault => Ok(from.as_any_box().downcast::<InsufficientFailoverResourcesFault>()?),
            StructType::InsufficientGraphicsResourcesFault => Ok(from.as_any_box().downcast::<InsufficientGraphicsResourcesFault>()?),
            StructType::InsufficientHostCapacityFault => Ok(from.as_any_box().downcast::<InsufficientHostCapacityFault>()?),
            StructType::InsufficientHostCpuCapacityFault => Ok(from.as_any_box().downcast::<InsufficientHostCpuCapacityFault>()?),
            StructType::InsufficientHostMemoryCapacityFault => Ok(from.as_any_box().downcast::<InsufficientHostMemoryCapacityFault>()?),
            StructType::InsufficientPerCpuCapacity => Ok(from.as_any_box().downcast::<InsufficientPerCpuCapacity>()?),
            StructType::InsufficientMemoryResourcesFault => Ok(from.as_any_box().downcast::<InsufficientMemoryResourcesFault>()?),
            StructType::InsufficientNetworkCapacity => Ok(from.as_any_box().downcast::<InsufficientNetworkCapacity>()?),
            StructType::InsufficientNetworkResourcePoolCapacity => Ok(from.as_any_box().downcast::<InsufficientNetworkResourcePoolCapacity>()?),
            StructType::InsufficientStandbyResource => Ok(from.as_any_box().downcast::<InsufficientStandbyResource>()?),
            StructType::InsufficientStandbyCpuResource => Ok(from.as_any_box().downcast::<InsufficientStandbyCpuResource>()?),
            StructType::InsufficientStandbyMemoryResource => Ok(from.as_any_box().downcast::<InsufficientStandbyMemoryResource>()?),
            StructType::InsufficientStorageSpace => Ok(from.as_any_box().downcast::<InsufficientStorageSpace>()?),
            StructType::InsufficientVFlashResourcesFault => Ok(from.as_any_box().downcast::<InsufficientVFlashResourcesFault>()?),
            StructType::InvalidResourcePoolStructureFault => Ok(from.as_any_box().downcast::<InvalidResourcePoolStructureFault>()?),
            StructType::NumVirtualCpusExceedsLimit => Ok(from.as_any_box().downcast::<NumVirtualCpusExceedsLimit>()?),
            StructType::VmFaultToleranceTooManyFtVcpusOnHost => Ok(from.as_any_box().downcast::<VmFaultToleranceTooManyFtVcpusOnHost>()?),
            StructType::VmFaultToleranceTooManyVMsOnHost => Ok(from.as_any_box().downcast::<VmFaultToleranceTooManyVMsOnHost>()?),
            StructType::VmSmpFaultToleranceTooManyVMsOnHost => Ok(from.as_any_box().downcast::<VmSmpFaultToleranceTooManyVMsOnHost>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The host does not have enough capacity for running the virtual machine.
pub trait InsufficientHostCapacityFaultTrait : super::traits::InsufficientResourcesFaultTrait {
    /// The host which does not have the enough capacity.
    /// 
    /// Refers instance of *HostSystem*.
    fn get_host(&self) -> &Option<ManagedObjectReference>;
}
impl<'s> serde::Serialize for dyn InsufficientHostCapacityFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn InsufficientHostCapacityFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(InsufficientHostCapacityFaultVisitor)
            }
        }

struct InsufficientHostCapacityFaultVisitor;

impl<'de> de::Visitor<'de> for InsufficientHostCapacityFaultVisitor {
    type Value = Box<dyn InsufficientHostCapacityFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid InsufficientHostCapacityFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl InsufficientHostCapacityFaultTrait for InsufficientHostCapacityFault {
    fn get_host(&self) -> &Option<ManagedObjectReference> { &self.host }
}
impl InsufficientHostCapacityFaultTrait for InsufficientHostCpuCapacityFault {
    fn get_host(&self) -> &Option<ManagedObjectReference> { &self.host }
}
impl InsufficientHostCapacityFaultTrait for InsufficientHostMemoryCapacityFault {
    fn get_host(&self) -> &Option<ManagedObjectReference> { &self.host }
}
impl InsufficientHostCapacityFaultTrait for InsufficientPerCpuCapacity {
    fn get_host(&self) -> &Option<ManagedObjectReference> { &self.host }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn InsufficientHostCapacityFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::InsufficientHostCapacityFault => Some(from.as_any_ref().downcast_ref::<InsufficientHostCapacityFault>()?),
            StructType::InsufficientHostCpuCapacityFault => Some(from.as_any_ref().downcast_ref::<InsufficientHostCpuCapacityFault>()?),
            StructType::InsufficientHostMemoryCapacityFault => Some(from.as_any_ref().downcast_ref::<InsufficientHostMemoryCapacityFault>()?),
            StructType::InsufficientPerCpuCapacity => Some(from.as_any_ref().downcast_ref::<InsufficientPerCpuCapacity>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::InsufficientHostCapacityFault => Ok(from.as_any_box().downcast::<InsufficientHostCapacityFault>()?),
            StructType::InsufficientHostCpuCapacityFault => Ok(from.as_any_box().downcast::<InsufficientHostCpuCapacityFault>()?),
            StructType::InsufficientHostMemoryCapacityFault => Ok(from.as_any_box().downcast::<InsufficientHostMemoryCapacityFault>()?),
            StructType::InsufficientPerCpuCapacity => Ok(from.as_any_box().downcast::<InsufficientPerCpuCapacity>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This fault is thrown when Distributed Power Management cannot perform
/// a given opeartion because there are insufficient CPU/memory resources
/// on standby hosts (if any) to meet the requirements of the operation.
pub trait InsufficientStandbyResourceTrait : super::traits::InsufficientResourcesFaultTrait {
}
impl<'s> serde::Serialize for dyn InsufficientStandbyResourceTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn InsufficientStandbyResourceTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(InsufficientStandbyResourceVisitor)
            }
        }

struct InsufficientStandbyResourceVisitor;

impl<'de> de::Visitor<'de> for InsufficientStandbyResourceVisitor {
    type Value = Box<dyn InsufficientStandbyResourceTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid InsufficientStandbyResourceTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl InsufficientStandbyResourceTrait for InsufficientStandbyResource {
}
impl InsufficientStandbyResourceTrait for InsufficientStandbyCpuResource {
}
impl InsufficientStandbyResourceTrait for InsufficientStandbyMemoryResource {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn InsufficientStandbyResourceTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::InsufficientStandbyResource => Some(from.as_any_ref().downcast_ref::<InsufficientStandbyResource>()?),
            StructType::InsufficientStandbyCpuResource => Some(from.as_any_ref().downcast_ref::<InsufficientStandbyCpuResource>()?),
            StructType::InsufficientStandbyMemoryResource => Some(from.as_any_ref().downcast_ref::<InsufficientStandbyMemoryResource>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::InsufficientStandbyResource => Ok(from.as_any_box().downcast::<InsufficientStandbyResource>()?),
            StructType::InsufficientStandbyCpuResource => Ok(from.as_any_box().downcast::<InsufficientStandbyCpuResource>()?),
            StructType::InsufficientStandbyMemoryResource => Ok(from.as_any_box().downcast::<InsufficientStandbyMemoryResource>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// An InvalidDatastore exception is thrown if an operation fails because of a
/// problem with the specified datastore.
/// 
/// Typically, a subclass of this
/// exception is thrown, indicating a problem such as an inaccessible datastore
/// or an invalid datastore path.
pub trait InvalidDatastoreTrait : super::traits::VimFaultTrait {
    /// The datastore that is invalid.
    /// 
    /// Refers instance of *Datastore*.
    fn get_datastore(&self) -> &Option<ManagedObjectReference>;
    /// The name of the datastore that is invalid.
    fn get_name(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn InvalidDatastoreTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn InvalidDatastoreTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(InvalidDatastoreVisitor)
            }
        }

struct InvalidDatastoreVisitor;

impl<'de> de::Visitor<'de> for InvalidDatastoreVisitor {
    type Value = Box<dyn InvalidDatastoreTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid InvalidDatastoreTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl InvalidDatastoreTrait for InvalidDatastore {
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
    fn get_name(&self) -> &Option<String> { &self.name }
}
impl InvalidDatastoreTrait for DatastoreNotWritableOnHost {
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
    fn get_name(&self) -> &Option<String> { &self.name }
}
impl InvalidDatastoreTrait for SwapDatastoreNotWritableOnHost {
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
    fn get_name(&self) -> &Option<String> { &self.name }
}
impl InvalidDatastoreTrait for InaccessibleDatastore {
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
    fn get_name(&self) -> &Option<String> { &self.name }
}
impl InvalidDatastoreTrait for InaccessibleFtMetadataDatastore {
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
    fn get_name(&self) -> &Option<String> { &self.name }
}
impl InvalidDatastoreTrait for InvalidDatastorePath {
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
    fn get_name(&self) -> &Option<String> { &self.name }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn InvalidDatastoreTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::InvalidDatastore => Some(from.as_any_ref().downcast_ref::<InvalidDatastore>()?),
            StructType::DatastoreNotWritableOnHost => Some(from.as_any_ref().downcast_ref::<DatastoreNotWritableOnHost>()?),
            StructType::SwapDatastoreNotWritableOnHost => Some(from.as_any_ref().downcast_ref::<SwapDatastoreNotWritableOnHost>()?),
            StructType::InaccessibleDatastore => Some(from.as_any_ref().downcast_ref::<InaccessibleDatastore>()?),
            StructType::InaccessibleFtMetadataDatastore => Some(from.as_any_ref().downcast_ref::<InaccessibleFtMetadataDatastore>()?),
            StructType::InvalidDatastorePath => Some(from.as_any_ref().downcast_ref::<InvalidDatastorePath>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::InvalidDatastore => Ok(from.as_any_box().downcast::<InvalidDatastore>()?),
            StructType::DatastoreNotWritableOnHost => Ok(from.as_any_box().downcast::<DatastoreNotWritableOnHost>()?),
            StructType::SwapDatastoreNotWritableOnHost => Ok(from.as_any_box().downcast::<SwapDatastoreNotWritableOnHost>()?),
            StructType::InaccessibleDatastore => Ok(from.as_any_box().downcast::<InaccessibleDatastore>()?),
            StructType::InaccessibleFtMetadataDatastore => Ok(from.as_any_box().downcast::<InaccessibleFtMetadataDatastore>()?),
            StructType::InvalidDatastorePath => Ok(from.as_any_box().downcast::<InvalidDatastorePath>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This exception is thrown if a datastore is not
/// writable on the target host.
pub trait DatastoreNotWritableOnHostTrait : super::traits::InvalidDatastoreTrait {
    /// The target host on which the datastore is not writable.
    /// 
    /// Refers instance of *HostSystem*.
    fn get_host(&self) -> &ManagedObjectReference;
}
impl<'s> serde::Serialize for dyn DatastoreNotWritableOnHostTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DatastoreNotWritableOnHostTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DatastoreNotWritableOnHostVisitor)
            }
        }

struct DatastoreNotWritableOnHostVisitor;

impl<'de> de::Visitor<'de> for DatastoreNotWritableOnHostVisitor {
    type Value = Box<dyn DatastoreNotWritableOnHostTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DatastoreNotWritableOnHostTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DatastoreNotWritableOnHostTrait for DatastoreNotWritableOnHost {
    fn get_host(&self) -> &ManagedObjectReference { &self.host }
}
impl DatastoreNotWritableOnHostTrait for SwapDatastoreNotWritableOnHost {
    fn get_host(&self) -> &ManagedObjectReference { &self.host }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DatastoreNotWritableOnHostTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DatastoreNotWritableOnHost => Some(from.as_any_ref().downcast_ref::<DatastoreNotWritableOnHost>()?),
            StructType::SwapDatastoreNotWritableOnHost => Some(from.as_any_ref().downcast_ref::<SwapDatastoreNotWritableOnHost>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DatastoreNotWritableOnHost => Ok(from.as_any_box().downcast::<DatastoreNotWritableOnHost>()?),
            StructType::SwapDatastoreNotWritableOnHost => Ok(from.as_any_box().downcast::<SwapDatastoreNotWritableOnHost>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// An InaccessibleDatastore exception is thrown if the datastore corresponding to the
/// given datastore path isn't currently accessible.
pub trait InaccessibleDatastoreTrait : super::traits::InvalidDatastoreTrait {
    fn get_detail(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn InaccessibleDatastoreTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn InaccessibleDatastoreTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(InaccessibleDatastoreVisitor)
            }
        }

struct InaccessibleDatastoreVisitor;

impl<'de> de::Visitor<'de> for InaccessibleDatastoreVisitor {
    type Value = Box<dyn InaccessibleDatastoreTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid InaccessibleDatastoreTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl InaccessibleDatastoreTrait for InaccessibleDatastore {
    fn get_detail(&self) -> &Option<String> { &self.detail }
}
impl InaccessibleDatastoreTrait for InaccessibleFtMetadataDatastore {
    fn get_detail(&self) -> &Option<String> { &self.detail }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn InaccessibleDatastoreTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::InaccessibleDatastore => Some(from.as_any_ref().downcast_ref::<InaccessibleDatastore>()?),
            StructType::InaccessibleFtMetadataDatastore => Some(from.as_any_ref().downcast_ref::<InaccessibleFtMetadataDatastore>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::InaccessibleDatastore => Ok(from.as_any_box().downcast::<InaccessibleDatastore>()?),
            StructType::InaccessibleFtMetadataDatastore => Ok(from.as_any_box().downcast::<InaccessibleFtMetadataDatastore>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// An InvalidFolderFault exception is thrown when a
/// node is moved to an invalid place in the hierarchy.
/// 
/// This can be because it is a child of the current node,
/// or a wrong kind of container.
pub trait InvalidFolderTrait : super::traits::VimFaultTrait {
    /// Reference to invalid target.
    /// 
    /// Refers instance of *ManagedEntity*.
    fn get_target(&self) -> &ManagedObjectReference;
}
impl<'s> serde::Serialize for dyn InvalidFolderTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn InvalidFolderTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(InvalidFolderVisitor)
            }
        }

struct InvalidFolderVisitor;

impl<'de> de::Visitor<'de> for InvalidFolderVisitor {
    type Value = Box<dyn InvalidFolderTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid InvalidFolderTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl InvalidFolderTrait for InvalidFolder {
    fn get_target(&self) -> &ManagedObjectReference { &self.target }
}
impl InvalidFolderTrait for VmAlreadyExistsInDatacenter {
    fn get_target(&self) -> &ManagedObjectReference { &self.target }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn InvalidFolderTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::InvalidFolder => Some(from.as_any_ref().downcast_ref::<InvalidFolder>()?),
            StructType::VmAlreadyExistsInDatacenter => Some(from.as_any_ref().downcast_ref::<VmAlreadyExistsInDatacenter>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::InvalidFolder => Ok(from.as_any_box().downcast::<InvalidFolder>()?),
            StructType::VmAlreadyExistsInDatacenter => Ok(from.as_any_box().downcast::<VmAlreadyExistsInDatacenter>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Thrown when a server logon fails due to a bad user name or
/// password.
pub trait InvalidLoginTrait : super::traits::VimFaultTrait {
}
impl<'s> serde::Serialize for dyn InvalidLoginTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn InvalidLoginTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(InvalidLoginVisitor)
            }
        }

struct InvalidLoginVisitor;

impl<'de> de::Visitor<'de> for InvalidLoginVisitor {
    type Value = Box<dyn InvalidLoginTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid InvalidLoginTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl InvalidLoginTrait for InvalidLogin {
}
impl InvalidLoginTrait for InvalidClientCertificate {
}
impl InvalidLoginTrait for PasswordExpired {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn InvalidLoginTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::InvalidLogin => Some(from.as_any_ref().downcast_ref::<InvalidLogin>()?),
            StructType::InvalidClientCertificate => Some(from.as_any_ref().downcast_ref::<InvalidClientCertificate>()?),
            StructType::PasswordExpired => Some(from.as_any_ref().downcast_ref::<PasswordExpired>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::InvalidLogin => Ok(from.as_any_box().downcast::<InvalidLogin>()?),
            StructType::InvalidClientCertificate => Ok(from.as_any_box().downcast::<InvalidClientCertificate>()?),
            StructType::PasswordExpired => Ok(from.as_any_box().downcast::<PasswordExpired>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// An InvalidState fault is thrown if the
/// operation failed due to the current state of the system.
pub trait InvalidStateTrait : super::traits::VimFaultTrait {
}
impl<'s> serde::Serialize for dyn InvalidStateTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn InvalidStateTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(InvalidStateVisitor)
            }
        }

struct InvalidStateVisitor;

impl<'de> de::Visitor<'de> for InvalidStateVisitor {
    type Value = Box<dyn InvalidStateTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid InvalidStateTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl InvalidStateTrait for InvalidState {
}
impl InvalidStateTrait for CannotPowerOffVmInCluster {
}
impl InvalidStateTrait for EncryptionKeyRequired {
}
impl InvalidStateTrait for InvalidDatastoreState {
}
impl InvalidStateTrait for InvalidHostState {
}
impl InvalidStateTrait for InvalidHostConnectionState {
}
impl InvalidStateTrait for InvalidPowerState {
}
impl InvalidStateTrait for InvalidVmState {
}
impl InvalidStateTrait for MksConnectionLimitReached {
}
impl InvalidStateTrait for NoActiveHostInCluster {
}
impl InvalidStateTrait for OvfConsumerPowerOnFault {
}
impl InvalidStateTrait for QuestionPending {
}
impl InvalidStateTrait for VmPowerOnDisabled {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn InvalidStateTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::InvalidState => Some(from.as_any_ref().downcast_ref::<InvalidState>()?),
            StructType::CannotPowerOffVmInCluster => Some(from.as_any_ref().downcast_ref::<CannotPowerOffVmInCluster>()?),
            StructType::EncryptionKeyRequired => Some(from.as_any_ref().downcast_ref::<EncryptionKeyRequired>()?),
            StructType::InvalidDatastoreState => Some(from.as_any_ref().downcast_ref::<InvalidDatastoreState>()?),
            StructType::InvalidHostState => Some(from.as_any_ref().downcast_ref::<InvalidHostState>()?),
            StructType::InvalidHostConnectionState => Some(from.as_any_ref().downcast_ref::<InvalidHostConnectionState>()?),
            StructType::InvalidPowerState => Some(from.as_any_ref().downcast_ref::<InvalidPowerState>()?),
            StructType::InvalidVmState => Some(from.as_any_ref().downcast_ref::<InvalidVmState>()?),
            StructType::MksConnectionLimitReached => Some(from.as_any_ref().downcast_ref::<MksConnectionLimitReached>()?),
            StructType::NoActiveHostInCluster => Some(from.as_any_ref().downcast_ref::<NoActiveHostInCluster>()?),
            StructType::OvfConsumerPowerOnFault => Some(from.as_any_ref().downcast_ref::<OvfConsumerPowerOnFault>()?),
            StructType::QuestionPending => Some(from.as_any_ref().downcast_ref::<QuestionPending>()?),
            StructType::VmPowerOnDisabled => Some(from.as_any_ref().downcast_ref::<VmPowerOnDisabled>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::InvalidState => Ok(from.as_any_box().downcast::<InvalidState>()?),
            StructType::CannotPowerOffVmInCluster => Ok(from.as_any_box().downcast::<CannotPowerOffVmInCluster>()?),
            StructType::EncryptionKeyRequired => Ok(from.as_any_box().downcast::<EncryptionKeyRequired>()?),
            StructType::InvalidDatastoreState => Ok(from.as_any_box().downcast::<InvalidDatastoreState>()?),
            StructType::InvalidHostState => Ok(from.as_any_box().downcast::<InvalidHostState>()?),
            StructType::InvalidHostConnectionState => Ok(from.as_any_box().downcast::<InvalidHostConnectionState>()?),
            StructType::InvalidPowerState => Ok(from.as_any_box().downcast::<InvalidPowerState>()?),
            StructType::InvalidVmState => Ok(from.as_any_box().downcast::<InvalidVmState>()?),
            StructType::MksConnectionLimitReached => Ok(from.as_any_box().downcast::<MksConnectionLimitReached>()?),
            StructType::NoActiveHostInCluster => Ok(from.as_any_box().downcast::<NoActiveHostInCluster>()?),
            StructType::OvfConsumerPowerOnFault => Ok(from.as_any_box().downcast::<OvfConsumerPowerOnFault>()?),
            StructType::QuestionPending => Ok(from.as_any_box().downcast::<QuestionPending>()?),
            StructType::VmPowerOnDisabled => Ok(from.as_any_box().downcast::<VmPowerOnDisabled>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The host has an invalid state.
pub trait InvalidHostStateTrait : super::traits::InvalidStateTrait {
    /// The host that has an invalid state.
    /// 
    /// Refers instance of *HostSystem*.
    fn get_host(&self) -> &Option<ManagedObjectReference>;
}
impl<'s> serde::Serialize for dyn InvalidHostStateTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn InvalidHostStateTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(InvalidHostStateVisitor)
            }
        }

struct InvalidHostStateVisitor;

impl<'de> de::Visitor<'de> for InvalidHostStateVisitor {
    type Value = Box<dyn InvalidHostStateTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid InvalidHostStateTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl InvalidHostStateTrait for InvalidHostState {
    fn get_host(&self) -> &Option<ManagedObjectReference> { &self.host }
}
impl InvalidHostStateTrait for InvalidHostConnectionState {
    fn get_host(&self) -> &Option<ManagedObjectReference> { &self.host }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn InvalidHostStateTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::InvalidHostState => Some(from.as_any_ref().downcast_ref::<InvalidHostState>()?),
            StructType::InvalidHostConnectionState => Some(from.as_any_ref().downcast_ref::<InvalidHostConnectionState>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::InvalidHostState => Ok(from.as_any_box().downcast::<InvalidHostState>()?),
            StructType::InvalidHostConnectionState => Ok(from.as_any_box().downcast::<InvalidHostConnectionState>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base class for faults that can be thrown while invoking iSCSI management operations.
pub trait IscsiFaultTrait : super::traits::VimFaultTrait {
}
impl<'s> serde::Serialize for dyn IscsiFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn IscsiFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(IscsiFaultVisitor)
            }
        }

struct IscsiFaultVisitor;

impl<'de> de::Visitor<'de> for IscsiFaultVisitor {
    type Value = Box<dyn IscsiFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid IscsiFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl IscsiFaultTrait for IscsiFault {
}
impl IscsiFaultTrait for IscsiFaultInvalidVnic {
}
impl IscsiFaultTrait for IscsiFaultPnicInUse {
}
impl IscsiFaultTrait for IscsiFaultVnicAlreadyBound {
}
impl IscsiFaultTrait for IscsiFaultVnicHasActivePaths {
}
impl IscsiFaultTrait for IscsiFaultVnicHasMultipleUplinks {
}
impl IscsiFaultTrait for IscsiFaultVnicHasNoUplinks {
}
impl IscsiFaultTrait for IscsiFaultVnicHasWrongUplink {
}
impl IscsiFaultTrait for IscsiFaultVnicInUse {
}
impl IscsiFaultTrait for IscsiFaultVnicIsLastPath {
}
impl IscsiFaultTrait for IscsiFaultVnicNotBound {
}
impl IscsiFaultTrait for IscsiFaultVnicNotFound {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn IscsiFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::IscsiFault => Some(from.as_any_ref().downcast_ref::<IscsiFault>()?),
            StructType::IscsiFaultInvalidVnic => Some(from.as_any_ref().downcast_ref::<IscsiFaultInvalidVnic>()?),
            StructType::IscsiFaultPnicInUse => Some(from.as_any_ref().downcast_ref::<IscsiFaultPnicInUse>()?),
            StructType::IscsiFaultVnicAlreadyBound => Some(from.as_any_ref().downcast_ref::<IscsiFaultVnicAlreadyBound>()?),
            StructType::IscsiFaultVnicHasActivePaths => Some(from.as_any_ref().downcast_ref::<IscsiFaultVnicHasActivePaths>()?),
            StructType::IscsiFaultVnicHasMultipleUplinks => Some(from.as_any_ref().downcast_ref::<IscsiFaultVnicHasMultipleUplinks>()?),
            StructType::IscsiFaultVnicHasNoUplinks => Some(from.as_any_ref().downcast_ref::<IscsiFaultVnicHasNoUplinks>()?),
            StructType::IscsiFaultVnicHasWrongUplink => Some(from.as_any_ref().downcast_ref::<IscsiFaultVnicHasWrongUplink>()?),
            StructType::IscsiFaultVnicInUse => Some(from.as_any_ref().downcast_ref::<IscsiFaultVnicInUse>()?),
            StructType::IscsiFaultVnicIsLastPath => Some(from.as_any_ref().downcast_ref::<IscsiFaultVnicIsLastPath>()?),
            StructType::IscsiFaultVnicNotBound => Some(from.as_any_ref().downcast_ref::<IscsiFaultVnicNotBound>()?),
            StructType::IscsiFaultVnicNotFound => Some(from.as_any_ref().downcast_ref::<IscsiFaultVnicNotFound>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::IscsiFault => Ok(from.as_any_box().downcast::<IscsiFault>()?),
            StructType::IscsiFaultInvalidVnic => Ok(from.as_any_box().downcast::<IscsiFaultInvalidVnic>()?),
            StructType::IscsiFaultPnicInUse => Ok(from.as_any_box().downcast::<IscsiFaultPnicInUse>()?),
            StructType::IscsiFaultVnicAlreadyBound => Ok(from.as_any_box().downcast::<IscsiFaultVnicAlreadyBound>()?),
            StructType::IscsiFaultVnicHasActivePaths => Ok(from.as_any_box().downcast::<IscsiFaultVnicHasActivePaths>()?),
            StructType::IscsiFaultVnicHasMultipleUplinks => Ok(from.as_any_box().downcast::<IscsiFaultVnicHasMultipleUplinks>()?),
            StructType::IscsiFaultVnicHasNoUplinks => Ok(from.as_any_box().downcast::<IscsiFaultVnicHasNoUplinks>()?),
            StructType::IscsiFaultVnicHasWrongUplink => Ok(from.as_any_box().downcast::<IscsiFaultVnicHasWrongUplink>()?),
            StructType::IscsiFaultVnicInUse => Ok(from.as_any_box().downcast::<IscsiFaultVnicInUse>()?),
            StructType::IscsiFaultVnicIsLastPath => Ok(from.as_any_box().downcast::<IscsiFaultVnicIsLastPath>()?),
            StructType::IscsiFaultVnicNotBound => Ok(from.as_any_box().downcast::<IscsiFaultVnicNotBound>()?),
            StructType::IscsiFaultVnicNotFound => Ok(from.as_any_box().downcast::<IscsiFaultVnicNotFound>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base object type for issues that can occur when reassigning the execution
/// host of a virtual machine using migrate or relocate.
/// 
/// These issues are typically
/// used as argument in the MigrationEvent. When a MigrationFault is used as a value
/// in a MigrationEvent, the type of MigrationEvent determines if the issue is a
/// warning or an error (for example, MigrationHostWarningEvent or
/// MigrationHostErrorEvent). When thrown as an exception, the fault is an error.
/// 
/// Issues are categorized as errors or warnings according to the following
/// criteria:
/// 
/// If the virtual machine is powered on:
/// 1. Error for fatal problems with the VMotion interfaces or licensing.
/// 2. Error if VMotion would fail.
/// 3. Error if VMotion would in any way interrupt the continuous and consistent
///    operation of the virtual machine.
/// 4. Warning for potential performance or connectivity problems between the
///    source and destination VMotion interfaces.
/// 5. Warning if the virtual machine's currently disconnected devices may not
///    be connectable after VMotion.
///    
/// If the virtual machine is powered off or suspended:
/// 1. Error if the destination host cannot access all the files that comprise
///    the virtual machine (including virtual disks).
/// 2. Error if aspects of the virtual machine are not supported by the
///    destination host's hardware or software.
/// 3. Warning if problems would occur when powering on or resuming the
///    virtual machine, if the usage/configuration of the destination
///    host were to remain in its current state.
pub trait MigrationFaultTrait : super::traits::VimFaultTrait {
}
impl<'s> serde::Serialize for dyn MigrationFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn MigrationFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(MigrationFaultVisitor)
            }
        }

struct MigrationFaultVisitor;

impl<'de> de::Visitor<'de> for MigrationFaultVisitor {
    type Value = Box<dyn MigrationFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid MigrationFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl MigrationFaultTrait for MigrationFault {
}
impl MigrationFaultTrait for AffinityConfigured {
}
impl MigrationFaultTrait for CannotModifyConfigCpuRequirements {
}
impl MigrationFaultTrait for CannotMoveVmWithDeltaDisk {
}
impl MigrationFaultTrait for CannotMoveVmWithNativeDeltaDisk {
}
impl MigrationFaultTrait for CloneFromSnapshotNotSupported {
}
impl MigrationFaultTrait for DatacenterMismatch {
}
impl MigrationFaultTrait for DisallowedMigrationDeviceAttached {
}
impl MigrationFaultTrait for DiskMoveTypeNotSupported {
}
impl MigrationFaultTrait for FaultToleranceAntiAffinityViolated {
}
impl MigrationFaultTrait for FaultToleranceNeedsThickDisk {
}
impl MigrationFaultTrait for FaultToleranceNotSameBuild {
}
impl MigrationFaultTrait for HaErrorsAtDest {
}
impl MigrationFaultTrait for IncompatibleDefaultDevice {
}
impl MigrationFaultTrait for LargeRdmConversionNotSupported {
}
impl MigrationFaultTrait for MaintenanceModeFileMove {
}
impl MigrationFaultTrait for MigrationDisabled {
}
impl MigrationFaultTrait for MigrationFeatureNotSupported {
}
impl MigrationFaultTrait for FullStorageVMotionNotSupported {
}
impl MigrationFaultTrait for IndependentDiskVMotionNotSupported {
}
impl MigrationFaultTrait for NonHomeRdmvMotionNotSupported {
}
impl MigrationFaultTrait for StorageVMotionNotSupported {
}
impl MigrationFaultTrait for UnsharedSwapVMotionNotSupported {
}
impl MigrationFaultTrait for VMotionAcrossNetworkNotSupported {
}
impl MigrationFaultTrait for MigrationNotReady {
}
impl MigrationFaultTrait for MismatchedNetworkPolicies {
}
impl MigrationFaultTrait for MismatchedVMotionNetworkNames {
}
impl MigrationFaultTrait for NetworksMayNotBeTheSame {
}
impl MigrationFaultTrait for NoGuestHeartbeat {
}
impl MigrationFaultTrait for RdmConversionNotSupported {
}
impl MigrationFaultTrait for RdmNotPreserved {
}
impl MigrationFaultTrait for ReadOnlyDisksWithLegacyDestination {
}
impl MigrationFaultTrait for SnapshotCopyNotSupported {
}
impl MigrationFaultTrait for HotSnapshotMoveNotSupported {
}
impl MigrationFaultTrait for SnapshotCloneNotSupported {
}
impl MigrationFaultTrait for SnapshotMoveFromNonHomeNotSupported {
}
impl MigrationFaultTrait for SnapshotMoveNotSupported {
}
impl MigrationFaultTrait for SnapshotMoveToNonHomeNotSupported {
}
impl MigrationFaultTrait for SnapshotRevertIssue {
}
impl MigrationFaultTrait for SuspendedRelocateNotSupported {
}
impl MigrationFaultTrait for TooManyDisksOnLegacyHost {
}
impl MigrationFaultTrait for ToolsInstallationInProgress {
}
impl MigrationFaultTrait for UncommittedUndoableDisk {
}
impl MigrationFaultTrait for VMotionInterfaceIssue {
}
impl MigrationFaultTrait for VMotionLinkCapacityLow {
}
impl MigrationFaultTrait for VMotionLinkDown {
}
impl MigrationFaultTrait for VMotionNotConfigured {
}
impl MigrationFaultTrait for VMotionNotLicensed {
}
impl MigrationFaultTrait for VMotionNotSupported {
}
impl MigrationFaultTrait for VMotionProtocolIncompatible {
}
impl MigrationFaultTrait for WillLoseHaProtection {
}
impl MigrationFaultTrait for WillModifyConfigCpuRequirements {
}
impl MigrationFaultTrait for WillResetSnapshotDirectory {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn MigrationFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::MigrationFault => Some(from.as_any_ref().downcast_ref::<MigrationFault>()?),
            StructType::AffinityConfigured => Some(from.as_any_ref().downcast_ref::<AffinityConfigured>()?),
            StructType::CannotModifyConfigCpuRequirements => Some(from.as_any_ref().downcast_ref::<CannotModifyConfigCpuRequirements>()?),
            StructType::CannotMoveVmWithDeltaDisk => Some(from.as_any_ref().downcast_ref::<CannotMoveVmWithDeltaDisk>()?),
            StructType::CannotMoveVmWithNativeDeltaDisk => Some(from.as_any_ref().downcast_ref::<CannotMoveVmWithNativeDeltaDisk>()?),
            StructType::CloneFromSnapshotNotSupported => Some(from.as_any_ref().downcast_ref::<CloneFromSnapshotNotSupported>()?),
            StructType::DatacenterMismatch => Some(from.as_any_ref().downcast_ref::<DatacenterMismatch>()?),
            StructType::DisallowedMigrationDeviceAttached => Some(from.as_any_ref().downcast_ref::<DisallowedMigrationDeviceAttached>()?),
            StructType::DiskMoveTypeNotSupported => Some(from.as_any_ref().downcast_ref::<DiskMoveTypeNotSupported>()?),
            StructType::FaultToleranceAntiAffinityViolated => Some(from.as_any_ref().downcast_ref::<FaultToleranceAntiAffinityViolated>()?),
            StructType::FaultToleranceNeedsThickDisk => Some(from.as_any_ref().downcast_ref::<FaultToleranceNeedsThickDisk>()?),
            StructType::FaultToleranceNotSameBuild => Some(from.as_any_ref().downcast_ref::<FaultToleranceNotSameBuild>()?),
            StructType::HaErrorsAtDest => Some(from.as_any_ref().downcast_ref::<HaErrorsAtDest>()?),
            StructType::IncompatibleDefaultDevice => Some(from.as_any_ref().downcast_ref::<IncompatibleDefaultDevice>()?),
            StructType::LargeRdmConversionNotSupported => Some(from.as_any_ref().downcast_ref::<LargeRdmConversionNotSupported>()?),
            StructType::MaintenanceModeFileMove => Some(from.as_any_ref().downcast_ref::<MaintenanceModeFileMove>()?),
            StructType::MigrationDisabled => Some(from.as_any_ref().downcast_ref::<MigrationDisabled>()?),
            StructType::MigrationFeatureNotSupported => Some(from.as_any_ref().downcast_ref::<MigrationFeatureNotSupported>()?),
            StructType::FullStorageVMotionNotSupported => Some(from.as_any_ref().downcast_ref::<FullStorageVMotionNotSupported>()?),
            StructType::IndependentDiskVMotionNotSupported => Some(from.as_any_ref().downcast_ref::<IndependentDiskVMotionNotSupported>()?),
            StructType::NonHomeRdmvMotionNotSupported => Some(from.as_any_ref().downcast_ref::<NonHomeRdmvMotionNotSupported>()?),
            StructType::StorageVMotionNotSupported => Some(from.as_any_ref().downcast_ref::<StorageVMotionNotSupported>()?),
            StructType::UnsharedSwapVMotionNotSupported => Some(from.as_any_ref().downcast_ref::<UnsharedSwapVMotionNotSupported>()?),
            StructType::VMotionAcrossNetworkNotSupported => Some(from.as_any_ref().downcast_ref::<VMotionAcrossNetworkNotSupported>()?),
            StructType::MigrationNotReady => Some(from.as_any_ref().downcast_ref::<MigrationNotReady>()?),
            StructType::MismatchedNetworkPolicies => Some(from.as_any_ref().downcast_ref::<MismatchedNetworkPolicies>()?),
            StructType::MismatchedVMotionNetworkNames => Some(from.as_any_ref().downcast_ref::<MismatchedVMotionNetworkNames>()?),
            StructType::NetworksMayNotBeTheSame => Some(from.as_any_ref().downcast_ref::<NetworksMayNotBeTheSame>()?),
            StructType::NoGuestHeartbeat => Some(from.as_any_ref().downcast_ref::<NoGuestHeartbeat>()?),
            StructType::RdmConversionNotSupported => Some(from.as_any_ref().downcast_ref::<RdmConversionNotSupported>()?),
            StructType::RdmNotPreserved => Some(from.as_any_ref().downcast_ref::<RdmNotPreserved>()?),
            StructType::ReadOnlyDisksWithLegacyDestination => Some(from.as_any_ref().downcast_ref::<ReadOnlyDisksWithLegacyDestination>()?),
            StructType::SnapshotCopyNotSupported => Some(from.as_any_ref().downcast_ref::<SnapshotCopyNotSupported>()?),
            StructType::HotSnapshotMoveNotSupported => Some(from.as_any_ref().downcast_ref::<HotSnapshotMoveNotSupported>()?),
            StructType::SnapshotCloneNotSupported => Some(from.as_any_ref().downcast_ref::<SnapshotCloneNotSupported>()?),
            StructType::SnapshotMoveFromNonHomeNotSupported => Some(from.as_any_ref().downcast_ref::<SnapshotMoveFromNonHomeNotSupported>()?),
            StructType::SnapshotMoveNotSupported => Some(from.as_any_ref().downcast_ref::<SnapshotMoveNotSupported>()?),
            StructType::SnapshotMoveToNonHomeNotSupported => Some(from.as_any_ref().downcast_ref::<SnapshotMoveToNonHomeNotSupported>()?),
            StructType::SnapshotRevertIssue => Some(from.as_any_ref().downcast_ref::<SnapshotRevertIssue>()?),
            StructType::SuspendedRelocateNotSupported => Some(from.as_any_ref().downcast_ref::<SuspendedRelocateNotSupported>()?),
            StructType::TooManyDisksOnLegacyHost => Some(from.as_any_ref().downcast_ref::<TooManyDisksOnLegacyHost>()?),
            StructType::ToolsInstallationInProgress => Some(from.as_any_ref().downcast_ref::<ToolsInstallationInProgress>()?),
            StructType::UncommittedUndoableDisk => Some(from.as_any_ref().downcast_ref::<UncommittedUndoableDisk>()?),
            StructType::VMotionInterfaceIssue => Some(from.as_any_ref().downcast_ref::<VMotionInterfaceIssue>()?),
            StructType::VMotionLinkCapacityLow => Some(from.as_any_ref().downcast_ref::<VMotionLinkCapacityLow>()?),
            StructType::VMotionLinkDown => Some(from.as_any_ref().downcast_ref::<VMotionLinkDown>()?),
            StructType::VMotionNotConfigured => Some(from.as_any_ref().downcast_ref::<VMotionNotConfigured>()?),
            StructType::VMotionNotLicensed => Some(from.as_any_ref().downcast_ref::<VMotionNotLicensed>()?),
            StructType::VMotionNotSupported => Some(from.as_any_ref().downcast_ref::<VMotionNotSupported>()?),
            StructType::VMotionProtocolIncompatible => Some(from.as_any_ref().downcast_ref::<VMotionProtocolIncompatible>()?),
            StructType::WillLoseHaProtection => Some(from.as_any_ref().downcast_ref::<WillLoseHaProtection>()?),
            StructType::WillModifyConfigCpuRequirements => Some(from.as_any_ref().downcast_ref::<WillModifyConfigCpuRequirements>()?),
            StructType::WillResetSnapshotDirectory => Some(from.as_any_ref().downcast_ref::<WillResetSnapshotDirectory>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::MigrationFault => Ok(from.as_any_box().downcast::<MigrationFault>()?),
            StructType::AffinityConfigured => Ok(from.as_any_box().downcast::<AffinityConfigured>()?),
            StructType::CannotModifyConfigCpuRequirements => Ok(from.as_any_box().downcast::<CannotModifyConfigCpuRequirements>()?),
            StructType::CannotMoveVmWithDeltaDisk => Ok(from.as_any_box().downcast::<CannotMoveVmWithDeltaDisk>()?),
            StructType::CannotMoveVmWithNativeDeltaDisk => Ok(from.as_any_box().downcast::<CannotMoveVmWithNativeDeltaDisk>()?),
            StructType::CloneFromSnapshotNotSupported => Ok(from.as_any_box().downcast::<CloneFromSnapshotNotSupported>()?),
            StructType::DatacenterMismatch => Ok(from.as_any_box().downcast::<DatacenterMismatch>()?),
            StructType::DisallowedMigrationDeviceAttached => Ok(from.as_any_box().downcast::<DisallowedMigrationDeviceAttached>()?),
            StructType::DiskMoveTypeNotSupported => Ok(from.as_any_box().downcast::<DiskMoveTypeNotSupported>()?),
            StructType::FaultToleranceAntiAffinityViolated => Ok(from.as_any_box().downcast::<FaultToleranceAntiAffinityViolated>()?),
            StructType::FaultToleranceNeedsThickDisk => Ok(from.as_any_box().downcast::<FaultToleranceNeedsThickDisk>()?),
            StructType::FaultToleranceNotSameBuild => Ok(from.as_any_box().downcast::<FaultToleranceNotSameBuild>()?),
            StructType::HaErrorsAtDest => Ok(from.as_any_box().downcast::<HaErrorsAtDest>()?),
            StructType::IncompatibleDefaultDevice => Ok(from.as_any_box().downcast::<IncompatibleDefaultDevice>()?),
            StructType::LargeRdmConversionNotSupported => Ok(from.as_any_box().downcast::<LargeRdmConversionNotSupported>()?),
            StructType::MaintenanceModeFileMove => Ok(from.as_any_box().downcast::<MaintenanceModeFileMove>()?),
            StructType::MigrationDisabled => Ok(from.as_any_box().downcast::<MigrationDisabled>()?),
            StructType::MigrationFeatureNotSupported => Ok(from.as_any_box().downcast::<MigrationFeatureNotSupported>()?),
            StructType::FullStorageVMotionNotSupported => Ok(from.as_any_box().downcast::<FullStorageVMotionNotSupported>()?),
            StructType::IndependentDiskVMotionNotSupported => Ok(from.as_any_box().downcast::<IndependentDiskVMotionNotSupported>()?),
            StructType::NonHomeRdmvMotionNotSupported => Ok(from.as_any_box().downcast::<NonHomeRdmvMotionNotSupported>()?),
            StructType::StorageVMotionNotSupported => Ok(from.as_any_box().downcast::<StorageVMotionNotSupported>()?),
            StructType::UnsharedSwapVMotionNotSupported => Ok(from.as_any_box().downcast::<UnsharedSwapVMotionNotSupported>()?),
            StructType::VMotionAcrossNetworkNotSupported => Ok(from.as_any_box().downcast::<VMotionAcrossNetworkNotSupported>()?),
            StructType::MigrationNotReady => Ok(from.as_any_box().downcast::<MigrationNotReady>()?),
            StructType::MismatchedNetworkPolicies => Ok(from.as_any_box().downcast::<MismatchedNetworkPolicies>()?),
            StructType::MismatchedVMotionNetworkNames => Ok(from.as_any_box().downcast::<MismatchedVMotionNetworkNames>()?),
            StructType::NetworksMayNotBeTheSame => Ok(from.as_any_box().downcast::<NetworksMayNotBeTheSame>()?),
            StructType::NoGuestHeartbeat => Ok(from.as_any_box().downcast::<NoGuestHeartbeat>()?),
            StructType::RdmConversionNotSupported => Ok(from.as_any_box().downcast::<RdmConversionNotSupported>()?),
            StructType::RdmNotPreserved => Ok(from.as_any_box().downcast::<RdmNotPreserved>()?),
            StructType::ReadOnlyDisksWithLegacyDestination => Ok(from.as_any_box().downcast::<ReadOnlyDisksWithLegacyDestination>()?),
            StructType::SnapshotCopyNotSupported => Ok(from.as_any_box().downcast::<SnapshotCopyNotSupported>()?),
            StructType::HotSnapshotMoveNotSupported => Ok(from.as_any_box().downcast::<HotSnapshotMoveNotSupported>()?),
            StructType::SnapshotCloneNotSupported => Ok(from.as_any_box().downcast::<SnapshotCloneNotSupported>()?),
            StructType::SnapshotMoveFromNonHomeNotSupported => Ok(from.as_any_box().downcast::<SnapshotMoveFromNonHomeNotSupported>()?),
            StructType::SnapshotMoveNotSupported => Ok(from.as_any_box().downcast::<SnapshotMoveNotSupported>()?),
            StructType::SnapshotMoveToNonHomeNotSupported => Ok(from.as_any_box().downcast::<SnapshotMoveToNonHomeNotSupported>()?),
            StructType::SnapshotRevertIssue => Ok(from.as_any_box().downcast::<SnapshotRevertIssue>()?),
            StructType::SuspendedRelocateNotSupported => Ok(from.as_any_box().downcast::<SuspendedRelocateNotSupported>()?),
            StructType::TooManyDisksOnLegacyHost => Ok(from.as_any_box().downcast::<TooManyDisksOnLegacyHost>()?),
            StructType::ToolsInstallationInProgress => Ok(from.as_any_box().downcast::<ToolsInstallationInProgress>()?),
            StructType::UncommittedUndoableDisk => Ok(from.as_any_box().downcast::<UncommittedUndoableDisk>()?),
            StructType::VMotionInterfaceIssue => Ok(from.as_any_box().downcast::<VMotionInterfaceIssue>()?),
            StructType::VMotionLinkCapacityLow => Ok(from.as_any_box().downcast::<VMotionLinkCapacityLow>()?),
            StructType::VMotionLinkDown => Ok(from.as_any_box().downcast::<VMotionLinkDown>()?),
            StructType::VMotionNotConfigured => Ok(from.as_any_box().downcast::<VMotionNotConfigured>()?),
            StructType::VMotionNotLicensed => Ok(from.as_any_box().downcast::<VMotionNotLicensed>()?),
            StructType::VMotionNotSupported => Ok(from.as_any_box().downcast::<VMotionNotSupported>()?),
            StructType::VMotionProtocolIncompatible => Ok(from.as_any_box().downcast::<VMotionProtocolIncompatible>()?),
            StructType::WillLoseHaProtection => Ok(from.as_any_box().downcast::<WillLoseHaProtection>()?),
            StructType::WillModifyConfigCpuRequirements => Ok(from.as_any_box().downcast::<WillModifyConfigCpuRequirements>()?),
            StructType::WillResetSnapshotDirectory => Ok(from.as_any_box().downcast::<WillResetSnapshotDirectory>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// A migration operation that requires feature support on source and
/// destination hosts is lacking support on the host.
pub trait MigrationFeatureNotSupportedTrait : super::traits::MigrationFaultTrait {
    /// Whether this error is for the source host.
    fn get_at_source_host(&self) -> bool;
    /// The name of the host.
    fn get_failed_host_name(&self) -> &str;
    /// The host.
    /// 
    /// Refers instance of *HostSystem*.
    fn get_failed_host(&self) -> &ManagedObjectReference;
}
impl<'s> serde::Serialize for dyn MigrationFeatureNotSupportedTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn MigrationFeatureNotSupportedTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(MigrationFeatureNotSupportedVisitor)
            }
        }

struct MigrationFeatureNotSupportedVisitor;

impl<'de> de::Visitor<'de> for MigrationFeatureNotSupportedVisitor {
    type Value = Box<dyn MigrationFeatureNotSupportedTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid MigrationFeatureNotSupportedTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl MigrationFeatureNotSupportedTrait for MigrationFeatureNotSupported {
    fn get_at_source_host(&self) -> bool { self.at_source_host }
    fn get_failed_host_name(&self) -> &str { &self.failed_host_name }
    fn get_failed_host(&self) -> &ManagedObjectReference { &self.failed_host }
}
impl MigrationFeatureNotSupportedTrait for FullStorageVMotionNotSupported {
    fn get_at_source_host(&self) -> bool { self.at_source_host }
    fn get_failed_host_name(&self) -> &str { &self.failed_host_name }
    fn get_failed_host(&self) -> &ManagedObjectReference { &self.failed_host }
}
impl MigrationFeatureNotSupportedTrait for IndependentDiskVMotionNotSupported {
    fn get_at_source_host(&self) -> bool { self.at_source_host }
    fn get_failed_host_name(&self) -> &str { &self.failed_host_name }
    fn get_failed_host(&self) -> &ManagedObjectReference { &self.failed_host }
}
impl MigrationFeatureNotSupportedTrait for NonHomeRdmvMotionNotSupported {
    fn get_at_source_host(&self) -> bool { self.at_source_host }
    fn get_failed_host_name(&self) -> &str { &self.failed_host_name }
    fn get_failed_host(&self) -> &ManagedObjectReference { &self.failed_host }
}
impl MigrationFeatureNotSupportedTrait for StorageVMotionNotSupported {
    fn get_at_source_host(&self) -> bool { self.at_source_host }
    fn get_failed_host_name(&self) -> &str { &self.failed_host_name }
    fn get_failed_host(&self) -> &ManagedObjectReference { &self.failed_host }
}
impl MigrationFeatureNotSupportedTrait for UnsharedSwapVMotionNotSupported {
    fn get_at_source_host(&self) -> bool { self.at_source_host }
    fn get_failed_host_name(&self) -> &str { &self.failed_host_name }
    fn get_failed_host(&self) -> &ManagedObjectReference { &self.failed_host }
}
impl MigrationFeatureNotSupportedTrait for VMotionAcrossNetworkNotSupported {
    fn get_at_source_host(&self) -> bool { self.at_source_host }
    fn get_failed_host_name(&self) -> &str { &self.failed_host_name }
    fn get_failed_host(&self) -> &ManagedObjectReference { &self.failed_host }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn MigrationFeatureNotSupportedTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::MigrationFeatureNotSupported => Some(from.as_any_ref().downcast_ref::<MigrationFeatureNotSupported>()?),
            StructType::FullStorageVMotionNotSupported => Some(from.as_any_ref().downcast_ref::<FullStorageVMotionNotSupported>()?),
            StructType::IndependentDiskVMotionNotSupported => Some(from.as_any_ref().downcast_ref::<IndependentDiskVMotionNotSupported>()?),
            StructType::NonHomeRdmvMotionNotSupported => Some(from.as_any_ref().downcast_ref::<NonHomeRdmvMotionNotSupported>()?),
            StructType::StorageVMotionNotSupported => Some(from.as_any_ref().downcast_ref::<StorageVMotionNotSupported>()?),
            StructType::UnsharedSwapVMotionNotSupported => Some(from.as_any_ref().downcast_ref::<UnsharedSwapVMotionNotSupported>()?),
            StructType::VMotionAcrossNetworkNotSupported => Some(from.as_any_ref().downcast_ref::<VMotionAcrossNetworkNotSupported>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::MigrationFeatureNotSupported => Ok(from.as_any_box().downcast::<MigrationFeatureNotSupported>()?),
            StructType::FullStorageVMotionNotSupported => Ok(from.as_any_box().downcast::<FullStorageVMotionNotSupported>()?),
            StructType::IndependentDiskVMotionNotSupported => Ok(from.as_any_box().downcast::<IndependentDiskVMotionNotSupported>()?),
            StructType::NonHomeRdmvMotionNotSupported => Ok(from.as_any_box().downcast::<NonHomeRdmvMotionNotSupported>()?),
            StructType::StorageVMotionNotSupported => Ok(from.as_any_box().downcast::<StorageVMotionNotSupported>()?),
            StructType::UnsharedSwapVMotionNotSupported => Ok(from.as_any_box().downcast::<UnsharedSwapVMotionNotSupported>()?),
            StructType::VMotionAcrossNetworkNotSupported => Ok(from.as_any_box().downcast::<VMotionAcrossNetworkNotSupported>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// An attempt is being made to move or copy a virtual machine's disk that has
/// associated snapshots, and preserving the snapshots is not supported
/// because of some aspect of the virtual machine configuration, virtual
/// machine power state, or the requested disk placement.
/// 
/// This is an error
/// for move operations (where the source is deleted after the copy) and a
/// warning for clones (where the source is preserved).
pub trait SnapshotCopyNotSupportedTrait : super::traits::MigrationFaultTrait {
}
impl<'s> serde::Serialize for dyn SnapshotCopyNotSupportedTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn SnapshotCopyNotSupportedTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(SnapshotCopyNotSupportedVisitor)
            }
        }

struct SnapshotCopyNotSupportedVisitor;

impl<'de> de::Visitor<'de> for SnapshotCopyNotSupportedVisitor {
    type Value = Box<dyn SnapshotCopyNotSupportedTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid SnapshotCopyNotSupportedTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl SnapshotCopyNotSupportedTrait for SnapshotCopyNotSupported {
}
impl SnapshotCopyNotSupportedTrait for HotSnapshotMoveNotSupported {
}
impl SnapshotCopyNotSupportedTrait for SnapshotCloneNotSupported {
}
impl SnapshotCopyNotSupportedTrait for SnapshotMoveFromNonHomeNotSupported {
}
impl SnapshotCopyNotSupportedTrait for SnapshotMoveNotSupported {
}
impl SnapshotCopyNotSupportedTrait for SnapshotMoveToNonHomeNotSupported {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn SnapshotCopyNotSupportedTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::SnapshotCopyNotSupported => Some(from.as_any_ref().downcast_ref::<SnapshotCopyNotSupported>()?),
            StructType::HotSnapshotMoveNotSupported => Some(from.as_any_ref().downcast_ref::<HotSnapshotMoveNotSupported>()?),
            StructType::SnapshotCloneNotSupported => Some(from.as_any_ref().downcast_ref::<SnapshotCloneNotSupported>()?),
            StructType::SnapshotMoveFromNonHomeNotSupported => Some(from.as_any_ref().downcast_ref::<SnapshotMoveFromNonHomeNotSupported>()?),
            StructType::SnapshotMoveNotSupported => Some(from.as_any_ref().downcast_ref::<SnapshotMoveNotSupported>()?),
            StructType::SnapshotMoveToNonHomeNotSupported => Some(from.as_any_ref().downcast_ref::<SnapshotMoveToNonHomeNotSupported>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::SnapshotCopyNotSupported => Ok(from.as_any_box().downcast::<SnapshotCopyNotSupported>()?),
            StructType::HotSnapshotMoveNotSupported => Ok(from.as_any_box().downcast::<HotSnapshotMoveNotSupported>()?),
            StructType::SnapshotCloneNotSupported => Ok(from.as_any_box().downcast::<SnapshotCloneNotSupported>()?),
            StructType::SnapshotMoveFromNonHomeNotSupported => Ok(from.as_any_box().downcast::<SnapshotMoveFromNonHomeNotSupported>()?),
            StructType::SnapshotMoveNotSupported => Ok(from.as_any_box().downcast::<SnapshotMoveNotSupported>()?),
            StructType::SnapshotMoveToNonHomeNotSupported => Ok(from.as_any_box().downcast::<SnapshotMoveToNonHomeNotSupported>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// A VMotion interface has a problem.
/// 
/// This may be an error or warning depending
/// on the specific fault subclass. This is an error or warning only when
/// migrating a powered-on virtual machine.
pub trait VMotionInterfaceIssueTrait : super::traits::MigrationFaultTrait {
    /// Whether this error is for the source host.
    fn get_at_source_host(&self) -> bool;
    /// The name of the host with the bad interface.
    fn get_failed_host(&self) -> &str;
    /// The host with the bad interface.
    /// 
    /// Refers instance of *HostSystem*.
    fn get_failed_host_entity(&self) -> &Option<ManagedObjectReference>;
}
impl<'s> serde::Serialize for dyn VMotionInterfaceIssueTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VMotionInterfaceIssueTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VMotionInterfaceIssueVisitor)
            }
        }

struct VMotionInterfaceIssueVisitor;

impl<'de> de::Visitor<'de> for VMotionInterfaceIssueVisitor {
    type Value = Box<dyn VMotionInterfaceIssueTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VMotionInterfaceIssueTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VMotionInterfaceIssueTrait for VMotionInterfaceIssue {
    fn get_at_source_host(&self) -> bool { self.at_source_host }
    fn get_failed_host(&self) -> &str { &self.failed_host }
    fn get_failed_host_entity(&self) -> &Option<ManagedObjectReference> { &self.failed_host_entity }
}
impl VMotionInterfaceIssueTrait for VMotionLinkCapacityLow {
    fn get_at_source_host(&self) -> bool { self.at_source_host }
    fn get_failed_host(&self) -> &str { &self.failed_host }
    fn get_failed_host_entity(&self) -> &Option<ManagedObjectReference> { &self.failed_host_entity }
}
impl VMotionInterfaceIssueTrait for VMotionLinkDown {
    fn get_at_source_host(&self) -> bool { self.at_source_host }
    fn get_failed_host(&self) -> &str { &self.failed_host }
    fn get_failed_host_entity(&self) -> &Option<ManagedObjectReference> { &self.failed_host_entity }
}
impl VMotionInterfaceIssueTrait for VMotionNotConfigured {
    fn get_at_source_host(&self) -> bool { self.at_source_host }
    fn get_failed_host(&self) -> &str { &self.failed_host }
    fn get_failed_host_entity(&self) -> &Option<ManagedObjectReference> { &self.failed_host_entity }
}
impl VMotionInterfaceIssueTrait for VMotionNotLicensed {
    fn get_at_source_host(&self) -> bool { self.at_source_host }
    fn get_failed_host(&self) -> &str { &self.failed_host }
    fn get_failed_host_entity(&self) -> &Option<ManagedObjectReference> { &self.failed_host_entity }
}
impl VMotionInterfaceIssueTrait for VMotionNotSupported {
    fn get_at_source_host(&self) -> bool { self.at_source_host }
    fn get_failed_host(&self) -> &str { &self.failed_host }
    fn get_failed_host_entity(&self) -> &Option<ManagedObjectReference> { &self.failed_host_entity }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VMotionInterfaceIssueTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VMotionInterfaceIssue => Some(from.as_any_ref().downcast_ref::<VMotionInterfaceIssue>()?),
            StructType::VMotionLinkCapacityLow => Some(from.as_any_ref().downcast_ref::<VMotionLinkCapacityLow>()?),
            StructType::VMotionLinkDown => Some(from.as_any_ref().downcast_ref::<VMotionLinkDown>()?),
            StructType::VMotionNotConfigured => Some(from.as_any_ref().downcast_ref::<VMotionNotConfigured>()?),
            StructType::VMotionNotLicensed => Some(from.as_any_ref().downcast_ref::<VMotionNotLicensed>()?),
            StructType::VMotionNotSupported => Some(from.as_any_ref().downcast_ref::<VMotionNotSupported>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VMotionInterfaceIssue => Ok(from.as_any_box().downcast::<VMotionInterfaceIssue>()?),
            StructType::VMotionLinkCapacityLow => Ok(from.as_any_box().downcast::<VMotionLinkCapacityLow>()?),
            StructType::VMotionLinkDown => Ok(from.as_any_box().downcast::<VMotionLinkDown>()?),
            StructType::VMotionNotConfigured => Ok(from.as_any_box().downcast::<VMotionNotConfigured>()?),
            StructType::VMotionNotLicensed => Ok(from.as_any_box().downcast::<VMotionNotLicensed>()?),
            StructType::VMotionNotSupported => Ok(from.as_any_box().downcast::<VMotionNotSupported>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// A NoCompatibleHost fault is thrown when DRS cannot find a compatible
/// host in a given compute resource to run a virtual machine on.
pub trait NoCompatibleHostTrait : super::traits::VimFaultTrait {
    /// The list of hosts that are not compatible, each element has a
    /// corresponding fault in the error array.
    /// 
    /// Refers instances of *HostSystem*.
    fn get_host(&self) -> &Option<Vec<ManagedObjectReference>>;
    /// An error in this array indicates why the corresponding host in the
    /// host array is incompatible.
    fn get_error(&self) -> &Option<Vec<Box<dyn super::traits::MethodFaultTrait>>>;
}
impl<'s> serde::Serialize for dyn NoCompatibleHostTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn NoCompatibleHostTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(NoCompatibleHostVisitor)
            }
        }

struct NoCompatibleHostVisitor;

impl<'de> de::Visitor<'de> for NoCompatibleHostVisitor {
    type Value = Box<dyn NoCompatibleHostTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid NoCompatibleHostTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl NoCompatibleHostTrait for NoCompatibleHost {
    fn get_host(&self) -> &Option<Vec<ManagedObjectReference>> { &self.host }
    fn get_error(&self) -> &Option<Vec<Box<dyn super::traits::MethodFaultTrait>>> { &self.error }
}
impl NoCompatibleHostTrait for NoCompatibleHostWithAccessToDevice {
    fn get_host(&self) -> &Option<Vec<ManagedObjectReference>> { &self.host }
    fn get_error(&self) -> &Option<Vec<Box<dyn super::traits::MethodFaultTrait>>> { &self.error }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn NoCompatibleHostTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::NoCompatibleHost => Some(from.as_any_ref().downcast_ref::<NoCompatibleHost>()?),
            StructType::NoCompatibleHostWithAccessToDevice => Some(from.as_any_ref().downcast_ref::<NoCompatibleHostWithAccessToDevice>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::NoCompatibleHost => Ok(from.as_any_box().downcast::<NoCompatibleHost>()?),
            StructType::NoCompatibleHostWithAccessToDevice => Ok(from.as_any_box().downcast::<NoCompatibleHostWithAccessToDevice>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// A common base type fault for all Ovf related faults.
/// 
/// The structure of OvfFault is as listed.
/// - OvfFault
///   - OvfInvalidPackage
///     - OvfXmlFormat
///     - OvfWrongNamespace
///     - OvfElement
///       - OvfElementInvalidValue
///       - OvfUnexpectedElement
///       - OvfDuplicateElement
///       - OvfMissingElement
///       - OvfMissingElementNormalBoundary
///       - OvfDuplicatedElementBoundary
///     - OvfAttribute
///       - OvfMissingAttribute
///       - OvfInvalidValue
///         - OvfInvalidValueFormatMalformed
///         - OvfInvalidValueConfiguration
///         - OvfInvalidValueReference
///         - OvfInvalidValueEmpty
///     - OvfProperty
///       - OvfPropertyType
///       - OvfPropertyValue
///       - OvfPropertyNetwork
///       - OvfPropertyQualifier
///       - OvfPropertyQualifierWarning
///   - OvfConstraint
///     - OvfDiskOrderConstraint
///     - OvfHostResourceConstraint
///   - OvfUnsupportedPackage
///     - OvfNoHostNic
///     - OvfInvalidVmName
///     - OvfUnsupportedAttribute
///       - OvfUnsupportedAttributeValue
///     - OvfUnsupportedElement
///       - OvfUnsupportedElementValue
///       - OvfUnsupportedSection
///       - OvfNoSpaceOnController
///     - OvfUnsupportedType
///     - OvfUnsupportedSubType
///     - OvfHardwareCheck
///     - OvfNoSupportedHardwareFamily
///   - OvfExport
///     - OvfExportFailed
///     - OvfHardwareExport
///       - OvfUnsupportedDeviceExport
///       - OvfUnknownDeviceBacking
///       - OvfConnectedDevice
///         - OvfConnectedDeviceISO
///       - OvfUnableToExportDisk
///     - OvfPropertyExport
///     - OvfPropertyNetworkExport
///     - OvfDuplicatedPropertyIdExport
///   - OvfImport (these are typically returned as warnings)
///     - OvfImportFailed
///     - OvfHardwareCheck
///     - OvfMissingHardware
///     - OvfCpuCompatibility
///     - OvfCpuCompatibilityCheckNotSupported
///     - OvfUnsupportedDiskProvisioning
///     - OvfDuplicatedPropertyIdImport
///     - OvfNetworkMappingNotSupported
///   - OvfSystemFault
///     - OvfDiskMappingNotFound
///     - OvfHostValueNotParsed
///     - OvfInternalError
///     - OvfUnsupportedDeviceBackingOption
///     - OvfUnsupportedDeviceBackingInfo
///     - OvfToXmlUnsupportedElement
///     - OvfUnknownDevice
///     - OvfUnknownEntity
///   - OvfConsumerCallbackFault
///     - OvfConsumerFault
///     - OvfConsumerCommunicationError
///     - OvfConsumerInvalidSection
///     - OvfConsumerUndeclaredSection
///     - OvfConsumerUndefinedPrefix
///       
/// All messages go into the vimlocale
pub trait OvfFaultTrait : super::traits::VimFaultTrait {
}
impl<'s> serde::Serialize for dyn OvfFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn OvfFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(OvfFaultVisitor)
            }
        }

struct OvfFaultVisitor;

impl<'de> de::Visitor<'de> for OvfFaultVisitor {
    type Value = Box<dyn OvfFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid OvfFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl OvfFaultTrait for OvfFault {
}
impl OvfFaultTrait for OvfConsumerCallbackFault {
}
impl OvfFaultTrait for OvfConsumerCommunicationError {
}
impl OvfFaultTrait for OvfConsumerFault {
}
impl OvfFaultTrait for OvfConsumerInvalidSection {
}
impl OvfFaultTrait for OvfConsumerUndeclaredSection {
}
impl OvfFaultTrait for OvfConsumerUndefinedPrefix {
}
impl OvfFaultTrait for OvfExport {
}
impl OvfFaultTrait for ConnectedIso {
}
impl OvfFaultTrait for OvfDuplicatedPropertyIdExport {
}
impl OvfFaultTrait for OvfDuplicatedPropertyIdImport {
}
impl OvfFaultTrait for OvfExportFailed {
}
impl OvfFaultTrait for OvfHardwareExport {
}
impl OvfFaultTrait for OvfConnectedDevice {
}
impl OvfFaultTrait for OvfConnectedDeviceFloppy {
}
impl OvfFaultTrait for OvfConnectedDeviceIso {
}
impl OvfFaultTrait for OvfUnableToExportDisk {
}
impl OvfFaultTrait for OvfUnknownDeviceBacking {
}
impl OvfFaultTrait for OvfUnsupportedDeviceExport {
}
impl OvfFaultTrait for OvfPropertyExport {
}
impl OvfFaultTrait for OvfPropertyNetworkExport {
}
impl OvfFaultTrait for OvfImport {
}
impl OvfFaultTrait for OvfCpuCompatibility {
}
impl OvfFaultTrait for OvfCpuCompatibilityCheckNotSupported {
}
impl OvfFaultTrait for OvfHardwareCheck {
}
impl OvfFaultTrait for OvfImportFailed {
}
impl OvfFaultTrait for OvfMappedOsId {
}
impl OvfFaultTrait for OvfMissingHardware {
}
impl OvfFaultTrait for OvfNetworkMappingNotSupported {
}
impl OvfFaultTrait for OvfUnsupportedDiskProvisioning {
}
impl OvfFaultTrait for OvfInvalidPackage {
}
impl OvfFaultTrait for OvfAttribute {
}
impl OvfFaultTrait for OvfInvalidValue {
}
impl OvfFaultTrait for OvfInvalidValueConfiguration {
}
impl OvfFaultTrait for OvfInvalidValueEmpty {
}
impl OvfFaultTrait for OvfInvalidValueFormatMalformed {
}
impl OvfFaultTrait for OvfInvalidValueReference {
}
impl OvfFaultTrait for OvfMissingAttribute {
}
impl OvfFaultTrait for OvfConstraint {
}
impl OvfFaultTrait for OvfDiskOrderConstraint {
}
impl OvfFaultTrait for OvfHostResourceConstraint {
}
impl OvfFaultTrait for OvfElement {
}
impl OvfFaultTrait for OvfDuplicateElement {
}
impl OvfFaultTrait for OvfDuplicatedElementBoundary {
}
impl OvfFaultTrait for OvfElementInvalidValue {
}
impl OvfFaultTrait for OvfMissingElement {
}
impl OvfFaultTrait for OvfMissingElementNormalBoundary {
}
impl OvfFaultTrait for OvfUnexpectedElement {
}
impl OvfFaultTrait for OvfWrongElement {
}
impl OvfFaultTrait for OvfProperty {
}
impl OvfFaultTrait for OvfPropertyNetwork {
}
impl OvfFaultTrait for OvfPropertyQualifier {
}
impl OvfFaultTrait for OvfPropertyQualifierDuplicate {
}
impl OvfFaultTrait for OvfPropertyQualifierIgnored {
}
impl OvfFaultTrait for OvfPropertyType {
}
impl OvfFaultTrait for OvfPropertyValue {
}
impl OvfFaultTrait for OvfWrongNamespace {
}
impl OvfFaultTrait for OvfXmlFormat {
}
impl OvfFaultTrait for OvfSystemFault {
}
impl OvfFaultTrait for OvfDiskMappingNotFound {
}
impl OvfFaultTrait for OvfHostValueNotParsed {
}
impl OvfFaultTrait for OvfInternalError {
}
impl OvfFaultTrait for OvfToXmlUnsupportedElement {
}
impl OvfFaultTrait for OvfUnknownDevice {
}
impl OvfFaultTrait for OvfUnknownEntity {
}
impl OvfFaultTrait for OvfUnsupportedDeviceBackingInfo {
}
impl OvfFaultTrait for OvfUnsupportedDeviceBackingOption {
}
impl OvfFaultTrait for OvfUnsupportedPackage {
}
impl OvfFaultTrait for OvfInvalidVmName {
}
impl OvfFaultTrait for OvfNoHostNic {
}
impl OvfFaultTrait for OvfNoSupportedHardwareFamily {
}
impl OvfFaultTrait for OvfUnsupportedAttribute {
}
impl OvfFaultTrait for OvfUnsupportedAttributeValue {
}
impl OvfFaultTrait for OvfUnsupportedElement {
}
impl OvfFaultTrait for OvfNoSpaceOnController {
}
impl OvfFaultTrait for OvfUnsupportedElementValue {
}
impl OvfFaultTrait for OvfUnsupportedSection {
}
impl OvfFaultTrait for OvfUnsupportedSubType {
}
impl OvfFaultTrait for OvfUnsupportedType {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn OvfFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfFault => Some(from.as_any_ref().downcast_ref::<OvfFault>()?),
            StructType::OvfConsumerCallbackFault => Some(from.as_any_ref().downcast_ref::<OvfConsumerCallbackFault>()?),
            StructType::OvfConsumerCommunicationError => Some(from.as_any_ref().downcast_ref::<OvfConsumerCommunicationError>()?),
            StructType::OvfConsumerFault => Some(from.as_any_ref().downcast_ref::<OvfConsumerFault>()?),
            StructType::OvfConsumerInvalidSection => Some(from.as_any_ref().downcast_ref::<OvfConsumerInvalidSection>()?),
            StructType::OvfConsumerUndeclaredSection => Some(from.as_any_ref().downcast_ref::<OvfConsumerUndeclaredSection>()?),
            StructType::OvfConsumerUndefinedPrefix => Some(from.as_any_ref().downcast_ref::<OvfConsumerUndefinedPrefix>()?),
            StructType::OvfExport => Some(from.as_any_ref().downcast_ref::<OvfExport>()?),
            StructType::ConnectedIso => Some(from.as_any_ref().downcast_ref::<ConnectedIso>()?),
            StructType::OvfDuplicatedPropertyIdExport => Some(from.as_any_ref().downcast_ref::<OvfDuplicatedPropertyIdExport>()?),
            StructType::OvfDuplicatedPropertyIdImport => Some(from.as_any_ref().downcast_ref::<OvfDuplicatedPropertyIdImport>()?),
            StructType::OvfExportFailed => Some(from.as_any_ref().downcast_ref::<OvfExportFailed>()?),
            StructType::OvfHardwareExport => Some(from.as_any_ref().downcast_ref::<OvfHardwareExport>()?),
            StructType::OvfConnectedDevice => Some(from.as_any_ref().downcast_ref::<OvfConnectedDevice>()?),
            StructType::OvfConnectedDeviceFloppy => Some(from.as_any_ref().downcast_ref::<OvfConnectedDeviceFloppy>()?),
            StructType::OvfConnectedDeviceIso => Some(from.as_any_ref().downcast_ref::<OvfConnectedDeviceIso>()?),
            StructType::OvfUnableToExportDisk => Some(from.as_any_ref().downcast_ref::<OvfUnableToExportDisk>()?),
            StructType::OvfUnknownDeviceBacking => Some(from.as_any_ref().downcast_ref::<OvfUnknownDeviceBacking>()?),
            StructType::OvfUnsupportedDeviceExport => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedDeviceExport>()?),
            StructType::OvfPropertyExport => Some(from.as_any_ref().downcast_ref::<OvfPropertyExport>()?),
            StructType::OvfPropertyNetworkExport => Some(from.as_any_ref().downcast_ref::<OvfPropertyNetworkExport>()?),
            StructType::OvfImport => Some(from.as_any_ref().downcast_ref::<OvfImport>()?),
            StructType::OvfCpuCompatibility => Some(from.as_any_ref().downcast_ref::<OvfCpuCompatibility>()?),
            StructType::OvfCpuCompatibilityCheckNotSupported => Some(from.as_any_ref().downcast_ref::<OvfCpuCompatibilityCheckNotSupported>()?),
            StructType::OvfHardwareCheck => Some(from.as_any_ref().downcast_ref::<OvfHardwareCheck>()?),
            StructType::OvfImportFailed => Some(from.as_any_ref().downcast_ref::<OvfImportFailed>()?),
            StructType::OvfMappedOsId => Some(from.as_any_ref().downcast_ref::<OvfMappedOsId>()?),
            StructType::OvfMissingHardware => Some(from.as_any_ref().downcast_ref::<OvfMissingHardware>()?),
            StructType::OvfNetworkMappingNotSupported => Some(from.as_any_ref().downcast_ref::<OvfNetworkMappingNotSupported>()?),
            StructType::OvfUnsupportedDiskProvisioning => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedDiskProvisioning>()?),
            StructType::OvfInvalidPackage => Some(from.as_any_ref().downcast_ref::<OvfInvalidPackage>()?),
            StructType::OvfAttribute => Some(from.as_any_ref().downcast_ref::<OvfAttribute>()?),
            StructType::OvfInvalidValue => Some(from.as_any_ref().downcast_ref::<OvfInvalidValue>()?),
            StructType::OvfInvalidValueConfiguration => Some(from.as_any_ref().downcast_ref::<OvfInvalidValueConfiguration>()?),
            StructType::OvfInvalidValueEmpty => Some(from.as_any_ref().downcast_ref::<OvfInvalidValueEmpty>()?),
            StructType::OvfInvalidValueFormatMalformed => Some(from.as_any_ref().downcast_ref::<OvfInvalidValueFormatMalformed>()?),
            StructType::OvfInvalidValueReference => Some(from.as_any_ref().downcast_ref::<OvfInvalidValueReference>()?),
            StructType::OvfMissingAttribute => Some(from.as_any_ref().downcast_ref::<OvfMissingAttribute>()?),
            StructType::OvfConstraint => Some(from.as_any_ref().downcast_ref::<OvfConstraint>()?),
            StructType::OvfDiskOrderConstraint => Some(from.as_any_ref().downcast_ref::<OvfDiskOrderConstraint>()?),
            StructType::OvfHostResourceConstraint => Some(from.as_any_ref().downcast_ref::<OvfHostResourceConstraint>()?),
            StructType::OvfElement => Some(from.as_any_ref().downcast_ref::<OvfElement>()?),
            StructType::OvfDuplicateElement => Some(from.as_any_ref().downcast_ref::<OvfDuplicateElement>()?),
            StructType::OvfDuplicatedElementBoundary => Some(from.as_any_ref().downcast_ref::<OvfDuplicatedElementBoundary>()?),
            StructType::OvfElementInvalidValue => Some(from.as_any_ref().downcast_ref::<OvfElementInvalidValue>()?),
            StructType::OvfMissingElement => Some(from.as_any_ref().downcast_ref::<OvfMissingElement>()?),
            StructType::OvfMissingElementNormalBoundary => Some(from.as_any_ref().downcast_ref::<OvfMissingElementNormalBoundary>()?),
            StructType::OvfUnexpectedElement => Some(from.as_any_ref().downcast_ref::<OvfUnexpectedElement>()?),
            StructType::OvfWrongElement => Some(from.as_any_ref().downcast_ref::<OvfWrongElement>()?),
            StructType::OvfProperty => Some(from.as_any_ref().downcast_ref::<OvfProperty>()?),
            StructType::OvfPropertyNetwork => Some(from.as_any_ref().downcast_ref::<OvfPropertyNetwork>()?),
            StructType::OvfPropertyQualifier => Some(from.as_any_ref().downcast_ref::<OvfPropertyQualifier>()?),
            StructType::OvfPropertyQualifierDuplicate => Some(from.as_any_ref().downcast_ref::<OvfPropertyQualifierDuplicate>()?),
            StructType::OvfPropertyQualifierIgnored => Some(from.as_any_ref().downcast_ref::<OvfPropertyQualifierIgnored>()?),
            StructType::OvfPropertyType => Some(from.as_any_ref().downcast_ref::<OvfPropertyType>()?),
            StructType::OvfPropertyValue => Some(from.as_any_ref().downcast_ref::<OvfPropertyValue>()?),
            StructType::OvfWrongNamespace => Some(from.as_any_ref().downcast_ref::<OvfWrongNamespace>()?),
            StructType::OvfXmlFormat => Some(from.as_any_ref().downcast_ref::<OvfXmlFormat>()?),
            StructType::OvfSystemFault => Some(from.as_any_ref().downcast_ref::<OvfSystemFault>()?),
            StructType::OvfDiskMappingNotFound => Some(from.as_any_ref().downcast_ref::<OvfDiskMappingNotFound>()?),
            StructType::OvfHostValueNotParsed => Some(from.as_any_ref().downcast_ref::<OvfHostValueNotParsed>()?),
            StructType::OvfInternalError => Some(from.as_any_ref().downcast_ref::<OvfInternalError>()?),
            StructType::OvfToXmlUnsupportedElement => Some(from.as_any_ref().downcast_ref::<OvfToXmlUnsupportedElement>()?),
            StructType::OvfUnknownDevice => Some(from.as_any_ref().downcast_ref::<OvfUnknownDevice>()?),
            StructType::OvfUnknownEntity => Some(from.as_any_ref().downcast_ref::<OvfUnknownEntity>()?),
            StructType::OvfUnsupportedDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedDeviceBackingInfo>()?),
            StructType::OvfUnsupportedDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedDeviceBackingOption>()?),
            StructType::OvfUnsupportedPackage => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedPackage>()?),
            StructType::OvfInvalidVmName => Some(from.as_any_ref().downcast_ref::<OvfInvalidVmName>()?),
            StructType::OvfNoHostNic => Some(from.as_any_ref().downcast_ref::<OvfNoHostNic>()?),
            StructType::OvfNoSupportedHardwareFamily => Some(from.as_any_ref().downcast_ref::<OvfNoSupportedHardwareFamily>()?),
            StructType::OvfUnsupportedAttribute => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedAttribute>()?),
            StructType::OvfUnsupportedAttributeValue => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedAttributeValue>()?),
            StructType::OvfUnsupportedElement => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedElement>()?),
            StructType::OvfNoSpaceOnController => Some(from.as_any_ref().downcast_ref::<OvfNoSpaceOnController>()?),
            StructType::OvfUnsupportedElementValue => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedElementValue>()?),
            StructType::OvfUnsupportedSection => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedSection>()?),
            StructType::OvfUnsupportedSubType => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedSubType>()?),
            StructType::OvfUnsupportedType => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedType>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfFault => Ok(from.as_any_box().downcast::<OvfFault>()?),
            StructType::OvfConsumerCallbackFault => Ok(from.as_any_box().downcast::<OvfConsumerCallbackFault>()?),
            StructType::OvfConsumerCommunicationError => Ok(from.as_any_box().downcast::<OvfConsumerCommunicationError>()?),
            StructType::OvfConsumerFault => Ok(from.as_any_box().downcast::<OvfConsumerFault>()?),
            StructType::OvfConsumerInvalidSection => Ok(from.as_any_box().downcast::<OvfConsumerInvalidSection>()?),
            StructType::OvfConsumerUndeclaredSection => Ok(from.as_any_box().downcast::<OvfConsumerUndeclaredSection>()?),
            StructType::OvfConsumerUndefinedPrefix => Ok(from.as_any_box().downcast::<OvfConsumerUndefinedPrefix>()?),
            StructType::OvfExport => Ok(from.as_any_box().downcast::<OvfExport>()?),
            StructType::ConnectedIso => Ok(from.as_any_box().downcast::<ConnectedIso>()?),
            StructType::OvfDuplicatedPropertyIdExport => Ok(from.as_any_box().downcast::<OvfDuplicatedPropertyIdExport>()?),
            StructType::OvfDuplicatedPropertyIdImport => Ok(from.as_any_box().downcast::<OvfDuplicatedPropertyIdImport>()?),
            StructType::OvfExportFailed => Ok(from.as_any_box().downcast::<OvfExportFailed>()?),
            StructType::OvfHardwareExport => Ok(from.as_any_box().downcast::<OvfHardwareExport>()?),
            StructType::OvfConnectedDevice => Ok(from.as_any_box().downcast::<OvfConnectedDevice>()?),
            StructType::OvfConnectedDeviceFloppy => Ok(from.as_any_box().downcast::<OvfConnectedDeviceFloppy>()?),
            StructType::OvfConnectedDeviceIso => Ok(from.as_any_box().downcast::<OvfConnectedDeviceIso>()?),
            StructType::OvfUnableToExportDisk => Ok(from.as_any_box().downcast::<OvfUnableToExportDisk>()?),
            StructType::OvfUnknownDeviceBacking => Ok(from.as_any_box().downcast::<OvfUnknownDeviceBacking>()?),
            StructType::OvfUnsupportedDeviceExport => Ok(from.as_any_box().downcast::<OvfUnsupportedDeviceExport>()?),
            StructType::OvfPropertyExport => Ok(from.as_any_box().downcast::<OvfPropertyExport>()?),
            StructType::OvfPropertyNetworkExport => Ok(from.as_any_box().downcast::<OvfPropertyNetworkExport>()?),
            StructType::OvfImport => Ok(from.as_any_box().downcast::<OvfImport>()?),
            StructType::OvfCpuCompatibility => Ok(from.as_any_box().downcast::<OvfCpuCompatibility>()?),
            StructType::OvfCpuCompatibilityCheckNotSupported => Ok(from.as_any_box().downcast::<OvfCpuCompatibilityCheckNotSupported>()?),
            StructType::OvfHardwareCheck => Ok(from.as_any_box().downcast::<OvfHardwareCheck>()?),
            StructType::OvfImportFailed => Ok(from.as_any_box().downcast::<OvfImportFailed>()?),
            StructType::OvfMappedOsId => Ok(from.as_any_box().downcast::<OvfMappedOsId>()?),
            StructType::OvfMissingHardware => Ok(from.as_any_box().downcast::<OvfMissingHardware>()?),
            StructType::OvfNetworkMappingNotSupported => Ok(from.as_any_box().downcast::<OvfNetworkMappingNotSupported>()?),
            StructType::OvfUnsupportedDiskProvisioning => Ok(from.as_any_box().downcast::<OvfUnsupportedDiskProvisioning>()?),
            StructType::OvfInvalidPackage => Ok(from.as_any_box().downcast::<OvfInvalidPackage>()?),
            StructType::OvfAttribute => Ok(from.as_any_box().downcast::<OvfAttribute>()?),
            StructType::OvfInvalidValue => Ok(from.as_any_box().downcast::<OvfInvalidValue>()?),
            StructType::OvfInvalidValueConfiguration => Ok(from.as_any_box().downcast::<OvfInvalidValueConfiguration>()?),
            StructType::OvfInvalidValueEmpty => Ok(from.as_any_box().downcast::<OvfInvalidValueEmpty>()?),
            StructType::OvfInvalidValueFormatMalformed => Ok(from.as_any_box().downcast::<OvfInvalidValueFormatMalformed>()?),
            StructType::OvfInvalidValueReference => Ok(from.as_any_box().downcast::<OvfInvalidValueReference>()?),
            StructType::OvfMissingAttribute => Ok(from.as_any_box().downcast::<OvfMissingAttribute>()?),
            StructType::OvfConstraint => Ok(from.as_any_box().downcast::<OvfConstraint>()?),
            StructType::OvfDiskOrderConstraint => Ok(from.as_any_box().downcast::<OvfDiskOrderConstraint>()?),
            StructType::OvfHostResourceConstraint => Ok(from.as_any_box().downcast::<OvfHostResourceConstraint>()?),
            StructType::OvfElement => Ok(from.as_any_box().downcast::<OvfElement>()?),
            StructType::OvfDuplicateElement => Ok(from.as_any_box().downcast::<OvfDuplicateElement>()?),
            StructType::OvfDuplicatedElementBoundary => Ok(from.as_any_box().downcast::<OvfDuplicatedElementBoundary>()?),
            StructType::OvfElementInvalidValue => Ok(from.as_any_box().downcast::<OvfElementInvalidValue>()?),
            StructType::OvfMissingElement => Ok(from.as_any_box().downcast::<OvfMissingElement>()?),
            StructType::OvfMissingElementNormalBoundary => Ok(from.as_any_box().downcast::<OvfMissingElementNormalBoundary>()?),
            StructType::OvfUnexpectedElement => Ok(from.as_any_box().downcast::<OvfUnexpectedElement>()?),
            StructType::OvfWrongElement => Ok(from.as_any_box().downcast::<OvfWrongElement>()?),
            StructType::OvfProperty => Ok(from.as_any_box().downcast::<OvfProperty>()?),
            StructType::OvfPropertyNetwork => Ok(from.as_any_box().downcast::<OvfPropertyNetwork>()?),
            StructType::OvfPropertyQualifier => Ok(from.as_any_box().downcast::<OvfPropertyQualifier>()?),
            StructType::OvfPropertyQualifierDuplicate => Ok(from.as_any_box().downcast::<OvfPropertyQualifierDuplicate>()?),
            StructType::OvfPropertyQualifierIgnored => Ok(from.as_any_box().downcast::<OvfPropertyQualifierIgnored>()?),
            StructType::OvfPropertyType => Ok(from.as_any_box().downcast::<OvfPropertyType>()?),
            StructType::OvfPropertyValue => Ok(from.as_any_box().downcast::<OvfPropertyValue>()?),
            StructType::OvfWrongNamespace => Ok(from.as_any_box().downcast::<OvfWrongNamespace>()?),
            StructType::OvfXmlFormat => Ok(from.as_any_box().downcast::<OvfXmlFormat>()?),
            StructType::OvfSystemFault => Ok(from.as_any_box().downcast::<OvfSystemFault>()?),
            StructType::OvfDiskMappingNotFound => Ok(from.as_any_box().downcast::<OvfDiskMappingNotFound>()?),
            StructType::OvfHostValueNotParsed => Ok(from.as_any_box().downcast::<OvfHostValueNotParsed>()?),
            StructType::OvfInternalError => Ok(from.as_any_box().downcast::<OvfInternalError>()?),
            StructType::OvfToXmlUnsupportedElement => Ok(from.as_any_box().downcast::<OvfToXmlUnsupportedElement>()?),
            StructType::OvfUnknownDevice => Ok(from.as_any_box().downcast::<OvfUnknownDevice>()?),
            StructType::OvfUnknownEntity => Ok(from.as_any_box().downcast::<OvfUnknownEntity>()?),
            StructType::OvfUnsupportedDeviceBackingInfo => Ok(from.as_any_box().downcast::<OvfUnsupportedDeviceBackingInfo>()?),
            StructType::OvfUnsupportedDeviceBackingOption => Ok(from.as_any_box().downcast::<OvfUnsupportedDeviceBackingOption>()?),
            StructType::OvfUnsupportedPackage => Ok(from.as_any_box().downcast::<OvfUnsupportedPackage>()?),
            StructType::OvfInvalidVmName => Ok(from.as_any_box().downcast::<OvfInvalidVmName>()?),
            StructType::OvfNoHostNic => Ok(from.as_any_box().downcast::<OvfNoHostNic>()?),
            StructType::OvfNoSupportedHardwareFamily => Ok(from.as_any_box().downcast::<OvfNoSupportedHardwareFamily>()?),
            StructType::OvfUnsupportedAttribute => Ok(from.as_any_box().downcast::<OvfUnsupportedAttribute>()?),
            StructType::OvfUnsupportedAttributeValue => Ok(from.as_any_box().downcast::<OvfUnsupportedAttributeValue>()?),
            StructType::OvfUnsupportedElement => Ok(from.as_any_box().downcast::<OvfUnsupportedElement>()?),
            StructType::OvfNoSpaceOnController => Ok(from.as_any_box().downcast::<OvfNoSpaceOnController>()?),
            StructType::OvfUnsupportedElementValue => Ok(from.as_any_box().downcast::<OvfUnsupportedElementValue>()?),
            StructType::OvfUnsupportedSection => Ok(from.as_any_box().downcast::<OvfUnsupportedSection>()?),
            StructType::OvfUnsupportedSubType => Ok(from.as_any_box().downcast::<OvfUnsupportedSubType>()?),
            StructType::OvfUnsupportedType => Ok(from.as_any_box().downcast::<OvfUnsupportedType>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Superclass for all faults that can be thrown during the callback to an OVF
/// consumer.
/// 
/// The *MethodFault.faultCause* gives details about what went
/// wrong.
pub trait OvfConsumerCallbackFaultTrait : super::traits::OvfFaultTrait {
    /// The OVF consumer's extension key.
    fn get_extension_key(&self) -> &str;
    /// The OVF consumer's extension name.
    fn get_extension_name(&self) -> &str;
}
impl<'s> serde::Serialize for dyn OvfConsumerCallbackFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn OvfConsumerCallbackFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(OvfConsumerCallbackFaultVisitor)
            }
        }

struct OvfConsumerCallbackFaultVisitor;

impl<'de> de::Visitor<'de> for OvfConsumerCallbackFaultVisitor {
    type Value = Box<dyn OvfConsumerCallbackFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid OvfConsumerCallbackFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl OvfConsumerCallbackFaultTrait for OvfConsumerCallbackFault {
    fn get_extension_key(&self) -> &str { &self.extension_key }
    fn get_extension_name(&self) -> &str { &self.extension_name }
}
impl OvfConsumerCallbackFaultTrait for OvfConsumerCommunicationError {
    fn get_extension_key(&self) -> &str { &self.extension_key }
    fn get_extension_name(&self) -> &str { &self.extension_name }
}
impl OvfConsumerCallbackFaultTrait for OvfConsumerFault {
    fn get_extension_key(&self) -> &str { &self.extension_key }
    fn get_extension_name(&self) -> &str { &self.extension_name }
}
impl OvfConsumerCallbackFaultTrait for OvfConsumerInvalidSection {
    fn get_extension_key(&self) -> &str { &self.extension_key }
    fn get_extension_name(&self) -> &str { &self.extension_name }
}
impl OvfConsumerCallbackFaultTrait for OvfConsumerUndeclaredSection {
    fn get_extension_key(&self) -> &str { &self.extension_key }
    fn get_extension_name(&self) -> &str { &self.extension_name }
}
impl OvfConsumerCallbackFaultTrait for OvfConsumerUndefinedPrefix {
    fn get_extension_key(&self) -> &str { &self.extension_key }
    fn get_extension_name(&self) -> &str { &self.extension_name }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn OvfConsumerCallbackFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfConsumerCallbackFault => Some(from.as_any_ref().downcast_ref::<OvfConsumerCallbackFault>()?),
            StructType::OvfConsumerCommunicationError => Some(from.as_any_ref().downcast_ref::<OvfConsumerCommunicationError>()?),
            StructType::OvfConsumerFault => Some(from.as_any_ref().downcast_ref::<OvfConsumerFault>()?),
            StructType::OvfConsumerInvalidSection => Some(from.as_any_ref().downcast_ref::<OvfConsumerInvalidSection>()?),
            StructType::OvfConsumerUndeclaredSection => Some(from.as_any_ref().downcast_ref::<OvfConsumerUndeclaredSection>()?),
            StructType::OvfConsumerUndefinedPrefix => Some(from.as_any_ref().downcast_ref::<OvfConsumerUndefinedPrefix>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfConsumerCallbackFault => Ok(from.as_any_box().downcast::<OvfConsumerCallbackFault>()?),
            StructType::OvfConsumerCommunicationError => Ok(from.as_any_box().downcast::<OvfConsumerCommunicationError>()?),
            StructType::OvfConsumerFault => Ok(from.as_any_box().downcast::<OvfConsumerFault>()?),
            StructType::OvfConsumerInvalidSection => Ok(from.as_any_box().downcast::<OvfConsumerInvalidSection>()?),
            StructType::OvfConsumerUndeclaredSection => Ok(from.as_any_box().downcast::<OvfConsumerUndeclaredSection>()?),
            StructType::OvfConsumerUndefinedPrefix => Ok(from.as_any_box().downcast::<OvfConsumerUndefinedPrefix>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// A common base class to host all the Ovf Lib Export Exceptions.
pub trait OvfExportTrait : super::traits::OvfFaultTrait {
}
impl<'s> serde::Serialize for dyn OvfExportTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn OvfExportTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(OvfExportVisitor)
            }
        }

struct OvfExportVisitor;

impl<'de> de::Visitor<'de> for OvfExportVisitor {
    type Value = Box<dyn OvfExportTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid OvfExportTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl OvfExportTrait for OvfExport {
}
impl OvfExportTrait for ConnectedIso {
}
impl OvfExportTrait for OvfDuplicatedPropertyIdExport {
}
impl OvfExportTrait for OvfDuplicatedPropertyIdImport {
}
impl OvfExportTrait for OvfExportFailed {
}
impl OvfExportTrait for OvfHardwareExport {
}
impl OvfExportTrait for OvfConnectedDevice {
}
impl OvfExportTrait for OvfConnectedDeviceFloppy {
}
impl OvfExportTrait for OvfConnectedDeviceIso {
}
impl OvfExportTrait for OvfUnableToExportDisk {
}
impl OvfExportTrait for OvfUnknownDeviceBacking {
}
impl OvfExportTrait for OvfUnsupportedDeviceExport {
}
impl OvfExportTrait for OvfPropertyExport {
}
impl OvfExportTrait for OvfPropertyNetworkExport {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn OvfExportTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfExport => Some(from.as_any_ref().downcast_ref::<OvfExport>()?),
            StructType::ConnectedIso => Some(from.as_any_ref().downcast_ref::<ConnectedIso>()?),
            StructType::OvfDuplicatedPropertyIdExport => Some(from.as_any_ref().downcast_ref::<OvfDuplicatedPropertyIdExport>()?),
            StructType::OvfDuplicatedPropertyIdImport => Some(from.as_any_ref().downcast_ref::<OvfDuplicatedPropertyIdImport>()?),
            StructType::OvfExportFailed => Some(from.as_any_ref().downcast_ref::<OvfExportFailed>()?),
            StructType::OvfHardwareExport => Some(from.as_any_ref().downcast_ref::<OvfHardwareExport>()?),
            StructType::OvfConnectedDevice => Some(from.as_any_ref().downcast_ref::<OvfConnectedDevice>()?),
            StructType::OvfConnectedDeviceFloppy => Some(from.as_any_ref().downcast_ref::<OvfConnectedDeviceFloppy>()?),
            StructType::OvfConnectedDeviceIso => Some(from.as_any_ref().downcast_ref::<OvfConnectedDeviceIso>()?),
            StructType::OvfUnableToExportDisk => Some(from.as_any_ref().downcast_ref::<OvfUnableToExportDisk>()?),
            StructType::OvfUnknownDeviceBacking => Some(from.as_any_ref().downcast_ref::<OvfUnknownDeviceBacking>()?),
            StructType::OvfUnsupportedDeviceExport => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedDeviceExport>()?),
            StructType::OvfPropertyExport => Some(from.as_any_ref().downcast_ref::<OvfPropertyExport>()?),
            StructType::OvfPropertyNetworkExport => Some(from.as_any_ref().downcast_ref::<OvfPropertyNetworkExport>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfExport => Ok(from.as_any_box().downcast::<OvfExport>()?),
            StructType::ConnectedIso => Ok(from.as_any_box().downcast::<ConnectedIso>()?),
            StructType::OvfDuplicatedPropertyIdExport => Ok(from.as_any_box().downcast::<OvfDuplicatedPropertyIdExport>()?),
            StructType::OvfDuplicatedPropertyIdImport => Ok(from.as_any_box().downcast::<OvfDuplicatedPropertyIdImport>()?),
            StructType::OvfExportFailed => Ok(from.as_any_box().downcast::<OvfExportFailed>()?),
            StructType::OvfHardwareExport => Ok(from.as_any_box().downcast::<OvfHardwareExport>()?),
            StructType::OvfConnectedDevice => Ok(from.as_any_box().downcast::<OvfConnectedDevice>()?),
            StructType::OvfConnectedDeviceFloppy => Ok(from.as_any_box().downcast::<OvfConnectedDeviceFloppy>()?),
            StructType::OvfConnectedDeviceIso => Ok(from.as_any_box().downcast::<OvfConnectedDeviceIso>()?),
            StructType::OvfUnableToExportDisk => Ok(from.as_any_box().downcast::<OvfUnableToExportDisk>()?),
            StructType::OvfUnknownDeviceBacking => Ok(from.as_any_box().downcast::<OvfUnknownDeviceBacking>()?),
            StructType::OvfUnsupportedDeviceExport => Ok(from.as_any_box().downcast::<OvfUnsupportedDeviceExport>()?),
            StructType::OvfPropertyExport => Ok(from.as_any_box().downcast::<OvfPropertyExport>()?),
            StructType::OvfPropertyNetworkExport => Ok(from.as_any_box().downcast::<OvfPropertyNetworkExport>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// A common base class to host all the OvfLib Export Exceptions for hardware.
pub trait OvfHardwareExportTrait : super::traits::OvfExportTrait {
    /// The virtual device we are exporting to OVF
    fn get_device(&self) -> &Option<Box<dyn super::traits::VirtualDeviceTrait>>;
    /// The path to the VM containing the device.
    /// 
    /// This path shows the location of the VM in the vApp hierarchy, on the form:
    /// 
    /// /ParentVApp/ChildVApp/VMName
    fn get_vm_path(&self) -> &str;
}
impl<'s> serde::Serialize for dyn OvfHardwareExportTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn OvfHardwareExportTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(OvfHardwareExportVisitor)
            }
        }

struct OvfHardwareExportVisitor;

impl<'de> de::Visitor<'de> for OvfHardwareExportVisitor {
    type Value = Box<dyn OvfHardwareExportTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid OvfHardwareExportTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl OvfHardwareExportTrait for OvfHardwareExport {
    fn get_device(&self) -> &Option<Box<dyn super::traits::VirtualDeviceTrait>> { &self.device }
    fn get_vm_path(&self) -> &str { &self.vm_path }
}
impl OvfHardwareExportTrait for OvfConnectedDevice {
    fn get_device(&self) -> &Option<Box<dyn super::traits::VirtualDeviceTrait>> { &self.device }
    fn get_vm_path(&self) -> &str { &self.vm_path }
}
impl OvfHardwareExportTrait for OvfConnectedDeviceFloppy {
    fn get_device(&self) -> &Option<Box<dyn super::traits::VirtualDeviceTrait>> { &self.device }
    fn get_vm_path(&self) -> &str { &self.vm_path }
}
impl OvfHardwareExportTrait for OvfConnectedDeviceIso {
    fn get_device(&self) -> &Option<Box<dyn super::traits::VirtualDeviceTrait>> { &self.device }
    fn get_vm_path(&self) -> &str { &self.vm_path }
}
impl OvfHardwareExportTrait for OvfUnableToExportDisk {
    fn get_device(&self) -> &Option<Box<dyn super::traits::VirtualDeviceTrait>> { &self.device }
    fn get_vm_path(&self) -> &str { &self.vm_path }
}
impl OvfHardwareExportTrait for OvfUnknownDeviceBacking {
    fn get_device(&self) -> &Option<Box<dyn super::traits::VirtualDeviceTrait>> { &self.device }
    fn get_vm_path(&self) -> &str { &self.vm_path }
}
impl OvfHardwareExportTrait for OvfUnsupportedDeviceExport {
    fn get_device(&self) -> &Option<Box<dyn super::traits::VirtualDeviceTrait>> { &self.device }
    fn get_vm_path(&self) -> &str { &self.vm_path }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn OvfHardwareExportTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfHardwareExport => Some(from.as_any_ref().downcast_ref::<OvfHardwareExport>()?),
            StructType::OvfConnectedDevice => Some(from.as_any_ref().downcast_ref::<OvfConnectedDevice>()?),
            StructType::OvfConnectedDeviceFloppy => Some(from.as_any_ref().downcast_ref::<OvfConnectedDeviceFloppy>()?),
            StructType::OvfConnectedDeviceIso => Some(from.as_any_ref().downcast_ref::<OvfConnectedDeviceIso>()?),
            StructType::OvfUnableToExportDisk => Some(from.as_any_ref().downcast_ref::<OvfUnableToExportDisk>()?),
            StructType::OvfUnknownDeviceBacking => Some(from.as_any_ref().downcast_ref::<OvfUnknownDeviceBacking>()?),
            StructType::OvfUnsupportedDeviceExport => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedDeviceExport>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfHardwareExport => Ok(from.as_any_box().downcast::<OvfHardwareExport>()?),
            StructType::OvfConnectedDevice => Ok(from.as_any_box().downcast::<OvfConnectedDevice>()?),
            StructType::OvfConnectedDeviceFloppy => Ok(from.as_any_box().downcast::<OvfConnectedDeviceFloppy>()?),
            StructType::OvfConnectedDeviceIso => Ok(from.as_any_box().downcast::<OvfConnectedDeviceIso>()?),
            StructType::OvfUnableToExportDisk => Ok(from.as_any_box().downcast::<OvfUnableToExportDisk>()?),
            StructType::OvfUnknownDeviceBacking => Ok(from.as_any_box().downcast::<OvfUnknownDeviceBacking>()?),
            StructType::OvfUnsupportedDeviceExport => Ok(from.as_any_box().downcast::<OvfUnsupportedDeviceExport>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
pub trait OvfConnectedDeviceTrait : super::traits::OvfHardwareExportTrait {
}
impl<'s> serde::Serialize for dyn OvfConnectedDeviceTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn OvfConnectedDeviceTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(OvfConnectedDeviceVisitor)
            }
        }

struct OvfConnectedDeviceVisitor;

impl<'de> de::Visitor<'de> for OvfConnectedDeviceVisitor {
    type Value = Box<dyn OvfConnectedDeviceTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid OvfConnectedDeviceTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl OvfConnectedDeviceTrait for OvfConnectedDevice {
}
impl OvfConnectedDeviceTrait for OvfConnectedDeviceFloppy {
}
impl OvfConnectedDeviceTrait for OvfConnectedDeviceIso {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn OvfConnectedDeviceTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfConnectedDevice => Some(from.as_any_ref().downcast_ref::<OvfConnectedDevice>()?),
            StructType::OvfConnectedDeviceFloppy => Some(from.as_any_ref().downcast_ref::<OvfConnectedDeviceFloppy>()?),
            StructType::OvfConnectedDeviceIso => Some(from.as_any_ref().downcast_ref::<OvfConnectedDeviceIso>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfConnectedDevice => Ok(from.as_any_box().downcast::<OvfConnectedDevice>()?),
            StructType::OvfConnectedDeviceFloppy => Ok(from.as_any_box().downcast::<OvfConnectedDeviceFloppy>()?),
            StructType::OvfConnectedDeviceIso => Ok(from.as_any_box().downcast::<OvfConnectedDeviceIso>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// A common base class for errors that can happen during Import and
/// that is not due to an invalid package (OvfInvalidPackage).
/// 
/// These
/// are typically issued as warnings.
pub trait OvfImportTrait : super::traits::OvfFaultTrait {
}
impl<'s> serde::Serialize for dyn OvfImportTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn OvfImportTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(OvfImportVisitor)
            }
        }

struct OvfImportVisitor;

impl<'de> de::Visitor<'de> for OvfImportVisitor {
    type Value = Box<dyn OvfImportTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid OvfImportTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl OvfImportTrait for OvfImport {
}
impl OvfImportTrait for OvfCpuCompatibility {
}
impl OvfImportTrait for OvfCpuCompatibilityCheckNotSupported {
}
impl OvfImportTrait for OvfHardwareCheck {
}
impl OvfImportTrait for OvfImportFailed {
}
impl OvfImportTrait for OvfMappedOsId {
}
impl OvfImportTrait for OvfMissingHardware {
}
impl OvfImportTrait for OvfNetworkMappingNotSupported {
}
impl OvfImportTrait for OvfUnsupportedDiskProvisioning {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn OvfImportTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfImport => Some(from.as_any_ref().downcast_ref::<OvfImport>()?),
            StructType::OvfCpuCompatibility => Some(from.as_any_ref().downcast_ref::<OvfCpuCompatibility>()?),
            StructType::OvfCpuCompatibilityCheckNotSupported => Some(from.as_any_ref().downcast_ref::<OvfCpuCompatibilityCheckNotSupported>()?),
            StructType::OvfHardwareCheck => Some(from.as_any_ref().downcast_ref::<OvfHardwareCheck>()?),
            StructType::OvfImportFailed => Some(from.as_any_ref().downcast_ref::<OvfImportFailed>()?),
            StructType::OvfMappedOsId => Some(from.as_any_ref().downcast_ref::<OvfMappedOsId>()?),
            StructType::OvfMissingHardware => Some(from.as_any_ref().downcast_ref::<OvfMissingHardware>()?),
            StructType::OvfNetworkMappingNotSupported => Some(from.as_any_ref().downcast_ref::<OvfNetworkMappingNotSupported>()?),
            StructType::OvfUnsupportedDiskProvisioning => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedDiskProvisioning>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfImport => Ok(from.as_any_box().downcast::<OvfImport>()?),
            StructType::OvfCpuCompatibility => Ok(from.as_any_box().downcast::<OvfCpuCompatibility>()?),
            StructType::OvfCpuCompatibilityCheckNotSupported => Ok(from.as_any_box().downcast::<OvfCpuCompatibilityCheckNotSupported>()?),
            StructType::OvfHardwareCheck => Ok(from.as_any_box().downcast::<OvfHardwareCheck>()?),
            StructType::OvfImportFailed => Ok(from.as_any_box().downcast::<OvfImportFailed>()?),
            StructType::OvfMappedOsId => Ok(from.as_any_box().downcast::<OvfMappedOsId>()?),
            StructType::OvfMissingHardware => Ok(from.as_any_box().downcast::<OvfMissingHardware>()?),
            StructType::OvfNetworkMappingNotSupported => Ok(from.as_any_box().downcast::<OvfNetworkMappingNotSupported>()?),
            StructType::OvfUnsupportedDiskProvisioning => Ok(from.as_any_box().downcast::<OvfUnsupportedDiskProvisioning>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base fault class for all Invalid OVF package faults.
pub trait OvfInvalidPackageTrait : super::traits::OvfFaultTrait {
    /// XML OVF descriptor line numbers
    fn get_line_number(&self) -> i32;
}
impl<'s> serde::Serialize for dyn OvfInvalidPackageTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn OvfInvalidPackageTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(OvfInvalidPackageVisitor)
            }
        }

struct OvfInvalidPackageVisitor;

impl<'de> de::Visitor<'de> for OvfInvalidPackageVisitor {
    type Value = Box<dyn OvfInvalidPackageTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid OvfInvalidPackageTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl OvfInvalidPackageTrait for OvfInvalidPackage {
    fn get_line_number(&self) -> i32 { self.line_number }
}
impl OvfInvalidPackageTrait for OvfAttribute {
    fn get_line_number(&self) -> i32 { self.line_number }
}
impl OvfInvalidPackageTrait for OvfInvalidValue {
    fn get_line_number(&self) -> i32 { self.line_number }
}
impl OvfInvalidPackageTrait for OvfInvalidValueConfiguration {
    fn get_line_number(&self) -> i32 { self.line_number }
}
impl OvfInvalidPackageTrait for OvfInvalidValueEmpty {
    fn get_line_number(&self) -> i32 { self.line_number }
}
impl OvfInvalidPackageTrait for OvfInvalidValueFormatMalformed {
    fn get_line_number(&self) -> i32 { self.line_number }
}
impl OvfInvalidPackageTrait for OvfInvalidValueReference {
    fn get_line_number(&self) -> i32 { self.line_number }
}
impl OvfInvalidPackageTrait for OvfMissingAttribute {
    fn get_line_number(&self) -> i32 { self.line_number }
}
impl OvfInvalidPackageTrait for OvfConstraint {
    fn get_line_number(&self) -> i32 { self.line_number }
}
impl OvfInvalidPackageTrait for OvfDiskOrderConstraint {
    fn get_line_number(&self) -> i32 { self.line_number }
}
impl OvfInvalidPackageTrait for OvfHostResourceConstraint {
    fn get_line_number(&self) -> i32 { self.line_number }
}
impl OvfInvalidPackageTrait for OvfElement {
    fn get_line_number(&self) -> i32 { self.line_number }
}
impl OvfInvalidPackageTrait for OvfDuplicateElement {
    fn get_line_number(&self) -> i32 { self.line_number }
}
impl OvfInvalidPackageTrait for OvfDuplicatedElementBoundary {
    fn get_line_number(&self) -> i32 { self.line_number }
}
impl OvfInvalidPackageTrait for OvfElementInvalidValue {
    fn get_line_number(&self) -> i32 { self.line_number }
}
impl OvfInvalidPackageTrait for OvfMissingElement {
    fn get_line_number(&self) -> i32 { self.line_number }
}
impl OvfInvalidPackageTrait for OvfMissingElementNormalBoundary {
    fn get_line_number(&self) -> i32 { self.line_number }
}
impl OvfInvalidPackageTrait for OvfUnexpectedElement {
    fn get_line_number(&self) -> i32 { self.line_number }
}
impl OvfInvalidPackageTrait for OvfWrongElement {
    fn get_line_number(&self) -> i32 { self.line_number }
}
impl OvfInvalidPackageTrait for OvfProperty {
    fn get_line_number(&self) -> i32 { self.line_number }
}
impl OvfInvalidPackageTrait for OvfPropertyNetwork {
    fn get_line_number(&self) -> i32 { self.line_number }
}
impl OvfInvalidPackageTrait for OvfPropertyQualifier {
    fn get_line_number(&self) -> i32 { self.line_number }
}
impl OvfInvalidPackageTrait for OvfPropertyQualifierDuplicate {
    fn get_line_number(&self) -> i32 { self.line_number }
}
impl OvfInvalidPackageTrait for OvfPropertyQualifierIgnored {
    fn get_line_number(&self) -> i32 { self.line_number }
}
impl OvfInvalidPackageTrait for OvfPropertyType {
    fn get_line_number(&self) -> i32 { self.line_number }
}
impl OvfInvalidPackageTrait for OvfPropertyValue {
    fn get_line_number(&self) -> i32 { self.line_number }
}
impl OvfInvalidPackageTrait for OvfWrongNamespace {
    fn get_line_number(&self) -> i32 { self.line_number }
}
impl OvfInvalidPackageTrait for OvfXmlFormat {
    fn get_line_number(&self) -> i32 { self.line_number }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn OvfInvalidPackageTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfInvalidPackage => Some(from.as_any_ref().downcast_ref::<OvfInvalidPackage>()?),
            StructType::OvfAttribute => Some(from.as_any_ref().downcast_ref::<OvfAttribute>()?),
            StructType::OvfInvalidValue => Some(from.as_any_ref().downcast_ref::<OvfInvalidValue>()?),
            StructType::OvfInvalidValueConfiguration => Some(from.as_any_ref().downcast_ref::<OvfInvalidValueConfiguration>()?),
            StructType::OvfInvalidValueEmpty => Some(from.as_any_ref().downcast_ref::<OvfInvalidValueEmpty>()?),
            StructType::OvfInvalidValueFormatMalformed => Some(from.as_any_ref().downcast_ref::<OvfInvalidValueFormatMalformed>()?),
            StructType::OvfInvalidValueReference => Some(from.as_any_ref().downcast_ref::<OvfInvalidValueReference>()?),
            StructType::OvfMissingAttribute => Some(from.as_any_ref().downcast_ref::<OvfMissingAttribute>()?),
            StructType::OvfConstraint => Some(from.as_any_ref().downcast_ref::<OvfConstraint>()?),
            StructType::OvfDiskOrderConstraint => Some(from.as_any_ref().downcast_ref::<OvfDiskOrderConstraint>()?),
            StructType::OvfHostResourceConstraint => Some(from.as_any_ref().downcast_ref::<OvfHostResourceConstraint>()?),
            StructType::OvfElement => Some(from.as_any_ref().downcast_ref::<OvfElement>()?),
            StructType::OvfDuplicateElement => Some(from.as_any_ref().downcast_ref::<OvfDuplicateElement>()?),
            StructType::OvfDuplicatedElementBoundary => Some(from.as_any_ref().downcast_ref::<OvfDuplicatedElementBoundary>()?),
            StructType::OvfElementInvalidValue => Some(from.as_any_ref().downcast_ref::<OvfElementInvalidValue>()?),
            StructType::OvfMissingElement => Some(from.as_any_ref().downcast_ref::<OvfMissingElement>()?),
            StructType::OvfMissingElementNormalBoundary => Some(from.as_any_ref().downcast_ref::<OvfMissingElementNormalBoundary>()?),
            StructType::OvfUnexpectedElement => Some(from.as_any_ref().downcast_ref::<OvfUnexpectedElement>()?),
            StructType::OvfWrongElement => Some(from.as_any_ref().downcast_ref::<OvfWrongElement>()?),
            StructType::OvfProperty => Some(from.as_any_ref().downcast_ref::<OvfProperty>()?),
            StructType::OvfPropertyNetwork => Some(from.as_any_ref().downcast_ref::<OvfPropertyNetwork>()?),
            StructType::OvfPropertyQualifier => Some(from.as_any_ref().downcast_ref::<OvfPropertyQualifier>()?),
            StructType::OvfPropertyQualifierDuplicate => Some(from.as_any_ref().downcast_ref::<OvfPropertyQualifierDuplicate>()?),
            StructType::OvfPropertyQualifierIgnored => Some(from.as_any_ref().downcast_ref::<OvfPropertyQualifierIgnored>()?),
            StructType::OvfPropertyType => Some(from.as_any_ref().downcast_ref::<OvfPropertyType>()?),
            StructType::OvfPropertyValue => Some(from.as_any_ref().downcast_ref::<OvfPropertyValue>()?),
            StructType::OvfWrongNamespace => Some(from.as_any_ref().downcast_ref::<OvfWrongNamespace>()?),
            StructType::OvfXmlFormat => Some(from.as_any_ref().downcast_ref::<OvfXmlFormat>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfInvalidPackage => Ok(from.as_any_box().downcast::<OvfInvalidPackage>()?),
            StructType::OvfAttribute => Ok(from.as_any_box().downcast::<OvfAttribute>()?),
            StructType::OvfInvalidValue => Ok(from.as_any_box().downcast::<OvfInvalidValue>()?),
            StructType::OvfInvalidValueConfiguration => Ok(from.as_any_box().downcast::<OvfInvalidValueConfiguration>()?),
            StructType::OvfInvalidValueEmpty => Ok(from.as_any_box().downcast::<OvfInvalidValueEmpty>()?),
            StructType::OvfInvalidValueFormatMalformed => Ok(from.as_any_box().downcast::<OvfInvalidValueFormatMalformed>()?),
            StructType::OvfInvalidValueReference => Ok(from.as_any_box().downcast::<OvfInvalidValueReference>()?),
            StructType::OvfMissingAttribute => Ok(from.as_any_box().downcast::<OvfMissingAttribute>()?),
            StructType::OvfConstraint => Ok(from.as_any_box().downcast::<OvfConstraint>()?),
            StructType::OvfDiskOrderConstraint => Ok(from.as_any_box().downcast::<OvfDiskOrderConstraint>()?),
            StructType::OvfHostResourceConstraint => Ok(from.as_any_box().downcast::<OvfHostResourceConstraint>()?),
            StructType::OvfElement => Ok(from.as_any_box().downcast::<OvfElement>()?),
            StructType::OvfDuplicateElement => Ok(from.as_any_box().downcast::<OvfDuplicateElement>()?),
            StructType::OvfDuplicatedElementBoundary => Ok(from.as_any_box().downcast::<OvfDuplicatedElementBoundary>()?),
            StructType::OvfElementInvalidValue => Ok(from.as_any_box().downcast::<OvfElementInvalidValue>()?),
            StructType::OvfMissingElement => Ok(from.as_any_box().downcast::<OvfMissingElement>()?),
            StructType::OvfMissingElementNormalBoundary => Ok(from.as_any_box().downcast::<OvfMissingElementNormalBoundary>()?),
            StructType::OvfUnexpectedElement => Ok(from.as_any_box().downcast::<OvfUnexpectedElement>()?),
            StructType::OvfWrongElement => Ok(from.as_any_box().downcast::<OvfWrongElement>()?),
            StructType::OvfProperty => Ok(from.as_any_box().downcast::<OvfProperty>()?),
            StructType::OvfPropertyNetwork => Ok(from.as_any_box().downcast::<OvfPropertyNetwork>()?),
            StructType::OvfPropertyQualifier => Ok(from.as_any_box().downcast::<OvfPropertyQualifier>()?),
            StructType::OvfPropertyQualifierDuplicate => Ok(from.as_any_box().downcast::<OvfPropertyQualifierDuplicate>()?),
            StructType::OvfPropertyQualifierIgnored => Ok(from.as_any_box().downcast::<OvfPropertyQualifierIgnored>()?),
            StructType::OvfPropertyType => Ok(from.as_any_box().downcast::<OvfPropertyType>()?),
            StructType::OvfPropertyValue => Ok(from.as_any_box().downcast::<OvfPropertyValue>()?),
            StructType::OvfWrongNamespace => Ok(from.as_any_box().downcast::<OvfWrongNamespace>()?),
            StructType::OvfXmlFormat => Ok(from.as_any_box().downcast::<OvfXmlFormat>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// An OVF descriptor Attribute base class.
pub trait OvfAttributeTrait : super::traits::OvfInvalidPackageTrait {
    /// Element name where the attribute is defined
    fn get_element_name(&self) -> &str;
    /// Attribute name
    fn get_attribute_name(&self) -> &str;
}
impl<'s> serde::Serialize for dyn OvfAttributeTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn OvfAttributeTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(OvfAttributeVisitor)
            }
        }

struct OvfAttributeVisitor;

impl<'de> de::Visitor<'de> for OvfAttributeVisitor {
    type Value = Box<dyn OvfAttributeTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid OvfAttributeTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl OvfAttributeTrait for OvfAttribute {
    fn get_element_name(&self) -> &str { &self.element_name }
    fn get_attribute_name(&self) -> &str { &self.attribute_name }
}
impl OvfAttributeTrait for OvfInvalidValue {
    fn get_element_name(&self) -> &str { &self.element_name }
    fn get_attribute_name(&self) -> &str { &self.attribute_name }
}
impl OvfAttributeTrait for OvfInvalidValueConfiguration {
    fn get_element_name(&self) -> &str { &self.element_name }
    fn get_attribute_name(&self) -> &str { &self.attribute_name }
}
impl OvfAttributeTrait for OvfInvalidValueEmpty {
    fn get_element_name(&self) -> &str { &self.element_name }
    fn get_attribute_name(&self) -> &str { &self.attribute_name }
}
impl OvfAttributeTrait for OvfInvalidValueFormatMalformed {
    fn get_element_name(&self) -> &str { &self.element_name }
    fn get_attribute_name(&self) -> &str { &self.attribute_name }
}
impl OvfAttributeTrait for OvfInvalidValueReference {
    fn get_element_name(&self) -> &str { &self.element_name }
    fn get_attribute_name(&self) -> &str { &self.attribute_name }
}
impl OvfAttributeTrait for OvfMissingAttribute {
    fn get_element_name(&self) -> &str { &self.element_name }
    fn get_attribute_name(&self) -> &str { &self.attribute_name }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn OvfAttributeTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfAttribute => Some(from.as_any_ref().downcast_ref::<OvfAttribute>()?),
            StructType::OvfInvalidValue => Some(from.as_any_ref().downcast_ref::<OvfInvalidValue>()?),
            StructType::OvfInvalidValueConfiguration => Some(from.as_any_ref().downcast_ref::<OvfInvalidValueConfiguration>()?),
            StructType::OvfInvalidValueEmpty => Some(from.as_any_ref().downcast_ref::<OvfInvalidValueEmpty>()?),
            StructType::OvfInvalidValueFormatMalformed => Some(from.as_any_ref().downcast_ref::<OvfInvalidValueFormatMalformed>()?),
            StructType::OvfInvalidValueReference => Some(from.as_any_ref().downcast_ref::<OvfInvalidValueReference>()?),
            StructType::OvfMissingAttribute => Some(from.as_any_ref().downcast_ref::<OvfMissingAttribute>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfAttribute => Ok(from.as_any_box().downcast::<OvfAttribute>()?),
            StructType::OvfInvalidValue => Ok(from.as_any_box().downcast::<OvfInvalidValue>()?),
            StructType::OvfInvalidValueConfiguration => Ok(from.as_any_box().downcast::<OvfInvalidValueConfiguration>()?),
            StructType::OvfInvalidValueEmpty => Ok(from.as_any_box().downcast::<OvfInvalidValueEmpty>()?),
            StructType::OvfInvalidValueFormatMalformed => Ok(from.as_any_box().downcast::<OvfInvalidValueFormatMalformed>()?),
            StructType::OvfInvalidValueReference => Ok(from.as_any_box().downcast::<OvfInvalidValueReference>()?),
            StructType::OvfMissingAttribute => Ok(from.as_any_box().downcast::<OvfMissingAttribute>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// If an invalid value is found in the Ovf descriptor we throw an OvfInvalidValue exception.
pub trait OvfInvalidValueTrait : super::traits::OvfAttributeTrait {
    /// Attribute value
    fn get_value(&self) -> &str;
}
impl<'s> serde::Serialize for dyn OvfInvalidValueTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn OvfInvalidValueTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(OvfInvalidValueVisitor)
            }
        }

struct OvfInvalidValueVisitor;

impl<'de> de::Visitor<'de> for OvfInvalidValueVisitor {
    type Value = Box<dyn OvfInvalidValueTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid OvfInvalidValueTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl OvfInvalidValueTrait for OvfInvalidValue {
    fn get_value(&self) -> &str { &self.value }
}
impl OvfInvalidValueTrait for OvfInvalidValueConfiguration {
    fn get_value(&self) -> &str { &self.value }
}
impl OvfInvalidValueTrait for OvfInvalidValueEmpty {
    fn get_value(&self) -> &str { &self.value }
}
impl OvfInvalidValueTrait for OvfInvalidValueFormatMalformed {
    fn get_value(&self) -> &str { &self.value }
}
impl OvfInvalidValueTrait for OvfInvalidValueReference {
    fn get_value(&self) -> &str { &self.value }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn OvfInvalidValueTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfInvalidValue => Some(from.as_any_ref().downcast_ref::<OvfInvalidValue>()?),
            StructType::OvfInvalidValueConfiguration => Some(from.as_any_ref().downcast_ref::<OvfInvalidValueConfiguration>()?),
            StructType::OvfInvalidValueEmpty => Some(from.as_any_ref().downcast_ref::<OvfInvalidValueEmpty>()?),
            StructType::OvfInvalidValueFormatMalformed => Some(from.as_any_ref().downcast_ref::<OvfInvalidValueFormatMalformed>()?),
            StructType::OvfInvalidValueReference => Some(from.as_any_ref().downcast_ref::<OvfInvalidValueReference>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfInvalidValue => Ok(from.as_any_box().downcast::<OvfInvalidValue>()?),
            StructType::OvfInvalidValueConfiguration => Ok(from.as_any_box().downcast::<OvfInvalidValueConfiguration>()?),
            StructType::OvfInvalidValueEmpty => Ok(from.as_any_box().downcast::<OvfInvalidValueEmpty>()?),
            StructType::OvfInvalidValueFormatMalformed => Ok(from.as_any_box().downcast::<OvfInvalidValueFormatMalformed>()?),
            StructType::OvfInvalidValueReference => Ok(from.as_any_box().downcast::<OvfInvalidValueReference>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// A base fault for Ovf descriptor constraints
pub trait OvfConstraintTrait : super::traits::OvfInvalidPackageTrait {
    /// The name of the element
    fn get_name(&self) -> &str;
}
impl<'s> serde::Serialize for dyn OvfConstraintTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn OvfConstraintTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(OvfConstraintVisitor)
            }
        }

struct OvfConstraintVisitor;

impl<'de> de::Visitor<'de> for OvfConstraintVisitor {
    type Value = Box<dyn OvfConstraintTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid OvfConstraintTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl OvfConstraintTrait for OvfConstraint {
    fn get_name(&self) -> &str { &self.name }
}
impl OvfConstraintTrait for OvfDiskOrderConstraint {
    fn get_name(&self) -> &str { &self.name }
}
impl OvfConstraintTrait for OvfHostResourceConstraint {
    fn get_name(&self) -> &str { &self.name }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn OvfConstraintTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfConstraint => Some(from.as_any_ref().downcast_ref::<OvfConstraint>()?),
            StructType::OvfDiskOrderConstraint => Some(from.as_any_ref().downcast_ref::<OvfDiskOrderConstraint>()?),
            StructType::OvfHostResourceConstraint => Some(from.as_any_ref().downcast_ref::<OvfHostResourceConstraint>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfConstraint => Ok(from.as_any_box().downcast::<OvfConstraint>()?),
            StructType::OvfDiskOrderConstraint => Ok(from.as_any_box().downcast::<OvfDiskOrderConstraint>()?),
            StructType::OvfHostResourceConstraint => Ok(from.as_any_box().downcast::<OvfHostResourceConstraint>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// A base fault for element exceptions in the Ovf XML descriptor.
pub trait OvfElementTrait : super::traits::OvfInvalidPackageTrait {
    /// The name of the element
    fn get_name(&self) -> &str;
}
impl<'s> serde::Serialize for dyn OvfElementTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn OvfElementTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(OvfElementVisitor)
            }
        }

struct OvfElementVisitor;

impl<'de> de::Visitor<'de> for OvfElementVisitor {
    type Value = Box<dyn OvfElementTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid OvfElementTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl OvfElementTrait for OvfElement {
    fn get_name(&self) -> &str { &self.name }
}
impl OvfElementTrait for OvfDuplicateElement {
    fn get_name(&self) -> &str { &self.name }
}
impl OvfElementTrait for OvfDuplicatedElementBoundary {
    fn get_name(&self) -> &str { &self.name }
}
impl OvfElementTrait for OvfElementInvalidValue {
    fn get_name(&self) -> &str { &self.name }
}
impl OvfElementTrait for OvfMissingElement {
    fn get_name(&self) -> &str { &self.name }
}
impl OvfElementTrait for OvfMissingElementNormalBoundary {
    fn get_name(&self) -> &str { &self.name }
}
impl OvfElementTrait for OvfUnexpectedElement {
    fn get_name(&self) -> &str { &self.name }
}
impl OvfElementTrait for OvfWrongElement {
    fn get_name(&self) -> &str { &self.name }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn OvfElementTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfElement => Some(from.as_any_ref().downcast_ref::<OvfElement>()?),
            StructType::OvfDuplicateElement => Some(from.as_any_ref().downcast_ref::<OvfDuplicateElement>()?),
            StructType::OvfDuplicatedElementBoundary => Some(from.as_any_ref().downcast_ref::<OvfDuplicatedElementBoundary>()?),
            StructType::OvfElementInvalidValue => Some(from.as_any_ref().downcast_ref::<OvfElementInvalidValue>()?),
            StructType::OvfMissingElement => Some(from.as_any_ref().downcast_ref::<OvfMissingElement>()?),
            StructType::OvfMissingElementNormalBoundary => Some(from.as_any_ref().downcast_ref::<OvfMissingElementNormalBoundary>()?),
            StructType::OvfUnexpectedElement => Some(from.as_any_ref().downcast_ref::<OvfUnexpectedElement>()?),
            StructType::OvfWrongElement => Some(from.as_any_ref().downcast_ref::<OvfWrongElement>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfElement => Ok(from.as_any_box().downcast::<OvfElement>()?),
            StructType::OvfDuplicateElement => Ok(from.as_any_box().downcast::<OvfDuplicateElement>()?),
            StructType::OvfDuplicatedElementBoundary => Ok(from.as_any_box().downcast::<OvfDuplicatedElementBoundary>()?),
            StructType::OvfElementInvalidValue => Ok(from.as_any_box().downcast::<OvfElementInvalidValue>()?),
            StructType::OvfMissingElement => Ok(from.as_any_box().downcast::<OvfMissingElement>()?),
            StructType::OvfMissingElementNormalBoundary => Ok(from.as_any_box().downcast::<OvfMissingElementNormalBoundary>()?),
            StructType::OvfUnexpectedElement => Ok(from.as_any_box().downcast::<OvfUnexpectedElement>()?),
            StructType::OvfWrongElement => Ok(from.as_any_box().downcast::<OvfWrongElement>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// If the Ovf descriptor is missing an Element this exception is thrown.
pub trait OvfMissingElementTrait : super::traits::OvfElementTrait {
}
impl<'s> serde::Serialize for dyn OvfMissingElementTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn OvfMissingElementTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(OvfMissingElementVisitor)
            }
        }

struct OvfMissingElementVisitor;

impl<'de> de::Visitor<'de> for OvfMissingElementVisitor {
    type Value = Box<dyn OvfMissingElementTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid OvfMissingElementTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl OvfMissingElementTrait for OvfMissingElement {
}
impl OvfMissingElementTrait for OvfMissingElementNormalBoundary {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn OvfMissingElementTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfMissingElement => Some(from.as_any_ref().downcast_ref::<OvfMissingElement>()?),
            StructType::OvfMissingElementNormalBoundary => Some(from.as_any_ref().downcast_ref::<OvfMissingElementNormalBoundary>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfMissingElement => Ok(from.as_any_box().downcast::<OvfMissingElement>()?),
            StructType::OvfMissingElementNormalBoundary => Ok(from.as_any_box().downcast::<OvfMissingElementNormalBoundary>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// A base fault for property faults in the property section of the Ovf XML descriptor.
pub trait OvfPropertyTrait : super::traits::OvfInvalidPackageTrait {
    /// The type of the property
    fn get_type(&self) -> &str;
    /// The value of the property
    fn get_value(&self) -> &str;
}
impl<'s> serde::Serialize for dyn OvfPropertyTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn OvfPropertyTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(OvfPropertyVisitor)
            }
        }

struct OvfPropertyVisitor;

impl<'de> de::Visitor<'de> for OvfPropertyVisitor {
    type Value = Box<dyn OvfPropertyTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid OvfPropertyTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl OvfPropertyTrait for OvfProperty {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_value(&self) -> &str { &self.value }
}
impl OvfPropertyTrait for OvfPropertyNetwork {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_value(&self) -> &str { &self.value }
}
impl OvfPropertyTrait for OvfPropertyQualifier {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_value(&self) -> &str { &self.value }
}
impl OvfPropertyTrait for OvfPropertyQualifierDuplicate {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_value(&self) -> &str { &self.value }
}
impl OvfPropertyTrait for OvfPropertyQualifierIgnored {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_value(&self) -> &str { &self.value }
}
impl OvfPropertyTrait for OvfPropertyType {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_value(&self) -> &str { &self.value }
}
impl OvfPropertyTrait for OvfPropertyValue {
    fn get_type(&self) -> &str { &self.r#type }
    fn get_value(&self) -> &str { &self.value }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn OvfPropertyTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfProperty => Some(from.as_any_ref().downcast_ref::<OvfProperty>()?),
            StructType::OvfPropertyNetwork => Some(from.as_any_ref().downcast_ref::<OvfPropertyNetwork>()?),
            StructType::OvfPropertyQualifier => Some(from.as_any_ref().downcast_ref::<OvfPropertyQualifier>()?),
            StructType::OvfPropertyQualifierDuplicate => Some(from.as_any_ref().downcast_ref::<OvfPropertyQualifierDuplicate>()?),
            StructType::OvfPropertyQualifierIgnored => Some(from.as_any_ref().downcast_ref::<OvfPropertyQualifierIgnored>()?),
            StructType::OvfPropertyType => Some(from.as_any_ref().downcast_ref::<OvfPropertyType>()?),
            StructType::OvfPropertyValue => Some(from.as_any_ref().downcast_ref::<OvfPropertyValue>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfProperty => Ok(from.as_any_box().downcast::<OvfProperty>()?),
            StructType::OvfPropertyNetwork => Ok(from.as_any_box().downcast::<OvfPropertyNetwork>()?),
            StructType::OvfPropertyQualifier => Ok(from.as_any_box().downcast::<OvfPropertyQualifier>()?),
            StructType::OvfPropertyQualifierDuplicate => Ok(from.as_any_box().downcast::<OvfPropertyQualifierDuplicate>()?),
            StructType::OvfPropertyQualifierIgnored => Ok(from.as_any_box().downcast::<OvfPropertyQualifierIgnored>()?),
            StructType::OvfPropertyType => Ok(from.as_any_box().downcast::<OvfPropertyType>()?),
            StructType::OvfPropertyValue => Ok(from.as_any_box().downcast::<OvfPropertyValue>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// A common base class to host all the OVF subsystems's system faults.
/// 
/// This is a class of fault that can be thrown because of
/// some api changes, new hardware that are not supported by
/// the host.
pub trait OvfSystemFaultTrait : super::traits::OvfFaultTrait {
}
impl<'s> serde::Serialize for dyn OvfSystemFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn OvfSystemFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(OvfSystemFaultVisitor)
            }
        }

struct OvfSystemFaultVisitor;

impl<'de> de::Visitor<'de> for OvfSystemFaultVisitor {
    type Value = Box<dyn OvfSystemFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid OvfSystemFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl OvfSystemFaultTrait for OvfSystemFault {
}
impl OvfSystemFaultTrait for OvfDiskMappingNotFound {
}
impl OvfSystemFaultTrait for OvfHostValueNotParsed {
}
impl OvfSystemFaultTrait for OvfInternalError {
}
impl OvfSystemFaultTrait for OvfToXmlUnsupportedElement {
}
impl OvfSystemFaultTrait for OvfUnknownDevice {
}
impl OvfSystemFaultTrait for OvfUnknownEntity {
}
impl OvfSystemFaultTrait for OvfUnsupportedDeviceBackingInfo {
}
impl OvfSystemFaultTrait for OvfUnsupportedDeviceBackingOption {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn OvfSystemFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfSystemFault => Some(from.as_any_ref().downcast_ref::<OvfSystemFault>()?),
            StructType::OvfDiskMappingNotFound => Some(from.as_any_ref().downcast_ref::<OvfDiskMappingNotFound>()?),
            StructType::OvfHostValueNotParsed => Some(from.as_any_ref().downcast_ref::<OvfHostValueNotParsed>()?),
            StructType::OvfInternalError => Some(from.as_any_ref().downcast_ref::<OvfInternalError>()?),
            StructType::OvfToXmlUnsupportedElement => Some(from.as_any_ref().downcast_ref::<OvfToXmlUnsupportedElement>()?),
            StructType::OvfUnknownDevice => Some(from.as_any_ref().downcast_ref::<OvfUnknownDevice>()?),
            StructType::OvfUnknownEntity => Some(from.as_any_ref().downcast_ref::<OvfUnknownEntity>()?),
            StructType::OvfUnsupportedDeviceBackingInfo => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedDeviceBackingInfo>()?),
            StructType::OvfUnsupportedDeviceBackingOption => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedDeviceBackingOption>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfSystemFault => Ok(from.as_any_box().downcast::<OvfSystemFault>()?),
            StructType::OvfDiskMappingNotFound => Ok(from.as_any_box().downcast::<OvfDiskMappingNotFound>()?),
            StructType::OvfHostValueNotParsed => Ok(from.as_any_box().downcast::<OvfHostValueNotParsed>()?),
            StructType::OvfInternalError => Ok(from.as_any_box().downcast::<OvfInternalError>()?),
            StructType::OvfToXmlUnsupportedElement => Ok(from.as_any_box().downcast::<OvfToXmlUnsupportedElement>()?),
            StructType::OvfUnknownDevice => Ok(from.as_any_box().downcast::<OvfUnknownDevice>()?),
            StructType::OvfUnknownEntity => Ok(from.as_any_box().downcast::<OvfUnknownEntity>()?),
            StructType::OvfUnsupportedDeviceBackingInfo => Ok(from.as_any_box().downcast::<OvfUnsupportedDeviceBackingInfo>()?),
            StructType::OvfUnsupportedDeviceBackingOption => Ok(from.as_any_box().downcast::<OvfUnsupportedDeviceBackingOption>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// A common base class to host all the Ovf Lib Unsupported Package faults
pub trait OvfUnsupportedPackageTrait : super::traits::OvfFaultTrait {
    /// OVF descriptor linenumber
    fn get_line_number(&self) -> Option<i32>;
}
impl<'s> serde::Serialize for dyn OvfUnsupportedPackageTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn OvfUnsupportedPackageTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(OvfUnsupportedPackageVisitor)
            }
        }

struct OvfUnsupportedPackageVisitor;

impl<'de> de::Visitor<'de> for OvfUnsupportedPackageVisitor {
    type Value = Box<dyn OvfUnsupportedPackageTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid OvfUnsupportedPackageTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl OvfUnsupportedPackageTrait for OvfUnsupportedPackage {
    fn get_line_number(&self) -> Option<i32> { self.line_number }
}
impl OvfUnsupportedPackageTrait for OvfInvalidVmName {
    fn get_line_number(&self) -> Option<i32> { self.line_number }
}
impl OvfUnsupportedPackageTrait for OvfNoHostNic {
    fn get_line_number(&self) -> Option<i32> { self.line_number }
}
impl OvfUnsupportedPackageTrait for OvfNoSupportedHardwareFamily {
    fn get_line_number(&self) -> Option<i32> { self.line_number }
}
impl OvfUnsupportedPackageTrait for OvfUnsupportedAttribute {
    fn get_line_number(&self) -> Option<i32> { self.line_number }
}
impl OvfUnsupportedPackageTrait for OvfUnsupportedAttributeValue {
    fn get_line_number(&self) -> Option<i32> { self.line_number }
}
impl OvfUnsupportedPackageTrait for OvfUnsupportedElement {
    fn get_line_number(&self) -> Option<i32> { self.line_number }
}
impl OvfUnsupportedPackageTrait for OvfNoSpaceOnController {
    fn get_line_number(&self) -> Option<i32> { self.line_number }
}
impl OvfUnsupportedPackageTrait for OvfUnsupportedElementValue {
    fn get_line_number(&self) -> Option<i32> { self.line_number }
}
impl OvfUnsupportedPackageTrait for OvfUnsupportedSection {
    fn get_line_number(&self) -> Option<i32> { self.line_number }
}
impl OvfUnsupportedPackageTrait for OvfUnsupportedSubType {
    fn get_line_number(&self) -> Option<i32> { self.line_number }
}
impl OvfUnsupportedPackageTrait for OvfUnsupportedType {
    fn get_line_number(&self) -> Option<i32> { self.line_number }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn OvfUnsupportedPackageTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfUnsupportedPackage => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedPackage>()?),
            StructType::OvfInvalidVmName => Some(from.as_any_ref().downcast_ref::<OvfInvalidVmName>()?),
            StructType::OvfNoHostNic => Some(from.as_any_ref().downcast_ref::<OvfNoHostNic>()?),
            StructType::OvfNoSupportedHardwareFamily => Some(from.as_any_ref().downcast_ref::<OvfNoSupportedHardwareFamily>()?),
            StructType::OvfUnsupportedAttribute => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedAttribute>()?),
            StructType::OvfUnsupportedAttributeValue => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedAttributeValue>()?),
            StructType::OvfUnsupportedElement => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedElement>()?),
            StructType::OvfNoSpaceOnController => Some(from.as_any_ref().downcast_ref::<OvfNoSpaceOnController>()?),
            StructType::OvfUnsupportedElementValue => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedElementValue>()?),
            StructType::OvfUnsupportedSection => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedSection>()?),
            StructType::OvfUnsupportedSubType => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedSubType>()?),
            StructType::OvfUnsupportedType => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedType>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfUnsupportedPackage => Ok(from.as_any_box().downcast::<OvfUnsupportedPackage>()?),
            StructType::OvfInvalidVmName => Ok(from.as_any_box().downcast::<OvfInvalidVmName>()?),
            StructType::OvfNoHostNic => Ok(from.as_any_box().downcast::<OvfNoHostNic>()?),
            StructType::OvfNoSupportedHardwareFamily => Ok(from.as_any_box().downcast::<OvfNoSupportedHardwareFamily>()?),
            StructType::OvfUnsupportedAttribute => Ok(from.as_any_box().downcast::<OvfUnsupportedAttribute>()?),
            StructType::OvfUnsupportedAttributeValue => Ok(from.as_any_box().downcast::<OvfUnsupportedAttributeValue>()?),
            StructType::OvfUnsupportedElement => Ok(from.as_any_box().downcast::<OvfUnsupportedElement>()?),
            StructType::OvfNoSpaceOnController => Ok(from.as_any_box().downcast::<OvfNoSpaceOnController>()?),
            StructType::OvfUnsupportedElementValue => Ok(from.as_any_box().downcast::<OvfUnsupportedElementValue>()?),
            StructType::OvfUnsupportedSection => Ok(from.as_any_box().downcast::<OvfUnsupportedSection>()?),
            StructType::OvfUnsupportedSubType => Ok(from.as_any_box().downcast::<OvfUnsupportedSubType>()?),
            StructType::OvfUnsupportedType => Ok(from.as_any_box().downcast::<OvfUnsupportedType>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// If the Ovf descriptor have an unsupported attribute.
pub trait OvfUnsupportedAttributeTrait : super::traits::OvfUnsupportedPackageTrait {
    /// The name of the element with the unsupported attribute
    fn get_element_name(&self) -> &str;
    /// The name of the unsupported attribute
    fn get_attribute_name(&self) -> &str;
}
impl<'s> serde::Serialize for dyn OvfUnsupportedAttributeTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn OvfUnsupportedAttributeTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(OvfUnsupportedAttributeVisitor)
            }
        }

struct OvfUnsupportedAttributeVisitor;

impl<'de> de::Visitor<'de> for OvfUnsupportedAttributeVisitor {
    type Value = Box<dyn OvfUnsupportedAttributeTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid OvfUnsupportedAttributeTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl OvfUnsupportedAttributeTrait for OvfUnsupportedAttribute {
    fn get_element_name(&self) -> &str { &self.element_name }
    fn get_attribute_name(&self) -> &str { &self.attribute_name }
}
impl OvfUnsupportedAttributeTrait for OvfUnsupportedAttributeValue {
    fn get_element_name(&self) -> &str { &self.element_name }
    fn get_attribute_name(&self) -> &str { &self.attribute_name }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn OvfUnsupportedAttributeTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfUnsupportedAttribute => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedAttribute>()?),
            StructType::OvfUnsupportedAttributeValue => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedAttributeValue>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfUnsupportedAttribute => Ok(from.as_any_box().downcast::<OvfUnsupportedAttribute>()?),
            StructType::OvfUnsupportedAttributeValue => Ok(from.as_any_box().downcast::<OvfUnsupportedAttributeValue>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// If the Ovf descriptor has an unsupported element where it is not allowed.
pub trait OvfUnsupportedElementTrait : super::traits::OvfUnsupportedPackageTrait {
    /// The name of the unsupported element
    fn get_name(&self) -> &str;
}
impl<'s> serde::Serialize for dyn OvfUnsupportedElementTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn OvfUnsupportedElementTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(OvfUnsupportedElementVisitor)
            }
        }

struct OvfUnsupportedElementVisitor;

impl<'de> de::Visitor<'de> for OvfUnsupportedElementVisitor {
    type Value = Box<dyn OvfUnsupportedElementTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid OvfUnsupportedElementTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl OvfUnsupportedElementTrait for OvfUnsupportedElement {
    fn get_name(&self) -> &str { &self.name }
}
impl OvfUnsupportedElementTrait for OvfNoSpaceOnController {
    fn get_name(&self) -> &str { &self.name }
}
impl OvfUnsupportedElementTrait for OvfUnsupportedElementValue {
    fn get_name(&self) -> &str { &self.name }
}
impl OvfUnsupportedElementTrait for OvfUnsupportedSection {
    fn get_name(&self) -> &str { &self.name }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn OvfUnsupportedElementTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfUnsupportedElement => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedElement>()?),
            StructType::OvfNoSpaceOnController => Some(from.as_any_ref().downcast_ref::<OvfNoSpaceOnController>()?),
            StructType::OvfUnsupportedElementValue => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedElementValue>()?),
            StructType::OvfUnsupportedSection => Some(from.as_any_ref().downcast_ref::<OvfUnsupportedSection>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::OvfUnsupportedElement => Ok(from.as_any_box().downcast::<OvfUnsupportedElement>()?),
            StructType::OvfNoSpaceOnController => Ok(from.as_any_box().downcast::<OvfNoSpaceOnController>()?),
            StructType::OvfUnsupportedElementValue => Ok(from.as_any_box().downcast::<OvfUnsupportedElementValue>()?),
            StructType::OvfUnsupportedSection => Ok(from.as_any_box().downcast::<OvfUnsupportedSection>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This fault is thrown if a patch query or
/// installation operation fails because of a problem with the metadata
/// associated with the patch.
/// 
/// Typically, a subclass of this exception is
/// thrown, indicating a problem such as the metadata is not found or the
/// metadata is corrupted.
pub trait PatchMetadataInvalidTrait : super::traits::VimFaultTrait {
    /// The patch ID whose associated metadata is invalid.
    fn get_patch_id(&self) -> &str;
    /// The metadata file that is not available or corrupted.
    fn get_meta_data(&self) -> &Option<Vec<String>>;
}
impl<'s> serde::Serialize for dyn PatchMetadataInvalidTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn PatchMetadataInvalidTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(PatchMetadataInvalidVisitor)
            }
        }

struct PatchMetadataInvalidVisitor;

impl<'de> de::Visitor<'de> for PatchMetadataInvalidVisitor {
    type Value = Box<dyn PatchMetadataInvalidTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid PatchMetadataInvalidTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl PatchMetadataInvalidTrait for PatchMetadataInvalid {
    fn get_patch_id(&self) -> &str { &self.patch_id }
    fn get_meta_data(&self) -> &Option<Vec<String>> { &self.meta_data }
}
impl PatchMetadataInvalidTrait for PatchMetadataCorrupted {
    fn get_patch_id(&self) -> &str { &self.patch_id }
    fn get_meta_data(&self) -> &Option<Vec<String>> { &self.meta_data }
}
impl PatchMetadataInvalidTrait for PatchMetadataNotFound {
    fn get_patch_id(&self) -> &str { &self.patch_id }
    fn get_meta_data(&self) -> &Option<Vec<String>> { &self.meta_data }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn PatchMetadataInvalidTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::PatchMetadataInvalid => Some(from.as_any_ref().downcast_ref::<PatchMetadataInvalid>()?),
            StructType::PatchMetadataCorrupted => Some(from.as_any_ref().downcast_ref::<PatchMetadataCorrupted>()?),
            StructType::PatchMetadataNotFound => Some(from.as_any_ref().downcast_ref::<PatchMetadataNotFound>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::PatchMetadataInvalid => Ok(from.as_any_box().downcast::<PatchMetadataInvalid>()?),
            StructType::PatchMetadataCorrupted => Ok(from.as_any_box().downcast::<PatchMetadataCorrupted>()?),
            StructType::PatchMetadataNotFound => Ok(from.as_any_box().downcast::<PatchMetadataNotFound>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// This fault is thrown if a patch install fails because the patch is not
/// applicable to the host.
/// 
/// Typically, a subclass of this exception is
/// thrown, indicating a problem such as the patch is superseded, already
/// installed, or has dependencies missing, and so on.
pub trait PatchNotApplicableTrait : super::traits::VimFaultTrait {
    /// The ID of the patch that is not applicable to the host.
    fn get_patch_id(&self) -> &str;
}
impl<'s> serde::Serialize for dyn PatchNotApplicableTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn PatchNotApplicableTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(PatchNotApplicableVisitor)
            }
        }

struct PatchNotApplicableVisitor;

impl<'de> de::Visitor<'de> for PatchNotApplicableVisitor {
    type Value = Box<dyn PatchNotApplicableTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid PatchNotApplicableTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl PatchNotApplicableTrait for PatchNotApplicable {
    fn get_patch_id(&self) -> &str { &self.patch_id }
}
impl PatchNotApplicableTrait for PatchAlreadyInstalled {
    fn get_patch_id(&self) -> &str { &self.patch_id }
}
impl PatchNotApplicableTrait for PatchMissingDependencies {
    fn get_patch_id(&self) -> &str { &self.patch_id }
}
impl PatchNotApplicableTrait for PatchSuperseded {
    fn get_patch_id(&self) -> &str { &self.patch_id }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn PatchNotApplicableTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::PatchNotApplicable => Some(from.as_any_ref().downcast_ref::<PatchNotApplicable>()?),
            StructType::PatchAlreadyInstalled => Some(from.as_any_ref().downcast_ref::<PatchAlreadyInstalled>()?),
            StructType::PatchMissingDependencies => Some(from.as_any_ref().downcast_ref::<PatchMissingDependencies>()?),
            StructType::PatchSuperseded => Some(from.as_any_ref().downcast_ref::<PatchSuperseded>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::PatchNotApplicable => Ok(from.as_any_box().downcast::<PatchNotApplicable>()?),
            StructType::PatchAlreadyInstalled => Ok(from.as_any_box().downcast::<PatchAlreadyInstalled>()?),
            StructType::PatchMissingDependencies => Ok(from.as_any_box().downcast::<PatchMissingDependencies>()?),
            StructType::PatchSuperseded => Ok(from.as_any_box().downcast::<PatchSuperseded>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base type for Replication-related errors.
pub trait ReplicationFaultTrait : super::traits::VimFaultTrait {
}
impl<'s> serde::Serialize for dyn ReplicationFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ReplicationFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ReplicationFaultVisitor)
            }
        }

struct ReplicationFaultVisitor;

impl<'de> de::Visitor<'de> for ReplicationFaultVisitor {
    type Value = Box<dyn ReplicationFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ReplicationFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ReplicationFaultTrait for ReplicationFault {
}
impl ReplicationFaultTrait for IncompatibleHostForVmReplication {
}
impl ReplicationFaultTrait for ReplicationConfigFault {
}
impl ReplicationFaultTrait for ReplicationDiskConfigFault {
}
impl ReplicationFaultTrait for ReplicationVmConfigFault {
}
impl ReplicationFaultTrait for ReplicationIncompatibleWithFt {
}
impl ReplicationFaultTrait for ReplicationInvalidOptions {
}
impl ReplicationFaultTrait for ReplicationNotSupportedOnHost {
}
impl ReplicationFaultTrait for ReplicationVmFault {
}
impl ReplicationFaultTrait for ReplicationVmInProgressFault {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ReplicationFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ReplicationFault => Some(from.as_any_ref().downcast_ref::<ReplicationFault>()?),
            StructType::IncompatibleHostForVmReplication => Some(from.as_any_ref().downcast_ref::<IncompatibleHostForVmReplication>()?),
            StructType::ReplicationConfigFault => Some(from.as_any_ref().downcast_ref::<ReplicationConfigFault>()?),
            StructType::ReplicationDiskConfigFault => Some(from.as_any_ref().downcast_ref::<ReplicationDiskConfigFault>()?),
            StructType::ReplicationVmConfigFault => Some(from.as_any_ref().downcast_ref::<ReplicationVmConfigFault>()?),
            StructType::ReplicationIncompatibleWithFt => Some(from.as_any_ref().downcast_ref::<ReplicationIncompatibleWithFt>()?),
            StructType::ReplicationInvalidOptions => Some(from.as_any_ref().downcast_ref::<ReplicationInvalidOptions>()?),
            StructType::ReplicationNotSupportedOnHost => Some(from.as_any_ref().downcast_ref::<ReplicationNotSupportedOnHost>()?),
            StructType::ReplicationVmFault => Some(from.as_any_ref().downcast_ref::<ReplicationVmFault>()?),
            StructType::ReplicationVmInProgressFault => Some(from.as_any_ref().downcast_ref::<ReplicationVmInProgressFault>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ReplicationFault => Ok(from.as_any_box().downcast::<ReplicationFault>()?),
            StructType::IncompatibleHostForVmReplication => Ok(from.as_any_box().downcast::<IncompatibleHostForVmReplication>()?),
            StructType::ReplicationConfigFault => Ok(from.as_any_box().downcast::<ReplicationConfigFault>()?),
            StructType::ReplicationDiskConfigFault => Ok(from.as_any_box().downcast::<ReplicationDiskConfigFault>()?),
            StructType::ReplicationVmConfigFault => Ok(from.as_any_box().downcast::<ReplicationVmConfigFault>()?),
            StructType::ReplicationIncompatibleWithFt => Ok(from.as_any_box().downcast::<ReplicationIncompatibleWithFt>()?),
            StructType::ReplicationInvalidOptions => Ok(from.as_any_box().downcast::<ReplicationInvalidOptions>()?),
            StructType::ReplicationNotSupportedOnHost => Ok(from.as_any_box().downcast::<ReplicationNotSupportedOnHost>()?),
            StructType::ReplicationVmFault => Ok(from.as_any_box().downcast::<ReplicationVmFault>()?),
            StructType::ReplicationVmInProgressFault => Ok(from.as_any_box().downcast::<ReplicationVmInProgressFault>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base type for Replication-related configuration errors.
pub trait ReplicationConfigFaultTrait : super::traits::ReplicationFaultTrait {
}
impl<'s> serde::Serialize for dyn ReplicationConfigFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ReplicationConfigFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ReplicationConfigFaultVisitor)
            }
        }

struct ReplicationConfigFaultVisitor;

impl<'de> de::Visitor<'de> for ReplicationConfigFaultVisitor {
    type Value = Box<dyn ReplicationConfigFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ReplicationConfigFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ReplicationConfigFaultTrait for ReplicationConfigFault {
}
impl ReplicationConfigFaultTrait for ReplicationDiskConfigFault {
}
impl ReplicationConfigFaultTrait for ReplicationVmConfigFault {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ReplicationConfigFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ReplicationConfigFault => Some(from.as_any_ref().downcast_ref::<ReplicationConfigFault>()?),
            StructType::ReplicationDiskConfigFault => Some(from.as_any_ref().downcast_ref::<ReplicationDiskConfigFault>()?),
            StructType::ReplicationVmConfigFault => Some(from.as_any_ref().downcast_ref::<ReplicationVmConfigFault>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ReplicationConfigFault => Ok(from.as_any_box().downcast::<ReplicationConfigFault>()?),
            StructType::ReplicationDiskConfigFault => Ok(from.as_any_box().downcast::<ReplicationDiskConfigFault>()?),
            StructType::ReplicationVmConfigFault => Ok(from.as_any_box().downcast::<ReplicationVmConfigFault>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// A ReplicationVmFault is thrown when there is an issue with
/// an operation performed on a replicated *VirtualMachine*
pub trait ReplicationVmFaultTrait : super::traits::ReplicationFaultTrait {
    /// The reason for the failure.
    /// 
    /// One of the above.
    fn get_reason(&self) -> &str;
    /// The current *ReplicationVmState_enum* of the
    /// *VirtualMachine*
    fn get_state(&self) -> &Option<String>;
    /// The name of the instance currently being created.
    fn get_instance_id(&self) -> &Option<String>;
    /// The virtual machine, for identification purposes.
    /// 
    /// Refers instance of *VirtualMachine*.
    fn get_vm(&self) -> &ManagedObjectReference;
}
impl<'s> serde::Serialize for dyn ReplicationVmFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ReplicationVmFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ReplicationVmFaultVisitor)
            }
        }

struct ReplicationVmFaultVisitor;

impl<'de> de::Visitor<'de> for ReplicationVmFaultVisitor {
    type Value = Box<dyn ReplicationVmFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ReplicationVmFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ReplicationVmFaultTrait for ReplicationVmFault {
    fn get_reason(&self) -> &str { &self.reason }
    fn get_state(&self) -> &Option<String> { &self.state }
    fn get_instance_id(&self) -> &Option<String> { &self.instance_id }
    fn get_vm(&self) -> &ManagedObjectReference { &self.vm }
}
impl ReplicationVmFaultTrait for ReplicationVmInProgressFault {
    fn get_reason(&self) -> &str { &self.reason }
    fn get_state(&self) -> &Option<String> { &self.state }
    fn get_instance_id(&self) -> &Option<String> { &self.instance_id }
    fn get_vm(&self) -> &ManagedObjectReference { &self.vm }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ReplicationVmFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ReplicationVmFault => Some(from.as_any_ref().downcast_ref::<ReplicationVmFault>()?),
            StructType::ReplicationVmInProgressFault => Some(from.as_any_ref().downcast_ref::<ReplicationVmInProgressFault>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ReplicationVmFault => Ok(from.as_any_box().downcast::<ReplicationVmFault>()?),
            StructType::ReplicationVmInProgressFault => Ok(from.as_any_box().downcast::<ReplicationVmInProgressFault>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// A ResourceInUse fault indicating that some error has occurred because a
/// resource was in use.
/// 
/// Information about the resource that is in use may
/// be supplied.
pub trait ResourceInUseTrait : super::traits::VimFaultTrait {
    /// Type of resource that is in use.
    fn get_type(&self) -> &Option<String>;
    /// Name of the instance of the resource that is in use.
    fn get_name(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn ResourceInUseTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ResourceInUseTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ResourceInUseVisitor)
            }
        }

struct ResourceInUseVisitor;

impl<'de> de::Visitor<'de> for ResourceInUseVisitor {
    type Value = Box<dyn ResourceInUseTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ResourceInUseTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ResourceInUseTrait for ResourceInUse {
    fn get_type(&self) -> &Option<String> { &self.r#type }
    fn get_name(&self) -> &Option<String> { &self.name }
}
impl ResourceInUseTrait for FilterInUse {
    fn get_type(&self) -> &Option<String> { &self.r#type }
    fn get_name(&self) -> &Option<String> { &self.name }
}
impl ResourceInUseTrait for QuiesceDatastoreIoForHaFailed {
    fn get_type(&self) -> &Option<String> { &self.r#type }
    fn get_name(&self) -> &Option<String> { &self.name }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ResourceInUseTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ResourceInUse => Some(from.as_any_ref().downcast_ref::<ResourceInUse>()?),
            StructType::FilterInUse => Some(from.as_any_ref().downcast_ref::<FilterInUse>()?),
            StructType::QuiesceDatastoreIoForHaFailed => Some(from.as_any_ref().downcast_ref::<QuiesceDatastoreIoForHaFailed>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ResourceInUse => Ok(from.as_any_box().downcast::<ResourceInUse>()?),
            StructType::FilterInUse => Ok(from.as_any_box().downcast::<FilterInUse>()?),
            StructType::QuiesceDatastoreIoForHaFailed => Ok(from.as_any_box().downcast::<QuiesceDatastoreIoForHaFailed>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base type for Snapshot-related errors.
pub trait SnapshotFaultTrait : super::traits::VimFaultTrait {
}
impl<'s> serde::Serialize for dyn SnapshotFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn SnapshotFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(SnapshotFaultVisitor)
            }
        }

struct SnapshotFaultVisitor;

impl<'de> de::Visitor<'de> for SnapshotFaultVisitor {
    type Value = Box<dyn SnapshotFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid SnapshotFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl SnapshotFaultTrait for SnapshotFault {
}
impl SnapshotFaultTrait for ApplicationQuiesceFault {
}
impl SnapshotFaultTrait for FilesystemQuiesceFault {
}
impl SnapshotFaultTrait for MemorySnapshotOnIndependentDisk {
}
impl SnapshotFaultTrait for MultipleSnapshotsNotSupported {
}
impl SnapshotFaultTrait for SnapshotDisabled {
}
impl SnapshotFaultTrait for SnapshotIncompatibleDeviceInVm {
}
impl SnapshotFaultTrait for SnapshotLocked {
}
impl SnapshotFaultTrait for SnapshotNoChange {
}
impl SnapshotFaultTrait for TooManySnapshotLevels {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn SnapshotFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::SnapshotFault => Some(from.as_any_ref().downcast_ref::<SnapshotFault>()?),
            StructType::ApplicationQuiesceFault => Some(from.as_any_ref().downcast_ref::<ApplicationQuiesceFault>()?),
            StructType::FilesystemQuiesceFault => Some(from.as_any_ref().downcast_ref::<FilesystemQuiesceFault>()?),
            StructType::MemorySnapshotOnIndependentDisk => Some(from.as_any_ref().downcast_ref::<MemorySnapshotOnIndependentDisk>()?),
            StructType::MultipleSnapshotsNotSupported => Some(from.as_any_ref().downcast_ref::<MultipleSnapshotsNotSupported>()?),
            StructType::SnapshotDisabled => Some(from.as_any_ref().downcast_ref::<SnapshotDisabled>()?),
            StructType::SnapshotIncompatibleDeviceInVm => Some(from.as_any_ref().downcast_ref::<SnapshotIncompatibleDeviceInVm>()?),
            StructType::SnapshotLocked => Some(from.as_any_ref().downcast_ref::<SnapshotLocked>()?),
            StructType::SnapshotNoChange => Some(from.as_any_ref().downcast_ref::<SnapshotNoChange>()?),
            StructType::TooManySnapshotLevels => Some(from.as_any_ref().downcast_ref::<TooManySnapshotLevels>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::SnapshotFault => Ok(from.as_any_box().downcast::<SnapshotFault>()?),
            StructType::ApplicationQuiesceFault => Ok(from.as_any_box().downcast::<ApplicationQuiesceFault>()?),
            StructType::FilesystemQuiesceFault => Ok(from.as_any_box().downcast::<FilesystemQuiesceFault>()?),
            StructType::MemorySnapshotOnIndependentDisk => Ok(from.as_any_box().downcast::<MemorySnapshotOnIndependentDisk>()?),
            StructType::MultipleSnapshotsNotSupported => Ok(from.as_any_box().downcast::<MultipleSnapshotsNotSupported>()?),
            StructType::SnapshotDisabled => Ok(from.as_any_box().downcast::<SnapshotDisabled>()?),
            StructType::SnapshotIncompatibleDeviceInVm => Ok(from.as_any_box().downcast::<SnapshotIncompatibleDeviceInVm>()?),
            StructType::SnapshotLocked => Ok(from.as_any_box().downcast::<SnapshotLocked>()?),
            StructType::SnapshotNoChange => Ok(from.as_any_box().downcast::<SnapshotNoChange>()?),
            StructType::TooManySnapshotLevels => Ok(from.as_any_box().downcast::<TooManySnapshotLevels>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The TaskInProgress data object type represents a fault when an operation tries
/// to access an entity that already has another (long) operation in progress.
pub trait TaskInProgressTrait : super::traits::VimFaultTrait {
    /// The task already in progress when the operation was attempted.
    /// 
    /// Refers instance of *Task*.
    fn get_task(&self) -> &ManagedObjectReference;
}
impl<'s> serde::Serialize for dyn TaskInProgressTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn TaskInProgressTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(TaskInProgressVisitor)
            }
        }

struct TaskInProgressVisitor;

impl<'de> de::Visitor<'de> for TaskInProgressVisitor {
    type Value = Box<dyn TaskInProgressTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid TaskInProgressTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl TaskInProgressTrait for TaskInProgress {
    fn get_task(&self) -> &ManagedObjectReference { &self.task }
}
impl TaskInProgressTrait for VAppTaskInProgress {
    fn get_task(&self) -> &ManagedObjectReference { &self.task }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn TaskInProgressTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::TaskInProgress => Some(from.as_any_ref().downcast_ref::<TaskInProgress>()?),
            StructType::VAppTaskInProgress => Some(from.as_any_ref().downcast_ref::<VAppTaskInProgress>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::TaskInProgress => Ok(from.as_any_box().downcast::<TaskInProgress>()?),
            StructType::VAppTaskInProgress => Ok(from.as_any_box().downcast::<VAppTaskInProgress>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Timedout exception is thrown when a server abandons an operation that
/// is taking longer than expected.
pub trait TimedoutTrait : super::traits::VimFaultTrait {
}
impl<'s> serde::Serialize for dyn TimedoutTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn TimedoutTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(TimedoutVisitor)
            }
        }

struct TimedoutVisitor;

impl<'de> de::Visitor<'de> for TimedoutVisitor {
    type Value = Box<dyn TimedoutTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid TimedoutTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl TimedoutTrait for Timedout {
}
impl TimedoutTrait for PowerOnFtSecondaryTimedout {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn TimedoutTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::Timedout => Some(from.as_any_ref().downcast_ref::<Timedout>()?),
            StructType::PowerOnFtSecondaryTimedout => Some(from.as_any_ref().downcast_ref::<PowerOnFtSecondaryTimedout>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::Timedout => Ok(from.as_any_box().downcast::<Timedout>()?),
            StructType::PowerOnFtSecondaryTimedout => Ok(from.as_any_box().downcast::<PowerOnFtSecondaryTimedout>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base for configuration / environment issues that can be thrown when powering on or
/// changing the configuration of a vApp.
pub trait VAppConfigFaultTrait : super::traits::VimFaultTrait {
}
impl<'s> serde::Serialize for dyn VAppConfigFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VAppConfigFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VAppConfigFaultVisitor)
            }
        }

struct VAppConfigFaultVisitor;

impl<'de> de::Visitor<'de> for VAppConfigFaultVisitor {
    type Value = Box<dyn VAppConfigFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VAppConfigFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VAppConfigFaultTrait for VAppConfigFault {
}
impl VAppConfigFaultTrait for MissingPowerOffConfiguration {
}
impl VAppConfigFaultTrait for MissingPowerOnConfiguration {
}
impl VAppConfigFaultTrait for NoVmInVApp {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VAppConfigFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VAppConfigFault => Some(from.as_any_ref().downcast_ref::<VAppConfigFault>()?),
            StructType::MissingPowerOffConfiguration => Some(from.as_any_ref().downcast_ref::<MissingPowerOffConfiguration>()?),
            StructType::MissingPowerOnConfiguration => Some(from.as_any_ref().downcast_ref::<MissingPowerOnConfiguration>()?),
            StructType::NoVmInVApp => Some(from.as_any_ref().downcast_ref::<NoVmInVApp>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VAppConfigFault => Ok(from.as_any_box().downcast::<VAppConfigFault>()?),
            StructType::MissingPowerOffConfiguration => Ok(from.as_any_box().downcast::<MissingPowerOffConfiguration>()?),
            StructType::MissingPowerOnConfiguration => Ok(from.as_any_box().downcast::<MissingPowerOnConfiguration>()?),
            StructType::NoVmInVApp => Ok(from.as_any_box().downcast::<NoVmInVApp>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base for configuration / environment issues that can be thrown when powering on or
/// changing the configuration of a virtual machine.
/// 
/// Subclasses of this fault is also
/// used as recent why a migration can fail.
pub trait VmConfigFaultTrait : super::traits::VimFaultTrait {
}
impl<'s> serde::Serialize for dyn VmConfigFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VmConfigFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VmConfigFaultVisitor)
            }
        }

struct VmConfigFaultVisitor;

impl<'de> de::Visitor<'de> for VmConfigFaultVisitor {
    type Value = Box<dyn VmConfigFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VmConfigFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VmConfigFaultTrait for VmConfigFault {
}
impl VmConfigFaultTrait for CannotAccessVmComponent {
}
impl VmConfigFaultTrait for CannotAccessVmConfig {
}
impl VmConfigFaultTrait for CannotAccessVmDevice {
}
impl VmConfigFaultTrait for CannotAccessNetwork {
}
impl VmConfigFaultTrait for DestinationSwitchFull {
}
impl VmConfigFaultTrait for LegacyNetworkInterfaceInUse {
}
impl VmConfigFaultTrait for VmOnConflictDvPort {
}
impl VmConfigFaultTrait for VmOnVirtualIntranet {
}
impl VmConfigFaultTrait for CannotAccessVmDisk {
}
impl VmConfigFaultTrait for RdmPointsToInaccessibleDisk {
}
impl VmConfigFaultTrait for CannotDisableSnapshot {
}
impl VmConfigFaultTrait for CannotUseNetwork {
}
impl VmConfigFaultTrait for CpuHotPlugNotSupported {
}
impl VmConfigFaultTrait for DeltaDiskFormatNotSupported {
}
impl VmConfigFaultTrait for EightHostLimitViolated {
}
impl VmConfigFaultTrait for FaultToleranceCannotEditMem {
}
impl VmConfigFaultTrait for GenericVmConfigFault {
}
impl VmConfigFaultTrait for InvalidFormat {
}
impl VmConfigFaultTrait for InvalidDiskFormat {
}
impl VmConfigFaultTrait for InvalidSnapshotFormat {
}
impl VmConfigFaultTrait for InvalidVmConfig {
}
impl VmConfigFaultTrait for InvalidDeviceSpec {
}
impl VmConfigFaultTrait for DeviceHotPlugNotSupported {
}
impl VmConfigFaultTrait for DeviceNotFound {
}
impl VmConfigFaultTrait for DeviceUnsupportedForVmPlatform {
}
impl VmConfigFaultTrait for DeviceUnsupportedForVmVersion {
}
impl VmConfigFaultTrait for DisallowedDiskModeChange {
}
impl VmConfigFaultTrait for InvalidController {
}
impl VmConfigFaultTrait for InvalidDeviceBacking {
}
impl VmConfigFaultTrait for InvalidDeviceOperation {
}
impl VmConfigFaultTrait for MissingController {
}
impl VmConfigFaultTrait for SwapPlacementOverrideNotSupported {
}
impl VmConfigFaultTrait for TooManyDevices {
}
impl VmConfigFaultTrait for UnsupportedGuest {
}
impl VmConfigFaultTrait for VmWwnConflict {
}
impl VmConfigFaultTrait for LargeRdmNotSupportedOnDatastore {
}
impl VmConfigFaultTrait for MemoryHotPlugNotSupported {
}
impl VmConfigFaultTrait for NoCompatibleHardAffinityHost {
}
impl VmConfigFaultTrait for NoCompatibleSoftAffinityHost {
}
impl VmConfigFaultTrait for NumVirtualCpusIncompatible {
}
impl VmConfigFaultTrait for OvfConsumerValidationFault {
}
impl VmConfigFaultTrait for QuarantineModeFault {
}
impl VmConfigFaultTrait for RdmNotSupportedOnDatastore {
}
impl VmConfigFaultTrait for RuleViolation {
}
impl VmConfigFaultTrait for SoftRuleVioCorrectionDisallowed {
}
impl VmConfigFaultTrait for SoftRuleVioCorrectionImpact {
}
impl VmConfigFaultTrait for UnsupportedDatastore {
}
impl VmConfigFaultTrait for MemoryFileFormatNotSupportedByDatastore {
}
impl VmConfigFaultTrait for UnSupportedDatastoreForVFlash {
}
impl VmConfigFaultTrait for UnsupportedVmxLocation {
}
impl VmConfigFaultTrait for VAppNotRunning {
}
impl VmConfigFaultTrait for VAppPropertyFault {
}
impl VmConfigFaultTrait for InvalidNetworkInType {
}
impl VmConfigFaultTrait for InvalidPropertyType {
}
impl VmConfigFaultTrait for InvalidPropertyValue {
}
impl VmConfigFaultTrait for UnconfiguredPropertyValue {
}
impl VmConfigFaultTrait for MissingIpPool {
}
impl VmConfigFaultTrait for MissingNetworkIpConfig {
}
impl VmConfigFaultTrait for NoAvailableIp {
}
impl VmConfigFaultTrait for NoVcManagedIpConfigured {
}
impl VmConfigFaultTrait for NotUserConfigurableProperty {
}
impl VmConfigFaultTrait for VFlashCacheHotConfigNotSupported {
}
impl VmConfigFaultTrait for VFlashModuleNotSupported {
}
impl VmConfigFaultTrait for VirtualHardwareCompatibilityIssue {
}
impl VmConfigFaultTrait for CpuIncompatible {
}
impl VmConfigFaultTrait for CpuCompatibilityUnknown {
}
impl VmConfigFaultTrait for CpuIncompatible1Ecx {
}
impl VmConfigFaultTrait for CpuIncompatible81Edx {
}
impl VmConfigFaultTrait for FaultToleranceCpuIncompatible {
}
impl VmConfigFaultTrait for DeviceNotSupported {
}
impl VmConfigFaultTrait for DeviceBackingNotSupported {
}
impl VmConfigFaultTrait for DvPortNotSupported {
}
impl VmConfigFaultTrait for UnusedVirtualDiskBlocksNotScrubbed {
}
impl VmConfigFaultTrait for VirtualDiskBlocksNotFullyProvisioned {
}
impl VmConfigFaultTrait for DeviceControllerNotSupported {
}
impl VmConfigFaultTrait for DigestNotSupported {
}
impl VmConfigFaultTrait for FileBackedPortNotSupported {
}
impl VmConfigFaultTrait for MultiWriterNotSupported {
}
impl VmConfigFaultTrait for NonPersistentDisksNotSupported {
}
impl VmConfigFaultTrait for RdmNotSupported {
}
impl VmConfigFaultTrait for PhysCompatRdmNotSupported {
}
impl VmConfigFaultTrait for RawDiskNotSupported {
}
impl VmConfigFaultTrait for RemoteDeviceNotSupported {
}
impl VmConfigFaultTrait for SharedBusControllerNotSupported {
}
impl VmConfigFaultTrait for VmiNotSupported {
}
impl VmConfigFaultTrait for VirtualDiskModeNotSupported {
}
impl VmConfigFaultTrait for VirtualEthernetCardNotSupported {
}
impl VmConfigFaultTrait for DiskNotSupported {
}
impl VmConfigFaultTrait for IdeDiskNotSupported {
}
impl VmConfigFaultTrait for DrsVmotionIncompatibleFault {
}
impl VmConfigFaultTrait for FeatureRequirementsNotMet {
}
impl VmConfigFaultTrait for MemorySizeNotRecommended {
}
impl VmConfigFaultTrait for MemorySizeNotSupported {
}
impl VmConfigFaultTrait for MemorySizeNotSupportedByDatastore {
}
impl VmConfigFaultTrait for NotEnoughCpus {
}
impl VmConfigFaultTrait for NotEnoughLogicalCpus {
}
impl VmConfigFaultTrait for NumVirtualCoresPerSocketNotSupported {
}
impl VmConfigFaultTrait for NumVirtualCpusNotSupported {
}
impl VmConfigFaultTrait for StorageVmotionIncompatible {
}
impl VmConfigFaultTrait for VirtualHardwareVersionNotSupported {
}
impl VmConfigFaultTrait for WakeOnLanNotSupported {
}
impl VmConfigFaultTrait for VmConfigIncompatibleForFaultTolerance {
}
impl VmConfigFaultTrait for VmConfigIncompatibleForRecordReplay {
}
impl VmConfigFaultTrait for VmHostAffinityRuleViolation {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VmConfigFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmConfigFault => Some(from.as_any_ref().downcast_ref::<VmConfigFault>()?),
            StructType::CannotAccessVmComponent => Some(from.as_any_ref().downcast_ref::<CannotAccessVmComponent>()?),
            StructType::CannotAccessVmConfig => Some(from.as_any_ref().downcast_ref::<CannotAccessVmConfig>()?),
            StructType::CannotAccessVmDevice => Some(from.as_any_ref().downcast_ref::<CannotAccessVmDevice>()?),
            StructType::CannotAccessNetwork => Some(from.as_any_ref().downcast_ref::<CannotAccessNetwork>()?),
            StructType::DestinationSwitchFull => Some(from.as_any_ref().downcast_ref::<DestinationSwitchFull>()?),
            StructType::LegacyNetworkInterfaceInUse => Some(from.as_any_ref().downcast_ref::<LegacyNetworkInterfaceInUse>()?),
            StructType::VmOnConflictDvPort => Some(from.as_any_ref().downcast_ref::<VmOnConflictDvPort>()?),
            StructType::VmOnVirtualIntranet => Some(from.as_any_ref().downcast_ref::<VmOnVirtualIntranet>()?),
            StructType::CannotAccessVmDisk => Some(from.as_any_ref().downcast_ref::<CannotAccessVmDisk>()?),
            StructType::RdmPointsToInaccessibleDisk => Some(from.as_any_ref().downcast_ref::<RdmPointsToInaccessibleDisk>()?),
            StructType::CannotDisableSnapshot => Some(from.as_any_ref().downcast_ref::<CannotDisableSnapshot>()?),
            StructType::CannotUseNetwork => Some(from.as_any_ref().downcast_ref::<CannotUseNetwork>()?),
            StructType::CpuHotPlugNotSupported => Some(from.as_any_ref().downcast_ref::<CpuHotPlugNotSupported>()?),
            StructType::DeltaDiskFormatNotSupported => Some(from.as_any_ref().downcast_ref::<DeltaDiskFormatNotSupported>()?),
            StructType::EightHostLimitViolated => Some(from.as_any_ref().downcast_ref::<EightHostLimitViolated>()?),
            StructType::FaultToleranceCannotEditMem => Some(from.as_any_ref().downcast_ref::<FaultToleranceCannotEditMem>()?),
            StructType::GenericVmConfigFault => Some(from.as_any_ref().downcast_ref::<GenericVmConfigFault>()?),
            StructType::InvalidFormat => Some(from.as_any_ref().downcast_ref::<InvalidFormat>()?),
            StructType::InvalidDiskFormat => Some(from.as_any_ref().downcast_ref::<InvalidDiskFormat>()?),
            StructType::InvalidSnapshotFormat => Some(from.as_any_ref().downcast_ref::<InvalidSnapshotFormat>()?),
            StructType::InvalidVmConfig => Some(from.as_any_ref().downcast_ref::<InvalidVmConfig>()?),
            StructType::InvalidDeviceSpec => Some(from.as_any_ref().downcast_ref::<InvalidDeviceSpec>()?),
            StructType::DeviceHotPlugNotSupported => Some(from.as_any_ref().downcast_ref::<DeviceHotPlugNotSupported>()?),
            StructType::DeviceNotFound => Some(from.as_any_ref().downcast_ref::<DeviceNotFound>()?),
            StructType::DeviceUnsupportedForVmPlatform => Some(from.as_any_ref().downcast_ref::<DeviceUnsupportedForVmPlatform>()?),
            StructType::DeviceUnsupportedForVmVersion => Some(from.as_any_ref().downcast_ref::<DeviceUnsupportedForVmVersion>()?),
            StructType::DisallowedDiskModeChange => Some(from.as_any_ref().downcast_ref::<DisallowedDiskModeChange>()?),
            StructType::InvalidController => Some(from.as_any_ref().downcast_ref::<InvalidController>()?),
            StructType::InvalidDeviceBacking => Some(from.as_any_ref().downcast_ref::<InvalidDeviceBacking>()?),
            StructType::InvalidDeviceOperation => Some(from.as_any_ref().downcast_ref::<InvalidDeviceOperation>()?),
            StructType::MissingController => Some(from.as_any_ref().downcast_ref::<MissingController>()?),
            StructType::SwapPlacementOverrideNotSupported => Some(from.as_any_ref().downcast_ref::<SwapPlacementOverrideNotSupported>()?),
            StructType::TooManyDevices => Some(from.as_any_ref().downcast_ref::<TooManyDevices>()?),
            StructType::UnsupportedGuest => Some(from.as_any_ref().downcast_ref::<UnsupportedGuest>()?),
            StructType::VmWwnConflict => Some(from.as_any_ref().downcast_ref::<VmWwnConflict>()?),
            StructType::LargeRdmNotSupportedOnDatastore => Some(from.as_any_ref().downcast_ref::<LargeRdmNotSupportedOnDatastore>()?),
            StructType::MemoryHotPlugNotSupported => Some(from.as_any_ref().downcast_ref::<MemoryHotPlugNotSupported>()?),
            StructType::NoCompatibleHardAffinityHost => Some(from.as_any_ref().downcast_ref::<NoCompatibleHardAffinityHost>()?),
            StructType::NoCompatibleSoftAffinityHost => Some(from.as_any_ref().downcast_ref::<NoCompatibleSoftAffinityHost>()?),
            StructType::NumVirtualCpusIncompatible => Some(from.as_any_ref().downcast_ref::<NumVirtualCpusIncompatible>()?),
            StructType::OvfConsumerValidationFault => Some(from.as_any_ref().downcast_ref::<OvfConsumerValidationFault>()?),
            StructType::QuarantineModeFault => Some(from.as_any_ref().downcast_ref::<QuarantineModeFault>()?),
            StructType::RdmNotSupportedOnDatastore => Some(from.as_any_ref().downcast_ref::<RdmNotSupportedOnDatastore>()?),
            StructType::RuleViolation => Some(from.as_any_ref().downcast_ref::<RuleViolation>()?),
            StructType::SoftRuleVioCorrectionDisallowed => Some(from.as_any_ref().downcast_ref::<SoftRuleVioCorrectionDisallowed>()?),
            StructType::SoftRuleVioCorrectionImpact => Some(from.as_any_ref().downcast_ref::<SoftRuleVioCorrectionImpact>()?),
            StructType::UnsupportedDatastore => Some(from.as_any_ref().downcast_ref::<UnsupportedDatastore>()?),
            StructType::MemoryFileFormatNotSupportedByDatastore => Some(from.as_any_ref().downcast_ref::<MemoryFileFormatNotSupportedByDatastore>()?),
            StructType::UnSupportedDatastoreForVFlash => Some(from.as_any_ref().downcast_ref::<UnSupportedDatastoreForVFlash>()?),
            StructType::UnsupportedVmxLocation => Some(from.as_any_ref().downcast_ref::<UnsupportedVmxLocation>()?),
            StructType::VAppNotRunning => Some(from.as_any_ref().downcast_ref::<VAppNotRunning>()?),
            StructType::VAppPropertyFault => Some(from.as_any_ref().downcast_ref::<VAppPropertyFault>()?),
            StructType::InvalidNetworkInType => Some(from.as_any_ref().downcast_ref::<InvalidNetworkInType>()?),
            StructType::InvalidPropertyType => Some(from.as_any_ref().downcast_ref::<InvalidPropertyType>()?),
            StructType::InvalidPropertyValue => Some(from.as_any_ref().downcast_ref::<InvalidPropertyValue>()?),
            StructType::UnconfiguredPropertyValue => Some(from.as_any_ref().downcast_ref::<UnconfiguredPropertyValue>()?),
            StructType::MissingIpPool => Some(from.as_any_ref().downcast_ref::<MissingIpPool>()?),
            StructType::MissingNetworkIpConfig => Some(from.as_any_ref().downcast_ref::<MissingNetworkIpConfig>()?),
            StructType::NoAvailableIp => Some(from.as_any_ref().downcast_ref::<NoAvailableIp>()?),
            StructType::NoVcManagedIpConfigured => Some(from.as_any_ref().downcast_ref::<NoVcManagedIpConfigured>()?),
            StructType::NotUserConfigurableProperty => Some(from.as_any_ref().downcast_ref::<NotUserConfigurableProperty>()?),
            StructType::VFlashCacheHotConfigNotSupported => Some(from.as_any_ref().downcast_ref::<VFlashCacheHotConfigNotSupported>()?),
            StructType::VFlashModuleNotSupported => Some(from.as_any_ref().downcast_ref::<VFlashModuleNotSupported>()?),
            StructType::VirtualHardwareCompatibilityIssue => Some(from.as_any_ref().downcast_ref::<VirtualHardwareCompatibilityIssue>()?),
            StructType::CpuIncompatible => Some(from.as_any_ref().downcast_ref::<CpuIncompatible>()?),
            StructType::CpuCompatibilityUnknown => Some(from.as_any_ref().downcast_ref::<CpuCompatibilityUnknown>()?),
            StructType::CpuIncompatible1Ecx => Some(from.as_any_ref().downcast_ref::<CpuIncompatible1Ecx>()?),
            StructType::CpuIncompatible81Edx => Some(from.as_any_ref().downcast_ref::<CpuIncompatible81Edx>()?),
            StructType::FaultToleranceCpuIncompatible => Some(from.as_any_ref().downcast_ref::<FaultToleranceCpuIncompatible>()?),
            StructType::DeviceNotSupported => Some(from.as_any_ref().downcast_ref::<DeviceNotSupported>()?),
            StructType::DeviceBackingNotSupported => Some(from.as_any_ref().downcast_ref::<DeviceBackingNotSupported>()?),
            StructType::DvPortNotSupported => Some(from.as_any_ref().downcast_ref::<DvPortNotSupported>()?),
            StructType::UnusedVirtualDiskBlocksNotScrubbed => Some(from.as_any_ref().downcast_ref::<UnusedVirtualDiskBlocksNotScrubbed>()?),
            StructType::VirtualDiskBlocksNotFullyProvisioned => Some(from.as_any_ref().downcast_ref::<VirtualDiskBlocksNotFullyProvisioned>()?),
            StructType::DeviceControllerNotSupported => Some(from.as_any_ref().downcast_ref::<DeviceControllerNotSupported>()?),
            StructType::DigestNotSupported => Some(from.as_any_ref().downcast_ref::<DigestNotSupported>()?),
            StructType::FileBackedPortNotSupported => Some(from.as_any_ref().downcast_ref::<FileBackedPortNotSupported>()?),
            StructType::MultiWriterNotSupported => Some(from.as_any_ref().downcast_ref::<MultiWriterNotSupported>()?),
            StructType::NonPersistentDisksNotSupported => Some(from.as_any_ref().downcast_ref::<NonPersistentDisksNotSupported>()?),
            StructType::RdmNotSupported => Some(from.as_any_ref().downcast_ref::<RdmNotSupported>()?),
            StructType::PhysCompatRdmNotSupported => Some(from.as_any_ref().downcast_ref::<PhysCompatRdmNotSupported>()?),
            StructType::RawDiskNotSupported => Some(from.as_any_ref().downcast_ref::<RawDiskNotSupported>()?),
            StructType::RemoteDeviceNotSupported => Some(from.as_any_ref().downcast_ref::<RemoteDeviceNotSupported>()?),
            StructType::SharedBusControllerNotSupported => Some(from.as_any_ref().downcast_ref::<SharedBusControllerNotSupported>()?),
            StructType::VmiNotSupported => Some(from.as_any_ref().downcast_ref::<VmiNotSupported>()?),
            StructType::VirtualDiskModeNotSupported => Some(from.as_any_ref().downcast_ref::<VirtualDiskModeNotSupported>()?),
            StructType::VirtualEthernetCardNotSupported => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardNotSupported>()?),
            StructType::DiskNotSupported => Some(from.as_any_ref().downcast_ref::<DiskNotSupported>()?),
            StructType::IdeDiskNotSupported => Some(from.as_any_ref().downcast_ref::<IdeDiskNotSupported>()?),
            StructType::DrsVmotionIncompatibleFault => Some(from.as_any_ref().downcast_ref::<DrsVmotionIncompatibleFault>()?),
            StructType::FeatureRequirementsNotMet => Some(from.as_any_ref().downcast_ref::<FeatureRequirementsNotMet>()?),
            StructType::MemorySizeNotRecommended => Some(from.as_any_ref().downcast_ref::<MemorySizeNotRecommended>()?),
            StructType::MemorySizeNotSupported => Some(from.as_any_ref().downcast_ref::<MemorySizeNotSupported>()?),
            StructType::MemorySizeNotSupportedByDatastore => Some(from.as_any_ref().downcast_ref::<MemorySizeNotSupportedByDatastore>()?),
            StructType::NotEnoughCpus => Some(from.as_any_ref().downcast_ref::<NotEnoughCpus>()?),
            StructType::NotEnoughLogicalCpus => Some(from.as_any_ref().downcast_ref::<NotEnoughLogicalCpus>()?),
            StructType::NumVirtualCoresPerSocketNotSupported => Some(from.as_any_ref().downcast_ref::<NumVirtualCoresPerSocketNotSupported>()?),
            StructType::NumVirtualCpusNotSupported => Some(from.as_any_ref().downcast_ref::<NumVirtualCpusNotSupported>()?),
            StructType::StorageVmotionIncompatible => Some(from.as_any_ref().downcast_ref::<StorageVmotionIncompatible>()?),
            StructType::VirtualHardwareVersionNotSupported => Some(from.as_any_ref().downcast_ref::<VirtualHardwareVersionNotSupported>()?),
            StructType::WakeOnLanNotSupported => Some(from.as_any_ref().downcast_ref::<WakeOnLanNotSupported>()?),
            StructType::VmConfigIncompatibleForFaultTolerance => Some(from.as_any_ref().downcast_ref::<VmConfigIncompatibleForFaultTolerance>()?),
            StructType::VmConfigIncompatibleForRecordReplay => Some(from.as_any_ref().downcast_ref::<VmConfigIncompatibleForRecordReplay>()?),
            StructType::VmHostAffinityRuleViolation => Some(from.as_any_ref().downcast_ref::<VmHostAffinityRuleViolation>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmConfigFault => Ok(from.as_any_box().downcast::<VmConfigFault>()?),
            StructType::CannotAccessVmComponent => Ok(from.as_any_box().downcast::<CannotAccessVmComponent>()?),
            StructType::CannotAccessVmConfig => Ok(from.as_any_box().downcast::<CannotAccessVmConfig>()?),
            StructType::CannotAccessVmDevice => Ok(from.as_any_box().downcast::<CannotAccessVmDevice>()?),
            StructType::CannotAccessNetwork => Ok(from.as_any_box().downcast::<CannotAccessNetwork>()?),
            StructType::DestinationSwitchFull => Ok(from.as_any_box().downcast::<DestinationSwitchFull>()?),
            StructType::LegacyNetworkInterfaceInUse => Ok(from.as_any_box().downcast::<LegacyNetworkInterfaceInUse>()?),
            StructType::VmOnConflictDvPort => Ok(from.as_any_box().downcast::<VmOnConflictDvPort>()?),
            StructType::VmOnVirtualIntranet => Ok(from.as_any_box().downcast::<VmOnVirtualIntranet>()?),
            StructType::CannotAccessVmDisk => Ok(from.as_any_box().downcast::<CannotAccessVmDisk>()?),
            StructType::RdmPointsToInaccessibleDisk => Ok(from.as_any_box().downcast::<RdmPointsToInaccessibleDisk>()?),
            StructType::CannotDisableSnapshot => Ok(from.as_any_box().downcast::<CannotDisableSnapshot>()?),
            StructType::CannotUseNetwork => Ok(from.as_any_box().downcast::<CannotUseNetwork>()?),
            StructType::CpuHotPlugNotSupported => Ok(from.as_any_box().downcast::<CpuHotPlugNotSupported>()?),
            StructType::DeltaDiskFormatNotSupported => Ok(from.as_any_box().downcast::<DeltaDiskFormatNotSupported>()?),
            StructType::EightHostLimitViolated => Ok(from.as_any_box().downcast::<EightHostLimitViolated>()?),
            StructType::FaultToleranceCannotEditMem => Ok(from.as_any_box().downcast::<FaultToleranceCannotEditMem>()?),
            StructType::GenericVmConfigFault => Ok(from.as_any_box().downcast::<GenericVmConfigFault>()?),
            StructType::InvalidFormat => Ok(from.as_any_box().downcast::<InvalidFormat>()?),
            StructType::InvalidDiskFormat => Ok(from.as_any_box().downcast::<InvalidDiskFormat>()?),
            StructType::InvalidSnapshotFormat => Ok(from.as_any_box().downcast::<InvalidSnapshotFormat>()?),
            StructType::InvalidVmConfig => Ok(from.as_any_box().downcast::<InvalidVmConfig>()?),
            StructType::InvalidDeviceSpec => Ok(from.as_any_box().downcast::<InvalidDeviceSpec>()?),
            StructType::DeviceHotPlugNotSupported => Ok(from.as_any_box().downcast::<DeviceHotPlugNotSupported>()?),
            StructType::DeviceNotFound => Ok(from.as_any_box().downcast::<DeviceNotFound>()?),
            StructType::DeviceUnsupportedForVmPlatform => Ok(from.as_any_box().downcast::<DeviceUnsupportedForVmPlatform>()?),
            StructType::DeviceUnsupportedForVmVersion => Ok(from.as_any_box().downcast::<DeviceUnsupportedForVmVersion>()?),
            StructType::DisallowedDiskModeChange => Ok(from.as_any_box().downcast::<DisallowedDiskModeChange>()?),
            StructType::InvalidController => Ok(from.as_any_box().downcast::<InvalidController>()?),
            StructType::InvalidDeviceBacking => Ok(from.as_any_box().downcast::<InvalidDeviceBacking>()?),
            StructType::InvalidDeviceOperation => Ok(from.as_any_box().downcast::<InvalidDeviceOperation>()?),
            StructType::MissingController => Ok(from.as_any_box().downcast::<MissingController>()?),
            StructType::SwapPlacementOverrideNotSupported => Ok(from.as_any_box().downcast::<SwapPlacementOverrideNotSupported>()?),
            StructType::TooManyDevices => Ok(from.as_any_box().downcast::<TooManyDevices>()?),
            StructType::UnsupportedGuest => Ok(from.as_any_box().downcast::<UnsupportedGuest>()?),
            StructType::VmWwnConflict => Ok(from.as_any_box().downcast::<VmWwnConflict>()?),
            StructType::LargeRdmNotSupportedOnDatastore => Ok(from.as_any_box().downcast::<LargeRdmNotSupportedOnDatastore>()?),
            StructType::MemoryHotPlugNotSupported => Ok(from.as_any_box().downcast::<MemoryHotPlugNotSupported>()?),
            StructType::NoCompatibleHardAffinityHost => Ok(from.as_any_box().downcast::<NoCompatibleHardAffinityHost>()?),
            StructType::NoCompatibleSoftAffinityHost => Ok(from.as_any_box().downcast::<NoCompatibleSoftAffinityHost>()?),
            StructType::NumVirtualCpusIncompatible => Ok(from.as_any_box().downcast::<NumVirtualCpusIncompatible>()?),
            StructType::OvfConsumerValidationFault => Ok(from.as_any_box().downcast::<OvfConsumerValidationFault>()?),
            StructType::QuarantineModeFault => Ok(from.as_any_box().downcast::<QuarantineModeFault>()?),
            StructType::RdmNotSupportedOnDatastore => Ok(from.as_any_box().downcast::<RdmNotSupportedOnDatastore>()?),
            StructType::RuleViolation => Ok(from.as_any_box().downcast::<RuleViolation>()?),
            StructType::SoftRuleVioCorrectionDisallowed => Ok(from.as_any_box().downcast::<SoftRuleVioCorrectionDisallowed>()?),
            StructType::SoftRuleVioCorrectionImpact => Ok(from.as_any_box().downcast::<SoftRuleVioCorrectionImpact>()?),
            StructType::UnsupportedDatastore => Ok(from.as_any_box().downcast::<UnsupportedDatastore>()?),
            StructType::MemoryFileFormatNotSupportedByDatastore => Ok(from.as_any_box().downcast::<MemoryFileFormatNotSupportedByDatastore>()?),
            StructType::UnSupportedDatastoreForVFlash => Ok(from.as_any_box().downcast::<UnSupportedDatastoreForVFlash>()?),
            StructType::UnsupportedVmxLocation => Ok(from.as_any_box().downcast::<UnsupportedVmxLocation>()?),
            StructType::VAppNotRunning => Ok(from.as_any_box().downcast::<VAppNotRunning>()?),
            StructType::VAppPropertyFault => Ok(from.as_any_box().downcast::<VAppPropertyFault>()?),
            StructType::InvalidNetworkInType => Ok(from.as_any_box().downcast::<InvalidNetworkInType>()?),
            StructType::InvalidPropertyType => Ok(from.as_any_box().downcast::<InvalidPropertyType>()?),
            StructType::InvalidPropertyValue => Ok(from.as_any_box().downcast::<InvalidPropertyValue>()?),
            StructType::UnconfiguredPropertyValue => Ok(from.as_any_box().downcast::<UnconfiguredPropertyValue>()?),
            StructType::MissingIpPool => Ok(from.as_any_box().downcast::<MissingIpPool>()?),
            StructType::MissingNetworkIpConfig => Ok(from.as_any_box().downcast::<MissingNetworkIpConfig>()?),
            StructType::NoAvailableIp => Ok(from.as_any_box().downcast::<NoAvailableIp>()?),
            StructType::NoVcManagedIpConfigured => Ok(from.as_any_box().downcast::<NoVcManagedIpConfigured>()?),
            StructType::NotUserConfigurableProperty => Ok(from.as_any_box().downcast::<NotUserConfigurableProperty>()?),
            StructType::VFlashCacheHotConfigNotSupported => Ok(from.as_any_box().downcast::<VFlashCacheHotConfigNotSupported>()?),
            StructType::VFlashModuleNotSupported => Ok(from.as_any_box().downcast::<VFlashModuleNotSupported>()?),
            StructType::VirtualHardwareCompatibilityIssue => Ok(from.as_any_box().downcast::<VirtualHardwareCompatibilityIssue>()?),
            StructType::CpuIncompatible => Ok(from.as_any_box().downcast::<CpuIncompatible>()?),
            StructType::CpuCompatibilityUnknown => Ok(from.as_any_box().downcast::<CpuCompatibilityUnknown>()?),
            StructType::CpuIncompatible1Ecx => Ok(from.as_any_box().downcast::<CpuIncompatible1Ecx>()?),
            StructType::CpuIncompatible81Edx => Ok(from.as_any_box().downcast::<CpuIncompatible81Edx>()?),
            StructType::FaultToleranceCpuIncompatible => Ok(from.as_any_box().downcast::<FaultToleranceCpuIncompatible>()?),
            StructType::DeviceNotSupported => Ok(from.as_any_box().downcast::<DeviceNotSupported>()?),
            StructType::DeviceBackingNotSupported => Ok(from.as_any_box().downcast::<DeviceBackingNotSupported>()?),
            StructType::DvPortNotSupported => Ok(from.as_any_box().downcast::<DvPortNotSupported>()?),
            StructType::UnusedVirtualDiskBlocksNotScrubbed => Ok(from.as_any_box().downcast::<UnusedVirtualDiskBlocksNotScrubbed>()?),
            StructType::VirtualDiskBlocksNotFullyProvisioned => Ok(from.as_any_box().downcast::<VirtualDiskBlocksNotFullyProvisioned>()?),
            StructType::DeviceControllerNotSupported => Ok(from.as_any_box().downcast::<DeviceControllerNotSupported>()?),
            StructType::DigestNotSupported => Ok(from.as_any_box().downcast::<DigestNotSupported>()?),
            StructType::FileBackedPortNotSupported => Ok(from.as_any_box().downcast::<FileBackedPortNotSupported>()?),
            StructType::MultiWriterNotSupported => Ok(from.as_any_box().downcast::<MultiWriterNotSupported>()?),
            StructType::NonPersistentDisksNotSupported => Ok(from.as_any_box().downcast::<NonPersistentDisksNotSupported>()?),
            StructType::RdmNotSupported => Ok(from.as_any_box().downcast::<RdmNotSupported>()?),
            StructType::PhysCompatRdmNotSupported => Ok(from.as_any_box().downcast::<PhysCompatRdmNotSupported>()?),
            StructType::RawDiskNotSupported => Ok(from.as_any_box().downcast::<RawDiskNotSupported>()?),
            StructType::RemoteDeviceNotSupported => Ok(from.as_any_box().downcast::<RemoteDeviceNotSupported>()?),
            StructType::SharedBusControllerNotSupported => Ok(from.as_any_box().downcast::<SharedBusControllerNotSupported>()?),
            StructType::VmiNotSupported => Ok(from.as_any_box().downcast::<VmiNotSupported>()?),
            StructType::VirtualDiskModeNotSupported => Ok(from.as_any_box().downcast::<VirtualDiskModeNotSupported>()?),
            StructType::VirtualEthernetCardNotSupported => Ok(from.as_any_box().downcast::<VirtualEthernetCardNotSupported>()?),
            StructType::DiskNotSupported => Ok(from.as_any_box().downcast::<DiskNotSupported>()?),
            StructType::IdeDiskNotSupported => Ok(from.as_any_box().downcast::<IdeDiskNotSupported>()?),
            StructType::DrsVmotionIncompatibleFault => Ok(from.as_any_box().downcast::<DrsVmotionIncompatibleFault>()?),
            StructType::FeatureRequirementsNotMet => Ok(from.as_any_box().downcast::<FeatureRequirementsNotMet>()?),
            StructType::MemorySizeNotRecommended => Ok(from.as_any_box().downcast::<MemorySizeNotRecommended>()?),
            StructType::MemorySizeNotSupported => Ok(from.as_any_box().downcast::<MemorySizeNotSupported>()?),
            StructType::MemorySizeNotSupportedByDatastore => Ok(from.as_any_box().downcast::<MemorySizeNotSupportedByDatastore>()?),
            StructType::NotEnoughCpus => Ok(from.as_any_box().downcast::<NotEnoughCpus>()?),
            StructType::NotEnoughLogicalCpus => Ok(from.as_any_box().downcast::<NotEnoughLogicalCpus>()?),
            StructType::NumVirtualCoresPerSocketNotSupported => Ok(from.as_any_box().downcast::<NumVirtualCoresPerSocketNotSupported>()?),
            StructType::NumVirtualCpusNotSupported => Ok(from.as_any_box().downcast::<NumVirtualCpusNotSupported>()?),
            StructType::StorageVmotionIncompatible => Ok(from.as_any_box().downcast::<StorageVmotionIncompatible>()?),
            StructType::VirtualHardwareVersionNotSupported => Ok(from.as_any_box().downcast::<VirtualHardwareVersionNotSupported>()?),
            StructType::WakeOnLanNotSupported => Ok(from.as_any_box().downcast::<WakeOnLanNotSupported>()?),
            StructType::VmConfigIncompatibleForFaultTolerance => Ok(from.as_any_box().downcast::<VmConfigIncompatibleForFaultTolerance>()?),
            StructType::VmConfigIncompatibleForRecordReplay => Ok(from.as_any_box().downcast::<VmConfigIncompatibleForRecordReplay>()?),
            StructType::VmHostAffinityRuleViolation => Ok(from.as_any_box().downcast::<VmHostAffinityRuleViolation>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// One of the virtual machine's components is not accessible on the execution host.
/// 
/// This is a base class. Subclasses will encode the type of component that is not
/// accessible.
pub trait CannotAccessVmComponentTrait : super::traits::VmConfigFaultTrait {
}
impl<'s> serde::Serialize for dyn CannotAccessVmComponentTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn CannotAccessVmComponentTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(CannotAccessVmComponentVisitor)
            }
        }

struct CannotAccessVmComponentVisitor;

impl<'de> de::Visitor<'de> for CannotAccessVmComponentVisitor {
    type Value = Box<dyn CannotAccessVmComponentTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid CannotAccessVmComponentTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl CannotAccessVmComponentTrait for CannotAccessVmComponent {
}
impl CannotAccessVmComponentTrait for CannotAccessVmConfig {
}
impl CannotAccessVmComponentTrait for CannotAccessVmDevice {
}
impl CannotAccessVmComponentTrait for CannotAccessNetwork {
}
impl CannotAccessVmComponentTrait for DestinationSwitchFull {
}
impl CannotAccessVmComponentTrait for LegacyNetworkInterfaceInUse {
}
impl CannotAccessVmComponentTrait for VmOnConflictDvPort {
}
impl CannotAccessVmComponentTrait for VmOnVirtualIntranet {
}
impl CannotAccessVmComponentTrait for CannotAccessVmDisk {
}
impl CannotAccessVmComponentTrait for RdmPointsToInaccessibleDisk {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn CannotAccessVmComponentTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::CannotAccessVmComponent => Some(from.as_any_ref().downcast_ref::<CannotAccessVmComponent>()?),
            StructType::CannotAccessVmConfig => Some(from.as_any_ref().downcast_ref::<CannotAccessVmConfig>()?),
            StructType::CannotAccessVmDevice => Some(from.as_any_ref().downcast_ref::<CannotAccessVmDevice>()?),
            StructType::CannotAccessNetwork => Some(from.as_any_ref().downcast_ref::<CannotAccessNetwork>()?),
            StructType::DestinationSwitchFull => Some(from.as_any_ref().downcast_ref::<DestinationSwitchFull>()?),
            StructType::LegacyNetworkInterfaceInUse => Some(from.as_any_ref().downcast_ref::<LegacyNetworkInterfaceInUse>()?),
            StructType::VmOnConflictDvPort => Some(from.as_any_ref().downcast_ref::<VmOnConflictDvPort>()?),
            StructType::VmOnVirtualIntranet => Some(from.as_any_ref().downcast_ref::<VmOnVirtualIntranet>()?),
            StructType::CannotAccessVmDisk => Some(from.as_any_ref().downcast_ref::<CannotAccessVmDisk>()?),
            StructType::RdmPointsToInaccessibleDisk => Some(from.as_any_ref().downcast_ref::<RdmPointsToInaccessibleDisk>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::CannotAccessVmComponent => Ok(from.as_any_box().downcast::<CannotAccessVmComponent>()?),
            StructType::CannotAccessVmConfig => Ok(from.as_any_box().downcast::<CannotAccessVmConfig>()?),
            StructType::CannotAccessVmDevice => Ok(from.as_any_box().downcast::<CannotAccessVmDevice>()?),
            StructType::CannotAccessNetwork => Ok(from.as_any_box().downcast::<CannotAccessNetwork>()?),
            StructType::DestinationSwitchFull => Ok(from.as_any_box().downcast::<DestinationSwitchFull>()?),
            StructType::LegacyNetworkInterfaceInUse => Ok(from.as_any_box().downcast::<LegacyNetworkInterfaceInUse>()?),
            StructType::VmOnConflictDvPort => Ok(from.as_any_box().downcast::<VmOnConflictDvPort>()?),
            StructType::VmOnVirtualIntranet => Ok(from.as_any_box().downcast::<VmOnVirtualIntranet>()?),
            StructType::CannotAccessVmDisk => Ok(from.as_any_box().downcast::<CannotAccessVmDisk>()?),
            StructType::RdmPointsToInaccessibleDisk => Ok(from.as_any_box().downcast::<RdmPointsToInaccessibleDisk>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// One of the virtual machine's devices uses a backing that is not accessible
/// on the host.
/// 
/// Following is a discussion of this fault's use in migration validation.
/// This is an error if the device is currently connected and a warning
/// otherwise. Devices that can be disconnected can only be connected if the virtual
/// machine is powered on.
/// 
/// The usage of this fault is slightly different if the backing of a device is
/// inherently host-local, and therefore not shared or globally named among
/// hosts. (Examples of such backings: physical CD-ROM drive, physical serial
/// port.) If a device with such a backing is currently connected, that will
/// be a migration error. If the device is disconnected, there will be a
/// warning if no backing with the same name exists on the destination host.
/// If the device is disconnected and a backing with the same name exists on
/// the destination host, this is neither a warning nor an error case, even
/// though the destination host's backing is not the same instance as the
/// source host's. It is assumed that use of the host-local backing is what is
/// desired for the device.
pub trait CannotAccessVmDeviceTrait : super::traits::CannotAccessVmComponentTrait {
    /// The label of the device.
    fn get_device(&self) -> &str;
    /// The backing of the device.
    fn get_backing(&self) -> &str;
    /// The connected/disconnected state of the device.
    fn get_connected(&self) -> bool;
}
impl<'s> serde::Serialize for dyn CannotAccessVmDeviceTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn CannotAccessVmDeviceTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(CannotAccessVmDeviceVisitor)
            }
        }

struct CannotAccessVmDeviceVisitor;

impl<'de> de::Visitor<'de> for CannotAccessVmDeviceVisitor {
    type Value = Box<dyn CannotAccessVmDeviceTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid CannotAccessVmDeviceTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl CannotAccessVmDeviceTrait for CannotAccessVmDevice {
    fn get_device(&self) -> &str { &self.device }
    fn get_backing(&self) -> &str { &self.backing }
    fn get_connected(&self) -> bool { self.connected }
}
impl CannotAccessVmDeviceTrait for CannotAccessNetwork {
    fn get_device(&self) -> &str { &self.device }
    fn get_backing(&self) -> &str { &self.backing }
    fn get_connected(&self) -> bool { self.connected }
}
impl CannotAccessVmDeviceTrait for DestinationSwitchFull {
    fn get_device(&self) -> &str { &self.device }
    fn get_backing(&self) -> &str { &self.backing }
    fn get_connected(&self) -> bool { self.connected }
}
impl CannotAccessVmDeviceTrait for LegacyNetworkInterfaceInUse {
    fn get_device(&self) -> &str { &self.device }
    fn get_backing(&self) -> &str { &self.backing }
    fn get_connected(&self) -> bool { self.connected }
}
impl CannotAccessVmDeviceTrait for VmOnConflictDvPort {
    fn get_device(&self) -> &str { &self.device }
    fn get_backing(&self) -> &str { &self.backing }
    fn get_connected(&self) -> bool { self.connected }
}
impl CannotAccessVmDeviceTrait for VmOnVirtualIntranet {
    fn get_device(&self) -> &str { &self.device }
    fn get_backing(&self) -> &str { &self.backing }
    fn get_connected(&self) -> bool { self.connected }
}
impl CannotAccessVmDeviceTrait for CannotAccessVmDisk {
    fn get_device(&self) -> &str { &self.device }
    fn get_backing(&self) -> &str { &self.backing }
    fn get_connected(&self) -> bool { self.connected }
}
impl CannotAccessVmDeviceTrait for RdmPointsToInaccessibleDisk {
    fn get_device(&self) -> &str { &self.device }
    fn get_backing(&self) -> &str { &self.backing }
    fn get_connected(&self) -> bool { self.connected }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn CannotAccessVmDeviceTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::CannotAccessVmDevice => Some(from.as_any_ref().downcast_ref::<CannotAccessVmDevice>()?),
            StructType::CannotAccessNetwork => Some(from.as_any_ref().downcast_ref::<CannotAccessNetwork>()?),
            StructType::DestinationSwitchFull => Some(from.as_any_ref().downcast_ref::<DestinationSwitchFull>()?),
            StructType::LegacyNetworkInterfaceInUse => Some(from.as_any_ref().downcast_ref::<LegacyNetworkInterfaceInUse>()?),
            StructType::VmOnConflictDvPort => Some(from.as_any_ref().downcast_ref::<VmOnConflictDvPort>()?),
            StructType::VmOnVirtualIntranet => Some(from.as_any_ref().downcast_ref::<VmOnVirtualIntranet>()?),
            StructType::CannotAccessVmDisk => Some(from.as_any_ref().downcast_ref::<CannotAccessVmDisk>()?),
            StructType::RdmPointsToInaccessibleDisk => Some(from.as_any_ref().downcast_ref::<RdmPointsToInaccessibleDisk>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::CannotAccessVmDevice => Ok(from.as_any_box().downcast::<CannotAccessVmDevice>()?),
            StructType::CannotAccessNetwork => Ok(from.as_any_box().downcast::<CannotAccessNetwork>()?),
            StructType::DestinationSwitchFull => Ok(from.as_any_box().downcast::<DestinationSwitchFull>()?),
            StructType::LegacyNetworkInterfaceInUse => Ok(from.as_any_box().downcast::<LegacyNetworkInterfaceInUse>()?),
            StructType::VmOnConflictDvPort => Ok(from.as_any_box().downcast::<VmOnConflictDvPort>()?),
            StructType::VmOnVirtualIntranet => Ok(from.as_any_box().downcast::<VmOnVirtualIntranet>()?),
            StructType::CannotAccessVmDisk => Ok(from.as_any_box().downcast::<CannotAccessVmDisk>()?),
            StructType::RdmPointsToInaccessibleDisk => Ok(from.as_any_box().downcast::<RdmPointsToInaccessibleDisk>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// A network associated with the virtual machine is not accessible.
/// 
/// If returned as
/// part of migration checks, this is an error if either of the following is true,
/// a warning otherwise:
/// - The virtual ethernet card device backing is a distributed virtual switch,
///   of which the destination host is not a member
/// - The virtual ethernet card device backing is a standard network and the
///   the device is connected
pub trait CannotAccessNetworkTrait : super::traits::CannotAccessVmDeviceTrait {
    /// A reference to the network that cannot be accessed
    /// 
    /// Refers instance of *Network*.
    fn get_network(&self) -> &Option<ManagedObjectReference>;
}
impl<'s> serde::Serialize for dyn CannotAccessNetworkTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn CannotAccessNetworkTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(CannotAccessNetworkVisitor)
            }
        }

struct CannotAccessNetworkVisitor;

impl<'de> de::Visitor<'de> for CannotAccessNetworkVisitor {
    type Value = Box<dyn CannotAccessNetworkTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid CannotAccessNetworkTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl CannotAccessNetworkTrait for CannotAccessNetwork {
    fn get_network(&self) -> &Option<ManagedObjectReference> { &self.network }
}
impl CannotAccessNetworkTrait for DestinationSwitchFull {
    fn get_network(&self) -> &Option<ManagedObjectReference> { &self.network }
}
impl CannotAccessNetworkTrait for LegacyNetworkInterfaceInUse {
    fn get_network(&self) -> &Option<ManagedObjectReference> { &self.network }
}
impl CannotAccessNetworkTrait for VmOnConflictDvPort {
    fn get_network(&self) -> &Option<ManagedObjectReference> { &self.network }
}
impl CannotAccessNetworkTrait for VmOnVirtualIntranet {
    fn get_network(&self) -> &Option<ManagedObjectReference> { &self.network }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn CannotAccessNetworkTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::CannotAccessNetwork => Some(from.as_any_ref().downcast_ref::<CannotAccessNetwork>()?),
            StructType::DestinationSwitchFull => Some(from.as_any_ref().downcast_ref::<DestinationSwitchFull>()?),
            StructType::LegacyNetworkInterfaceInUse => Some(from.as_any_ref().downcast_ref::<LegacyNetworkInterfaceInUse>()?),
            StructType::VmOnConflictDvPort => Some(from.as_any_ref().downcast_ref::<VmOnConflictDvPort>()?),
            StructType::VmOnVirtualIntranet => Some(from.as_any_ref().downcast_ref::<VmOnVirtualIntranet>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::CannotAccessNetwork => Ok(from.as_any_box().downcast::<CannotAccessNetwork>()?),
            StructType::DestinationSwitchFull => Ok(from.as_any_box().downcast::<DestinationSwitchFull>()?),
            StructType::LegacyNetworkInterfaceInUse => Ok(from.as_any_box().downcast::<LegacyNetworkInterfaceInUse>()?),
            StructType::VmOnConflictDvPort => Ok(from.as_any_box().downcast::<VmOnConflictDvPort>()?),
            StructType::VmOnVirtualIntranet => Ok(from.as_any_box().downcast::<VmOnVirtualIntranet>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// One of the virtual machine's virtual disks is not accessible.
pub trait CannotAccessVmDiskTrait : super::traits::CannotAccessVmDeviceTrait {
    /// The reason why the disk could not be accessed
    fn get_fault(&self) -> &Box<dyn super::traits::MethodFaultTrait>;
}
impl<'s> serde::Serialize for dyn CannotAccessVmDiskTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn CannotAccessVmDiskTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(CannotAccessVmDiskVisitor)
            }
        }

struct CannotAccessVmDiskVisitor;

impl<'de> de::Visitor<'de> for CannotAccessVmDiskVisitor {
    type Value = Box<dyn CannotAccessVmDiskTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid CannotAccessVmDiskTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl CannotAccessVmDiskTrait for CannotAccessVmDisk {
    fn get_fault(&self) -> &Box<dyn super::traits::MethodFaultTrait> { &self.fault }
}
impl CannotAccessVmDiskTrait for RdmPointsToInaccessibleDisk {
    fn get_fault(&self) -> &Box<dyn super::traits::MethodFaultTrait> { &self.fault }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn CannotAccessVmDiskTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::CannotAccessVmDisk => Some(from.as_any_ref().downcast_ref::<CannotAccessVmDisk>()?),
            StructType::RdmPointsToInaccessibleDisk => Some(from.as_any_ref().downcast_ref::<RdmPointsToInaccessibleDisk>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::CannotAccessVmDisk => Ok(from.as_any_box().downcast::<CannotAccessVmDisk>()?),
            StructType::RdmPointsToInaccessibleDisk => Ok(from.as_any_box().downcast::<RdmPointsToInaccessibleDisk>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Throws when an invalid format is detected.
/// 
/// For example, when
/// a virtual machine is registered and the system is unable to parse
/// the files as a virtual machine.
pub trait InvalidFormatTrait : super::traits::VmConfigFaultTrait {
}
impl<'s> serde::Serialize for dyn InvalidFormatTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn InvalidFormatTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(InvalidFormatVisitor)
            }
        }

struct InvalidFormatVisitor;

impl<'de> de::Visitor<'de> for InvalidFormatVisitor {
    type Value = Box<dyn InvalidFormatTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid InvalidFormatTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl InvalidFormatTrait for InvalidFormat {
}
impl InvalidFormatTrait for InvalidDiskFormat {
}
impl InvalidFormatTrait for InvalidSnapshotFormat {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn InvalidFormatTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::InvalidFormat => Some(from.as_any_ref().downcast_ref::<InvalidFormat>()?),
            StructType::InvalidDiskFormat => Some(from.as_any_ref().downcast_ref::<InvalidDiskFormat>()?),
            StructType::InvalidSnapshotFormat => Some(from.as_any_ref().downcast_ref::<InvalidSnapshotFormat>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::InvalidFormat => Ok(from.as_any_box().downcast::<InvalidFormat>()?),
            StructType::InvalidDiskFormat => Ok(from.as_any_box().downcast::<InvalidDiskFormat>()?),
            StructType::InvalidSnapshotFormat => Ok(from.as_any_box().downcast::<InvalidSnapshotFormat>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Thrown when virtual machine creation or configuration fails.
/// 
/// This is
/// a base type for all virtual machine configuration errors.
pub trait InvalidVmConfigTrait : super::traits::VmConfigFaultTrait {
    /// Path of the property in configSpec that has an invalid value.
    fn get_property(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn InvalidVmConfigTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn InvalidVmConfigTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(InvalidVmConfigVisitor)
            }
        }

struct InvalidVmConfigVisitor;

impl<'de> de::Visitor<'de> for InvalidVmConfigVisitor {
    type Value = Box<dyn InvalidVmConfigTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid InvalidVmConfigTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl InvalidVmConfigTrait for InvalidVmConfig {
    fn get_property(&self) -> &Option<String> { &self.property }
}
impl InvalidVmConfigTrait for InvalidDeviceSpec {
    fn get_property(&self) -> &Option<String> { &self.property }
}
impl InvalidVmConfigTrait for DeviceHotPlugNotSupported {
    fn get_property(&self) -> &Option<String> { &self.property }
}
impl InvalidVmConfigTrait for DeviceNotFound {
    fn get_property(&self) -> &Option<String> { &self.property }
}
impl InvalidVmConfigTrait for DeviceUnsupportedForVmPlatform {
    fn get_property(&self) -> &Option<String> { &self.property }
}
impl InvalidVmConfigTrait for DeviceUnsupportedForVmVersion {
    fn get_property(&self) -> &Option<String> { &self.property }
}
impl InvalidVmConfigTrait for DisallowedDiskModeChange {
    fn get_property(&self) -> &Option<String> { &self.property }
}
impl InvalidVmConfigTrait for InvalidController {
    fn get_property(&self) -> &Option<String> { &self.property }
}
impl InvalidVmConfigTrait for InvalidDeviceBacking {
    fn get_property(&self) -> &Option<String> { &self.property }
}
impl InvalidVmConfigTrait for InvalidDeviceOperation {
    fn get_property(&self) -> &Option<String> { &self.property }
}
impl InvalidVmConfigTrait for MissingController {
    fn get_property(&self) -> &Option<String> { &self.property }
}
impl InvalidVmConfigTrait for SwapPlacementOverrideNotSupported {
    fn get_property(&self) -> &Option<String> { &self.property }
}
impl InvalidVmConfigTrait for TooManyDevices {
    fn get_property(&self) -> &Option<String> { &self.property }
}
impl InvalidVmConfigTrait for UnsupportedGuest {
    fn get_property(&self) -> &Option<String> { &self.property }
}
impl InvalidVmConfigTrait for VmWwnConflict {
    fn get_property(&self) -> &Option<String> { &self.property }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn InvalidVmConfigTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::InvalidVmConfig => Some(from.as_any_ref().downcast_ref::<InvalidVmConfig>()?),
            StructType::InvalidDeviceSpec => Some(from.as_any_ref().downcast_ref::<InvalidDeviceSpec>()?),
            StructType::DeviceHotPlugNotSupported => Some(from.as_any_ref().downcast_ref::<DeviceHotPlugNotSupported>()?),
            StructType::DeviceNotFound => Some(from.as_any_ref().downcast_ref::<DeviceNotFound>()?),
            StructType::DeviceUnsupportedForVmPlatform => Some(from.as_any_ref().downcast_ref::<DeviceUnsupportedForVmPlatform>()?),
            StructType::DeviceUnsupportedForVmVersion => Some(from.as_any_ref().downcast_ref::<DeviceUnsupportedForVmVersion>()?),
            StructType::DisallowedDiskModeChange => Some(from.as_any_ref().downcast_ref::<DisallowedDiskModeChange>()?),
            StructType::InvalidController => Some(from.as_any_ref().downcast_ref::<InvalidController>()?),
            StructType::InvalidDeviceBacking => Some(from.as_any_ref().downcast_ref::<InvalidDeviceBacking>()?),
            StructType::InvalidDeviceOperation => Some(from.as_any_ref().downcast_ref::<InvalidDeviceOperation>()?),
            StructType::MissingController => Some(from.as_any_ref().downcast_ref::<MissingController>()?),
            StructType::SwapPlacementOverrideNotSupported => Some(from.as_any_ref().downcast_ref::<SwapPlacementOverrideNotSupported>()?),
            StructType::TooManyDevices => Some(from.as_any_ref().downcast_ref::<TooManyDevices>()?),
            StructType::UnsupportedGuest => Some(from.as_any_ref().downcast_ref::<UnsupportedGuest>()?),
            StructType::VmWwnConflict => Some(from.as_any_ref().downcast_ref::<VmWwnConflict>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::InvalidVmConfig => Ok(from.as_any_box().downcast::<InvalidVmConfig>()?),
            StructType::InvalidDeviceSpec => Ok(from.as_any_box().downcast::<InvalidDeviceSpec>()?),
            StructType::DeviceHotPlugNotSupported => Ok(from.as_any_box().downcast::<DeviceHotPlugNotSupported>()?),
            StructType::DeviceNotFound => Ok(from.as_any_box().downcast::<DeviceNotFound>()?),
            StructType::DeviceUnsupportedForVmPlatform => Ok(from.as_any_box().downcast::<DeviceUnsupportedForVmPlatform>()?),
            StructType::DeviceUnsupportedForVmVersion => Ok(from.as_any_box().downcast::<DeviceUnsupportedForVmVersion>()?),
            StructType::DisallowedDiskModeChange => Ok(from.as_any_box().downcast::<DisallowedDiskModeChange>()?),
            StructType::InvalidController => Ok(from.as_any_box().downcast::<InvalidController>()?),
            StructType::InvalidDeviceBacking => Ok(from.as_any_box().downcast::<InvalidDeviceBacking>()?),
            StructType::InvalidDeviceOperation => Ok(from.as_any_box().downcast::<InvalidDeviceOperation>()?),
            StructType::MissingController => Ok(from.as_any_box().downcast::<MissingController>()?),
            StructType::SwapPlacementOverrideNotSupported => Ok(from.as_any_box().downcast::<SwapPlacementOverrideNotSupported>()?),
            StructType::TooManyDevices => Ok(from.as_any_box().downcast::<TooManyDevices>()?),
            StructType::UnsupportedGuest => Ok(from.as_any_box().downcast::<UnsupportedGuest>()?),
            StructType::VmWwnConflict => Ok(from.as_any_box().downcast::<VmWwnConflict>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// An InvalidDeviceSpec exception is thrown if
/// a virtual machine creation or configuration fails because a device
/// specification contains an invalid value.
pub trait InvalidDeviceSpecTrait : super::traits::InvalidVmConfigTrait {
    /// Index of the device in the configuration specification that has the invalid value.
    fn get_device_index(&self) -> i32;
}
impl<'s> serde::Serialize for dyn InvalidDeviceSpecTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn InvalidDeviceSpecTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(InvalidDeviceSpecVisitor)
            }
        }

struct InvalidDeviceSpecVisitor;

impl<'de> de::Visitor<'de> for InvalidDeviceSpecVisitor {
    type Value = Box<dyn InvalidDeviceSpecTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid InvalidDeviceSpecTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl InvalidDeviceSpecTrait for InvalidDeviceSpec {
    fn get_device_index(&self) -> i32 { self.device_index }
}
impl InvalidDeviceSpecTrait for DeviceHotPlugNotSupported {
    fn get_device_index(&self) -> i32 { self.device_index }
}
impl InvalidDeviceSpecTrait for DeviceNotFound {
    fn get_device_index(&self) -> i32 { self.device_index }
}
impl InvalidDeviceSpecTrait for DeviceUnsupportedForVmPlatform {
    fn get_device_index(&self) -> i32 { self.device_index }
}
impl InvalidDeviceSpecTrait for DeviceUnsupportedForVmVersion {
    fn get_device_index(&self) -> i32 { self.device_index }
}
impl InvalidDeviceSpecTrait for DisallowedDiskModeChange {
    fn get_device_index(&self) -> i32 { self.device_index }
}
impl InvalidDeviceSpecTrait for InvalidController {
    fn get_device_index(&self) -> i32 { self.device_index }
}
impl InvalidDeviceSpecTrait for InvalidDeviceBacking {
    fn get_device_index(&self) -> i32 { self.device_index }
}
impl InvalidDeviceSpecTrait for InvalidDeviceOperation {
    fn get_device_index(&self) -> i32 { self.device_index }
}
impl InvalidDeviceSpecTrait for MissingController {
    fn get_device_index(&self) -> i32 { self.device_index }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn InvalidDeviceSpecTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::InvalidDeviceSpec => Some(from.as_any_ref().downcast_ref::<InvalidDeviceSpec>()?),
            StructType::DeviceHotPlugNotSupported => Some(from.as_any_ref().downcast_ref::<DeviceHotPlugNotSupported>()?),
            StructType::DeviceNotFound => Some(from.as_any_ref().downcast_ref::<DeviceNotFound>()?),
            StructType::DeviceUnsupportedForVmPlatform => Some(from.as_any_ref().downcast_ref::<DeviceUnsupportedForVmPlatform>()?),
            StructType::DeviceUnsupportedForVmVersion => Some(from.as_any_ref().downcast_ref::<DeviceUnsupportedForVmVersion>()?),
            StructType::DisallowedDiskModeChange => Some(from.as_any_ref().downcast_ref::<DisallowedDiskModeChange>()?),
            StructType::InvalidController => Some(from.as_any_ref().downcast_ref::<InvalidController>()?),
            StructType::InvalidDeviceBacking => Some(from.as_any_ref().downcast_ref::<InvalidDeviceBacking>()?),
            StructType::InvalidDeviceOperation => Some(from.as_any_ref().downcast_ref::<InvalidDeviceOperation>()?),
            StructType::MissingController => Some(from.as_any_ref().downcast_ref::<MissingController>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::InvalidDeviceSpec => Ok(from.as_any_box().downcast::<InvalidDeviceSpec>()?),
            StructType::DeviceHotPlugNotSupported => Ok(from.as_any_box().downcast::<DeviceHotPlugNotSupported>()?),
            StructType::DeviceNotFound => Ok(from.as_any_box().downcast::<DeviceNotFound>()?),
            StructType::DeviceUnsupportedForVmPlatform => Ok(from.as_any_box().downcast::<DeviceUnsupportedForVmPlatform>()?),
            StructType::DeviceUnsupportedForVmVersion => Ok(from.as_any_box().downcast::<DeviceUnsupportedForVmVersion>()?),
            StructType::DisallowedDiskModeChange => Ok(from.as_any_box().downcast::<DisallowedDiskModeChange>()?),
            StructType::InvalidController => Ok(from.as_any_box().downcast::<InvalidController>()?),
            StructType::InvalidDeviceBacking => Ok(from.as_any_box().downcast::<InvalidDeviceBacking>()?),
            StructType::InvalidDeviceOperation => Ok(from.as_any_box().downcast::<InvalidDeviceOperation>()?),
            StructType::MissingController => Ok(from.as_any_box().downcast::<MissingController>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The virtual machine is not supported on the target datastore.
/// 
/// This fault is
/// thrown by provisioning operations when an attempt is made to create a virtual
/// machine on an unsupported datastore (for example, creating a non-legacy
/// virtual machine on a legacy datastore).
pub trait UnsupportedDatastoreTrait : super::traits::VmConfigFaultTrait {
    /// The invalid datastore for this virtual machine.
    /// 
    /// Refers instance of *Datastore*.
    fn get_datastore(&self) -> &Option<ManagedObjectReference>;
}
impl<'s> serde::Serialize for dyn UnsupportedDatastoreTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn UnsupportedDatastoreTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(UnsupportedDatastoreVisitor)
            }
        }

struct UnsupportedDatastoreVisitor;

impl<'de> de::Visitor<'de> for UnsupportedDatastoreVisitor {
    type Value = Box<dyn UnsupportedDatastoreTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid UnsupportedDatastoreTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl UnsupportedDatastoreTrait for UnsupportedDatastore {
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
}
impl UnsupportedDatastoreTrait for MemoryFileFormatNotSupportedByDatastore {
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
}
impl UnsupportedDatastoreTrait for UnSupportedDatastoreForVFlash {
    fn get_datastore(&self) -> &Option<ManagedObjectReference> { &self.datastore }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn UnsupportedDatastoreTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::UnsupportedDatastore => Some(from.as_any_ref().downcast_ref::<UnsupportedDatastore>()?),
            StructType::MemoryFileFormatNotSupportedByDatastore => Some(from.as_any_ref().downcast_ref::<MemoryFileFormatNotSupportedByDatastore>()?),
            StructType::UnSupportedDatastoreForVFlash => Some(from.as_any_ref().downcast_ref::<UnSupportedDatastoreForVFlash>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::UnsupportedDatastore => Ok(from.as_any_box().downcast::<UnsupportedDatastore>()?),
            StructType::MemoryFileFormatNotSupportedByDatastore => Ok(from.as_any_box().downcast::<MemoryFileFormatNotSupportedByDatastore>()?),
            StructType::UnSupportedDatastoreForVFlash => Ok(from.as_any_box().downcast::<UnSupportedDatastoreForVFlash>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The base fault for all vApp property configuration issues
pub trait VAppPropertyFaultTrait : super::traits::VmConfigFaultTrait {
    /// The fully-qualified id of the property, including instance and class
    /// identifiers.
    fn get_id(&self) -> &str;
    /// The user-readable category
    fn get_category(&self) -> &str;
    /// The user-readable label
    fn get_label(&self) -> &str;
    /// The type specified for the property
    fn get_type(&self) -> &str;
    /// The value of the property
    fn get_value(&self) -> &str;
}
impl<'s> serde::Serialize for dyn VAppPropertyFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VAppPropertyFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VAppPropertyFaultVisitor)
            }
        }

struct VAppPropertyFaultVisitor;

impl<'de> de::Visitor<'de> for VAppPropertyFaultVisitor {
    type Value = Box<dyn VAppPropertyFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VAppPropertyFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VAppPropertyFaultTrait for VAppPropertyFault {
    fn get_id(&self) -> &str { &self.id }
    fn get_category(&self) -> &str { &self.category }
    fn get_label(&self) -> &str { &self.label }
    fn get_type(&self) -> &str { &self.r#type }
    fn get_value(&self) -> &str { &self.value }
}
impl VAppPropertyFaultTrait for InvalidNetworkInType {
    fn get_id(&self) -> &str { &self.id }
    fn get_category(&self) -> &str { &self.category }
    fn get_label(&self) -> &str { &self.label }
    fn get_type(&self) -> &str { &self.r#type }
    fn get_value(&self) -> &str { &self.value }
}
impl VAppPropertyFaultTrait for InvalidPropertyType {
    fn get_id(&self) -> &str { &self.id }
    fn get_category(&self) -> &str { &self.category }
    fn get_label(&self) -> &str { &self.label }
    fn get_type(&self) -> &str { &self.r#type }
    fn get_value(&self) -> &str { &self.value }
}
impl VAppPropertyFaultTrait for InvalidPropertyValue {
    fn get_id(&self) -> &str { &self.id }
    fn get_category(&self) -> &str { &self.category }
    fn get_label(&self) -> &str { &self.label }
    fn get_type(&self) -> &str { &self.r#type }
    fn get_value(&self) -> &str { &self.value }
}
impl VAppPropertyFaultTrait for UnconfiguredPropertyValue {
    fn get_id(&self) -> &str { &self.id }
    fn get_category(&self) -> &str { &self.category }
    fn get_label(&self) -> &str { &self.label }
    fn get_type(&self) -> &str { &self.r#type }
    fn get_value(&self) -> &str { &self.value }
}
impl VAppPropertyFaultTrait for MissingIpPool {
    fn get_id(&self) -> &str { &self.id }
    fn get_category(&self) -> &str { &self.category }
    fn get_label(&self) -> &str { &self.label }
    fn get_type(&self) -> &str { &self.r#type }
    fn get_value(&self) -> &str { &self.value }
}
impl VAppPropertyFaultTrait for MissingNetworkIpConfig {
    fn get_id(&self) -> &str { &self.id }
    fn get_category(&self) -> &str { &self.category }
    fn get_label(&self) -> &str { &self.label }
    fn get_type(&self) -> &str { &self.r#type }
    fn get_value(&self) -> &str { &self.value }
}
impl VAppPropertyFaultTrait for NoAvailableIp {
    fn get_id(&self) -> &str { &self.id }
    fn get_category(&self) -> &str { &self.category }
    fn get_label(&self) -> &str { &self.label }
    fn get_type(&self) -> &str { &self.r#type }
    fn get_value(&self) -> &str { &self.value }
}
impl VAppPropertyFaultTrait for NoVcManagedIpConfigured {
    fn get_id(&self) -> &str { &self.id }
    fn get_category(&self) -> &str { &self.category }
    fn get_label(&self) -> &str { &self.label }
    fn get_type(&self) -> &str { &self.r#type }
    fn get_value(&self) -> &str { &self.value }
}
impl VAppPropertyFaultTrait for NotUserConfigurableProperty {
    fn get_id(&self) -> &str { &self.id }
    fn get_category(&self) -> &str { &self.category }
    fn get_label(&self) -> &str { &self.label }
    fn get_type(&self) -> &str { &self.r#type }
    fn get_value(&self) -> &str { &self.value }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VAppPropertyFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VAppPropertyFault => Some(from.as_any_ref().downcast_ref::<VAppPropertyFault>()?),
            StructType::InvalidNetworkInType => Some(from.as_any_ref().downcast_ref::<InvalidNetworkInType>()?),
            StructType::InvalidPropertyType => Some(from.as_any_ref().downcast_ref::<InvalidPropertyType>()?),
            StructType::InvalidPropertyValue => Some(from.as_any_ref().downcast_ref::<InvalidPropertyValue>()?),
            StructType::UnconfiguredPropertyValue => Some(from.as_any_ref().downcast_ref::<UnconfiguredPropertyValue>()?),
            StructType::MissingIpPool => Some(from.as_any_ref().downcast_ref::<MissingIpPool>()?),
            StructType::MissingNetworkIpConfig => Some(from.as_any_ref().downcast_ref::<MissingNetworkIpConfig>()?),
            StructType::NoAvailableIp => Some(from.as_any_ref().downcast_ref::<NoAvailableIp>()?),
            StructType::NoVcManagedIpConfigured => Some(from.as_any_ref().downcast_ref::<NoVcManagedIpConfigured>()?),
            StructType::NotUserConfigurableProperty => Some(from.as_any_ref().downcast_ref::<NotUserConfigurableProperty>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VAppPropertyFault => Ok(from.as_any_box().downcast::<VAppPropertyFault>()?),
            StructType::InvalidNetworkInType => Ok(from.as_any_box().downcast::<InvalidNetworkInType>()?),
            StructType::InvalidPropertyType => Ok(from.as_any_box().downcast::<InvalidPropertyType>()?),
            StructType::InvalidPropertyValue => Ok(from.as_any_box().downcast::<InvalidPropertyValue>()?),
            StructType::UnconfiguredPropertyValue => Ok(from.as_any_box().downcast::<UnconfiguredPropertyValue>()?),
            StructType::MissingIpPool => Ok(from.as_any_box().downcast::<MissingIpPool>()?),
            StructType::MissingNetworkIpConfig => Ok(from.as_any_box().downcast::<MissingNetworkIpConfig>()?),
            StructType::NoAvailableIp => Ok(from.as_any_box().downcast::<NoAvailableIp>()?),
            StructType::NoVcManagedIpConfigured => Ok(from.as_any_box().downcast::<NoVcManagedIpConfigured>()?),
            StructType::NotUserConfigurableProperty => Ok(from.as_any_box().downcast::<NotUserConfigurableProperty>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The value of the property is not valid given the type of the property.
pub trait InvalidPropertyValueTrait : super::traits::VAppPropertyFaultTrait {
}
impl<'s> serde::Serialize for dyn InvalidPropertyValueTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn InvalidPropertyValueTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(InvalidPropertyValueVisitor)
            }
        }

struct InvalidPropertyValueVisitor;

impl<'de> de::Visitor<'de> for InvalidPropertyValueVisitor {
    type Value = Box<dyn InvalidPropertyValueTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid InvalidPropertyValueTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl InvalidPropertyValueTrait for InvalidPropertyValue {
}
impl InvalidPropertyValueTrait for UnconfiguredPropertyValue {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn InvalidPropertyValueTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::InvalidPropertyValue => Some(from.as_any_ref().downcast_ref::<InvalidPropertyValue>()?),
            StructType::UnconfiguredPropertyValue => Some(from.as_any_ref().downcast_ref::<UnconfiguredPropertyValue>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::InvalidPropertyValue => Ok(from.as_any_box().downcast::<InvalidPropertyValue>()?),
            StructType::UnconfiguredPropertyValue => Ok(from.as_any_box().downcast::<UnconfiguredPropertyValue>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// There is a problem with the compatibility between the intended execution host
/// and the virtual machine.
/// 
/// This may be an error or warning depending on
/// the specific fault subclass.
pub trait VirtualHardwareCompatibilityIssueTrait : super::traits::VmConfigFaultTrait {
}
impl<'s> serde::Serialize for dyn VirtualHardwareCompatibilityIssueTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VirtualHardwareCompatibilityIssueTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VirtualHardwareCompatibilityIssueVisitor)
            }
        }

struct VirtualHardwareCompatibilityIssueVisitor;

impl<'de> de::Visitor<'de> for VirtualHardwareCompatibilityIssueVisitor {
    type Value = Box<dyn VirtualHardwareCompatibilityIssueTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VirtualHardwareCompatibilityIssueTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VirtualHardwareCompatibilityIssueTrait for VirtualHardwareCompatibilityIssue {
}
impl VirtualHardwareCompatibilityIssueTrait for CpuIncompatible {
}
impl VirtualHardwareCompatibilityIssueTrait for CpuCompatibilityUnknown {
}
impl VirtualHardwareCompatibilityIssueTrait for CpuIncompatible1Ecx {
}
impl VirtualHardwareCompatibilityIssueTrait for CpuIncompatible81Edx {
}
impl VirtualHardwareCompatibilityIssueTrait for FaultToleranceCpuIncompatible {
}
impl VirtualHardwareCompatibilityIssueTrait for DeviceNotSupported {
}
impl VirtualHardwareCompatibilityIssueTrait for DeviceBackingNotSupported {
}
impl VirtualHardwareCompatibilityIssueTrait for DvPortNotSupported {
}
impl VirtualHardwareCompatibilityIssueTrait for UnusedVirtualDiskBlocksNotScrubbed {
}
impl VirtualHardwareCompatibilityIssueTrait for VirtualDiskBlocksNotFullyProvisioned {
}
impl VirtualHardwareCompatibilityIssueTrait for DeviceControllerNotSupported {
}
impl VirtualHardwareCompatibilityIssueTrait for DigestNotSupported {
}
impl VirtualHardwareCompatibilityIssueTrait for FileBackedPortNotSupported {
}
impl VirtualHardwareCompatibilityIssueTrait for MultiWriterNotSupported {
}
impl VirtualHardwareCompatibilityIssueTrait for NonPersistentDisksNotSupported {
}
impl VirtualHardwareCompatibilityIssueTrait for RdmNotSupported {
}
impl VirtualHardwareCompatibilityIssueTrait for PhysCompatRdmNotSupported {
}
impl VirtualHardwareCompatibilityIssueTrait for RawDiskNotSupported {
}
impl VirtualHardwareCompatibilityIssueTrait for RemoteDeviceNotSupported {
}
impl VirtualHardwareCompatibilityIssueTrait for SharedBusControllerNotSupported {
}
impl VirtualHardwareCompatibilityIssueTrait for VmiNotSupported {
}
impl VirtualHardwareCompatibilityIssueTrait for VirtualDiskModeNotSupported {
}
impl VirtualHardwareCompatibilityIssueTrait for VirtualEthernetCardNotSupported {
}
impl VirtualHardwareCompatibilityIssueTrait for DiskNotSupported {
}
impl VirtualHardwareCompatibilityIssueTrait for IdeDiskNotSupported {
}
impl VirtualHardwareCompatibilityIssueTrait for DrsVmotionIncompatibleFault {
}
impl VirtualHardwareCompatibilityIssueTrait for FeatureRequirementsNotMet {
}
impl VirtualHardwareCompatibilityIssueTrait for MemorySizeNotRecommended {
}
impl VirtualHardwareCompatibilityIssueTrait for MemorySizeNotSupported {
}
impl VirtualHardwareCompatibilityIssueTrait for MemorySizeNotSupportedByDatastore {
}
impl VirtualHardwareCompatibilityIssueTrait for NotEnoughCpus {
}
impl VirtualHardwareCompatibilityIssueTrait for NotEnoughLogicalCpus {
}
impl VirtualHardwareCompatibilityIssueTrait for NumVirtualCoresPerSocketNotSupported {
}
impl VirtualHardwareCompatibilityIssueTrait for NumVirtualCpusNotSupported {
}
impl VirtualHardwareCompatibilityIssueTrait for StorageVmotionIncompatible {
}
impl VirtualHardwareCompatibilityIssueTrait for VirtualHardwareVersionNotSupported {
}
impl VirtualHardwareCompatibilityIssueTrait for WakeOnLanNotSupported {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VirtualHardwareCompatibilityIssueTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualHardwareCompatibilityIssue => Some(from.as_any_ref().downcast_ref::<VirtualHardwareCompatibilityIssue>()?),
            StructType::CpuIncompatible => Some(from.as_any_ref().downcast_ref::<CpuIncompatible>()?),
            StructType::CpuCompatibilityUnknown => Some(from.as_any_ref().downcast_ref::<CpuCompatibilityUnknown>()?),
            StructType::CpuIncompatible1Ecx => Some(from.as_any_ref().downcast_ref::<CpuIncompatible1Ecx>()?),
            StructType::CpuIncompatible81Edx => Some(from.as_any_ref().downcast_ref::<CpuIncompatible81Edx>()?),
            StructType::FaultToleranceCpuIncompatible => Some(from.as_any_ref().downcast_ref::<FaultToleranceCpuIncompatible>()?),
            StructType::DeviceNotSupported => Some(from.as_any_ref().downcast_ref::<DeviceNotSupported>()?),
            StructType::DeviceBackingNotSupported => Some(from.as_any_ref().downcast_ref::<DeviceBackingNotSupported>()?),
            StructType::DvPortNotSupported => Some(from.as_any_ref().downcast_ref::<DvPortNotSupported>()?),
            StructType::UnusedVirtualDiskBlocksNotScrubbed => Some(from.as_any_ref().downcast_ref::<UnusedVirtualDiskBlocksNotScrubbed>()?),
            StructType::VirtualDiskBlocksNotFullyProvisioned => Some(from.as_any_ref().downcast_ref::<VirtualDiskBlocksNotFullyProvisioned>()?),
            StructType::DeviceControllerNotSupported => Some(from.as_any_ref().downcast_ref::<DeviceControllerNotSupported>()?),
            StructType::DigestNotSupported => Some(from.as_any_ref().downcast_ref::<DigestNotSupported>()?),
            StructType::FileBackedPortNotSupported => Some(from.as_any_ref().downcast_ref::<FileBackedPortNotSupported>()?),
            StructType::MultiWriterNotSupported => Some(from.as_any_ref().downcast_ref::<MultiWriterNotSupported>()?),
            StructType::NonPersistentDisksNotSupported => Some(from.as_any_ref().downcast_ref::<NonPersistentDisksNotSupported>()?),
            StructType::RdmNotSupported => Some(from.as_any_ref().downcast_ref::<RdmNotSupported>()?),
            StructType::PhysCompatRdmNotSupported => Some(from.as_any_ref().downcast_ref::<PhysCompatRdmNotSupported>()?),
            StructType::RawDiskNotSupported => Some(from.as_any_ref().downcast_ref::<RawDiskNotSupported>()?),
            StructType::RemoteDeviceNotSupported => Some(from.as_any_ref().downcast_ref::<RemoteDeviceNotSupported>()?),
            StructType::SharedBusControllerNotSupported => Some(from.as_any_ref().downcast_ref::<SharedBusControllerNotSupported>()?),
            StructType::VmiNotSupported => Some(from.as_any_ref().downcast_ref::<VmiNotSupported>()?),
            StructType::VirtualDiskModeNotSupported => Some(from.as_any_ref().downcast_ref::<VirtualDiskModeNotSupported>()?),
            StructType::VirtualEthernetCardNotSupported => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardNotSupported>()?),
            StructType::DiskNotSupported => Some(from.as_any_ref().downcast_ref::<DiskNotSupported>()?),
            StructType::IdeDiskNotSupported => Some(from.as_any_ref().downcast_ref::<IdeDiskNotSupported>()?),
            StructType::DrsVmotionIncompatibleFault => Some(from.as_any_ref().downcast_ref::<DrsVmotionIncompatibleFault>()?),
            StructType::FeatureRequirementsNotMet => Some(from.as_any_ref().downcast_ref::<FeatureRequirementsNotMet>()?),
            StructType::MemorySizeNotRecommended => Some(from.as_any_ref().downcast_ref::<MemorySizeNotRecommended>()?),
            StructType::MemorySizeNotSupported => Some(from.as_any_ref().downcast_ref::<MemorySizeNotSupported>()?),
            StructType::MemorySizeNotSupportedByDatastore => Some(from.as_any_ref().downcast_ref::<MemorySizeNotSupportedByDatastore>()?),
            StructType::NotEnoughCpus => Some(from.as_any_ref().downcast_ref::<NotEnoughCpus>()?),
            StructType::NotEnoughLogicalCpus => Some(from.as_any_ref().downcast_ref::<NotEnoughLogicalCpus>()?),
            StructType::NumVirtualCoresPerSocketNotSupported => Some(from.as_any_ref().downcast_ref::<NumVirtualCoresPerSocketNotSupported>()?),
            StructType::NumVirtualCpusNotSupported => Some(from.as_any_ref().downcast_ref::<NumVirtualCpusNotSupported>()?),
            StructType::StorageVmotionIncompatible => Some(from.as_any_ref().downcast_ref::<StorageVmotionIncompatible>()?),
            StructType::VirtualHardwareVersionNotSupported => Some(from.as_any_ref().downcast_ref::<VirtualHardwareVersionNotSupported>()?),
            StructType::WakeOnLanNotSupported => Some(from.as_any_ref().downcast_ref::<WakeOnLanNotSupported>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VirtualHardwareCompatibilityIssue => Ok(from.as_any_box().downcast::<VirtualHardwareCompatibilityIssue>()?),
            StructType::CpuIncompatible => Ok(from.as_any_box().downcast::<CpuIncompatible>()?),
            StructType::CpuCompatibilityUnknown => Ok(from.as_any_box().downcast::<CpuCompatibilityUnknown>()?),
            StructType::CpuIncompatible1Ecx => Ok(from.as_any_box().downcast::<CpuIncompatible1Ecx>()?),
            StructType::CpuIncompatible81Edx => Ok(from.as_any_box().downcast::<CpuIncompatible81Edx>()?),
            StructType::FaultToleranceCpuIncompatible => Ok(from.as_any_box().downcast::<FaultToleranceCpuIncompatible>()?),
            StructType::DeviceNotSupported => Ok(from.as_any_box().downcast::<DeviceNotSupported>()?),
            StructType::DeviceBackingNotSupported => Ok(from.as_any_box().downcast::<DeviceBackingNotSupported>()?),
            StructType::DvPortNotSupported => Ok(from.as_any_box().downcast::<DvPortNotSupported>()?),
            StructType::UnusedVirtualDiskBlocksNotScrubbed => Ok(from.as_any_box().downcast::<UnusedVirtualDiskBlocksNotScrubbed>()?),
            StructType::VirtualDiskBlocksNotFullyProvisioned => Ok(from.as_any_box().downcast::<VirtualDiskBlocksNotFullyProvisioned>()?),
            StructType::DeviceControllerNotSupported => Ok(from.as_any_box().downcast::<DeviceControllerNotSupported>()?),
            StructType::DigestNotSupported => Ok(from.as_any_box().downcast::<DigestNotSupported>()?),
            StructType::FileBackedPortNotSupported => Ok(from.as_any_box().downcast::<FileBackedPortNotSupported>()?),
            StructType::MultiWriterNotSupported => Ok(from.as_any_box().downcast::<MultiWriterNotSupported>()?),
            StructType::NonPersistentDisksNotSupported => Ok(from.as_any_box().downcast::<NonPersistentDisksNotSupported>()?),
            StructType::RdmNotSupported => Ok(from.as_any_box().downcast::<RdmNotSupported>()?),
            StructType::PhysCompatRdmNotSupported => Ok(from.as_any_box().downcast::<PhysCompatRdmNotSupported>()?),
            StructType::RawDiskNotSupported => Ok(from.as_any_box().downcast::<RawDiskNotSupported>()?),
            StructType::RemoteDeviceNotSupported => Ok(from.as_any_box().downcast::<RemoteDeviceNotSupported>()?),
            StructType::SharedBusControllerNotSupported => Ok(from.as_any_box().downcast::<SharedBusControllerNotSupported>()?),
            StructType::VmiNotSupported => Ok(from.as_any_box().downcast::<VmiNotSupported>()?),
            StructType::VirtualDiskModeNotSupported => Ok(from.as_any_box().downcast::<VirtualDiskModeNotSupported>()?),
            StructType::VirtualEthernetCardNotSupported => Ok(from.as_any_box().downcast::<VirtualEthernetCardNotSupported>()?),
            StructType::DiskNotSupported => Ok(from.as_any_box().downcast::<DiskNotSupported>()?),
            StructType::IdeDiskNotSupported => Ok(from.as_any_box().downcast::<IdeDiskNotSupported>()?),
            StructType::DrsVmotionIncompatibleFault => Ok(from.as_any_box().downcast::<DrsVmotionIncompatibleFault>()?),
            StructType::FeatureRequirementsNotMet => Ok(from.as_any_box().downcast::<FeatureRequirementsNotMet>()?),
            StructType::MemorySizeNotRecommended => Ok(from.as_any_box().downcast::<MemorySizeNotRecommended>()?),
            StructType::MemorySizeNotSupported => Ok(from.as_any_box().downcast::<MemorySizeNotSupported>()?),
            StructType::MemorySizeNotSupportedByDatastore => Ok(from.as_any_box().downcast::<MemorySizeNotSupportedByDatastore>()?),
            StructType::NotEnoughCpus => Ok(from.as_any_box().downcast::<NotEnoughCpus>()?),
            StructType::NotEnoughLogicalCpus => Ok(from.as_any_box().downcast::<NotEnoughLogicalCpus>()?),
            StructType::NumVirtualCoresPerSocketNotSupported => Ok(from.as_any_box().downcast::<NumVirtualCoresPerSocketNotSupported>()?),
            StructType::NumVirtualCpusNotSupported => Ok(from.as_any_box().downcast::<NumVirtualCpusNotSupported>()?),
            StructType::StorageVmotionIncompatible => Ok(from.as_any_box().downcast::<StorageVmotionIncompatible>()?),
            StructType::VirtualHardwareVersionNotSupported => Ok(from.as_any_box().downcast::<VirtualHardwareVersionNotSupported>()?),
            StructType::WakeOnLanNotSupported => Ok(from.as_any_box().downcast::<WakeOnLanNotSupported>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Deprecated as of vSphere API 6.5 use
/// *FeatureRequirementsNotMet*.
/// 
/// The host is not compatible with the CPU feature requirements of the
/// virtual machine, for a particular CPUID register.
/// 
/// A subclass of this fault
/// may be used to express the incompatibilities in a more easily
/// understandable format.
pub trait CpuIncompatibleTrait : super::traits::VirtualHardwareCompatibilityIssueTrait {
    /// The CpuIdInfo level where a problem was detected.
    /// 
    /// Other levels may
    /// also have problems.
    fn get_level(&self) -> i32;
    /// The CpuIdInfo register where a problem was detected.
    /// 
    /// Other registers
    /// may also have problems. Possible register names are eax, ebx, ecx, or edx.
    fn get_register_name(&self) -> &str;
    /// The contents of the register on the target host, in CpuIdInfo register
    /// format.
    /// 
    /// The '-' character indicates an unknown value.
    fn get_register_bits(&self) -> &Option<String>;
    /// The desired values for the register's bits.
    /// 
    /// The 'x' character indicates
    /// don't-care.
    fn get_desired_bits(&self) -> &Option<String>;
    /// The host that is not compatible with the requirements.
    /// 
    /// Refers instance of *HostSystem*.
    fn get_host(&self) -> &Option<ManagedObjectReference>;
}
impl<'s> serde::Serialize for dyn CpuIncompatibleTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn CpuIncompatibleTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(CpuIncompatibleVisitor)
            }
        }

struct CpuIncompatibleVisitor;

impl<'de> de::Visitor<'de> for CpuIncompatibleVisitor {
    type Value = Box<dyn CpuIncompatibleTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid CpuIncompatibleTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl CpuIncompatibleTrait for CpuIncompatible {
    fn get_level(&self) -> i32 { self.level }
    fn get_register_name(&self) -> &str { &self.register_name }
    fn get_register_bits(&self) -> &Option<String> { &self.register_bits }
    fn get_desired_bits(&self) -> &Option<String> { &self.desired_bits }
    fn get_host(&self) -> &Option<ManagedObjectReference> { &self.host }
}
impl CpuIncompatibleTrait for CpuCompatibilityUnknown {
    fn get_level(&self) -> i32 { self.level }
    fn get_register_name(&self) -> &str { &self.register_name }
    fn get_register_bits(&self) -> &Option<String> { &self.register_bits }
    fn get_desired_bits(&self) -> &Option<String> { &self.desired_bits }
    fn get_host(&self) -> &Option<ManagedObjectReference> { &self.host }
}
impl CpuIncompatibleTrait for CpuIncompatible1Ecx {
    fn get_level(&self) -> i32 { self.level }
    fn get_register_name(&self) -> &str { &self.register_name }
    fn get_register_bits(&self) -> &Option<String> { &self.register_bits }
    fn get_desired_bits(&self) -> &Option<String> { &self.desired_bits }
    fn get_host(&self) -> &Option<ManagedObjectReference> { &self.host }
}
impl CpuIncompatibleTrait for CpuIncompatible81Edx {
    fn get_level(&self) -> i32 { self.level }
    fn get_register_name(&self) -> &str { &self.register_name }
    fn get_register_bits(&self) -> &Option<String> { &self.register_bits }
    fn get_desired_bits(&self) -> &Option<String> { &self.desired_bits }
    fn get_host(&self) -> &Option<ManagedObjectReference> { &self.host }
}
impl CpuIncompatibleTrait for FaultToleranceCpuIncompatible {
    fn get_level(&self) -> i32 { self.level }
    fn get_register_name(&self) -> &str { &self.register_name }
    fn get_register_bits(&self) -> &Option<String> { &self.register_bits }
    fn get_desired_bits(&self) -> &Option<String> { &self.desired_bits }
    fn get_host(&self) -> &Option<ManagedObjectReference> { &self.host }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn CpuIncompatibleTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::CpuIncompatible => Some(from.as_any_ref().downcast_ref::<CpuIncompatible>()?),
            StructType::CpuCompatibilityUnknown => Some(from.as_any_ref().downcast_ref::<CpuCompatibilityUnknown>()?),
            StructType::CpuIncompatible1Ecx => Some(from.as_any_ref().downcast_ref::<CpuIncompatible1Ecx>()?),
            StructType::CpuIncompatible81Edx => Some(from.as_any_ref().downcast_ref::<CpuIncompatible81Edx>()?),
            StructType::FaultToleranceCpuIncompatible => Some(from.as_any_ref().downcast_ref::<FaultToleranceCpuIncompatible>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::CpuIncompatible => Ok(from.as_any_box().downcast::<CpuIncompatible>()?),
            StructType::CpuCompatibilityUnknown => Ok(from.as_any_box().downcast::<CpuCompatibilityUnknown>()?),
            StructType::CpuIncompatible1Ecx => Ok(from.as_any_box().downcast::<CpuIncompatible1Ecx>()?),
            StructType::CpuIncompatible81Edx => Ok(from.as_any_box().downcast::<CpuIncompatible81Edx>()?),
            StructType::FaultToleranceCpuIncompatible => Ok(from.as_any_box().downcast::<FaultToleranceCpuIncompatible>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The virtual machine uses a device type that is not supported on the
/// host.
/// 
/// If this fault is returned as a subfault of
/// *DisallowedMigrationDeviceAttached*, this indicates that although
/// this device may be supported on the destination host, the hosts do
/// not support the requested migration of the virtual machine while
/// using this device.
pub trait DeviceNotSupportedTrait : super::traits::VirtualHardwareCompatibilityIssueTrait {
    /// The label of the device.
    fn get_device(&self) -> &str;
    /// The specific reason why the device is not supported.
    /// 
    /// Values should come from *DeviceNotSupportedReason_enum*.
    /// This might not be set if we're not sure of the reason, or
    /// if this doesn't make sense in the context. For example,
    /// in the *DisallowedMigrationDeviceAttached* context
    /// we already know the problem.
    fn get_reason(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn DeviceNotSupportedTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DeviceNotSupportedTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DeviceNotSupportedVisitor)
            }
        }

struct DeviceNotSupportedVisitor;

impl<'de> de::Visitor<'de> for DeviceNotSupportedVisitor {
    type Value = Box<dyn DeviceNotSupportedTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DeviceNotSupportedTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DeviceNotSupportedTrait for DeviceNotSupported {
    fn get_device(&self) -> &str { &self.device }
    fn get_reason(&self) -> &Option<String> { &self.reason }
}
impl DeviceNotSupportedTrait for DeviceBackingNotSupported {
    fn get_device(&self) -> &str { &self.device }
    fn get_reason(&self) -> &Option<String> { &self.reason }
}
impl DeviceNotSupportedTrait for DvPortNotSupported {
    fn get_device(&self) -> &str { &self.device }
    fn get_reason(&self) -> &Option<String> { &self.reason }
}
impl DeviceNotSupportedTrait for UnusedVirtualDiskBlocksNotScrubbed {
    fn get_device(&self) -> &str { &self.device }
    fn get_reason(&self) -> &Option<String> { &self.reason }
}
impl DeviceNotSupportedTrait for VirtualDiskBlocksNotFullyProvisioned {
    fn get_device(&self) -> &str { &self.device }
    fn get_reason(&self) -> &Option<String> { &self.reason }
}
impl DeviceNotSupportedTrait for DeviceControllerNotSupported {
    fn get_device(&self) -> &str { &self.device }
    fn get_reason(&self) -> &Option<String> { &self.reason }
}
impl DeviceNotSupportedTrait for DigestNotSupported {
    fn get_device(&self) -> &str { &self.device }
    fn get_reason(&self) -> &Option<String> { &self.reason }
}
impl DeviceNotSupportedTrait for FileBackedPortNotSupported {
    fn get_device(&self) -> &str { &self.device }
    fn get_reason(&self) -> &Option<String> { &self.reason }
}
impl DeviceNotSupportedTrait for MultiWriterNotSupported {
    fn get_device(&self) -> &str { &self.device }
    fn get_reason(&self) -> &Option<String> { &self.reason }
}
impl DeviceNotSupportedTrait for NonPersistentDisksNotSupported {
    fn get_device(&self) -> &str { &self.device }
    fn get_reason(&self) -> &Option<String> { &self.reason }
}
impl DeviceNotSupportedTrait for RdmNotSupported {
    fn get_device(&self) -> &str { &self.device }
    fn get_reason(&self) -> &Option<String> { &self.reason }
}
impl DeviceNotSupportedTrait for PhysCompatRdmNotSupported {
    fn get_device(&self) -> &str { &self.device }
    fn get_reason(&self) -> &Option<String> { &self.reason }
}
impl DeviceNotSupportedTrait for RawDiskNotSupported {
    fn get_device(&self) -> &str { &self.device }
    fn get_reason(&self) -> &Option<String> { &self.reason }
}
impl DeviceNotSupportedTrait for RemoteDeviceNotSupported {
    fn get_device(&self) -> &str { &self.device }
    fn get_reason(&self) -> &Option<String> { &self.reason }
}
impl DeviceNotSupportedTrait for SharedBusControllerNotSupported {
    fn get_device(&self) -> &str { &self.device }
    fn get_reason(&self) -> &Option<String> { &self.reason }
}
impl DeviceNotSupportedTrait for VmiNotSupported {
    fn get_device(&self) -> &str { &self.device }
    fn get_reason(&self) -> &Option<String> { &self.reason }
}
impl DeviceNotSupportedTrait for VirtualDiskModeNotSupported {
    fn get_device(&self) -> &str { &self.device }
    fn get_reason(&self) -> &Option<String> { &self.reason }
}
impl DeviceNotSupportedTrait for VirtualEthernetCardNotSupported {
    fn get_device(&self) -> &str { &self.device }
    fn get_reason(&self) -> &Option<String> { &self.reason }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DeviceNotSupportedTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DeviceNotSupported => Some(from.as_any_ref().downcast_ref::<DeviceNotSupported>()?),
            StructType::DeviceBackingNotSupported => Some(from.as_any_ref().downcast_ref::<DeviceBackingNotSupported>()?),
            StructType::DvPortNotSupported => Some(from.as_any_ref().downcast_ref::<DvPortNotSupported>()?),
            StructType::UnusedVirtualDiskBlocksNotScrubbed => Some(from.as_any_ref().downcast_ref::<UnusedVirtualDiskBlocksNotScrubbed>()?),
            StructType::VirtualDiskBlocksNotFullyProvisioned => Some(from.as_any_ref().downcast_ref::<VirtualDiskBlocksNotFullyProvisioned>()?),
            StructType::DeviceControllerNotSupported => Some(from.as_any_ref().downcast_ref::<DeviceControllerNotSupported>()?),
            StructType::DigestNotSupported => Some(from.as_any_ref().downcast_ref::<DigestNotSupported>()?),
            StructType::FileBackedPortNotSupported => Some(from.as_any_ref().downcast_ref::<FileBackedPortNotSupported>()?),
            StructType::MultiWriterNotSupported => Some(from.as_any_ref().downcast_ref::<MultiWriterNotSupported>()?),
            StructType::NonPersistentDisksNotSupported => Some(from.as_any_ref().downcast_ref::<NonPersistentDisksNotSupported>()?),
            StructType::RdmNotSupported => Some(from.as_any_ref().downcast_ref::<RdmNotSupported>()?),
            StructType::PhysCompatRdmNotSupported => Some(from.as_any_ref().downcast_ref::<PhysCompatRdmNotSupported>()?),
            StructType::RawDiskNotSupported => Some(from.as_any_ref().downcast_ref::<RawDiskNotSupported>()?),
            StructType::RemoteDeviceNotSupported => Some(from.as_any_ref().downcast_ref::<RemoteDeviceNotSupported>()?),
            StructType::SharedBusControllerNotSupported => Some(from.as_any_ref().downcast_ref::<SharedBusControllerNotSupported>()?),
            StructType::VmiNotSupported => Some(from.as_any_ref().downcast_ref::<VmiNotSupported>()?),
            StructType::VirtualDiskModeNotSupported => Some(from.as_any_ref().downcast_ref::<VirtualDiskModeNotSupported>()?),
            StructType::VirtualEthernetCardNotSupported => Some(from.as_any_ref().downcast_ref::<VirtualEthernetCardNotSupported>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DeviceNotSupported => Ok(from.as_any_box().downcast::<DeviceNotSupported>()?),
            StructType::DeviceBackingNotSupported => Ok(from.as_any_box().downcast::<DeviceBackingNotSupported>()?),
            StructType::DvPortNotSupported => Ok(from.as_any_box().downcast::<DvPortNotSupported>()?),
            StructType::UnusedVirtualDiskBlocksNotScrubbed => Ok(from.as_any_box().downcast::<UnusedVirtualDiskBlocksNotScrubbed>()?),
            StructType::VirtualDiskBlocksNotFullyProvisioned => Ok(from.as_any_box().downcast::<VirtualDiskBlocksNotFullyProvisioned>()?),
            StructType::DeviceControllerNotSupported => Ok(from.as_any_box().downcast::<DeviceControllerNotSupported>()?),
            StructType::DigestNotSupported => Ok(from.as_any_box().downcast::<DigestNotSupported>()?),
            StructType::FileBackedPortNotSupported => Ok(from.as_any_box().downcast::<FileBackedPortNotSupported>()?),
            StructType::MultiWriterNotSupported => Ok(from.as_any_box().downcast::<MultiWriterNotSupported>()?),
            StructType::NonPersistentDisksNotSupported => Ok(from.as_any_box().downcast::<NonPersistentDisksNotSupported>()?),
            StructType::RdmNotSupported => Ok(from.as_any_box().downcast::<RdmNotSupported>()?),
            StructType::PhysCompatRdmNotSupported => Ok(from.as_any_box().downcast::<PhysCompatRdmNotSupported>()?),
            StructType::RawDiskNotSupported => Ok(from.as_any_box().downcast::<RawDiskNotSupported>()?),
            StructType::RemoteDeviceNotSupported => Ok(from.as_any_box().downcast::<RemoteDeviceNotSupported>()?),
            StructType::SharedBusControllerNotSupported => Ok(from.as_any_box().downcast::<SharedBusControllerNotSupported>()?),
            StructType::VmiNotSupported => Ok(from.as_any_box().downcast::<VmiNotSupported>()?),
            StructType::VirtualDiskModeNotSupported => Ok(from.as_any_box().downcast::<VirtualDiskModeNotSupported>()?),
            StructType::VirtualEthernetCardNotSupported => Ok(from.as_any_box().downcast::<VirtualEthernetCardNotSupported>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The device is backed by a backing type which is not supported
/// for this particular device.
/// 
/// If this fault is returned as a subfault of
/// DisallowedMigrationDeviceAttached, this indicates that although
/// this backing for the device may be supported on the destination
/// host, the hosts do not support the requested migration of the
/// virtual machine while using this device with this backing.
pub trait DeviceBackingNotSupportedTrait : super::traits::DeviceNotSupportedTrait {
    /// The type of the backing.
    fn get_backing(&self) -> &str;
}
impl<'s> serde::Serialize for dyn DeviceBackingNotSupportedTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DeviceBackingNotSupportedTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DeviceBackingNotSupportedVisitor)
            }
        }

struct DeviceBackingNotSupportedVisitor;

impl<'de> de::Visitor<'de> for DeviceBackingNotSupportedVisitor {
    type Value = Box<dyn DeviceBackingNotSupportedTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DeviceBackingNotSupportedTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DeviceBackingNotSupportedTrait for DeviceBackingNotSupported {
    fn get_backing(&self) -> &str { &self.backing }
}
impl DeviceBackingNotSupportedTrait for DvPortNotSupported {
    fn get_backing(&self) -> &str { &self.backing }
}
impl DeviceBackingNotSupportedTrait for UnusedVirtualDiskBlocksNotScrubbed {
    fn get_backing(&self) -> &str { &self.backing }
}
impl DeviceBackingNotSupportedTrait for VirtualDiskBlocksNotFullyProvisioned {
    fn get_backing(&self) -> &str { &self.backing }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DeviceBackingNotSupportedTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DeviceBackingNotSupported => Some(from.as_any_ref().downcast_ref::<DeviceBackingNotSupported>()?),
            StructType::DvPortNotSupported => Some(from.as_any_ref().downcast_ref::<DvPortNotSupported>()?),
            StructType::UnusedVirtualDiskBlocksNotScrubbed => Some(from.as_any_ref().downcast_ref::<UnusedVirtualDiskBlocksNotScrubbed>()?),
            StructType::VirtualDiskBlocksNotFullyProvisioned => Some(from.as_any_ref().downcast_ref::<VirtualDiskBlocksNotFullyProvisioned>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DeviceBackingNotSupported => Ok(from.as_any_box().downcast::<DeviceBackingNotSupported>()?),
            StructType::DvPortNotSupported => Ok(from.as_any_box().downcast::<DvPortNotSupported>()?),
            StructType::UnusedVirtualDiskBlocksNotScrubbed => Ok(from.as_any_box().downcast::<UnusedVirtualDiskBlocksNotScrubbed>()?),
            StructType::VirtualDiskBlocksNotFullyProvisioned => Ok(from.as_any_box().downcast::<VirtualDiskBlocksNotFullyProvisioned>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The virtual machine is configured with a Raw Disk Mapping.
/// 
/// This is not
/// supported on the host.
pub trait RdmNotSupportedTrait : super::traits::DeviceNotSupportedTrait {
}
impl<'s> serde::Serialize for dyn RdmNotSupportedTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn RdmNotSupportedTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(RdmNotSupportedVisitor)
            }
        }

struct RdmNotSupportedVisitor;

impl<'de> de::Visitor<'de> for RdmNotSupportedVisitor {
    type Value = Box<dyn RdmNotSupportedTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid RdmNotSupportedTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl RdmNotSupportedTrait for RdmNotSupported {
}
impl RdmNotSupportedTrait for PhysCompatRdmNotSupported {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn RdmNotSupportedTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::RdmNotSupported => Some(from.as_any_ref().downcast_ref::<RdmNotSupported>()?),
            StructType::PhysCompatRdmNotSupported => Some(from.as_any_ref().downcast_ref::<PhysCompatRdmNotSupported>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::RdmNotSupported => Ok(from.as_any_box().downcast::<RdmNotSupported>()?),
            StructType::PhysCompatRdmNotSupported => Ok(from.as_any_box().downcast::<PhysCompatRdmNotSupported>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The host does not support the backings for the disks specified by the virtual
/// machine.
/// 
/// For example, this fault is thrown if a virtual machine is created from
/// a template that specifies backings that the host does not have. Similarly, this fault
/// is thrown if a virtual machine is registered on a host that does not support the
/// specified backings.
pub trait DiskNotSupportedTrait : super::traits::VirtualHardwareCompatibilityIssueTrait {
    /// The ID of disk that is not supported.
    fn get_disk(&self) -> i32;
}
impl<'s> serde::Serialize for dyn DiskNotSupportedTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn DiskNotSupportedTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(DiskNotSupportedVisitor)
            }
        }

struct DiskNotSupportedVisitor;

impl<'de> de::Visitor<'de> for DiskNotSupportedVisitor {
    type Value = Box<dyn DiskNotSupportedTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid DiskNotSupportedTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl DiskNotSupportedTrait for DiskNotSupported {
    fn get_disk(&self) -> i32 { self.disk }
}
impl DiskNotSupportedTrait for IdeDiskNotSupported {
    fn get_disk(&self) -> i32 { self.disk }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn DiskNotSupportedTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::DiskNotSupported => Some(from.as_any_ref().downcast_ref::<DiskNotSupported>()?),
            StructType::IdeDiskNotSupported => Some(from.as_any_ref().downcast_ref::<IdeDiskNotSupported>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::DiskNotSupported => Ok(from.as_any_box().downcast::<DiskNotSupported>()?),
            StructType::IdeDiskNotSupported => Ok(from.as_any_box().downcast::<IdeDiskNotSupported>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The host hardware does not have enough CPU cores to support the number of
/// virtual CPUs in the virtual machine.
/// 
/// If the host is using hyperthreading, NotEnoughLogicalCpus is
/// employed instead of NotEnoughCpus.
pub trait NotEnoughCpusTrait : super::traits::VirtualHardwareCompatibilityIssueTrait {
    /// The number of CPUs present on the host.
    fn get_num_cpu_dest(&self) -> i32;
    /// The number of virtual CPUs present in the virtual machine.
    fn get_num_cpu_vm(&self) -> i32;
}
impl<'s> serde::Serialize for dyn NotEnoughCpusTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn NotEnoughCpusTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(NotEnoughCpusVisitor)
            }
        }

struct NotEnoughCpusVisitor;

impl<'de> de::Visitor<'de> for NotEnoughCpusVisitor {
    type Value = Box<dyn NotEnoughCpusTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid NotEnoughCpusTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl NotEnoughCpusTrait for NotEnoughCpus {
    fn get_num_cpu_dest(&self) -> i32 { self.num_cpu_dest }
    fn get_num_cpu_vm(&self) -> i32 { self.num_cpu_vm }
}
impl NotEnoughCpusTrait for NotEnoughLogicalCpus {
    fn get_num_cpu_dest(&self) -> i32 { self.num_cpu_dest }
    fn get_num_cpu_vm(&self) -> i32 { self.num_cpu_vm }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn NotEnoughCpusTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::NotEnoughCpus => Some(from.as_any_ref().downcast_ref::<NotEnoughCpus>()?),
            StructType::NotEnoughLogicalCpus => Some(from.as_any_ref().downcast_ref::<NotEnoughLogicalCpus>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::NotEnoughCpus => Ok(from.as_any_box().downcast::<NotEnoughCpus>()?),
            StructType::NotEnoughLogicalCpus => Ok(from.as_any_box().downcast::<NotEnoughLogicalCpus>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base object type for issues that can occur during operations
/// related to fault tolerance protection for virtual machines.
pub trait VmFaultToleranceIssueTrait : super::traits::VimFaultTrait {
}
impl<'s> serde::Serialize for dyn VmFaultToleranceIssueTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VmFaultToleranceIssueTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VmFaultToleranceIssueVisitor)
            }
        }

struct VmFaultToleranceIssueVisitor;

impl<'de> de::Visitor<'de> for VmFaultToleranceIssueVisitor {
    type Value = Box<dyn VmFaultToleranceIssueTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VmFaultToleranceIssueTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VmFaultToleranceIssueTrait for VmFaultToleranceIssue {
}
impl VmFaultToleranceIssueTrait for CannotChangeDrsBehaviorForFtSecondary {
}
impl VmFaultToleranceIssueTrait for CannotChangeHaSettingsForFtSecondary {
}
impl VmFaultToleranceIssueTrait for CannotComputeFtCompatibleHosts {
}
impl VmFaultToleranceIssueTrait for FaultToleranceNotLicensed {
}
impl VmFaultToleranceIssueTrait for FaultTolerancePrimaryPowerOnNotAttempted {
}
impl VmFaultToleranceIssueTrait for FtIssuesOnHost {
}
impl VmFaultToleranceIssueTrait for HostIncompatibleForFaultTolerance {
}
impl VmFaultToleranceIssueTrait for IncompatibleHostForFtSecondary {
}
impl VmFaultToleranceIssueTrait for InvalidOperationOnSecondaryVm {
}
impl VmFaultToleranceIssueTrait for NoHostSuitableForFtSecondary {
}
impl VmFaultToleranceIssueTrait for NotSupportedDeviceForFt {
}
impl VmFaultToleranceIssueTrait for PowerOnFtSecondaryFailed {
}
impl VmFaultToleranceIssueTrait for SecondaryVmAlreadyDisabled {
}
impl VmFaultToleranceIssueTrait for SecondaryVmAlreadyEnabled {
}
impl VmFaultToleranceIssueTrait for SecondaryVmAlreadyRegistered {
}
impl VmFaultToleranceIssueTrait for SecondaryVmNotRegistered {
}
impl VmFaultToleranceIssueTrait for VmFaultToleranceConfigIssue {
}
impl VmFaultToleranceIssueTrait for VmFaultToleranceConfigIssueWrapper {
}
impl VmFaultToleranceIssueTrait for VmFaultToleranceInvalidFileBacking {
}
impl VmFaultToleranceIssueTrait for VmFaultToleranceOpIssuesList {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VmFaultToleranceIssueTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmFaultToleranceIssue => Some(from.as_any_ref().downcast_ref::<VmFaultToleranceIssue>()?),
            StructType::CannotChangeDrsBehaviorForFtSecondary => Some(from.as_any_ref().downcast_ref::<CannotChangeDrsBehaviorForFtSecondary>()?),
            StructType::CannotChangeHaSettingsForFtSecondary => Some(from.as_any_ref().downcast_ref::<CannotChangeHaSettingsForFtSecondary>()?),
            StructType::CannotComputeFtCompatibleHosts => Some(from.as_any_ref().downcast_ref::<CannotComputeFtCompatibleHosts>()?),
            StructType::FaultToleranceNotLicensed => Some(from.as_any_ref().downcast_ref::<FaultToleranceNotLicensed>()?),
            StructType::FaultTolerancePrimaryPowerOnNotAttempted => Some(from.as_any_ref().downcast_ref::<FaultTolerancePrimaryPowerOnNotAttempted>()?),
            StructType::FtIssuesOnHost => Some(from.as_any_ref().downcast_ref::<FtIssuesOnHost>()?),
            StructType::HostIncompatibleForFaultTolerance => Some(from.as_any_ref().downcast_ref::<HostIncompatibleForFaultTolerance>()?),
            StructType::IncompatibleHostForFtSecondary => Some(from.as_any_ref().downcast_ref::<IncompatibleHostForFtSecondary>()?),
            StructType::InvalidOperationOnSecondaryVm => Some(from.as_any_ref().downcast_ref::<InvalidOperationOnSecondaryVm>()?),
            StructType::NoHostSuitableForFtSecondary => Some(from.as_any_ref().downcast_ref::<NoHostSuitableForFtSecondary>()?),
            StructType::NotSupportedDeviceForFt => Some(from.as_any_ref().downcast_ref::<NotSupportedDeviceForFt>()?),
            StructType::PowerOnFtSecondaryFailed => Some(from.as_any_ref().downcast_ref::<PowerOnFtSecondaryFailed>()?),
            StructType::SecondaryVmAlreadyDisabled => Some(from.as_any_ref().downcast_ref::<SecondaryVmAlreadyDisabled>()?),
            StructType::SecondaryVmAlreadyEnabled => Some(from.as_any_ref().downcast_ref::<SecondaryVmAlreadyEnabled>()?),
            StructType::SecondaryVmAlreadyRegistered => Some(from.as_any_ref().downcast_ref::<SecondaryVmAlreadyRegistered>()?),
            StructType::SecondaryVmNotRegistered => Some(from.as_any_ref().downcast_ref::<SecondaryVmNotRegistered>()?),
            StructType::VmFaultToleranceConfigIssue => Some(from.as_any_ref().downcast_ref::<VmFaultToleranceConfigIssue>()?),
            StructType::VmFaultToleranceConfigIssueWrapper => Some(from.as_any_ref().downcast_ref::<VmFaultToleranceConfigIssueWrapper>()?),
            StructType::VmFaultToleranceInvalidFileBacking => Some(from.as_any_ref().downcast_ref::<VmFaultToleranceInvalidFileBacking>()?),
            StructType::VmFaultToleranceOpIssuesList => Some(from.as_any_ref().downcast_ref::<VmFaultToleranceOpIssuesList>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmFaultToleranceIssue => Ok(from.as_any_box().downcast::<VmFaultToleranceIssue>()?),
            StructType::CannotChangeDrsBehaviorForFtSecondary => Ok(from.as_any_box().downcast::<CannotChangeDrsBehaviorForFtSecondary>()?),
            StructType::CannotChangeHaSettingsForFtSecondary => Ok(from.as_any_box().downcast::<CannotChangeHaSettingsForFtSecondary>()?),
            StructType::CannotComputeFtCompatibleHosts => Ok(from.as_any_box().downcast::<CannotComputeFtCompatibleHosts>()?),
            StructType::FaultToleranceNotLicensed => Ok(from.as_any_box().downcast::<FaultToleranceNotLicensed>()?),
            StructType::FaultTolerancePrimaryPowerOnNotAttempted => Ok(from.as_any_box().downcast::<FaultTolerancePrimaryPowerOnNotAttempted>()?),
            StructType::FtIssuesOnHost => Ok(from.as_any_box().downcast::<FtIssuesOnHost>()?),
            StructType::HostIncompatibleForFaultTolerance => Ok(from.as_any_box().downcast::<HostIncompatibleForFaultTolerance>()?),
            StructType::IncompatibleHostForFtSecondary => Ok(from.as_any_box().downcast::<IncompatibleHostForFtSecondary>()?),
            StructType::InvalidOperationOnSecondaryVm => Ok(from.as_any_box().downcast::<InvalidOperationOnSecondaryVm>()?),
            StructType::NoHostSuitableForFtSecondary => Ok(from.as_any_box().downcast::<NoHostSuitableForFtSecondary>()?),
            StructType::NotSupportedDeviceForFt => Ok(from.as_any_box().downcast::<NotSupportedDeviceForFt>()?),
            StructType::PowerOnFtSecondaryFailed => Ok(from.as_any_box().downcast::<PowerOnFtSecondaryFailed>()?),
            StructType::SecondaryVmAlreadyDisabled => Ok(from.as_any_box().downcast::<SecondaryVmAlreadyDisabled>()?),
            StructType::SecondaryVmAlreadyEnabled => Ok(from.as_any_box().downcast::<SecondaryVmAlreadyEnabled>()?),
            StructType::SecondaryVmAlreadyRegistered => Ok(from.as_any_box().downcast::<SecondaryVmAlreadyRegistered>()?),
            StructType::SecondaryVmNotRegistered => Ok(from.as_any_box().downcast::<SecondaryVmNotRegistered>()?),
            StructType::VmFaultToleranceConfigIssue => Ok(from.as_any_box().downcast::<VmFaultToleranceConfigIssue>()?),
            StructType::VmFaultToleranceConfigIssueWrapper => Ok(from.as_any_box().downcast::<VmFaultToleranceConfigIssueWrapper>()?),
            StructType::VmFaultToleranceInvalidFileBacking => Ok(from.as_any_box().downcast::<VmFaultToleranceInvalidFileBacking>()?),
            StructType::VmFaultToleranceOpIssuesList => Ok(from.as_any_box().downcast::<VmFaultToleranceOpIssuesList>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// A base fault to indicate that something went wrong when upgrading tools.
pub trait VmToolsUpgradeFaultTrait : super::traits::VimFaultTrait {
}
impl<'s> serde::Serialize for dyn VmToolsUpgradeFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VmToolsUpgradeFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VmToolsUpgradeFaultVisitor)
            }
        }

struct VmToolsUpgradeFaultVisitor;

impl<'de> de::Visitor<'de> for VmToolsUpgradeFaultVisitor {
    type Value = Box<dyn VmToolsUpgradeFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VmToolsUpgradeFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VmToolsUpgradeFaultTrait for VmToolsUpgradeFault {
}
impl VmToolsUpgradeFaultTrait for ToolsAlreadyUpgraded {
}
impl VmToolsUpgradeFaultTrait for ToolsAutoUpgradeNotSupported {
}
impl VmToolsUpgradeFaultTrait for ToolsImageCopyFailed {
}
impl VmToolsUpgradeFaultTrait for ToolsImageNotAvailable {
}
impl VmToolsUpgradeFaultTrait for ToolsImageSignatureCheckFailed {
}
impl VmToolsUpgradeFaultTrait for ToolsUpgradeCancelled {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VmToolsUpgradeFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmToolsUpgradeFault => Some(from.as_any_ref().downcast_ref::<VmToolsUpgradeFault>()?),
            StructType::ToolsAlreadyUpgraded => Some(from.as_any_ref().downcast_ref::<ToolsAlreadyUpgraded>()?),
            StructType::ToolsAutoUpgradeNotSupported => Some(from.as_any_ref().downcast_ref::<ToolsAutoUpgradeNotSupported>()?),
            StructType::ToolsImageCopyFailed => Some(from.as_any_ref().downcast_ref::<ToolsImageCopyFailed>()?),
            StructType::ToolsImageNotAvailable => Some(from.as_any_ref().downcast_ref::<ToolsImageNotAvailable>()?),
            StructType::ToolsImageSignatureCheckFailed => Some(from.as_any_ref().downcast_ref::<ToolsImageSignatureCheckFailed>()?),
            StructType::ToolsUpgradeCancelled => Some(from.as_any_ref().downcast_ref::<ToolsUpgradeCancelled>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VmToolsUpgradeFault => Ok(from.as_any_box().downcast::<VmToolsUpgradeFault>()?),
            StructType::ToolsAlreadyUpgraded => Ok(from.as_any_box().downcast::<ToolsAlreadyUpgraded>()?),
            StructType::ToolsAutoUpgradeNotSupported => Ok(from.as_any_box().downcast::<ToolsAutoUpgradeNotSupported>()?),
            StructType::ToolsImageCopyFailed => Ok(from.as_any_box().downcast::<ToolsImageCopyFailed>()?),
            StructType::ToolsImageNotAvailable => Ok(from.as_any_box().downcast::<ToolsImageNotAvailable>()?),
            StructType::ToolsImageSignatureCheckFailed => Ok(from.as_any_box().downcast::<ToolsImageSignatureCheckFailed>()?),
            StructType::ToolsUpgradeCancelled => Ok(from.as_any_box().downcast::<ToolsUpgradeCancelled>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base exception class for VSAN-specific faults raised for host
/// or cluster operations.
/// 
/// See also *HostVsanSystem*, *ComputeResource.ReconfigureComputeResource_Task*.
pub trait VsanFaultTrait : super::traits::VimFaultTrait {
}
impl<'s> serde::Serialize for dyn VsanFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VsanFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VsanFaultVisitor)
            }
        }

struct VsanFaultVisitor;

impl<'de> de::Visitor<'de> for VsanFaultVisitor {
    type Value = Box<dyn VsanFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VsanFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VsanFaultTrait for VsanFault {
}
impl VsanFaultTrait for CannotChangeVsanClusterUuid {
}
impl VsanFaultTrait for CannotChangeVsanNodeUuid {
}
impl VsanFaultTrait for CannotMoveVsanEnabledHost {
}
impl VsanFaultTrait for DestinationVsanDisabled {
}
impl VsanFaultTrait for VsanClusterUuidMismatch {
}
impl VsanFaultTrait for CannotReconfigureVsanWhenHaEnabled {
}
impl VsanFaultTrait for DuplicateVsanNetworkInterface {
}
impl VsanFaultTrait for VsanDiskFault {
}
impl VsanFaultTrait for DiskHasPartitions {
}
impl VsanFaultTrait for DiskIsLastRemainingNonSsd {
}
impl VsanFaultTrait for DiskIsNonLocal {
}
impl VsanFaultTrait for DiskIsUsb {
}
impl VsanFaultTrait for DiskTooSmall {
}
impl VsanFaultTrait for DuplicateDisks {
}
impl VsanFaultTrait for InsufficientDisks {
}
impl VsanFaultTrait for VsanIncompatibleDiskMapping {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VsanFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VsanFault => Some(from.as_any_ref().downcast_ref::<VsanFault>()?),
            StructType::CannotChangeVsanClusterUuid => Some(from.as_any_ref().downcast_ref::<CannotChangeVsanClusterUuid>()?),
            StructType::CannotChangeVsanNodeUuid => Some(from.as_any_ref().downcast_ref::<CannotChangeVsanNodeUuid>()?),
            StructType::CannotMoveVsanEnabledHost => Some(from.as_any_ref().downcast_ref::<CannotMoveVsanEnabledHost>()?),
            StructType::DestinationVsanDisabled => Some(from.as_any_ref().downcast_ref::<DestinationVsanDisabled>()?),
            StructType::VsanClusterUuidMismatch => Some(from.as_any_ref().downcast_ref::<VsanClusterUuidMismatch>()?),
            StructType::CannotReconfigureVsanWhenHaEnabled => Some(from.as_any_ref().downcast_ref::<CannotReconfigureVsanWhenHaEnabled>()?),
            StructType::DuplicateVsanNetworkInterface => Some(from.as_any_ref().downcast_ref::<DuplicateVsanNetworkInterface>()?),
            StructType::VsanDiskFault => Some(from.as_any_ref().downcast_ref::<VsanDiskFault>()?),
            StructType::DiskHasPartitions => Some(from.as_any_ref().downcast_ref::<DiskHasPartitions>()?),
            StructType::DiskIsLastRemainingNonSsd => Some(from.as_any_ref().downcast_ref::<DiskIsLastRemainingNonSsd>()?),
            StructType::DiskIsNonLocal => Some(from.as_any_ref().downcast_ref::<DiskIsNonLocal>()?),
            StructType::DiskIsUsb => Some(from.as_any_ref().downcast_ref::<DiskIsUsb>()?),
            StructType::DiskTooSmall => Some(from.as_any_ref().downcast_ref::<DiskTooSmall>()?),
            StructType::DuplicateDisks => Some(from.as_any_ref().downcast_ref::<DuplicateDisks>()?),
            StructType::InsufficientDisks => Some(from.as_any_ref().downcast_ref::<InsufficientDisks>()?),
            StructType::VsanIncompatibleDiskMapping => Some(from.as_any_ref().downcast_ref::<VsanIncompatibleDiskMapping>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VsanFault => Ok(from.as_any_box().downcast::<VsanFault>()?),
            StructType::CannotChangeVsanClusterUuid => Ok(from.as_any_box().downcast::<CannotChangeVsanClusterUuid>()?),
            StructType::CannotChangeVsanNodeUuid => Ok(from.as_any_box().downcast::<CannotChangeVsanNodeUuid>()?),
            StructType::CannotMoveVsanEnabledHost => Ok(from.as_any_box().downcast::<CannotMoveVsanEnabledHost>()?),
            StructType::DestinationVsanDisabled => Ok(from.as_any_box().downcast::<DestinationVsanDisabled>()?),
            StructType::VsanClusterUuidMismatch => Ok(from.as_any_box().downcast::<VsanClusterUuidMismatch>()?),
            StructType::CannotReconfigureVsanWhenHaEnabled => Ok(from.as_any_box().downcast::<CannotReconfigureVsanWhenHaEnabled>()?),
            StructType::DuplicateVsanNetworkInterface => Ok(from.as_any_box().downcast::<DuplicateVsanNetworkInterface>()?),
            StructType::VsanDiskFault => Ok(from.as_any_box().downcast::<VsanDiskFault>()?),
            StructType::DiskHasPartitions => Ok(from.as_any_box().downcast::<DiskHasPartitions>()?),
            StructType::DiskIsLastRemainingNonSsd => Ok(from.as_any_box().downcast::<DiskIsLastRemainingNonSsd>()?),
            StructType::DiskIsNonLocal => Ok(from.as_any_box().downcast::<DiskIsNonLocal>()?),
            StructType::DiskIsUsb => Ok(from.as_any_box().downcast::<DiskIsUsb>()?),
            StructType::DiskTooSmall => Ok(from.as_any_box().downcast::<DiskTooSmall>()?),
            StructType::DuplicateDisks => Ok(from.as_any_box().downcast::<DuplicateDisks>()?),
            StructType::InsufficientDisks => Ok(from.as_any_box().downcast::<InsufficientDisks>()?),
            StructType::VsanIncompatibleDiskMapping => Ok(from.as_any_box().downcast::<VsanIncompatibleDiskMapping>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Fault thrown for the case that an attempt is made to move a host which
/// is enabled for VSAN into an unsuitable *ClusterComputeResource*.
/// 
/// The destination vim.ClusterComputeResource may be disabled for VSAN, or
/// may be using VSAN with a different cluster UUID.
/// 
/// See also *ClusterComputeResource.AddHost_Task*, *ClusterComputeResource.MoveHostInto_Task*, *ClusterComputeResource.MoveInto_Task*, *VsanClusterUuidMismatch*, *DestinationVsanDisabled*.
pub trait CannotMoveVsanEnabledHostTrait : super::traits::VsanFaultTrait {
}
impl<'s> serde::Serialize for dyn CannotMoveVsanEnabledHostTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn CannotMoveVsanEnabledHostTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(CannotMoveVsanEnabledHostVisitor)
            }
        }

struct CannotMoveVsanEnabledHostVisitor;

impl<'de> de::Visitor<'de> for CannotMoveVsanEnabledHostVisitor {
    type Value = Box<dyn CannotMoveVsanEnabledHostTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid CannotMoveVsanEnabledHostTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl CannotMoveVsanEnabledHostTrait for CannotMoveVsanEnabledHost {
}
impl CannotMoveVsanEnabledHostTrait for DestinationVsanDisabled {
}
impl CannotMoveVsanEnabledHostTrait for VsanClusterUuidMismatch {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn CannotMoveVsanEnabledHostTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::CannotMoveVsanEnabledHost => Some(from.as_any_ref().downcast_ref::<CannotMoveVsanEnabledHost>()?),
            StructType::DestinationVsanDisabled => Some(from.as_any_ref().downcast_ref::<DestinationVsanDisabled>()?),
            StructType::VsanClusterUuidMismatch => Some(from.as_any_ref().downcast_ref::<VsanClusterUuidMismatch>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::CannotMoveVsanEnabledHost => Ok(from.as_any_box().downcast::<CannotMoveVsanEnabledHost>()?),
            StructType::DestinationVsanDisabled => Ok(from.as_any_box().downcast::<DestinationVsanDisabled>()?),
            StructType::VsanClusterUuidMismatch => Ok(from.as_any_box().downcast::<VsanClusterUuidMismatch>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Base exception class for VSAN disk-related faults.
pub trait VsanDiskFaultTrait : super::traits::VsanFaultTrait {
    /// The canonical name for the disk at hand, if applicable.
    /// 
    /// See also *ScsiLun.canonicalName*.
    fn get_device(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn VsanDiskFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn VsanDiskFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(VsanDiskFaultVisitor)
            }
        }

struct VsanDiskFaultVisitor;

impl<'de> de::Visitor<'de> for VsanDiskFaultVisitor {
    type Value = Box<dyn VsanDiskFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid VsanDiskFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl VsanDiskFaultTrait for VsanDiskFault {
    fn get_device(&self) -> &Option<String> { &self.device }
}
impl VsanDiskFaultTrait for DiskHasPartitions {
    fn get_device(&self) -> &Option<String> { &self.device }
}
impl VsanDiskFaultTrait for DiskIsLastRemainingNonSsd {
    fn get_device(&self) -> &Option<String> { &self.device }
}
impl VsanDiskFaultTrait for DiskIsNonLocal {
    fn get_device(&self) -> &Option<String> { &self.device }
}
impl VsanDiskFaultTrait for DiskIsUsb {
    fn get_device(&self) -> &Option<String> { &self.device }
}
impl VsanDiskFaultTrait for DiskTooSmall {
    fn get_device(&self) -> &Option<String> { &self.device }
}
impl VsanDiskFaultTrait for DuplicateDisks {
    fn get_device(&self) -> &Option<String> { &self.device }
}
impl VsanDiskFaultTrait for InsufficientDisks {
    fn get_device(&self) -> &Option<String> { &self.device }
}
impl VsanDiskFaultTrait for VsanIncompatibleDiskMapping {
    fn get_device(&self) -> &Option<String> { &self.device }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn VsanDiskFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::VsanDiskFault => Some(from.as_any_ref().downcast_ref::<VsanDiskFault>()?),
            StructType::DiskHasPartitions => Some(from.as_any_ref().downcast_ref::<DiskHasPartitions>()?),
            StructType::DiskIsLastRemainingNonSsd => Some(from.as_any_ref().downcast_ref::<DiskIsLastRemainingNonSsd>()?),
            StructType::DiskIsNonLocal => Some(from.as_any_ref().downcast_ref::<DiskIsNonLocal>()?),
            StructType::DiskIsUsb => Some(from.as_any_ref().downcast_ref::<DiskIsUsb>()?),
            StructType::DiskTooSmall => Some(from.as_any_ref().downcast_ref::<DiskTooSmall>()?),
            StructType::DuplicateDisks => Some(from.as_any_ref().downcast_ref::<DuplicateDisks>()?),
            StructType::InsufficientDisks => Some(from.as_any_ref().downcast_ref::<InsufficientDisks>()?),
            StructType::VsanIncompatibleDiskMapping => Some(from.as_any_ref().downcast_ref::<VsanIncompatibleDiskMapping>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::VsanDiskFault => Ok(from.as_any_box().downcast::<VsanDiskFault>()?),
            StructType::DiskHasPartitions => Ok(from.as_any_box().downcast::<DiskHasPartitions>()?),
            StructType::DiskIsLastRemainingNonSsd => Ok(from.as_any_box().downcast::<DiskIsLastRemainingNonSsd>()?),
            StructType::DiskIsNonLocal => Ok(from.as_any_box().downcast::<DiskIsNonLocal>()?),
            StructType::DiskIsUsb => Ok(from.as_any_box().downcast::<DiskIsUsb>()?),
            StructType::DiskTooSmall => Ok(from.as_any_box().downcast::<DiskTooSmall>()?),
            StructType::DuplicateDisks => Ok(from.as_any_box().downcast::<DuplicateDisks>()?),
            StructType::InsufficientDisks => Ok(from.as_any_box().downcast::<InsufficientDisks>()?),
            StructType::VsanIncompatibleDiskMapping => Ok(from.as_any_box().downcast::<VsanIncompatibleDiskMapping>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// The base data object type for all runtime faults that can be
/// thrown by a method.
pub trait RuntimeFaultTrait : super::traits::MethodFaultTrait {
}
impl<'s> serde::Serialize for dyn RuntimeFaultTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn RuntimeFaultTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(RuntimeFaultVisitor)
            }
        }

struct RuntimeFaultVisitor;

impl<'de> de::Visitor<'de> for RuntimeFaultVisitor {
    type Value = Box<dyn RuntimeFaultTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid RuntimeFaultTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl RuntimeFaultTrait for RuntimeFault {
}
impl RuntimeFaultTrait for CannotDisableDrsOnClustersWithVApps {
}
impl RuntimeFaultTrait for ConflictingDatastoreFound {
}
impl RuntimeFaultTrait for DatabaseError {
}
impl RuntimeFaultTrait for DisallowedChangeByService {
}
impl RuntimeFaultTrait for DisallowedOperationOnFailoverHost {
}
impl RuntimeFaultTrait for FailToLockFaultToleranceVMs {
}
impl RuntimeFaultTrait for InvalidProfileReferenceHost {
}
impl RuntimeFaultTrait for InvalidScheduledTask {
}
impl RuntimeFaultTrait for LicenseAssignmentFailed {
}
impl RuntimeFaultTrait for MethodAlreadyDisabledFault {
}
impl RuntimeFaultTrait for MethodDisabled {
}
impl RuntimeFaultTrait for OperationDisallowedOnHost {
}
impl RuntimeFaultTrait for RestrictedByAdministrator {
}
impl RuntimeFaultTrait for ThirdPartyLicenseAssignmentFailed {
}
impl RuntimeFaultTrait for VAppOperationInProgress {
}
impl RuntimeFaultTrait for HostCommunication {
}
impl RuntimeFaultTrait for HostNotConnected {
}
impl RuntimeFaultTrait for HostNotReachable {
}
impl RuntimeFaultTrait for InvalidArgument {
}
impl RuntimeFaultTrait for IncompatibleSetting {
}
impl RuntimeFaultTrait for InvalidDasConfigArgument {
}
impl RuntimeFaultTrait for InvalidDasRestartPriorityForFtVm {
}
impl RuntimeFaultTrait for InvalidDrsBehaviorForFtVm {
}
impl RuntimeFaultTrait for InvalidIndexArgument {
}
impl RuntimeFaultTrait for InvalidRequest {
}
impl RuntimeFaultTrait for InvalidType {
}
impl RuntimeFaultTrait for MethodNotFound {
}
impl RuntimeFaultTrait for ManagedObjectNotFound {
}
impl RuntimeFaultTrait for NotEnoughLicenses {
}
impl RuntimeFaultTrait for ExpiredFeatureLicense {
}
impl RuntimeFaultTrait for ExpiredAddonLicense {
}
impl RuntimeFaultTrait for ExpiredEditionLicense {
}
impl RuntimeFaultTrait for FailToEnableSpbm {
}
impl RuntimeFaultTrait for HostInventoryFull {
}
impl RuntimeFaultTrait for InUseFeatureManipulationDisallowed {
}
impl RuntimeFaultTrait for IncorrectHostInformation {
}
impl RuntimeFaultTrait for InvalidEditionLicense {
}
impl RuntimeFaultTrait for InventoryHasStandardAloneHosts {
}
impl RuntimeFaultTrait for LicenseDowngradeDisallowed {
}
impl RuntimeFaultTrait for LicenseExpired {
}
impl RuntimeFaultTrait for LicenseKeyEntityMismatch {
}
impl RuntimeFaultTrait for LicenseRestricted {
}
impl RuntimeFaultTrait for LicenseSourceUnavailable {
}
impl RuntimeFaultTrait for NoLicenseServerConfigured {
}
impl RuntimeFaultTrait for VmLimitLicense {
}
impl RuntimeFaultTrait for VramLimitLicense {
}
impl RuntimeFaultTrait for NotImplemented {
}
impl RuntimeFaultTrait for NotSupported {
}
impl RuntimeFaultTrait for HostAccessRestrictedToManagementServer {
}
impl RuntimeFaultTrait for RequestCanceled {
}
impl RuntimeFaultTrait for SecurityError {
}
impl RuntimeFaultTrait for NoPermission {
}
impl RuntimeFaultTrait for NotAuthenticated {
}
impl RuntimeFaultTrait for RestrictedVersion {
}
impl RuntimeFaultTrait for SolutionUserRequired {
}
impl RuntimeFaultTrait for SystemError {
}
impl RuntimeFaultTrait for UnexpectedFault {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn RuntimeFaultTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::RuntimeFault => Some(from.as_any_ref().downcast_ref::<RuntimeFault>()?),
            StructType::CannotDisableDrsOnClustersWithVApps => Some(from.as_any_ref().downcast_ref::<CannotDisableDrsOnClustersWithVApps>()?),
            StructType::ConflictingDatastoreFound => Some(from.as_any_ref().downcast_ref::<ConflictingDatastoreFound>()?),
            StructType::DatabaseError => Some(from.as_any_ref().downcast_ref::<DatabaseError>()?),
            StructType::DisallowedChangeByService => Some(from.as_any_ref().downcast_ref::<DisallowedChangeByService>()?),
            StructType::DisallowedOperationOnFailoverHost => Some(from.as_any_ref().downcast_ref::<DisallowedOperationOnFailoverHost>()?),
            StructType::FailToLockFaultToleranceVMs => Some(from.as_any_ref().downcast_ref::<FailToLockFaultToleranceVMs>()?),
            StructType::InvalidProfileReferenceHost => Some(from.as_any_ref().downcast_ref::<InvalidProfileReferenceHost>()?),
            StructType::InvalidScheduledTask => Some(from.as_any_ref().downcast_ref::<InvalidScheduledTask>()?),
            StructType::LicenseAssignmentFailed => Some(from.as_any_ref().downcast_ref::<LicenseAssignmentFailed>()?),
            StructType::MethodAlreadyDisabledFault => Some(from.as_any_ref().downcast_ref::<MethodAlreadyDisabledFault>()?),
            StructType::MethodDisabled => Some(from.as_any_ref().downcast_ref::<MethodDisabled>()?),
            StructType::OperationDisallowedOnHost => Some(from.as_any_ref().downcast_ref::<OperationDisallowedOnHost>()?),
            StructType::RestrictedByAdministrator => Some(from.as_any_ref().downcast_ref::<RestrictedByAdministrator>()?),
            StructType::ThirdPartyLicenseAssignmentFailed => Some(from.as_any_ref().downcast_ref::<ThirdPartyLicenseAssignmentFailed>()?),
            StructType::VAppOperationInProgress => Some(from.as_any_ref().downcast_ref::<VAppOperationInProgress>()?),
            StructType::HostCommunication => Some(from.as_any_ref().downcast_ref::<HostCommunication>()?),
            StructType::HostNotConnected => Some(from.as_any_ref().downcast_ref::<HostNotConnected>()?),
            StructType::HostNotReachable => Some(from.as_any_ref().downcast_ref::<HostNotReachable>()?),
            StructType::InvalidArgument => Some(from.as_any_ref().downcast_ref::<InvalidArgument>()?),
            StructType::IncompatibleSetting => Some(from.as_any_ref().downcast_ref::<IncompatibleSetting>()?),
            StructType::InvalidDasConfigArgument => Some(from.as_any_ref().downcast_ref::<InvalidDasConfigArgument>()?),
            StructType::InvalidDasRestartPriorityForFtVm => Some(from.as_any_ref().downcast_ref::<InvalidDasRestartPriorityForFtVm>()?),
            StructType::InvalidDrsBehaviorForFtVm => Some(from.as_any_ref().downcast_ref::<InvalidDrsBehaviorForFtVm>()?),
            StructType::InvalidIndexArgument => Some(from.as_any_ref().downcast_ref::<InvalidIndexArgument>()?),
            StructType::InvalidRequest => Some(from.as_any_ref().downcast_ref::<InvalidRequest>()?),
            StructType::InvalidType => Some(from.as_any_ref().downcast_ref::<InvalidType>()?),
            StructType::MethodNotFound => Some(from.as_any_ref().downcast_ref::<MethodNotFound>()?),
            StructType::ManagedObjectNotFound => Some(from.as_any_ref().downcast_ref::<ManagedObjectNotFound>()?),
            StructType::NotEnoughLicenses => Some(from.as_any_ref().downcast_ref::<NotEnoughLicenses>()?),
            StructType::ExpiredFeatureLicense => Some(from.as_any_ref().downcast_ref::<ExpiredFeatureLicense>()?),
            StructType::ExpiredAddonLicense => Some(from.as_any_ref().downcast_ref::<ExpiredAddonLicense>()?),
            StructType::ExpiredEditionLicense => Some(from.as_any_ref().downcast_ref::<ExpiredEditionLicense>()?),
            StructType::FailToEnableSpbm => Some(from.as_any_ref().downcast_ref::<FailToEnableSpbm>()?),
            StructType::HostInventoryFull => Some(from.as_any_ref().downcast_ref::<HostInventoryFull>()?),
            StructType::InUseFeatureManipulationDisallowed => Some(from.as_any_ref().downcast_ref::<InUseFeatureManipulationDisallowed>()?),
            StructType::IncorrectHostInformation => Some(from.as_any_ref().downcast_ref::<IncorrectHostInformation>()?),
            StructType::InvalidEditionLicense => Some(from.as_any_ref().downcast_ref::<InvalidEditionLicense>()?),
            StructType::InventoryHasStandardAloneHosts => Some(from.as_any_ref().downcast_ref::<InventoryHasStandardAloneHosts>()?),
            StructType::LicenseDowngradeDisallowed => Some(from.as_any_ref().downcast_ref::<LicenseDowngradeDisallowed>()?),
            StructType::LicenseExpired => Some(from.as_any_ref().downcast_ref::<LicenseExpired>()?),
            StructType::LicenseKeyEntityMismatch => Some(from.as_any_ref().downcast_ref::<LicenseKeyEntityMismatch>()?),
            StructType::LicenseRestricted => Some(from.as_any_ref().downcast_ref::<LicenseRestricted>()?),
            StructType::LicenseSourceUnavailable => Some(from.as_any_ref().downcast_ref::<LicenseSourceUnavailable>()?),
            StructType::NoLicenseServerConfigured => Some(from.as_any_ref().downcast_ref::<NoLicenseServerConfigured>()?),
            StructType::VmLimitLicense => Some(from.as_any_ref().downcast_ref::<VmLimitLicense>()?),
            StructType::VramLimitLicense => Some(from.as_any_ref().downcast_ref::<VramLimitLicense>()?),
            StructType::NotImplemented => Some(from.as_any_ref().downcast_ref::<NotImplemented>()?),
            StructType::NotSupported => Some(from.as_any_ref().downcast_ref::<NotSupported>()?),
            StructType::HostAccessRestrictedToManagementServer => Some(from.as_any_ref().downcast_ref::<HostAccessRestrictedToManagementServer>()?),
            StructType::RequestCanceled => Some(from.as_any_ref().downcast_ref::<RequestCanceled>()?),
            StructType::SecurityError => Some(from.as_any_ref().downcast_ref::<SecurityError>()?),
            StructType::NoPermission => Some(from.as_any_ref().downcast_ref::<NoPermission>()?),
            StructType::NotAuthenticated => Some(from.as_any_ref().downcast_ref::<NotAuthenticated>()?),
            StructType::RestrictedVersion => Some(from.as_any_ref().downcast_ref::<RestrictedVersion>()?),
            StructType::SolutionUserRequired => Some(from.as_any_ref().downcast_ref::<SolutionUserRequired>()?),
            StructType::SystemError => Some(from.as_any_ref().downcast_ref::<SystemError>()?),
            StructType::UnexpectedFault => Some(from.as_any_ref().downcast_ref::<UnexpectedFault>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::RuntimeFault => Ok(from.as_any_box().downcast::<RuntimeFault>()?),
            StructType::CannotDisableDrsOnClustersWithVApps => Ok(from.as_any_box().downcast::<CannotDisableDrsOnClustersWithVApps>()?),
            StructType::ConflictingDatastoreFound => Ok(from.as_any_box().downcast::<ConflictingDatastoreFound>()?),
            StructType::DatabaseError => Ok(from.as_any_box().downcast::<DatabaseError>()?),
            StructType::DisallowedChangeByService => Ok(from.as_any_box().downcast::<DisallowedChangeByService>()?),
            StructType::DisallowedOperationOnFailoverHost => Ok(from.as_any_box().downcast::<DisallowedOperationOnFailoverHost>()?),
            StructType::FailToLockFaultToleranceVMs => Ok(from.as_any_box().downcast::<FailToLockFaultToleranceVMs>()?),
            StructType::InvalidProfileReferenceHost => Ok(from.as_any_box().downcast::<InvalidProfileReferenceHost>()?),
            StructType::InvalidScheduledTask => Ok(from.as_any_box().downcast::<InvalidScheduledTask>()?),
            StructType::LicenseAssignmentFailed => Ok(from.as_any_box().downcast::<LicenseAssignmentFailed>()?),
            StructType::MethodAlreadyDisabledFault => Ok(from.as_any_box().downcast::<MethodAlreadyDisabledFault>()?),
            StructType::MethodDisabled => Ok(from.as_any_box().downcast::<MethodDisabled>()?),
            StructType::OperationDisallowedOnHost => Ok(from.as_any_box().downcast::<OperationDisallowedOnHost>()?),
            StructType::RestrictedByAdministrator => Ok(from.as_any_box().downcast::<RestrictedByAdministrator>()?),
            StructType::ThirdPartyLicenseAssignmentFailed => Ok(from.as_any_box().downcast::<ThirdPartyLicenseAssignmentFailed>()?),
            StructType::VAppOperationInProgress => Ok(from.as_any_box().downcast::<VAppOperationInProgress>()?),
            StructType::HostCommunication => Ok(from.as_any_box().downcast::<HostCommunication>()?),
            StructType::HostNotConnected => Ok(from.as_any_box().downcast::<HostNotConnected>()?),
            StructType::HostNotReachable => Ok(from.as_any_box().downcast::<HostNotReachable>()?),
            StructType::InvalidArgument => Ok(from.as_any_box().downcast::<InvalidArgument>()?),
            StructType::IncompatibleSetting => Ok(from.as_any_box().downcast::<IncompatibleSetting>()?),
            StructType::InvalidDasConfigArgument => Ok(from.as_any_box().downcast::<InvalidDasConfigArgument>()?),
            StructType::InvalidDasRestartPriorityForFtVm => Ok(from.as_any_box().downcast::<InvalidDasRestartPriorityForFtVm>()?),
            StructType::InvalidDrsBehaviorForFtVm => Ok(from.as_any_box().downcast::<InvalidDrsBehaviorForFtVm>()?),
            StructType::InvalidIndexArgument => Ok(from.as_any_box().downcast::<InvalidIndexArgument>()?),
            StructType::InvalidRequest => Ok(from.as_any_box().downcast::<InvalidRequest>()?),
            StructType::InvalidType => Ok(from.as_any_box().downcast::<InvalidType>()?),
            StructType::MethodNotFound => Ok(from.as_any_box().downcast::<MethodNotFound>()?),
            StructType::ManagedObjectNotFound => Ok(from.as_any_box().downcast::<ManagedObjectNotFound>()?),
            StructType::NotEnoughLicenses => Ok(from.as_any_box().downcast::<NotEnoughLicenses>()?),
            StructType::ExpiredFeatureLicense => Ok(from.as_any_box().downcast::<ExpiredFeatureLicense>()?),
            StructType::ExpiredAddonLicense => Ok(from.as_any_box().downcast::<ExpiredAddonLicense>()?),
            StructType::ExpiredEditionLicense => Ok(from.as_any_box().downcast::<ExpiredEditionLicense>()?),
            StructType::FailToEnableSpbm => Ok(from.as_any_box().downcast::<FailToEnableSpbm>()?),
            StructType::HostInventoryFull => Ok(from.as_any_box().downcast::<HostInventoryFull>()?),
            StructType::InUseFeatureManipulationDisallowed => Ok(from.as_any_box().downcast::<InUseFeatureManipulationDisallowed>()?),
            StructType::IncorrectHostInformation => Ok(from.as_any_box().downcast::<IncorrectHostInformation>()?),
            StructType::InvalidEditionLicense => Ok(from.as_any_box().downcast::<InvalidEditionLicense>()?),
            StructType::InventoryHasStandardAloneHosts => Ok(from.as_any_box().downcast::<InventoryHasStandardAloneHosts>()?),
            StructType::LicenseDowngradeDisallowed => Ok(from.as_any_box().downcast::<LicenseDowngradeDisallowed>()?),
            StructType::LicenseExpired => Ok(from.as_any_box().downcast::<LicenseExpired>()?),
            StructType::LicenseKeyEntityMismatch => Ok(from.as_any_box().downcast::<LicenseKeyEntityMismatch>()?),
            StructType::LicenseRestricted => Ok(from.as_any_box().downcast::<LicenseRestricted>()?),
            StructType::LicenseSourceUnavailable => Ok(from.as_any_box().downcast::<LicenseSourceUnavailable>()?),
            StructType::NoLicenseServerConfigured => Ok(from.as_any_box().downcast::<NoLicenseServerConfigured>()?),
            StructType::VmLimitLicense => Ok(from.as_any_box().downcast::<VmLimitLicense>()?),
            StructType::VramLimitLicense => Ok(from.as_any_box().downcast::<VramLimitLicense>()?),
            StructType::NotImplemented => Ok(from.as_any_box().downcast::<NotImplemented>()?),
            StructType::NotSupported => Ok(from.as_any_box().downcast::<NotSupported>()?),
            StructType::HostAccessRestrictedToManagementServer => Ok(from.as_any_box().downcast::<HostAccessRestrictedToManagementServer>()?),
            StructType::RequestCanceled => Ok(from.as_any_box().downcast::<RequestCanceled>()?),
            StructType::SecurityError => Ok(from.as_any_box().downcast::<SecurityError>()?),
            StructType::NoPermission => Ok(from.as_any_box().downcast::<NoPermission>()?),
            StructType::NotAuthenticated => Ok(from.as_any_box().downcast::<NotAuthenticated>()?),
            StructType::RestrictedVersion => Ok(from.as_any_box().downcast::<RestrictedVersion>()?),
            StructType::SolutionUserRequired => Ok(from.as_any_box().downcast::<SolutionUserRequired>()?),
            StructType::SystemError => Ok(from.as_any_box().downcast::<SystemError>()?),
            StructType::UnexpectedFault => Ok(from.as_any_box().downcast::<UnexpectedFault>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// A HostCommunication fault is thrown if an error happened
/// while communicating to a host.
/// 
/// This would typically be
/// due to network connections or server failures.
pub trait HostCommunicationTrait : super::traits::RuntimeFaultTrait {
}
impl<'s> serde::Serialize for dyn HostCommunicationTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn HostCommunicationTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(HostCommunicationVisitor)
            }
        }

struct HostCommunicationVisitor;

impl<'de> de::Visitor<'de> for HostCommunicationVisitor {
    type Value = Box<dyn HostCommunicationTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid HostCommunicationTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl HostCommunicationTrait for HostCommunication {
}
impl HostCommunicationTrait for HostNotConnected {
}
impl HostCommunicationTrait for HostNotReachable {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn HostCommunicationTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostCommunication => Some(from.as_any_ref().downcast_ref::<HostCommunication>()?),
            StructType::HostNotConnected => Some(from.as_any_ref().downcast_ref::<HostNotConnected>()?),
            StructType::HostNotReachable => Some(from.as_any_ref().downcast_ref::<HostNotReachable>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::HostCommunication => Ok(from.as_any_box().downcast::<HostCommunication>()?),
            StructType::HostNotConnected => Ok(from.as_any_box().downcast::<HostNotConnected>()?),
            StructType::HostNotReachable => Ok(from.as_any_box().downcast::<HostNotReachable>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// An InvalidArgument exception is thrown if the
/// set of arguments passed to the function is not
/// specified correctly.
pub trait InvalidArgumentTrait : super::traits::RuntimeFaultTrait {
    /// Optional name of the invalid property.
    fn get_invalid_property(&self) -> &Option<String>;
}
impl<'s> serde::Serialize for dyn InvalidArgumentTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn InvalidArgumentTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(InvalidArgumentVisitor)
            }
        }

struct InvalidArgumentVisitor;

impl<'de> de::Visitor<'de> for InvalidArgumentVisitor {
    type Value = Box<dyn InvalidArgumentTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid InvalidArgumentTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl InvalidArgumentTrait for InvalidArgument {
    fn get_invalid_property(&self) -> &Option<String> { &self.invalid_property }
}
impl InvalidArgumentTrait for IncompatibleSetting {
    fn get_invalid_property(&self) -> &Option<String> { &self.invalid_property }
}
impl InvalidArgumentTrait for InvalidDasConfigArgument {
    fn get_invalid_property(&self) -> &Option<String> { &self.invalid_property }
}
impl InvalidArgumentTrait for InvalidDasRestartPriorityForFtVm {
    fn get_invalid_property(&self) -> &Option<String> { &self.invalid_property }
}
impl InvalidArgumentTrait for InvalidDrsBehaviorForFtVm {
    fn get_invalid_property(&self) -> &Option<String> { &self.invalid_property }
}
impl InvalidArgumentTrait for InvalidIndexArgument {
    fn get_invalid_property(&self) -> &Option<String> { &self.invalid_property }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn InvalidArgumentTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::InvalidArgument => Some(from.as_any_ref().downcast_ref::<InvalidArgument>()?),
            StructType::IncompatibleSetting => Some(from.as_any_ref().downcast_ref::<IncompatibleSetting>()?),
            StructType::InvalidDasConfigArgument => Some(from.as_any_ref().downcast_ref::<InvalidDasConfigArgument>()?),
            StructType::InvalidDasRestartPriorityForFtVm => Some(from.as_any_ref().downcast_ref::<InvalidDasRestartPriorityForFtVm>()?),
            StructType::InvalidDrsBehaviorForFtVm => Some(from.as_any_ref().downcast_ref::<InvalidDrsBehaviorForFtVm>()?),
            StructType::InvalidIndexArgument => Some(from.as_any_ref().downcast_ref::<InvalidIndexArgument>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::InvalidArgument => Ok(from.as_any_box().downcast::<InvalidArgument>()?),
            StructType::IncompatibleSetting => Ok(from.as_any_box().downcast::<IncompatibleSetting>()?),
            StructType::InvalidDasConfigArgument => Ok(from.as_any_box().downcast::<InvalidDasConfigArgument>()?),
            StructType::InvalidDasRestartPriorityForFtVm => Ok(from.as_any_box().downcast::<InvalidDasRestartPriorityForFtVm>()?),
            StructType::InvalidDrsBehaviorForFtVm => Ok(from.as_any_box().downcast::<InvalidDrsBehaviorForFtVm>()?),
            StructType::InvalidIndexArgument => Ok(from.as_any_box().downcast::<InvalidIndexArgument>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// An InvalidRequest fault is thrown in response to a malformed
/// request to the server that fails in the transport layer, e.g.,
/// the SOAP XML request was invalid.
/// 
/// Sub-types of this fault,
/// provides more specific transport errors, such as a using a
/// reference to an unknown managed object type or method.
pub trait InvalidRequestTrait : super::traits::RuntimeFaultTrait {
}
impl<'s> serde::Serialize for dyn InvalidRequestTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn InvalidRequestTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(InvalidRequestVisitor)
            }
        }

struct InvalidRequestVisitor;

impl<'de> de::Visitor<'de> for InvalidRequestVisitor {
    type Value = Box<dyn InvalidRequestTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid InvalidRequestTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl InvalidRequestTrait for InvalidRequest {
}
impl InvalidRequestTrait for InvalidType {
}
impl InvalidRequestTrait for MethodNotFound {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn InvalidRequestTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::InvalidRequest => Some(from.as_any_ref().downcast_ref::<InvalidRequest>()?),
            StructType::InvalidType => Some(from.as_any_ref().downcast_ref::<InvalidType>()?),
            StructType::MethodNotFound => Some(from.as_any_ref().downcast_ref::<MethodNotFound>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::InvalidRequest => Ok(from.as_any_box().downcast::<InvalidRequest>()?),
            StructType::InvalidType => Ok(from.as_any_box().downcast::<InvalidType>()?),
            StructType::MethodNotFound => Ok(from.as_any_box().downcast::<MethodNotFound>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// A NotEnoughLicensesFault occurs when an operation
/// fails because there are not enough licenses installed.
pub trait NotEnoughLicensesTrait : super::traits::RuntimeFaultTrait {
}
impl<'s> serde::Serialize for dyn NotEnoughLicensesTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn NotEnoughLicensesTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(NotEnoughLicensesVisitor)
            }
        }

struct NotEnoughLicensesVisitor;

impl<'de> de::Visitor<'de> for NotEnoughLicensesVisitor {
    type Value = Box<dyn NotEnoughLicensesTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid NotEnoughLicensesTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl NotEnoughLicensesTrait for NotEnoughLicenses {
}
impl NotEnoughLicensesTrait for ExpiredFeatureLicense {
}
impl NotEnoughLicensesTrait for ExpiredAddonLicense {
}
impl NotEnoughLicensesTrait for ExpiredEditionLicense {
}
impl NotEnoughLicensesTrait for FailToEnableSpbm {
}
impl NotEnoughLicensesTrait for HostInventoryFull {
}
impl NotEnoughLicensesTrait for InUseFeatureManipulationDisallowed {
}
impl NotEnoughLicensesTrait for IncorrectHostInformation {
}
impl NotEnoughLicensesTrait for InvalidEditionLicense {
}
impl NotEnoughLicensesTrait for InventoryHasStandardAloneHosts {
}
impl NotEnoughLicensesTrait for LicenseDowngradeDisallowed {
}
impl NotEnoughLicensesTrait for LicenseExpired {
}
impl NotEnoughLicensesTrait for LicenseKeyEntityMismatch {
}
impl NotEnoughLicensesTrait for LicenseRestricted {
}
impl NotEnoughLicensesTrait for LicenseSourceUnavailable {
}
impl NotEnoughLicensesTrait for NoLicenseServerConfigured {
}
impl NotEnoughLicensesTrait for VmLimitLicense {
}
impl NotEnoughLicensesTrait for VramLimitLicense {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn NotEnoughLicensesTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::NotEnoughLicenses => Some(from.as_any_ref().downcast_ref::<NotEnoughLicenses>()?),
            StructType::ExpiredFeatureLicense => Some(from.as_any_ref().downcast_ref::<ExpiredFeatureLicense>()?),
            StructType::ExpiredAddonLicense => Some(from.as_any_ref().downcast_ref::<ExpiredAddonLicense>()?),
            StructType::ExpiredEditionLicense => Some(from.as_any_ref().downcast_ref::<ExpiredEditionLicense>()?),
            StructType::FailToEnableSpbm => Some(from.as_any_ref().downcast_ref::<FailToEnableSpbm>()?),
            StructType::HostInventoryFull => Some(from.as_any_ref().downcast_ref::<HostInventoryFull>()?),
            StructType::InUseFeatureManipulationDisallowed => Some(from.as_any_ref().downcast_ref::<InUseFeatureManipulationDisallowed>()?),
            StructType::IncorrectHostInformation => Some(from.as_any_ref().downcast_ref::<IncorrectHostInformation>()?),
            StructType::InvalidEditionLicense => Some(from.as_any_ref().downcast_ref::<InvalidEditionLicense>()?),
            StructType::InventoryHasStandardAloneHosts => Some(from.as_any_ref().downcast_ref::<InventoryHasStandardAloneHosts>()?),
            StructType::LicenseDowngradeDisallowed => Some(from.as_any_ref().downcast_ref::<LicenseDowngradeDisallowed>()?),
            StructType::LicenseExpired => Some(from.as_any_ref().downcast_ref::<LicenseExpired>()?),
            StructType::LicenseKeyEntityMismatch => Some(from.as_any_ref().downcast_ref::<LicenseKeyEntityMismatch>()?),
            StructType::LicenseRestricted => Some(from.as_any_ref().downcast_ref::<LicenseRestricted>()?),
            StructType::LicenseSourceUnavailable => Some(from.as_any_ref().downcast_ref::<LicenseSourceUnavailable>()?),
            StructType::NoLicenseServerConfigured => Some(from.as_any_ref().downcast_ref::<NoLicenseServerConfigured>()?),
            StructType::VmLimitLicense => Some(from.as_any_ref().downcast_ref::<VmLimitLicense>()?),
            StructType::VramLimitLicense => Some(from.as_any_ref().downcast_ref::<VramLimitLicense>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::NotEnoughLicenses => Ok(from.as_any_box().downcast::<NotEnoughLicenses>()?),
            StructType::ExpiredFeatureLicense => Ok(from.as_any_box().downcast::<ExpiredFeatureLicense>()?),
            StructType::ExpiredAddonLicense => Ok(from.as_any_box().downcast::<ExpiredAddonLicense>()?),
            StructType::ExpiredEditionLicense => Ok(from.as_any_box().downcast::<ExpiredEditionLicense>()?),
            StructType::FailToEnableSpbm => Ok(from.as_any_box().downcast::<FailToEnableSpbm>()?),
            StructType::HostInventoryFull => Ok(from.as_any_box().downcast::<HostInventoryFull>()?),
            StructType::InUseFeatureManipulationDisallowed => Ok(from.as_any_box().downcast::<InUseFeatureManipulationDisallowed>()?),
            StructType::IncorrectHostInformation => Ok(from.as_any_box().downcast::<IncorrectHostInformation>()?),
            StructType::InvalidEditionLicense => Ok(from.as_any_box().downcast::<InvalidEditionLicense>()?),
            StructType::InventoryHasStandardAloneHosts => Ok(from.as_any_box().downcast::<InventoryHasStandardAloneHosts>()?),
            StructType::LicenseDowngradeDisallowed => Ok(from.as_any_box().downcast::<LicenseDowngradeDisallowed>()?),
            StructType::LicenseExpired => Ok(from.as_any_box().downcast::<LicenseExpired>()?),
            StructType::LicenseKeyEntityMismatch => Ok(from.as_any_box().downcast::<LicenseKeyEntityMismatch>()?),
            StructType::LicenseRestricted => Ok(from.as_any_box().downcast::<LicenseRestricted>()?),
            StructType::LicenseSourceUnavailable => Ok(from.as_any_box().downcast::<LicenseSourceUnavailable>()?),
            StructType::NoLicenseServerConfigured => Ok(from.as_any_box().downcast::<NoLicenseServerConfigured>()?),
            StructType::VmLimitLicense => Ok(from.as_any_box().downcast::<VmLimitLicense>()?),
            StructType::VramLimitLicense => Ok(from.as_any_box().downcast::<VramLimitLicense>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// An ExpiredFeatureLicense fault is thrown if an attempt to acquire an Addon license
/// 'feature failed for count 'count'.
pub trait ExpiredFeatureLicenseTrait : super::traits::NotEnoughLicensesTrait {
    fn get_feature(&self) -> &str;
    fn get_count(&self) -> i32;
    fn get_expiration_date(&self) -> &str;
}
impl<'s> serde::Serialize for dyn ExpiredFeatureLicenseTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn ExpiredFeatureLicenseTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(ExpiredFeatureLicenseVisitor)
            }
        }

struct ExpiredFeatureLicenseVisitor;

impl<'de> de::Visitor<'de> for ExpiredFeatureLicenseVisitor {
    type Value = Box<dyn ExpiredFeatureLicenseTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid ExpiredFeatureLicenseTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl ExpiredFeatureLicenseTrait for ExpiredFeatureLicense {
    fn get_feature(&self) -> &str { &self.feature }
    fn get_count(&self) -> i32 { self.count }
    fn get_expiration_date(&self) -> &str { &self.expiration_date }
}
impl ExpiredFeatureLicenseTrait for ExpiredAddonLicense {
    fn get_feature(&self) -> &str { &self.feature }
    fn get_count(&self) -> i32 { self.count }
    fn get_expiration_date(&self) -> &str { &self.expiration_date }
}
impl ExpiredFeatureLicenseTrait for ExpiredEditionLicense {
    fn get_feature(&self) -> &str { &self.feature }
    fn get_count(&self) -> i32 { self.count }
    fn get_expiration_date(&self) -> &str { &self.expiration_date }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn ExpiredFeatureLicenseTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::ExpiredFeatureLicense => Some(from.as_any_ref().downcast_ref::<ExpiredFeatureLicense>()?),
            StructType::ExpiredAddonLicense => Some(from.as_any_ref().downcast_ref::<ExpiredAddonLicense>()?),
            StructType::ExpiredEditionLicense => Some(from.as_any_ref().downcast_ref::<ExpiredEditionLicense>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::ExpiredFeatureLicense => Ok(from.as_any_box().downcast::<ExpiredFeatureLicense>()?),
            StructType::ExpiredAddonLicense => Ok(from.as_any_box().downcast::<ExpiredAddonLicense>()?),
            StructType::ExpiredEditionLicense => Ok(from.as_any_box().downcast::<ExpiredEditionLicense>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Thrown if the method is not supported on the
/// server.
/// 
/// Not all methods are supported on all servers
/// (for example, an ESX Server host supports less functionality than
/// a VirtualCenter server). A feature might also be disabled
/// due to missing liceneses.
pub trait NotSupportedTrait : super::traits::RuntimeFaultTrait {
}
impl<'s> serde::Serialize for dyn NotSupportedTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn NotSupportedTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(NotSupportedVisitor)
            }
        }

struct NotSupportedVisitor;

impl<'de> de::Visitor<'de> for NotSupportedVisitor {
    type Value = Box<dyn NotSupportedTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid NotSupportedTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl NotSupportedTrait for NotSupported {
}
impl NotSupportedTrait for HostAccessRestrictedToManagementServer {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn NotSupportedTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::NotSupported => Some(from.as_any_ref().downcast_ref::<NotSupported>()?),
            StructType::HostAccessRestrictedToManagementServer => Some(from.as_any_ref().downcast_ref::<HostAccessRestrictedToManagementServer>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::NotSupported => Ok(from.as_any_box().downcast::<NotSupported>()?),
            StructType::HostAccessRestrictedToManagementServer => Ok(from.as_any_box().downcast::<HostAccessRestrictedToManagementServer>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Thrown when the client is not allowed access to the property or method.
pub trait SecurityErrorTrait : super::traits::RuntimeFaultTrait {
}
impl<'s> serde::Serialize for dyn SecurityErrorTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn SecurityErrorTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(SecurityErrorVisitor)
            }
        }

struct SecurityErrorVisitor;

impl<'de> de::Visitor<'de> for SecurityErrorVisitor {
    type Value = Box<dyn SecurityErrorTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid SecurityErrorTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl SecurityErrorTrait for SecurityError {
}
impl SecurityErrorTrait for NoPermission {
}
impl SecurityErrorTrait for NotAuthenticated {
}
impl SecurityErrorTrait for RestrictedVersion {
}
impl SecurityErrorTrait for SolutionUserRequired {
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn SecurityErrorTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::SecurityError => Some(from.as_any_ref().downcast_ref::<SecurityError>()?),
            StructType::NoPermission => Some(from.as_any_ref().downcast_ref::<NoPermission>()?),
            StructType::NotAuthenticated => Some(from.as_any_ref().downcast_ref::<NotAuthenticated>()?),
            StructType::RestrictedVersion => Some(from.as_any_ref().downcast_ref::<RestrictedVersion>()?),
            StructType::SolutionUserRequired => Some(from.as_any_ref().downcast_ref::<SolutionUserRequired>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::SecurityError => Ok(from.as_any_box().downcast::<SecurityError>()?),
            StructType::NoPermission => Ok(from.as_any_box().downcast::<NoPermission>()?),
            StructType::NotAuthenticated => Ok(from.as_any_box().downcast::<NotAuthenticated>()?),
            StructType::RestrictedVersion => Ok(from.as_any_box().downcast::<RestrictedVersion>()?),
            StructType::SolutionUserRequired => Ok(from.as_any_box().downcast::<SolutionUserRequired>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
/// Thrown when an operation is denied because of privileges
/// not held on managed object(s).
pub trait NoPermissionTrait : super::traits::SecurityErrorTrait {
    /// Deprecated as of vSphere 8.0, use the *NoPermission.missingPrivileges* field.
    /// 
    /// The managed object on which a permission is required.
    fn get_object(&self) -> &Option<ManagedObjectReference>;
    /// Deprecated as of vSphere 8.0, use the *NoPermission.missingPrivileges* field.
    /// 
    /// The privilege identifier required
    fn get_privilege_id(&self) -> &Option<String>;
    /// List of entities and missing privileges for each entity
    /// 
    /// ***Since:*** vSphere API Release 7.0.3.2
    fn get_missing_privileges(&self) -> &Option<Vec<NoPermissionEntityPrivileges>>;
}
impl<'s> serde::Serialize for dyn NoPermissionTrait + 's {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                dyn_serialize::serialize_polymorphic(self.as_vim_object_ref(), serializer)
            }
        }
impl<'de> serde::Deserialize<'de> for Box<dyn NoPermissionTrait> {
            fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
                deserializer.deserialize_map(NoPermissionVisitor)
            }
        }

struct NoPermissionVisitor;

impl<'de> de::Visitor<'de> for NoPermissionVisitor {
    type Value = Box<dyn NoPermissionTrait>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("a valid NoPermissionTrait JSON object with a _typeName field")
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: de::MapAccess<'de>,
    {
        let deserializer = de::value::MapAccessDeserializer::new(&mut map);
        let any: VimAny = de::Deserialize::deserialize(deserializer)?;
        match any {
            VimAny::Object(obj) => Ok(CastFrom::from_box(obj)
                .map_err(|_| de::Error::custom("Internal error converting to trait type"))?),
            VimAny::Value(value) => Err(de::Error::custom(format!(
                "expected object not wrapped value: {:?}",
                value))),
        }
    }
}

impl NoPermissionTrait for NoPermission {
    fn get_object(&self) -> &Option<ManagedObjectReference> { &self.object }
    fn get_privilege_id(&self) -> &Option<String> { &self.privilege_id }
    fn get_missing_privileges(&self) -> &Option<Vec<NoPermissionEntityPrivileges>> { &self.missing_privileges }
}
impl NoPermissionTrait for NotAuthenticated {
    fn get_object(&self) -> &Option<ManagedObjectReference> { &self.object }
    fn get_privilege_id(&self) -> &Option<String> { &self.privilege_id }
    fn get_missing_privileges(&self) -> &Option<Vec<NoPermissionEntityPrivileges>> { &self.missing_privileges }
}
impl<From: VimObjectTrait + ?Sized + 'static> CastFrom<From> for dyn NoPermissionTrait {
    fn from_ref<'a>(from: &'a From) -> Option<&'a Self> {
        let data_type = from.data_type();
        match data_type {
            StructType::NoPermission => Some(from.as_any_ref().downcast_ref::<NoPermission>()?),
            StructType::NotAuthenticated => Some(from.as_any_ref().downcast_ref::<NotAuthenticated>()?),
            _ => None,
        }
    }
    
    fn from_box(from: Box<From>) -> Result<Box<Self>, Box<dyn std::any::Any + 'static>> {
        let data_type = from.data_type();
        match data_type {
            StructType::NoPermission => Ok(from.as_any_box().downcast::<NoPermission>()?),
            StructType::NotAuthenticated => Ok(from.as_any_box().downcast::<NotAuthenticated>()?),
            _ => Err(from.as_any_box()),
        }
    }
}
